/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./gulp/node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/ajv/lib/ajv.js":
/*!*************************************!*\
  !*** ./node_modules/ajv/lib/ajv.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var compileSchema = __webpack_require__(/*! ./compile */ "./node_modules/ajv/lib/compile/index.js")
  , resolve = __webpack_require__(/*! ./compile/resolve */ "./node_modules/ajv/lib/compile/resolve.js")
  , Cache = __webpack_require__(/*! ./cache */ "./node_modules/ajv/lib/cache.js")
  , SchemaObject = __webpack_require__(/*! ./compile/schema_obj */ "./node_modules/ajv/lib/compile/schema_obj.js")
  , stableStringify = __webpack_require__(/*! fast-json-stable-stringify */ "./node_modules/fast-json-stable-stringify/index.js")
  , formats = __webpack_require__(/*! ./compile/formats */ "./node_modules/ajv/lib/compile/formats.js")
  , rules = __webpack_require__(/*! ./compile/rules */ "./node_modules/ajv/lib/compile/rules.js")
  , $dataMetaSchema = __webpack_require__(/*! ./data */ "./node_modules/ajv/lib/data.js")
  , util = __webpack_require__(/*! ./compile/util */ "./node_modules/ajv/lib/compile/util.js");

module.exports = Ajv;

Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;

Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;

Ajv.prototype.compileAsync = __webpack_require__(/*! ./compile/async */ "./node_modules/ajv/lib/compile/async.js");
var customKeyword = __webpack_require__(/*! ./keyword */ "./node_modules/ajv/lib/keyword.js");
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
Ajv.prototype.validateKeyword = customKeyword.validate;

var errorClasses = __webpack_require__(/*! ./compile/error_classes */ "./node_modules/ajv/lib/compile/error_classes.js");
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;

var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';

var META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults' ];
var META_SUPPORT_DATA = ['/properties'];

/**
 * Creates validator instance.
 * Usage: `Ajv(opts)`
 * @param {Object} opts optional options
 * @return {Object} ajv instance
 */
function Ajv(opts) {
  if (!(this instanceof Ajv)) return new Ajv(opts);
  opts = this._opts = util.copy(opts) || {};
  setLogger(this);
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats(opts.format);

  this._cache = opts.cache || new Cache;
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules();
  this._getId = chooseGetId(opts);

  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
  if (opts.serialize === undefined) opts.serialize = stableStringify;
  this._metaOpts = getMetaSchemaOptions(this);

  if (opts.formats) addInitialFormats(this);
  if (opts.keywords) addInitialKeywords(this);
  addDefaultMetaSchema(this);
  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
  if (opts.nullable) this.addKeyword('nullable', {metaSchema: {type: 'boolean'}});
  addInitialSchemas(this);
}



/**
 * Validate data using schema
 * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
 * @this   Ajv
 * @param  {String|Object} schemaKeyRef key, ref or schema object
 * @param  {Any} data to be validated
 * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
 */
function validate(schemaKeyRef, data) {
  var v;
  if (typeof schemaKeyRef == 'string') {
    v = this.getSchema(schemaKeyRef);
    if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
  } else {
    var schemaObj = this._addSchema(schemaKeyRef);
    v = schemaObj.validate || this._compile(schemaObj);
  }

  var valid = v(data);
  if (v.$async !== true) this.errors = v.errors;
  return valid;
}


/**
 * Create validating function for passed schema.
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
 * @return {Function} validating function
 */
function compile(schema, _meta) {
  var schemaObj = this._addSchema(schema, undefined, _meta);
  return schemaObj.validate || this._compile(schemaObj);
}


/**
 * Adds schema to the instance.
 * @this   Ajv
 * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
 * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
 * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
 * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
 * @return {Ajv} this for method chaining
 */
function addSchema(schema, key, _skipValidation, _meta) {
  if (Array.isArray(schema)){
    for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
    return this;
  }
  var id = this._getId(schema);
  if (id !== undefined && typeof id != 'string')
    throw new Error('schema id must be string');
  key = resolve.normalizeId(key || id);
  checkUnique(this, key);
  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
  return this;
}


/**
 * Add schema that will be used to validate other schemas
 * options in META_IGNORE_OPTIONS are alway set to false
 * @this   Ajv
 * @param {Object} schema schema object
 * @param {String} key optional schema key
 * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
 * @return {Ajv} this for method chaining
 */
function addMetaSchema(schema, key, skipValidation) {
  this.addSchema(schema, key, skipValidation, true);
  return this;
}


/**
 * Validate schema
 * @this   Ajv
 * @param {Object} schema schema to validate
 * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
 * @return {Boolean} true if schema is valid
 */
function validateSchema(schema, throwOrLogError) {
  var $schema = schema.$schema;
  if ($schema !== undefined && typeof $schema != 'string')
    throw new Error('$schema must be a string');
  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
  if (!$schema) {
    this.logger.warn('meta-schema not available');
    this.errors = null;
    return true;
  }
  var valid = this.validate($schema, schema);
  if (!valid && throwOrLogError) {
    var message = 'schema is invalid: ' + this.errorsText();
    if (this._opts.validateSchema == 'log') this.logger.error(message);
    else throw new Error(message);
  }
  return valid;
}


function defaultMeta(self) {
  var meta = self._opts.meta;
  self._opts.defaultMeta = typeof meta == 'object'
                            ? self._getId(meta) || meta
                            : self.getSchema(META_SCHEMA_ID)
                              ? META_SCHEMA_ID
                              : undefined;
  return self._opts.defaultMeta;
}


/**
 * Get compiled schema from the instance by `key` or `ref`.
 * @this   Ajv
 * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
 * @return {Function} schema validating function (with property `schema`).
 */
function getSchema(keyRef) {
  var schemaObj = _getSchemaObj(this, keyRef);
  switch (typeof schemaObj) {
    case 'object': return schemaObj.validate || this._compile(schemaObj);
    case 'string': return this.getSchema(schemaObj);
    case 'undefined': return _getSchemaFragment(this, keyRef);
  }
}


function _getSchemaFragment(self, ref) {
  var res = resolve.schema.call(self, { schema: {} }, ref);
  if (res) {
    var schema = res.schema
      , root = res.root
      , baseId = res.baseId;
    var v = compileSchema.call(self, schema, root, undefined, baseId);
    self._fragments[ref] = new SchemaObject({
      ref: ref,
      fragment: true,
      schema: schema,
      root: root,
      baseId: baseId,
      validate: v
    });
    return v;
  }
}


function _getSchemaObj(self, keyRef) {
  keyRef = resolve.normalizeId(keyRef);
  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}


/**
 * Remove cached schema(s).
 * If no parameter is passed all schemas but meta-schemas are removed.
 * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
 * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
 * @this   Ajv
 * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
 * @return {Ajv} this for method chaining
 */
function removeSchema(schemaKeyRef) {
  if (schemaKeyRef instanceof RegExp) {
    _removeAllSchemas(this, this._schemas, schemaKeyRef);
    _removeAllSchemas(this, this._refs, schemaKeyRef);
    return this;
  }
  switch (typeof schemaKeyRef) {
    case 'undefined':
      _removeAllSchemas(this, this._schemas);
      _removeAllSchemas(this, this._refs);
      this._cache.clear();
      return this;
    case 'string':
      var schemaObj = _getSchemaObj(this, schemaKeyRef);
      if (schemaObj) this._cache.del(schemaObj.cacheKey);
      delete this._schemas[schemaKeyRef];
      delete this._refs[schemaKeyRef];
      return this;
    case 'object':
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
      this._cache.del(cacheKey);
      var id = this._getId(schemaKeyRef);
      if (id) {
        id = resolve.normalizeId(id);
        delete this._schemas[id];
        delete this._refs[id];
      }
  }
  return this;
}


function _removeAllSchemas(self, schemas, regex) {
  for (var keyRef in schemas) {
    var schemaObj = schemas[keyRef];
    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
      self._cache.del(schemaObj.cacheKey);
      delete schemas[keyRef];
    }
  }
}


/* @this   Ajv */
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
  if (typeof schema != 'object' && typeof schema != 'boolean')
    throw new Error('schema should be object or boolean');
  var serialize = this._opts.serialize;
  var cacheKey = serialize ? serialize(schema) : schema;
  var cached = this._cache.get(cacheKey);
  if (cached) return cached;

  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;

  var id = resolve.normalizeId(this._getId(schema));
  if (id && shouldAddSchema) checkUnique(this, id);

  var willValidate = this._opts.validateSchema !== false && !skipValidation;
  var recursiveMeta;
  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
    this.validateSchema(schema, true);

  var localRefs = resolve.ids.call(this, schema);

  var schemaObj = new SchemaObject({
    id: id,
    schema: schema,
    localRefs: localRefs,
    cacheKey: cacheKey,
    meta: meta
  });

  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
  this._cache.put(cacheKey, schemaObj);

  if (willValidate && recursiveMeta) this.validateSchema(schema, true);

  return schemaObj;
}


/* @this   Ajv */
function _compile(schemaObj, root) {
  if (schemaObj.compiling) {
    schemaObj.validate = callValidate;
    callValidate.schema = schemaObj.schema;
    callValidate.errors = null;
    callValidate.root = root ? root : callValidate;
    if (schemaObj.schema.$async === true)
      callValidate.$async = true;
    return callValidate;
  }
  schemaObj.compiling = true;

  var currentOpts;
  if (schemaObj.meta) {
    currentOpts = this._opts;
    this._opts = this._metaOpts;
  }

  var v;
  try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }
  catch(e) {
    delete schemaObj.validate;
    throw e;
  }
  finally {
    schemaObj.compiling = false;
    if (schemaObj.meta) this._opts = currentOpts;
  }

  schemaObj.validate = v;
  schemaObj.refs = v.refs;
  schemaObj.refVal = v.refVal;
  schemaObj.root = v.root;
  return v;


  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var _validate = schemaObj.validate;
    var result = _validate.apply(this, arguments);
    callValidate.errors = _validate.errors;
    return result;
  }
}


function chooseGetId(opts) {
  switch (opts.schemaId) {
    case 'auto': return _get$IdOrId;
    case 'id': return _getId;
    default: return _get$Id;
  }
}

/* @this   Ajv */
function _getId(schema) {
  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
  return schema.id;
}

/* @this   Ajv */
function _get$Id(schema) {
  if (schema.id) this.logger.warn('schema id ignored', schema.id);
  return schema.$id;
}


function _get$IdOrId(schema) {
  if (schema.$id && schema.id && schema.$id != schema.id)
    throw new Error('schema $id is different from id');
  return schema.$id || schema.id;
}


/**
 * Convert array of error message objects to string
 * @this   Ajv
 * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
 * @param  {Object} options optional options with properties `separator` and `dataVar`.
 * @return {String} human readable string with all errors descriptions
 */
function errorsText(errors, options) {
  errors = errors || this.errors;
  if (!errors) return 'No errors';
  options = options || {};
  var separator = options.separator === undefined ? ', ' : options.separator;
  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;

  var text = '';
  for (var i=0; i<errors.length; i++) {
    var e = errors[i];
    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
  }
  return text.slice(0, -separator.length);
}


/**
 * Add custom format
 * @this   Ajv
 * @param {String} name format name
 * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
 * @return {Ajv} this for method chaining
 */
function addFormat(name, format) {
  if (typeof format == 'string') format = new RegExp(format);
  this._formats[name] = format;
  return this;
}


function addDefaultMetaSchema(self) {
  var $dataSchema;
  if (self._opts.$data) {
    $dataSchema = __webpack_require__(/*! ./refs/data.json */ "./node_modules/ajv/lib/refs/data.json");
    self.addMetaSchema($dataSchema, $dataSchema.$id, true);
  }
  if (self._opts.meta === false) return;
  var metaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ "./node_modules/ajv/lib/refs/json-schema-draft-07.json");
  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
}


function addInitialSchemas(self) {
  var optsSchemas = self._opts.schemas;
  if (!optsSchemas) return;
  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
}


function addInitialFormats(self) {
  for (var name in self._opts.formats) {
    var format = self._opts.formats[name];
    self.addFormat(name, format);
  }
}


function addInitialKeywords(self) {
  for (var name in self._opts.keywords) {
    var keyword = self._opts.keywords[name];
    self.addKeyword(name, keyword);
  }
}


function checkUnique(self, id) {
  if (self._schemas[id] || self._refs[id])
    throw new Error('schema with key or id "' + id + '" already exists');
}


function getMetaSchemaOptions(self) {
  var metaOpts = util.copy(self._opts);
  for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
    delete metaOpts[META_IGNORE_OPTIONS[i]];
  return metaOpts;
}


function setLogger(self) {
  var logger = self._opts.logger;
  if (logger === false) {
    self.logger = {log: noop, warn: noop, error: noop};
  } else {
    if (logger === undefined) logger = console;
    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))
      throw new Error('logger must implement log, warn and error methods');
    self.logger = logger;
  }
}


function noop() {}


/***/ }),

/***/ "./node_modules/ajv/lib/cache.js":
/*!***************************************!*\
  !*** ./node_modules/ajv/lib/cache.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var Cache = module.exports = function Cache() {
  this._cache = {};
};


Cache.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};


Cache.prototype.get = function Cache_get(key) {
  return this._cache[key];
};


Cache.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};


Cache.prototype.clear = function Cache_clear() {
  this._cache = {};
};


/***/ }),

/***/ "./node_modules/ajv/lib/compile/async.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/compile/async.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MissingRefError = __webpack_require__(/*! ./error_classes */ "./node_modules/ajv/lib/compile/error_classes.js").MissingRef;

module.exports = compileAsync;


/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
 * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
 * @return {Promise} promise that resolves with a validating function.
 */
function compileAsync(schema, meta, callback) {
  /* eslint no-shadow: 0 */
  /* global Promise */
  /* jshint validthis: true */
  var self = this;
  if (typeof this._opts.loadSchema != 'function')
    throw new Error('options.loadSchema should be a function');

  if (typeof meta == 'function') {
    callback = meta;
    meta = undefined;
  }

  var p = loadMetaSchemaOf(schema).then(function () {
    var schemaObj = self._addSchema(schema, undefined, meta);
    return schemaObj.validate || _compileAsync(schemaObj);
  });

  if (callback) {
    p.then(
      function(v) { callback(null, v); },
      callback
    );
  }

  return p;


  function loadMetaSchemaOf(sch) {
    var $schema = sch.$schema;
    return $schema && !self.getSchema($schema)
            ? compileAsync.call(self, { $ref: $schema }, true)
            : Promise.resolve();
  }


  function _compileAsync(schemaObj) {
    try { return self._compile(schemaObj); }
    catch(e) {
      if (e instanceof MissingRefError) return loadMissingSchema(e);
      throw e;
    }


    function loadMissingSchema(e) {
      var ref = e.missingSchema;
      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');

      var schemaPromise = self._loadingSchemas[ref];
      if (!schemaPromise) {
        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
        schemaPromise.then(removePromise, removePromise);
      }

      return schemaPromise.then(function (sch) {
        if (!added(ref)) {
          return loadMetaSchemaOf(sch).then(function () {
            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
          });
        }
      }).then(function() {
        return _compileAsync(schemaObj);
      });

      function removePromise() {
        delete self._loadingSchemas[ref];
      }

      function added(ref) {
        return self._refs[ref] || self._schemas[ref];
      }
    }
  }
}


/***/ }),

/***/ "./node_modules/ajv/lib/compile/error_classes.js":
/*!*******************************************************!*\
  !*** ./node_modules/ajv/lib/compile/error_classes.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var resolve = __webpack_require__(/*! ./resolve */ "./node_modules/ajv/lib/compile/resolve.js");

module.exports = {
  Validation: errorSubclass(ValidationError),
  MissingRef: errorSubclass(MissingRefError)
};


function ValidationError(errors) {
  this.message = 'validation failed';
  this.errors = errors;
  this.ajv = this.validation = true;
}


MissingRefError.message = function (baseId, ref) {
  return 'can\'t resolve reference ' + ref + ' from id ' + baseId;
};


function MissingRefError(baseId, ref, message) {
  this.message = message || MissingRefError.message(baseId, ref);
  this.missingRef = resolve.url(baseId, ref);
  this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
}


function errorSubclass(Subclass) {
  Subclass.prototype = Object.create(Error.prototype);
  Subclass.prototype.constructor = Subclass;
  return Subclass;
}


/***/ }),

/***/ "./node_modules/ajv/lib/compile/formats.js":
/*!*************************************************!*\
  !*** ./node_modules/ajv/lib/compile/formats.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js");

var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0,31,28,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;


module.exports = formats;

function formats(mode) {
  mode = mode == 'full' ? 'full' : 'fast';
  return util.copy(formats[mode]);
}


formats.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
  'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+-.]*:)(?:\/?\/)?[^\s]*$/i,
  'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
  'uri-template': URITEMPLATE,
  url: URL,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


formats.full = {
  date: date,
  time: time,
  'date-time': date_time,
  uri: uri,
  'uri-reference': URIREF,
  'uri-template': URITEMPLATE,
  url: URL,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: HOSTNAME,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  uuid: UUID,
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


function isLeapYear(year) {
  // https://tools.ietf.org/html/rfc3339#appendix-C
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}


function date(str) {
  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
  var matches = str.match(DATE);
  if (!matches) return false;

  var year = +matches[1];
  var month = +matches[2];
  var day = +matches[3];

  return month >= 1 && month <= 12 && day >= 1 &&
          day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}


function time(str, full) {
  var matches = str.match(TIME);
  if (!matches) return false;

  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return ((hour <= 23 && minute <= 59 && second <= 59) ||
          (hour == 23 && minute == 59 && second == 60)) &&
         (!full || timeZone);
}


var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  // http://tools.ietf.org/html/rfc3339#section-5.6
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}


var NOT_URI_FRAGMENT = /\/|:/;
function uri(str) {
  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}


var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str)) return false;
  try {
    new RegExp(str);
    return true;
  } catch(e) {
    return false;
  }
}


/***/ }),

/***/ "./node_modules/ajv/lib/compile/index.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/compile/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var resolve = __webpack_require__(/*! ./resolve */ "./node_modules/ajv/lib/compile/resolve.js")
  , util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js")
  , errorClasses = __webpack_require__(/*! ./error_classes */ "./node_modules/ajv/lib/compile/error_classes.js")
  , stableStringify = __webpack_require__(/*! fast-json-stable-stringify */ "./node_modules/fast-json-stable-stringify/index.js");

var validateGenerator = __webpack_require__(/*! ../dotjs/validate */ "./node_modules/ajv/lib/dotjs/validate.js");

/**
 * Functions below are used inside compiled validations function
 */

var ucs2length = util.ucs2length;
var equal = __webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js");

// this error is thrown by async schemas to return validation errors via exception
var ValidationError = errorClasses.Validation;

module.exports = compile;


/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */
function compile(schema, root, localRefs, baseId) {
  /* jshint validthis: true, evil: true */
  /* eslint no-shadow: 0 */
  var self = this
    , opts = this._opts
    , refVal = [ undefined ]
    , refs = {}
    , patterns = []
    , patternsHash = {}
    , defaults = []
    , defaultsHash = {}
    , customRules = [];

  root = root || { schema: schema, refVal: refVal, refs: refs };

  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling) return (compilation.callValidate = callValidate);

  var formats = this._formats;
  var RULES = this.RULES;

  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode) cv.source = v.source;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }

  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var validate = compilation.validate;
    var result = validate.apply(this, arguments);
    callValidate.errors = validate.errors;
    return result;
  }

  function localCompile(_schema, _root, localRefs, baseId) {
    var isRoot = !_root || (_root && _root.schema == _schema);
    if (_root.schema != root.schema)
      return compile.call(self, _schema, _root, localRefs, baseId);

    var $async = _schema.$async === true;

    var sourceCode = validateGenerator({
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: '',
      errSchemaPath: '#',
      errorPath: '""',
      MissingRefError: errorClasses.MissingRef,
      RULES: RULES,
      validate: validateGenerator,
      util: util,
      resolve: resolve,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      logger: self.logger,
      self: self
    });

    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
                   + sourceCode;

    if (opts.processCode) sourceCode = opts.processCode(sourceCode);
    // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
    var validate;
    try {
      var makeValidate = new Function(
        'self',
        'RULES',
        'formats',
        'root',
        'refVal',
        'defaults',
        'customRules',
        'equal',
        'ucs2length',
        'ValidationError',
        sourceCode
      );

      validate = makeValidate(
        self,
        RULES,
        formats,
        root,
        refVal,
        defaults,
        customRules,
        equal,
        ucs2length,
        ValidationError
      );

      refVal[0] = validate;
    } catch(e) {
      self.logger.error('Error compiling schema, function code:', sourceCode);
      throw e;
    }

    validate.schema = _schema;
    validate.errors = null;
    validate.refs = refs;
    validate.refVal = refVal;
    validate.root = isRoot ? validate : _root;
    if ($async) validate.$async = true;
    if (opts.sourceCode === true) {
      validate.source = {
        code: sourceCode,
        patterns: patterns,
        defaults: defaults
      };
    }

    return validate;
  }

  function resolveRef(baseId, ref, isRoot) {
    ref = resolve.url(baseId, ref);
    var refIndex = refs[ref];
    var _refVal, refCode;
    if (refIndex !== undefined) {
      _refVal = refVal[refIndex];
      refCode = 'refVal[' + refIndex + ']';
      return resolvedRef(_refVal, refCode);
    }
    if (!isRoot && root.refs) {
      var rootRefId = root.refs[ref];
      if (rootRefId !== undefined) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }

    refCode = addLocalRef(ref);
    var v = resolve.call(self, localCompile, root, ref);
    if (v === undefined) {
      var localSchema = localRefs && localRefs[ref];
      if (localSchema) {
        v = resolve.inlineRef(localSchema, opts.inlineRefs)
            ? localSchema
            : compile.call(self, localSchema, root, localRefs, baseId);
      }
    }

    if (v === undefined) {
      removeLocalRef(ref);
    } else {
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    }
  }

  function addLocalRef(ref, v) {
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return 'refVal' + refId;
  }

  function removeLocalRef(ref) {
    delete refs[ref];
  }

  function replaceLocalRef(ref, v) {
    var refId = refs[ref];
    refVal[refId] = v;
  }

  function resolvedRef(refVal, code) {
    return typeof refVal == 'object' || typeof refVal == 'boolean'
            ? { code: code, schema: refVal, inline: true }
            : { code: code, $async: refVal && !!refVal.$async };
  }

  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === undefined) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return 'pattern' + index;
  }

  function useDefault(value) {
    switch (typeof value) {
      case 'boolean':
      case 'number':
        return '' + value;
      case 'string':
        return util.toQuotedString(value);
      case 'object':
        if (value === null) return 'null';
        var valueStr = stableStringify(value);
        var index = defaultsHash[valueStr];
        if (index === undefined) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return 'default' + index;
    }
  }

  function useCustomRule(rule, schema, parentSchema, it) {
    if (self._opts.validateSchema !== false) {
      var deps = rule.definition.dependencies;
      if (deps && !deps.every(function(keyword) {
        return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
      }))
        throw new Error('parent schema must have all required keywords: ' + deps.join(','));

      var validateSchema = rule.definition.validateSchema;
      if (validateSchema) {
        var valid = validateSchema(schema);
        if (!valid) {
          var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
          if (self._opts.validateSchema == 'log') self.logger.error(message);
          else throw new Error(message);
        }
      }
    }

    var compile = rule.definition.compile
      , inline = rule.definition.inline
      , macro = rule.definition.macro;

    var validate;
    if (compile) {
      validate = compile.call(self, schema, parentSchema, it);
    } else if (macro) {
      validate = macro.call(self, schema, parentSchema, it);
      if (opts.validateSchema !== false) self.validateSchema(validate, true);
    } else if (inline) {
      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    } else {
      validate = rule.definition.validate;
      if (!validate) return;
    }

    if (validate === undefined)
      throw new Error('custom keyword "' + rule.keyword + '"failed to compile');

    var index = customRules.length;
    customRules[index] = validate;

    return {
      code: 'customRule' + index,
      validate: validate
    };
  }
}


/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
 */
function checkCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0) return { index: index, compiling: true };
  index = this._compilations.length;
  this._compilations[index] = {
    schema: schema,
    root: root,
    baseId: baseId
  };
  return { index: index, compiling: false };
}


/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 */
function endCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0) this._compilations.splice(i, 1);
}


/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Integer} compilation index
 */
function compIndex(schema, root, baseId) {
  /* jshint validthis: true */
  for (var i=0; i<this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
  }
  return -1;
}


function patternCode(i, patterns) {
  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
}


function defaultCode(i) {
  return 'var default' + i + ' = defaults[' + i + '];';
}


function refValCode(i, refVal) {
  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
}


function customRuleCode(i) {
  return 'var customRule' + i + ' = customRules[' + i + '];';
}


function vars(arr, statement) {
  if (!arr.length) return '';
  var code = '';
  for (var i=0; i<arr.length; i++)
    code += statement(i, arr);
  return code;
}


/***/ }),

/***/ "./node_modules/ajv/lib/compile/resolve.js":
/*!*************************************************!*\
  !*** ./node_modules/ajv/lib/compile/resolve.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var URI = __webpack_require__(/*! uri-js */ "./node_modules/uri-js/dist/es5/uri.all.js")
  , equal = __webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js")
  , util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js")
  , SchemaObject = __webpack_require__(/*! ./schema_obj */ "./node_modules/ajv/lib/compile/schema_obj.js")
  , traverse = __webpack_require__(/*! json-schema-traverse */ "./node_modules/json-schema-traverse/index.js");

module.exports = resolve;

resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;

/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */
function resolve(compile, root, ref) {
  /* jshint validthis: true */
  var refVal = this._refs[ref];
  if (typeof refVal == 'string') {
    if (this._refs[refVal]) refVal = this._refs[refVal];
    else return resolve.call(this, compile, root, refVal);
  }

  refVal = refVal || this._schemas[ref];
  if (refVal instanceof SchemaObject) {
    return inlineRef(refVal.schema, this._opts.inlineRefs)
            ? refVal.schema
            : refVal.validate || this._compile(refVal);
  }

  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }

  if (schema instanceof SchemaObject) {
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  } else if (schema !== undefined) {
    v = inlineRef(schema, this._opts.inlineRefs)
        ? schema
        : compile.call(this, schema, root, undefined, baseId);
  }

  return v;
}


/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */
function resolveSchema(root, ref) {
  /* jshint validthis: true */
  var p = URI.parse(ref)
    , refPath = _getFullPath(p)
    , baseId = getFullPath(this._getId(root.schema));
  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == 'string') {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof SchemaObject) {
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject) {
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref))
          return { schema: refVal, root: root, baseId: baseId };
        root = refVal;
      } else {
        return;
      }
    }
    if (!root.schema) return;
    baseId = getFullPath(this._getId(root.schema));
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}


/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);
  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    var id = this._getId(schema);
    if (id) baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}


var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
  /* jshint validthis: true */
  parsedRef.fragment = parsedRef.fragment || '';
  if (parsedRef.fragment.slice(0,1) != '/') return;
  var parts = parsedRef.fragment.split('/');

  for (var i = 1; i < parts.length; i++) {
    var part = parts[i];
    if (part) {
      part = util.unescapeFragment(part);
      schema = schema[part];
      if (schema === undefined) break;
      var id;
      if (!PREVENT_SCOPE_CHANGE[part]) {
        id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        if (schema.$ref) {
          var $ref = resolveUrl(baseId, schema.$ref);
          var res = resolveSchema.call(this, root, $ref);
          if (res) {
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          }
        }
      }
    }
  }
  if (schema !== undefined && schema !== root.schema)
    return { schema: schema, root: root, baseId: baseId };
}


var SIMPLE_INLINED = util.toHash([
  'type', 'format', 'pattern',
  'maxLength', 'minLength',
  'maxProperties', 'minProperties',
  'maxItems', 'minItems',
  'maximum', 'minimum',
  'uniqueItems', 'multipleOf',
  'required', 'enum'
]);
function inlineRef(schema, limit) {
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);
  else if (limit) return countKeys(schema) <= limit;
}


function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return false;
      item = schema[key];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  }
  return true;
}


function countKeys(schema) {
  var count = 0, item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object') count += countKeys(item);
      if (count == Infinity) return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return Infinity;
      if (SIMPLE_INLINED[key]) {
        count++;
      } else {
        item = schema[key];
        if (typeof item == 'object') count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      }
    }
  }
  return count;
}


function getFullPath(id, normalize) {
  if (normalize !== false) id = normalizeId(id);
  var p = URI.parse(id);
  return _getFullPath(p);
}


function _getFullPath(p) {
  return URI.serialize(p).split('#')[0] + '#';
}


var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
}


function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return URI.resolve(baseId, id);
}


/* @this Ajv */
function resolveIds(schema) {
  var schemaId = normalizeId(this._getId(schema));
  var baseIds = {'': schemaId};
  var fullPaths = {'': getFullPath(schemaId, false)};
  var localRefs = {};
  var self = this;

  traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (jsonPtr === '') return;
    var id = self._getId(sch);
    var baseId = baseIds[parentJsonPtr];
    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
    if (keyIndex !== undefined)
      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));

    if (typeof id == 'string') {
      id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);

      var refVal = self._refs[id];
      if (typeof refVal == 'string') refVal = self._refs[refVal];
      if (refVal && refVal.schema) {
        if (!equal(sch, refVal.schema))
          throw new Error('id "' + id + '" resolves to more than one schema');
      } else if (id != normalizeId(fullPath)) {
        if (id[0] == '#') {
          if (localRefs[id] && !equal(sch, localRefs[id]))
            throw new Error('id "' + id + '" resolves to more than one schema');
          localRefs[id] = sch;
        } else {
          self._refs[id] = fullPath;
        }
      }
    }
    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  });

  return localRefs;
}


/***/ }),

/***/ "./node_modules/ajv/lib/compile/rules.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/compile/rules.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ruleModules = __webpack_require__(/*! ../dotjs */ "./node_modules/ajv/lib/dotjs/index.js")
  , toHash = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js").toHash;

module.exports = function rules() {
  var RULES = [
    { type: 'number',
      rules: [ { 'maximum': ['exclusiveMaximum'] },
               { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] },
    { type: 'string',
      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },
    { type: 'array',
      rules: [ 'maxItems', 'minItems', 'items', 'contains', 'uniqueItems' ] },
    { type: 'object',
      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',
               { 'properties': ['additionalProperties', 'patternProperties'] } ] },
    { rules: [ '$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if' ] }
  ];

  var ALL = [ 'type', '$comment' ];
  var KEYWORDS = [
    '$schema', '$id', 'id', '$data', '$async', 'title',
    'description', 'default', 'definitions',
    'examples', 'readOnly', 'writeOnly',
    'contentMediaType', 'contentEncoding',
    'additionalItems', 'then', 'else'
  ];
  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];
  RULES.all = toHash(ALL);
  RULES.types = toHash(TYPES);

  RULES.forEach(function (group) {
    group.rules = group.rules.map(function (keyword) {
      var implKeywords;
      if (typeof keyword == 'object') {
        var key = Object.keys(keyword)[0];
        implKeywords = keyword[key];
        keyword = key;
        implKeywords.forEach(function (k) {
          ALL.push(k);
          RULES.all[k] = true;
        });
      }
      ALL.push(keyword);
      var rule = RULES.all[keyword] = {
        keyword: keyword,
        code: ruleModules[keyword],
        implements: implKeywords
      };
      return rule;
    });

    RULES.all.$comment = {
      keyword: '$comment',
      code: ruleModules.$comment
    };

    if (group.type) RULES.types[group.type] = group;
  });

  RULES.keywords = toHash(ALL.concat(KEYWORDS));
  RULES.custom = {};

  return RULES;
};


/***/ }),

/***/ "./node_modules/ajv/lib/compile/schema_obj.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/lib/compile/schema_obj.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js");

module.exports = SchemaObject;

function SchemaObject(obj) {
  util.copy(obj, this);
}


/***/ }),

/***/ "./node_modules/ajv/lib/compile/ucs2length.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/lib/compile/ucs2length.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
module.exports = function ucs2length(str) {
  var length = 0
    , len = str.length
    , pos = 0
    , value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
      // high surrogate, and there is a next character
      value = str.charCodeAt(pos);
      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
    }
  }
  return length;
};


/***/ }),

/***/ "./node_modules/ajv/lib/compile/util.js":
/*!**********************************************!*\
  !*** ./node_modules/ajv/lib/compile/util.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



module.exports = {
  copy: copy,
  checkDataType: checkDataType,
  checkDataTypes: checkDataTypes,
  coerceToTypes: coerceToTypes,
  toHash: toHash,
  getProperty: getProperty,
  escapeQuotes: escapeQuotes,
  equal: __webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js"),
  ucs2length: __webpack_require__(/*! ./ucs2length */ "./node_modules/ajv/lib/compile/ucs2length.js"),
  varOccurences: varOccurences,
  varReplace: varReplace,
  cleanUpCode: cleanUpCode,
  finalCleanUpCode: finalCleanUpCode,
  schemaHasRules: schemaHasRules,
  schemaHasRulesExcept: schemaHasRulesExcept,
  schemaUnknownRules: schemaUnknownRules,
  toQuotedString: toQuotedString,
  getPathExpr: getPathExpr,
  getPath: getPath,
  getData: getData,
  unescapeFragment: unescapeFragment,
  unescapeJsonPointer: unescapeJsonPointer,
  escapeFragment: escapeFragment,
  escapeJsonPointer: escapeJsonPointer
};


function copy(o, to) {
  to = to || {};
  for (var key in o) to[key] = o[key];
  return to;
}


function checkDataType(dataType, data, negate) {
  var EQUAL = negate ? ' !== ' : ' === '
    , AND = negate ? ' || ' : ' && '
    , OK = negate ? '!' : ''
    , NOT = negate ? '' : '!';
  switch (dataType) {
    case 'null': return data + EQUAL + 'null';
    case 'array': return OK + 'Array.isArray(' + data + ')';
    case 'object': return '(' + OK + data + AND +
                          'typeof ' + data + EQUAL + '"object"' + AND +
                          NOT + 'Array.isArray(' + data + '))';
    case 'integer': return '(typeof ' + data + EQUAL + '"number"' + AND +
                           NOT + '(' + data + ' % 1)' +
                           AND + data + EQUAL + data + ')';
    default: return 'typeof ' + data + EQUAL + '"' + dataType + '"';
  }
}


function checkDataTypes(dataTypes, data) {
  switch (dataTypes.length) {
    case 1: return checkDataType(dataTypes[0], data, true);
    default:
      var code = '';
      var types = toHash(dataTypes);
      if (types.array && types.object) {
        code = types.null ? '(': '(!' + data + ' || ';
        code += 'typeof ' + data + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      }
      if (types.number) delete types.integer;
      for (var t in types)
        code += (code ? ' && ' : '' ) + checkDataType(t, data, true);

      return code;
  }
}


var COERCE_TO_TYPES = toHash([ 'string', 'number', 'integer', 'boolean', 'null' ]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i=0; i<dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t]) types[types.length] = t;
      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
    }
    if (types.length) return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
    return ['array'];
  }
}


function toHash(arr) {
  var hash = {};
  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
  return hash;
}


var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\/g;
function getProperty(key) {
  return typeof key == 'number'
          ? '[' + key + ']'
          : IDENTIFIER.test(key)
            ? '.' + key
            : "['" + escapeQuotes(key) + "']";
}


function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, '\\$&')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\f/g, '\\f')
            .replace(/\t/g, '\\t');
}


function varOccurences(str, dataVar) {
  dataVar += '[^0-9]';
  var matches = str.match(new RegExp(dataVar, 'g'));
  return matches ? matches.length : 0;
}


function varReplace(str, dataVar, expr) {
  dataVar += '([^0-9])';
  expr = expr.replace(/\$/g, '$$$$');
  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
}


var EMPTY_ELSE = /else\s*{\s*}/g
  , EMPTY_IF_NO_ELSE = /if\s*\([^)]+\)\s*\{\s*\}(?!\s*else)/g
  , EMPTY_IF_WITH_ELSE = /if\s*\(([^)]+)\)\s*\{\s*\}\s*else(?!\s*if)/g;
function cleanUpCode(out) {
  return out.replace(EMPTY_ELSE, '')
            .replace(EMPTY_IF_NO_ELSE, '')
            .replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');
}


var ERRORS_REGEXP = /[^v.]errors/g
  , REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g
  , REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g
  , RETURN_VALID = 'return errors === 0;'
  , RETURN_TRUE = 'validate.errors = null; return true;'
  , RETURN_ASYNC = /if \(errors === 0\) return data;\s*else throw new ValidationError\(vErrors\);/
  , RETURN_DATA_ASYNC = 'return data;'
  , ROOTDATA_REGEXP = /[^A-Za-z_$]rootData[^A-Za-z0-9_$]/g
  , REMOVE_ROOTDATA = /if \(rootData === undefined\) rootData = data;/;

function finalCleanUpCode(out, async) {
  var matches = out.match(ERRORS_REGEXP);
  if (matches && matches.length == 2) {
    out = async
          ? out.replace(REMOVE_ERRORS_ASYNC, '')
               .replace(RETURN_ASYNC, RETURN_DATA_ASYNC)
          : out.replace(REMOVE_ERRORS, '')
               .replace(RETURN_VALID, RETURN_TRUE);
  }

  matches = out.match(ROOTDATA_REGEXP);
  if (!matches || matches.length !== 3) return out;
  return out.replace(REMOVE_ROOTDATA, '');
}


function schemaHasRules(schema, rules) {
  if (typeof schema == 'boolean') return !schema;
  for (var key in schema) if (rules[key]) return true;
}


function schemaHasRulesExcept(schema, rules, exceptKeyword) {
  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
}


function schemaUnknownRules(schema, rules) {
  if (typeof schema == 'boolean') return;
  for (var key in schema) if (!rules[key]) return key;
}


function toQuotedString(str) {
  return '\'' + escapeQuotes(str) + '\'';
}


function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers // false by default
              ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')')
              : (isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'');
  return joinPaths(currentPath, path);
}


function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers // false by default
              ? toQuotedString('/' + escapeJsonPointer(prop))
              : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}


var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
  var up, jsonPointer, data, matches;
  if ($data === '') return 'rootData';
  if ($data[0] == '/') {
    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
    jsonPointer = $data;
    data = 'rootData';
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER);
    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == '#') {
      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
      return paths[lvl - up];
    }

    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
    data = 'data' + ((lvl - up) || '');
    if (!jsonPointer) return data;
  }

  var expr = data;
  var segments = jsonPointer.split('/');
  for (var i=0; i<segments.length; i++) {
    var segment = segments[i];
    if (segment) {
      data += getProperty(unescapeJsonPointer(segment));
      expr += ' && ' + data;
    }
  }
  return expr;
}


function joinPaths (a, b) {
  if (a == '""') return b;
  return (a + ' + ' + b).replace(/' \+ '/g, '');
}


function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}


function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}


function escapeJsonPointer(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}


function unescapeJsonPointer(str) {
  return str.replace(/~1/g, '/').replace(/~0/g, '~');
}


/***/ }),

/***/ "./node_modules/ajv/lib/data.js":
/*!**************************************!*\
  !*** ./node_modules/ajv/lib/data.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var KEYWORDS = [
  'multipleOf',
  'maximum',
  'exclusiveMaximum',
  'minimum',
  'exclusiveMinimum',
  'maxLength',
  'minLength',
  'pattern',
  'additionalItems',
  'maxItems',
  'minItems',
  'uniqueItems',
  'maxProperties',
  'minProperties',
  'required',
  'additionalProperties',
  'enum',
  'format',
  'const'
];

module.exports = function (metaSchema, keywordsJsonPointers) {
  for (var i=0; i<keywordsJsonPointers.length; i++) {
    metaSchema = JSON.parse(JSON.stringify(metaSchema));
    var segments = keywordsJsonPointers[i].split('/');
    var keywords = metaSchema;
    var j;
    for (j=1; j<segments.length; j++)
      keywords = keywords[segments[j]];

    for (j=0; j<KEYWORDS.length; j++) {
      var key = KEYWORDS[j];
      var schema = keywords[key];
      if (schema) {
        keywords[key] = {
          anyOf: [
            schema,
            { $ref: 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
    }
  }

  return metaSchema;
};


/***/ }),

/***/ "./node_modules/ajv/lib/definition_schema.js":
/*!***************************************************!*\
  !*** ./node_modules/ajv/lib/definition_schema.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var metaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ "./node_modules/ajv/lib/refs/json-schema-draft-07.json");

module.exports = {
  $id: 'https://github.com/epoberezkin/ajv/blob/master/lib/definition_schema.js',
  definitions: {
    simpleTypes: metaSchema.definitions.simpleTypes
  },
  type: 'object',
  dependencies: {
    schema: ['validate'],
    $data: ['validate'],
    statements: ['inline'],
    valid: {not: {required: ['macro']}}
  },
  properties: {
    type: metaSchema.properties.type,
    schema: {type: 'boolean'},
    statements: {type: 'boolean'},
    dependencies: {
      type: 'array',
      items: {type: 'string'}
    },
    metaSchema: {type: 'object'},
    modifying: {type: 'boolean'},
    valid: {type: 'boolean'},
    $data: {type: 'boolean'},
    async: {type: 'boolean'},
    errors: {
      anyOf: [
        {type: 'boolean'},
        {const: 'full'}
      ]
    }
  }
};


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/_limit.js":
/*!**********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/_limit.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate__limit(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $isMax = $keyword == 'maximum',
    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
    $op = $isMax ? '<' : '>',
    $notOp = $isMax ? '>' : '<',
    $errorKeyword = undefined;
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = 'exclusive' + $lvl,
      $exclType = 'exclType' + $lvl,
      $exclIsNumber = 'exclIsNumber' + $lvl,
      $opExpr = 'op' + $lvl,
      $opStr = '\' + ' + $opExpr + ' + \'';
    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
    $schemaValueExcl = 'schemaExcl' + $lvl;
    out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \'boolean\' && ' + ($exclType) + ' != \'undefined\' && ' + ($exclType) + ' != \'number\') { ';
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else if ( ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
    }
    out += ' ' + ($exclType) + ' == \'number\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\'; ';
    if ($schema === undefined) {
      $errorKeyword = $exclusiveKeyword;
      $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
      $schemaValue = $schemaValueExcl;
      $isData = $isDataExcl;
    }
  } else {
    var $exclIsNumber = typeof $schemaExcl == 'number',
      $opStr = $op;
    if ($exclIsNumber && $isData) {
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { ';
    } else {
      if ($exclIsNumber && $schema === undefined) {
        $exclusive = true;
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
        $schemaValue = $schemaExcl;
        $notOp += '=';
      } else {
        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
          $notOp += '=';
        } else {
          $exclusive = false;
          $opStr += '=';
        }
      }
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') { ';
    }
  }
  $errorKeyword = $errorKeyword || $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be ' + ($opStr) + ' ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/_limitItems.js":
/*!***************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/_limitItems.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate__limitItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxItems' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxItems') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' items\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/_limitLength.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/_limitLength.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate__limitLength(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxLength' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  if (it.opts.unicode === false) {
    out += ' ' + ($data) + '.length ';
  } else {
    out += ' ucs2length(' + ($data) + ') ';
  }
  out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT be ';
      if ($keyword == 'maxLength') {
        out += 'longer';
      } else {
        out += 'shorter';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' characters\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/_limitProperties.js":
/*!********************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/_limitProperties.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxProperties' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxProperties') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' properties\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/allOf.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/allOf.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_allOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $allSchemasEmpty = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($breakOnError) {
    if ($allSchemasEmpty) {
      out += ' if (true) { ';
    } else {
      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';
    }
  }
  out = it.util.cleanUpCode(out);
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/anyOf.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/anyOf.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_anyOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $noEmptySchema = $schema.every(function($sch) {
    return (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all));
  });
  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';
        $closingBraces += '}';
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('anyOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match some schema in anyOf\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
    out = it.util.cleanUpCode(out);
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/comment.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/comment.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_comment(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $comment = it.util.toQuotedString($schema);
  if (it.opts.$comment === true) {
    out += ' console.log(' + ($comment) + ');';
  } else if (typeof it.opts.$comment == 'function') {
    out += ' self._opts.$comment(' + ($comment) + ', ' + (it.util.toQuotedString($errSchemaPath)) + ', validate.root.schema);';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/const.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/const.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_const(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!$isData) {
    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('const') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValue: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to constant\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/contains.js":
/*!************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/contains.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_contains(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId,
    $nonEmptySchema = (it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all));
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($nonEmptySchema) {
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    out += ' if (' + ($nextValid) + ') break; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') {';
  } else {
    out += ' if (' + ($data) + '.length == 0) {';
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('contains') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should contain a valid item\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } else { ';
  if ($nonEmptySchema) {
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
  }
  if (it.opts.allErrors) {
    out += ' } ';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/custom.js":
/*!**********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/custom.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_custom(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $rule = this,
    $definition = 'definition' + $lvl,
    $rDef = $rule.definition,
    $closingBraces = '';
  var $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData && $rDef.$data) {
    $validateCode = 'keywordValidate' + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += ' var ' + ($definition) + ' = RULES.custom[\'' + ($keyword) + '\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
    if (!$ruleValidate) return;
    $schemaValue = 'validate.schema' + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + '.errors',
    $i = 'i' + $lvl,
    $ruleErr = 'ruleErr' + $lvl,
    $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
  if (!($inline || $macro)) {
    out += '' + ($ruleErrs) + ' = null;';
  }
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($isData && $rDef.$data) {
    $closingBraces += '}';
    out += ' if (' + ($schemaValue) + ' === undefined) { ' + ($valid) + ' = true; } else { ';
    if ($validateSchema) {
      $closingBraces += '}';
      out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') { ';
    }
  }
  if ($inline) {
    if ($rDef.statements) {
      out += ' ' + ($ruleValidate.validate) + ' ';
    } else {
      out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';
    }
  } else if ($macro) {
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = '';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($code);
  } else {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    out += '  ' + ($validateCode) + '.call( ';
    if (it.opts.passContext) {
      out += 'this';
    } else {
      out += 'self';
    }
    if ($compile || $rDef.schema === false) {
      out += ' , ' + ($data) + ' ';
    } else {
      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';
    }
    out += ' , (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors === false) {
      out += ' ' + ($valid) + ' = ';
      if ($asyncKeyword) {
        out += 'await ';
      }
      out += '' + (def_callRuleValidate) + '; ';
    } else {
      if ($asyncKeyword) {
        $ruleErrs = 'customErrors' + $lvl;
        out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = await ' + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';
      } else {
        out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';
      }
    }
  }
  if ($rDef.modifying) {
    out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';
  }
  out += '' + ($closingBraces);
  if ($rDef.valid) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  } else {
    out += ' if ( ';
    if ($rDef.valid === undefined) {
      out += ' !';
      if ($macro) {
        out += '' + ($nextValid);
      } else {
        out += '' + ($valid);
      }
    } else {
      out += ' ' + (!$rDef.valid) + ' ';
    }
    out += ') { ';
    $errorKeyword = $rule.keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    var def_customError = out;
    out = $$outStack.pop();
    if ($inline) {
      if ($rDef.errors) {
        if ($rDef.errors != 'full') {
          out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } ';
        }
      } else {
        if ($rDef.errors === false) {
          out += ' ' + (def_customError) + ' ';
        } else {
          out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } } ';
        }
      }
    } else if ($macro) {
      out += '   var err =   '; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
    } else {
      if ($rDef.errors === false) {
        out += ' ' + (def_customError) + ' ';
      } else {
        out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '";  ';
        if (it.opts.verbose) {
          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
        }
        out += ' } } else { ' + (def_customError) + ' } ';
      }
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/dependencies.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/dependencies.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_dependencies(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $schemaDeps = {},
    $propertyDeps = {},
    $ownProperties = it.opts.ownProperties;
  for ($property in $schema) {
    var $sch = $schema[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += 'var ' + ($errs) + ' = errors;';
  var $currentErrorPath = it.errorPath;
  out += 'var missing' + ($lvl) + ';';
  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];
    if ($deps.length) {
      out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
      }
      if ($breakOnError) {
        out += ' && ( ';
        var arr1 = $deps;
        if (arr1) {
          var $propertyKey, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $propertyKey = arr1[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ')) {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should have ';
            if ($deps.length == 1) {
              out += 'property ' + (it.util.escapeQuotes($deps[0]));
            } else {
              out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
            }
            out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      } else {
        out += ' ) { ';
        var arr2 = $deps;
        if (arr2) {
          var $propertyKey, i2 = -1,
            l2 = arr2.length - 1;
          while (i2 < l2) {
            $propertyKey = arr2[i2 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should have ';
                if ($deps.length == 1) {
                  out += 'property ' + (it.util.escapeQuotes($deps[0]));
                } else {
                  out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
                }
                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
      out += ' }   ';
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
  }
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];
    if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
      out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
      }
      out += ') { ';
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  }
  if ($breakOnError) {
    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/enum.js":
/*!********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/enum.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_enum(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $i = 'i' + $lvl,
    $vSchema = 'schema' + $lvl;
  if (!$isData) {
    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ';';
  if ($isData) {
    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
  }
  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';
  if ($isData) {
    out += '  }  ';
  }
  out += ' if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('enum') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to one of the allowed values\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/format.js":
/*!**********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/format.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_format(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  if (it.opts.format === false) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
    return out;
  }
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $unknownFormats = it.opts.unknownFormats,
    $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) {
    var $format = 'format' + $lvl,
      $isObject = 'isObject' + $lvl,
      $formatType = 'formatType' + $lvl;
    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \'object\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \'string\'; if (' + ($isObject) + ') { ';
    if (it.async) {
      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';
    }
    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
    }
    out += ' (';
    if ($unknownFormats != 'ignore') {
      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';
      if ($allowUnknown) {
        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';
      }
      out += ') || ';
    }
    out += ' (' + ($format) + ' && ' + ($formatType) + ' == \'' + ($ruleType) + '\' && !(typeof ' + ($format) + ' == \'function\' ? ';
    if (it.async) {
      out += ' (async' + ($lvl) + ' ? await ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';
    } else {
      out += ' ' + ($format) + '(' + ($data) + ') ';
    }
    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';
  } else {
    var $format = it.formats[$schema];
    if (!$format) {
      if ($unknownFormats == 'ignore') {
        it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else {
        throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
      }
    }
    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
    var $formatType = $isObject && $format.type || 'string';
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($formatType != $ruleType) {
      if ($breakOnError) {
        out += ' if (true) { ';
      }
      return out;
    }
    if ($async) {
      if (!it.async) throw new Error('async format in sync schema');
      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
      out += ' if (!(await ' + ($formatRef) + '(' + ($data) + '))) { ';
    } else {
      out += ' if (! ';
      var $formatRef = 'formats' + it.util.getProperty($schema);
      if ($isObject) $formatRef += '.validate';
      if (typeof $format == 'function') {
        out += ' ' + ($formatRef) + '(' + ($data) + ') ';
      } else {
        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';
      }
      out += ') { ';
    }
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('format') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match format "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/if.js":
/*!******************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/if.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_if(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $thenSch = it.schema['then'],
    $elseSch = it.schema['else'],
    $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? typeof $thenSch == 'object' && Object.keys($thenSch).length > 0 : it.util.schemaHasRules($thenSch, it.RULES.all)),
    $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? typeof $elseSch == 'object' && Object.keys($elseSch).length > 0 : it.util.schemaHasRules($elseSch, it.RULES.all)),
    $currentBaseId = $it.baseId;
  if ($thenPresent || $elsePresent) {
    var $ifClause;
    $it.createErrors = false;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = true;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    out += '  ' + (it.validate($it)) + ' ';
    $it.baseId = $currentBaseId;
    $it.createErrors = true;
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    if ($thenPresent) {
      out += ' if (' + ($nextValid) + ') {  ';
      $it.schema = it.schema['then'];
      $it.schemaPath = it.schemaPath + '.then';
      $it.errSchemaPath = it.errSchemaPath + '/then';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \'then\'; ';
      } else {
        $ifClause = '\'then\'';
      }
      out += ' } ';
      if ($elsePresent) {
        out += ' else { ';
      }
    } else {
      out += ' if (!' + ($nextValid) + ') { ';
    }
    if ($elsePresent) {
      $it.schema = it.schema['else'];
      $it.schemaPath = it.schemaPath + '.else';
      $it.errSchemaPath = it.errSchemaPath + '/else';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \'else\'; ';
      } else {
        $ifClause = '\'else\'';
      }
      out += ' } ';
    }
    out += ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('if') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { failingKeyword: ' + ($ifClause) + ' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match "\' + ' + ($ifClause) + ' + \'" schema\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' }   ';
    if ($breakOnError) {
      out += ' else { ';
    }
    out = it.util.cleanUpCode(out);
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//all requires must be explicit because browserify won't work with dynamic requires
module.exports = {
  '$ref': __webpack_require__(/*! ./ref */ "./node_modules/ajv/lib/dotjs/ref.js"),
  allOf: __webpack_require__(/*! ./allOf */ "./node_modules/ajv/lib/dotjs/allOf.js"),
  anyOf: __webpack_require__(/*! ./anyOf */ "./node_modules/ajv/lib/dotjs/anyOf.js"),
  '$comment': __webpack_require__(/*! ./comment */ "./node_modules/ajv/lib/dotjs/comment.js"),
  const: __webpack_require__(/*! ./const */ "./node_modules/ajv/lib/dotjs/const.js"),
  contains: __webpack_require__(/*! ./contains */ "./node_modules/ajv/lib/dotjs/contains.js"),
  dependencies: __webpack_require__(/*! ./dependencies */ "./node_modules/ajv/lib/dotjs/dependencies.js"),
  'enum': __webpack_require__(/*! ./enum */ "./node_modules/ajv/lib/dotjs/enum.js"),
  format: __webpack_require__(/*! ./format */ "./node_modules/ajv/lib/dotjs/format.js"),
  'if': __webpack_require__(/*! ./if */ "./node_modules/ajv/lib/dotjs/if.js"),
  items: __webpack_require__(/*! ./items */ "./node_modules/ajv/lib/dotjs/items.js"),
  maximum: __webpack_require__(/*! ./_limit */ "./node_modules/ajv/lib/dotjs/_limit.js"),
  minimum: __webpack_require__(/*! ./_limit */ "./node_modules/ajv/lib/dotjs/_limit.js"),
  maxItems: __webpack_require__(/*! ./_limitItems */ "./node_modules/ajv/lib/dotjs/_limitItems.js"),
  minItems: __webpack_require__(/*! ./_limitItems */ "./node_modules/ajv/lib/dotjs/_limitItems.js"),
  maxLength: __webpack_require__(/*! ./_limitLength */ "./node_modules/ajv/lib/dotjs/_limitLength.js"),
  minLength: __webpack_require__(/*! ./_limitLength */ "./node_modules/ajv/lib/dotjs/_limitLength.js"),
  maxProperties: __webpack_require__(/*! ./_limitProperties */ "./node_modules/ajv/lib/dotjs/_limitProperties.js"),
  minProperties: __webpack_require__(/*! ./_limitProperties */ "./node_modules/ajv/lib/dotjs/_limitProperties.js"),
  multipleOf: __webpack_require__(/*! ./multipleOf */ "./node_modules/ajv/lib/dotjs/multipleOf.js"),
  not: __webpack_require__(/*! ./not */ "./node_modules/ajv/lib/dotjs/not.js"),
  oneOf: __webpack_require__(/*! ./oneOf */ "./node_modules/ajv/lib/dotjs/oneOf.js"),
  pattern: __webpack_require__(/*! ./pattern */ "./node_modules/ajv/lib/dotjs/pattern.js"),
  properties: __webpack_require__(/*! ./properties */ "./node_modules/ajv/lib/dotjs/properties.js"),
  propertyNames: __webpack_require__(/*! ./propertyNames */ "./node_modules/ajv/lib/dotjs/propertyNames.js"),
  required: __webpack_require__(/*! ./required */ "./node_modules/ajv/lib/dotjs/required.js"),
  uniqueItems: __webpack_require__(/*! ./uniqueItems */ "./node_modules/ajv/lib/dotjs/uniqueItems.js"),
  validate: __webpack_require__(/*! ./validate */ "./node_modules/ajv/lib/dotjs/validate.js")
};


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/items.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/items.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_items(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId;
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if (Array.isArray($schema)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += '  if (!' + ($valid) + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ('additionalItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT have more than ' + ($schema.length) + ' items\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';
          var $passData = $data + '[' + $i + ']';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
    if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0 : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + '.additionalItems';
      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
      } else {
        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
      }
      if ($breakOnError) {
        out += ' if (!' + ($nextValid) + ') break; ';
      }
      out += ' } }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  } else if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    if ($breakOnError) {
      out += ' if (!' + ($nextValid) + ') break; ';
    }
    out += ' }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/multipleOf.js":
/*!**************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/multipleOf.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  out += 'var division' + ($lvl) + ';if (';
  if ($isData) {
    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \'number\' || ';
  }
  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';
  if (it.opts.multipleOfPrecision) {
    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';
  } else {
    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';
  }
  out += ' ) ';
  if ($isData) {
    out += '  )  ';
  }
  out += ' ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('multipleOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be multiple of ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/not.js":
/*!*******************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/not.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_not(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += ' ' + (it.validate($it)) + ' ';
    $it.createErrors = true;
    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (' + ($nextValid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    out += '  var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if ($breakOnError) {
      out += ' if (false) { ';
    }
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/oneOf.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/oneOf.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_oneOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $prevValid = 'prevValid' + $lvl,
    $passingSchemas = 'passingSchemas' + $lvl;
  out += 'var ' + ($errs) + ' = errors , ' + ($prevValid) + ' = false , ' + ($valid) + ' = false , ' + ($passingSchemas) + ' = null; ';
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
      } else {
        out += ' var ' + ($nextValid) + ' = true; ';
      }
      if ($i) {
        out += ' if (' + ($nextValid) + ' && ' + ($prevValid) + ') { ' + ($valid) + ' = false; ' + ($passingSchemas) + ' = [' + ($passingSchemas) + ', ' + ($i) + ']; } else { ';
        $closingBraces += '}';
      }
      out += ' if (' + ($nextValid) + ') { ' + ($valid) + ' = ' + ($prevValid) + ' = true; ' + ($passingSchemas) + ' = ' + ($i) + '; }';
    }
  }
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('oneOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { passingSchemas: ' + ($passingSchemas) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match exactly one schema in oneOf\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; return false; ';
    }
  }
  out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';
  if (it.opts.allErrors) {
    out += ' } ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/pattern.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/pattern.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_pattern(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
  }
  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('pattern') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match pattern "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/properties.js":
/*!**************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/properties.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_properties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $key = 'key' + $lvl,
    $idx = 'idx' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $dataProperties = 'dataProperties' + $lvl;
  var $schemaKeys = Object.keys($schema || {}),
    $pProperties = it.schema.patternProperties || {},
    $pPropertyKeys = Object.keys($pProperties),
    $aProperties = it.schema.additionalProperties,
    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
    $noAdditional = $aProperties === false,
    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
    $removeAdditional = it.opts.removeAdditional,
    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
    $ownProperties = it.opts.ownProperties,
    $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';
  if ($ownProperties) {
    out += ' var ' + ($dataProperties) + ' = undefined;';
  }
  if ($checkAdditional) {
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    if ($someProperties) {
      out += ' var isAdditional' + ($lvl) + ' = !(false ';
      if ($schemaKeys.length) {
        if ($schemaKeys.length > 8) {
          out += ' || validate.schema' + ($schemaPath) + '.hasOwnProperty(' + ($key) + ') ';
        } else {
          var arr1 = $schemaKeys;
          if (arr1) {
            var $propertyKey, i1 = -1,
              l1 = arr1.length - 1;
            while (i1 < l1) {
              $propertyKey = arr1[i1 += 1];
              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2) {
          var $pProperty, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $pProperty = arr2[$i += 1];
            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';
          }
        }
      }
      out += ' ); if (isAdditional' + ($lvl) + ') { ';
    }
    if ($removeAdditional == 'all') {
      out += ' delete ' + ($data) + '[' + ($key) + ']; ';
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = '\' + ' + $key + ' + \'';
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      }
      if ($noAdditional) {
        if ($removeAdditional) {
          out += ' delete ' + ($data) + '[' + ($key) + ']; ';
        } else {
          out += ' ' + ($nextValid) + ' = false; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalProperties';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ('additionalProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \'' + ($additionalProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is an invalid additional property';
              } else {
                out += 'should NOT have additional properties';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            out += ' break; ';
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == 'failing') {
          out += ' var ' + ($errs) + ' = errors;  ';
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
        }
      }
      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) {
      out += ' } ';
    }
    out += ' }  ';
    if ($breakOnError) {
      out += ' if (' + ($nextValid) + ') { ';
      $closingBraces += '}';
    }
  }
  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
  if ($schemaKeys.length) {
    var arr3 = $schemaKeys;
    if (arr3) {
      var $propertyKey, i3 = -1,
        l3 = arr3.length - 1;
      while (i3 < l3) {
        $propertyKey = arr3[i3 += 1];
        var $sch = $schema[$propertyKey];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          var $prop = it.util.getProperty($propertyKey),
            $passData = $data + $prop,
            $hasDefault = $useDefaults && $sch.default !== undefined;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';
          }
          if ($hasDefault) {
            out += ' ' + ($code) + ' ';
          } else {
            if ($requiredHash && $requiredHash[$propertyKey]) {
              out += ' if ( ' + ($useData) + ' === undefined ';
              if ($ownProperties) {
                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
              }
              out += ') { ' + ($nextValid) + ' = false; ';
              var $currentErrorPath = it.errorPath,
                $currErrSchemaPath = $errSchemaPath,
                $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              $errSchemaPath = it.errSchemaPath + '/required';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'';
                  if (it.opts._errorDataPathProperty) {
                    out += 'is a required property';
                  } else {
                    out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += ' } else { ';
            } else {
              if ($breakOnError) {
                out += ' if ( ' + ($useData) + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ') { ' + ($nextValid) + ' = true; } else { ';
              } else {
                out += ' if (' + ($useData) + ' !== undefined ';
                if ($ownProperties) {
                  out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ' ) { ';
              }
            }
            out += ' ' + ($code) + ' } ';
          }
        }
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($pPropertyKeys.length) {
    var arr4 = $pPropertyKeys;
    if (arr4) {
      var $pProperty, i4 = -1,
        l4 = arr4.length - 1;
      while (i4 < l4) {
        $pProperty = arr4[i4 += 1];
        var $sch = $pProperties[$pProperty];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
          if ($ownProperties) {
            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
          } else {
            out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
          }
          out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
          out += ' } ';
          if ($breakOnError) {
            out += ' else ' + ($nextValid) + ' = true; ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/propertyNames.js":
/*!*****************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/propertyNames.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  out += 'var ' + ($errs) + ' = errors;';
  if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    var $key = 'key' + $lvl,
      $idx = 'idx' + $lvl,
      $i = 'i' + $lvl,
      $invalidName = '\' + ' + $key + ' + \'',
      $dataNxt = $it.dataLevel = it.dataLevel + 1,
      $nextData = 'data' + $dataNxt,
      $dataProperties = 'dataProperties' + $lvl,
      $ownProperties = it.opts.ownProperties,
      $currentBaseId = it.baseId;
    if ($ownProperties) {
      out += ' var ' + ($dataProperties) + ' = undefined; ';
    }
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    out += ' var startErrs' + ($lvl) + ' = errors; ';
    var $passData = $key;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (!' + ($nextValid) + ') { for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) { vErrors[' + ($i) + '].propertyName = ' + ($key) + '; }   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('propertyNames') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { propertyName: \'' + ($invalidName) + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'property name \\\'' + ($invalidName) + '\\\' is invalid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    if ($breakOnError) {
      out += ' break; ';
    }
    out += ' } }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/ref.js":
/*!*******************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/ref.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_ref(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $async, $refCode;
  if ($schema == '#' || $schema == '#/') {
    if (it.isRoot) {
      $async = it.async;
      $refCode = 'validate';
    } else {
      $async = it.root.schema.$async === true;
      $refCode = 'root.refVal[0]';
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
    if ($refVal === undefined) {
      var $message = it.MissingRefError.message(it.baseId, $schema);
      if (it.opts.missingRefs == 'fail') {
        it.logger.error($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('$ref') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \'' + (it.util.escapeQuotes($schema)) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'can\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        if ($breakOnError) {
          out += ' if (false) { ';
        }
      } else if (it.opts.missingRefs == 'ignore') {
        it.logger.warn($message);
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      } else {
        throw new it.MissingRefError(it.baseId, $schema, $message);
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = '';
      $it.errSchemaPath = $schema;
      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
      out += ' ' + ($code) + ' ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
      }
    } else {
      $async = $refVal.$async === true || (it.async && $refVal.$async !== false);
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.opts.passContext) {
      out += ' ' + ($refCode) + '.call(this, ';
    } else {
      out += ' ' + ($refCode) + '( ';
    }
    out += ' ' + ($data) + ', (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) {
      if (!it.async) throw new Error('async schema referenced by sync schema');
      if ($breakOnError) {
        out += ' var ' + ($valid) + '; ';
      }
      out += ' try { await ' + (__callValidate) + '; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = true; ';
      }
      out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = false; ';
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' if (' + ($valid) + ') { ';
      }
    } else {
      out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';
      if ($breakOnError) {
        out += ' else { ';
      }
    }
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/required.js":
/*!************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/required.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_required(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $vSchema = 'schema' + $lvl;
  if (!$isData) {
    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema;
      if (arr1) {
        var $property, i1 = -1,
          l1 = arr1.length - 1;
        while (i1 < l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == 'object' && Object.keys($propertySch).length > 0 : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema;
    }
  }
  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath,
      $loopRequired = $isData || $required.length >= it.opts.loopRequired,
      $ownProperties = it.opts.ownProperties;
    if ($breakOnError) {
      out += ' var missing' + ($lvl) + '; ';
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        out += ' var ' + ($valid) + ' = true; ';
        if ($isData) {
          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';
        if ($ownProperties) {
          out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += '; if (!' + ($valid) + ') break; } ';
        if ($isData) {
          out += '  }  ';
        }
        out += '  if (!' + ($valid) + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      } else {
        out += ' if ( ';
        var arr2 = $required;
        if (arr2) {
          var $propertyKey, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $propertyKey = arr2[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ') {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        if ($isData) {
          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is a required property';
              } else {
                out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';
        if ($ownProperties) {
          out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += ') {  var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
        if ($isData) {
          out += '  }  ';
        }
      } else {
        var arr3 = $required;
        if (arr3) {
          var $propertyKey, i3 = -1,
            l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += ' if (true) {';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/uniqueItems.js":
/*!***************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/uniqueItems.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (($schema || $isData) && it.opts.uniqueItems !== false) {
    if ($isData) {
      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'boolean\') ' + ($valid) + ' = false; else { ';
    }
    out += ' var i = ' + ($data) + '.length , ' + ($valid) + ' = true , j; if (i > 1) { ';
    var $itemType = it.schema.items && it.schema.items.type,
      $typeIsArray = Array.isArray($itemType);
    if (!$itemType || $itemType == 'object' || $itemType == 'array' || ($typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))) {
      out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } ';
    } else {
      out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + ($data) + '[i]; ';
      var $method = 'checkDataType' + ($typeIsArray ? 's' : '');
      out += ' if (' + (it.util[$method]($itemType, 'item', true)) + ') continue; ';
      if ($typeIsArray) {
        out += ' if (typeof item == \'string\') item = \'"\' + item; ';
      }
      out += ' if (typeof itemIndices[item] == \'number\') { ' + ($valid) + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';
    }
    out += ' } ';
    if ($isData) {
      out += '  }  ';
    }
    out += ' if (!' + ($valid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('uniqueItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + ($schemaPath);
        } else {
          out += '' + ($schema);
        }
        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/validate.js":
/*!************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/validate.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_validate(it, $keyword, $ruleType) {
  var out = '';
  var $async = it.schema.$async === true,
    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
    $id = it.self._getId(it.schema);
  if (it.opts.strictKeywords) {
    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
    if ($unknownKwd) {
      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;
      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);
      else throw new Error($keywordsMsg);
    }
  }
  if (it.isTop) {
    out += ' var validate = ';
    if ($async) {
      it.async = true;
      out += 'async ';
    }
    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \'use strict\'; ';
    if ($id && (it.opts.sourceCode || it.opts.processCode)) {
      out += ' ' + ('/\*# sourceURL=' + $id + ' */') + ' ';
    }
  }
  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
    var $keyword = 'false schema';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    if (it.schema === false) {
      if (it.isTop) {
        $breakOnError = true;
      } else {
        out += ' var ' + ($valid) + ' = false; ';
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'false schema') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
        if (it.opts.messages !== false) {
          out += ' , message: \'boolean schema is false\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
    } else {
      if (it.isTop) {
        if ($async) {
          out += ' return data; ';
        } else {
          out += ' validate.errors = null; return true; ';
        }
      } else {
        out += ' var ' + ($valid) + ' = true; ';
      }
    }
    if (it.isTop) {
      out += ' }; return validate; ';
    }
    return out;
  }
  if (it.isTop) {
    var $top = it.isTop,
      $lvl = it.level = 0,
      $dataLvl = it.dataLevel = 0,
      $data = 'data';
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;
    it.dataPathArr = [undefined];
    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
      var $defaultMsg = 'default is ignored in the schema root';
      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
      else throw new Error($defaultMsg);
    }
    out += ' var vErrors = null; ';
    out += ' var errors = 0;     ';
    out += ' if (rootData === undefined) rootData = data; ';
  } else {
    var $lvl = it.level,
      $dataLvl = it.dataLevel,
      $data = 'data' + ($dataLvl || '');
    if ($id) it.baseId = it.resolve.url(it.baseId, $id);
    if ($async && !it.async) throw new Error('async schema in sync schema');
    out += ' var errs_' + ($lvl) + ' = errors;';
  }
  var $valid = 'valid' + $lvl,
    $breakOnError = !it.opts.allErrors,
    $closingBraces1 = '',
    $closingBraces2 = '';
  var $errorKeyword;
  var $typeSchema = it.schema.type,
    $typeIsArray = Array.isArray($typeSchema);
  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
    if ($typeIsArray) {
      if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');
    } else if ($typeSchema != 'null') {
      $typeSchema = [$typeSchema, 'null'];
      $typeIsArray = true;
    }
  }
  if ($typeIsArray && $typeSchema.length == 1) {
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  }
  if (it.schema.$ref && $refKeywords) {
    if (it.opts.extendRefs == 'fail') {
      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
    } else if (it.opts.extendRefs !== true) {
      $refKeywords = false;
      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    }
  }
  if (it.schema.$comment && it.opts.$comment) {
    out += ' ' + (it.RULES.all.$comment.code(it, '$comment'));
  }
  if ($typeSchema) {
    if (it.opts.coerceTypes) {
      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    }
    var $rulesGroup = it.RULES.types[$typeSchema];
    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type';
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type',
        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
      out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') { ';
      if ($coerceToTypes) {
        var $dataType = 'dataType' + $lvl,
          $coerced = 'coerced' + $lvl;
        out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; ';
        if (it.opts.coerceTypes == 'array') {
          out += ' if (' + ($dataType) + ' == \'object\' && Array.isArray(' + ($data) + ')) ' + ($dataType) + ' = \'array\'; ';
        }
        out += ' var ' + ($coerced) + ' = undefined; ';
        var $bracesCoercion = '';
        var arr1 = $coerceToTypes;
        if (arr1) {
          var $type, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $type = arr1[$i += 1];
            if ($i) {
              out += ' if (' + ($coerced) + ' === undefined) { ';
              $bracesCoercion += '}';
            }
            if (it.opts.coerceTypes == 'array' && $type != 'array') {
              out += ' if (' + ($dataType) + ' == \'array\' && ' + ($data) + '.length == 1) { ' + ($coerced) + ' = ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + ';  } ';
            }
            if ($type == 'string') {
              out += ' if (' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\') ' + ($coerced) + ' = \'\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \'\'; ';
            } else if ($type == 'number' || $type == 'integer') {
              out += ' if (' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \'string\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';
              if ($type == 'integer') {
                out += ' && !(' + ($data) + ' % 1)';
              }
              out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';
            } else if ($type == 'boolean') {
              out += ' if (' + ($data) + ' === \'false\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \'true\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';
            } else if ($type == 'null') {
              out += ' if (' + ($data) + ' === \'\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';
            } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
              out += ' if (' + ($dataType) + ' == \'string\' || ' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';
            }
          }
        }
        out += ' ' + ($bracesCoercion) + ' if (' + ($coerced) + ' === undefined) {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else {  ';
        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' ' + ($data) + ' = ' + ($coerced) + '; ';
        if (!$dataLvl) {
          out += 'if (' + ($parentData) + ' !== undefined)';
        }
        out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } ';
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      }
      out += ' } ';
    }
  }
  if (it.schema.$ref && !$refKeywords) {
    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';
    if ($breakOnError) {
      out += ' } if (errors === ';
      if ($top) {
        out += '0';
      } else {
        out += 'errs_' + ($lvl);
      }
      out += ') { ';
      $closingBraces2 += '}';
    }
  } else {
    var arr2 = it.RULES;
    if (arr2) {
      var $rulesGroup, i2 = -1,
        l2 = arr2.length - 1;
      while (i2 < l2) {
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data)) + ') { ';
          }
          if (it.opts.useDefaults) {
            if ($rulesGroup.type == 'object' && it.schema.properties) {
              var $schema = it.schema.properties,
                $schemaKeys = Object.keys($schema);
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey, i3 = -1,
                  l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema[$propertyKey];
                  if ($sch.default !== undefined) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + ($passData) + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                      }
                      out += ' ) ' + ($passData) + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + (it.useDefault($sch.default)) + ' ';
                      } else {
                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                var $sch, $i = -1,
                  l4 = arr4.length - 1;
                while ($i < l4) {
                  $sch = arr4[$i += 1];
                  if ($sch.default !== undefined) {
                    var $passData = $data + '[' + $i + ']';
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + ($passData) + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                      }
                      out += ' ) ' + ($passData) + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + (it.useDefault($sch.default)) + ' ';
                      } else {
                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            }
          }
          var arr5 = $rulesGroup.rules;
          if (arr5) {
            var $rule, i5 = -1,
              l5 = arr5.length - 1;
            while (i5 < l5) {
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) {
                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                if ($code) {
                  out += ' ' + ($code) + ' ';
                  if ($breakOnError) {
                    $closingBraces1 += '}';
                  }
                }
              }
            }
          }
          if ($breakOnError) {
            out += ' ' + ($closingBraces1) + ' ';
            $closingBraces1 = '';
          }
          if ($rulesGroup.type) {
            out += ' } ';
            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
              out += ' else { ';
              var $schemaPath = it.schemaPath + '.type',
                $errSchemaPath = it.errSchemaPath + '/type';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
                if ($typeIsArray) {
                  out += '' + ($typeSchema.join(","));
                } else {
                  out += '' + ($typeSchema);
                }
                out += '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should be ';
                  if ($typeIsArray) {
                    out += '' + ($typeSchema.join(","));
                  } else {
                    out += '' + ($typeSchema);
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } ';
            }
          }
          if ($breakOnError) {
            out += ' if (errors === ';
            if ($top) {
              out += '0';
            } else {
              out += 'errs_' + ($lvl);
            }
            out += ') { ';
            $closingBraces2 += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces2) + ' ';
  }
  if ($top) {
    if ($async) {
      out += ' if (errors === 0) return data;           ';
      out += ' else throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; ';
      out += ' return errors === 0;       ';
    }
    out += ' }; return validate;';
  } else {
    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';
  }
  out = it.util.cleanUpCode(out);
  if ($top) {
    out = it.util.finalCleanUpCode(out, $async);
  }

  function $shouldUseGroup($rulesGroup) {
    var rules = $rulesGroup.rules;
    for (var i = 0; i < rules.length; i++)
      if ($shouldUseRule(rules[i])) return true;
  }

  function $shouldUseRule($rule) {
    return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));
  }

  function $ruleImplementsSomeKeyword($rule) {
    var impl = $rule.implements;
    for (var i = 0; i < impl.length; i++)
      if (it.schema[impl[i]] !== undefined) return true;
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/keyword.js":
/*!*****************************************!*\
  !*** ./node_modules/ajv/lib/keyword.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = __webpack_require__(/*! ./dotjs/custom */ "./node_modules/ajv/lib/dotjs/custom.js");
var definitionSchema = __webpack_require__(/*! ./definition_schema */ "./node_modules/ajv/lib/definition_schema.js");

module.exports = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword,
  validate: validateKeyword
};


/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 * @return {Ajv} this for method chaining
 */
function addKeyword(keyword, definition) {
  /* jshint validthis: true */
  /* eslint no-shadow: 0 */
  var RULES = this.RULES;
  if (RULES.keywords[keyword])
    throw new Error('Keyword ' + keyword + ' is already defined');

  if (!IDENTIFIER.test(keyword))
    throw new Error('Keyword ' + keyword + ' is not a valid identifier');

  if (definition) {
    this.validateKeyword(definition, true);

    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      for (var i=0; i<dataType.length; i++)
        _addRule(keyword, dataType[i], definition);
    } else {
      _addRule(keyword, dataType, definition);
    }

    var metaSchema = definition.metaSchema;
    if (metaSchema) {
      if (definition.$data && this._opts.$data) {
        metaSchema = {
          anyOf: [
            metaSchema,
            { '$ref': 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
      definition.validateSchema = this.compile(metaSchema, true);
    }
  }

  RULES.keywords[keyword] = RULES.all[keyword] = true;


  function _addRule(keyword, dataType, definition) {
    var ruleGroup;
    for (var i=0; i<RULES.length; i++) {
      var rg = RULES[i];
      if (rg.type == dataType) {
        ruleGroup = rg;
        break;
      }
    }

    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.push(ruleGroup);
    }

    var rule = {
      keyword: keyword,
      definition: definition,
      custom: true,
      code: customRuleCode,
      implements: definition.implements
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword] = rule;
  }

  return this;
}


/**
 * Get keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
 */
function getKeyword(keyword) {
  /* jshint validthis: true */
  var rule = this.RULES.custom[keyword];
  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}


/**
 * Remove keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Ajv} this for method chaining
 */
function removeKeyword(keyword) {
  /* jshint validthis: true */
  var RULES = this.RULES;
  delete RULES.keywords[keyword];
  delete RULES.all[keyword];
  delete RULES.custom[keyword];
  for (var i=0; i<RULES.length; i++) {
    var rules = RULES[i].rules;
    for (var j=0; j<rules.length; j++) {
      if (rules[j].keyword == keyword) {
        rules.splice(j, 1);
        break;
      }
    }
  }
  return this;
}


/**
 * Validate keyword definition
 * @this  Ajv
 * @param {Object} definition keyword definition object.
 * @param {Boolean} throwError true to throw exception if definition is invalid
 * @return {boolean} validation result
 */
function validateKeyword(definition, throwError) {
  validateKeyword.errors = null;
  var v = this._validateKeyword = this._validateKeyword
                                  || this.compile(definitionSchema, true);

  if (v(definition)) return true;
  validateKeyword.errors = v.errors;
  if (throwError)
    throw new Error('custom keyword definition is invalid: '  + this.errorsText(v.errors));
  else
    return false;
}


/***/ }),

/***/ "./node_modules/ajv/lib/refs/data.json":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/refs/data.json ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (function() {
        return JSON.parse(__webpack_require__(/*! global-compression */ "./src/js/core/lzstring.js").decompressX64("N4KABBYEQCQM4GMAWBTAtgQygLmkgLvgA7YD0pAVnAPYB2AtIqpgHTUBOA5qQCbsYAzfPQAMAdlJN0GAMRQANOEiwAljxx5CROGVL8A7i04r8SAK4AjM3BTsEdfClr4W9tKRRFqF2ygBeANYqtKQYFABupJhwjuykADYqFnooAnC8GPgYLFR0coqQ0DwoiOwqRPgqdBpQALIoWYzI0mACHGAwPJkYYOypvrQIKGAAFABSAMoA8gByYBPNmGAoAB6OtHBVtGBE7NRecBjxAJQKShBQ+ACeRCg13hQoCPhnhVB9AI5mKn3quADa0E63SgYAAugVlLt9rZKiUNKBCm9gVkEeckW9rrcajEyrROK8MUioBhaFcpgINP90USkcBoG12JgXrh3ih4pkVOEUPRcgwvMFYqCAL7yMA02mQelQRnMmp8+gC5y2EUSjFgtVgYXo0Xokk8HgmLZHAAKe1u7DhcA0AiONhA2qAA"));
    })()

/***/ }),

/***/ "./node_modules/ajv/lib/refs/json-schema-draft-07.json":
/*!*************************************************************!*\
  !*** ./node_modules/ajv/lib/refs/json-schema-draft-07.json ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (function() {
        return JSON.parse(__webpack_require__(/*! global-compression */ "./src/js/core/lzstring.js").decompressX64("N4KABBYEQCQM4GMAWBTAtgQygLmkgLvgA7YD0pAVnAPYB2AtIqpgHTUBOA5qQCbsYAzfPQAMAdlJN0GAMRQANOEiwAljxx5CJclTqNk0tl178hoiVMxzFkaPhX4ANig1QAwhxRhLGMGhT4GPrMWDbKPCgCKrQOKnRwGqC2tlA+AILs-ACeiUrJyVD4WUQuuFAYmRg5YfkpaNEAkvjoCbgAjDW1EFAOLYnQMOyRrnJgAL55yWOdKbR0AHIonBj2AG4oDbTNnCjsuV0pRSWu0du7CpNdUPUxaACuaBoil5DTL91ztIvLaxtbS7sACKRDB3Rz4ET7A7dDCORwAeQEGgA2u8DsABkMkWUZLxItFYvFSJ9visVOtNmc9uMZtCwBioBEBKDwU9xmjbABdNFvK5wFRoIjOAAqxRQrXpHOUKFoDxRUvy5Uq1QVBQARtRqM4MLQLnSCqcAXtadCoLK4Xr9cpZWg1ecTQcoNQ1RQUAh8JardA4Ph2NFOFBVdyurzaqlff6MtkoaajqVoBVow6Ur00BKGXHXD6-bQAzTVVA7jEAI53DbNNMaX1l5PhEFgj24ZHB2oTWyh7qZptOl1uj3yaAarUoHVQTmdKBEdjUErsezimMFGBqRdXLveiO5z2OgQcTCN6B3P30LG7GUIFw8h2wHyrsPr8M5gO17q79j71xHlSBkPXwbDXAkjpQoxSzTdnwLN8PzKL8T0iM9aAvH9Wz-BBqDQfwtjvRUH2zf1kPyDsCnsJx4yA2NQLKPCtyvNFGXFBA-SIew6Gw4jKI3J8CKma8mRZA9qxQa8hgwHh4VoRwckAgsHyHbVdRfaA+IbDRmUcOAUFoq4UAADwwQVnHTGSOKVJMC1TCVBK0sN7nBFQhRQRE2MOEybTtY0C10hBHDufl1gAWQJe5HlwZ5fzozAdIFOVpP1EDjjKNzzmsxUvJ8vyUH8jAouC5zlAfJK9hSgobmikLJTigqHnc7j22vNLfPJTKgpiirgKq21kvCq5IoAGRlTh8CQfpYCxEY8SiGIWNoOBiQWJYyQpf4dmpIi6mifrcyGkb-2xaBcSZAlptmkkFt+SkjWBZkG0hfMriIFZmnYXVYvakzqIguKoJWVwhh2HTatea9RJ4QlaFhJo+kAzEAP2qA7rDCy8phWgsicptVVsBldpGeG1rpbGxpxCajriGbJAMTAoyqPGg0U+jrtZXArO6mzsshytodG2GoAO-EprJk75p+JqLpWvHrxuDn0xhvbeZJgWiVOkWlqpK7+Nu-HuiLFRS3LKG2oohLB01eTtyuZSmbANSNOKlI0K2DBohl7m5dGLXoEigAFadZ3nF2ceJw7FfJ5XFr+KkJYi6IfZnXZ-Z2on9oVsGha+M7ReWoF63BTXhJQUsVCGdQucD5Pg9TyRwOpnIEcVEGwdhWO-ZUBdS6T3mo4t-nU+RuwTOdV13XNsMG+mpvffj1uA47936ctg9gDbFC6KnOO52nvv4vjHsh-7Asx7Jif14T9uebngsF8SZfCOvB7CF2Whm6ntvDcdB9B77Ef654UHx8cZ+G9X6E3Pl3YCa8-ZZHmPpYB0BvoHigH9XSYDTRX0AjfHidEIglFoBERCm9XpGx3p-Ye9ND50GPi3YBmNlA6jRntVEXp8ggLdigphEAWHjQrsdKuT4a603YS2aEGC6qr0nnOKBMCZ6gLrgUB2PoqzsBrHRGUrVyLvxMomGm9MkbMyUUJAsUsKwSg6AWHWetpaKLLHbfKHF1FXDoejMAjCmGcKDj3Hh-IDIoFFCUBIsj9T2KYdvVwWiVTsJTMYxO58U6eIFA5XxC4AnBKMQbUxETlDmLLJYvR1j2EiNqEIzBVx4EjVwuBNh9s6DNC2P5FAoMMCJLKe9CpyTugOxqfgAAoohagoMtxc3KVxNp0AVB7WAK7XGHtCioBevSSZOIoDTJQOpMiCy4bTNhAicZssuEeMFhTEI-CRnlFRk4tx5d9lEnSMqSpyg6COR2es+W3CDk3OjCcuYi9dmLPZKIlIaCwBWQmEAA"));
    })()

/***/ }),

/***/ "./node_modules/circular-json/build/circular-json.node.js":
/*!****************************************************************!*\
  !*** ./node_modules/circular-json/build/circular-json.node.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
Copyright (C) 2013-2017 by Andrea Giammarchi - @WebReflection

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
var
  // should be a not so common char
  // possibly one JSON does not encode
  // possibly one encodeURIComponent does not encode
  // right now this char is '~' but this might change in the future
  specialChar = '~',
  safeSpecialChar = '\\x' + (
    '0' + specialChar.charCodeAt(0).toString(16)
  ).slice(-2),
  escapedSafeSpecialChar = '\\' + safeSpecialChar,
  specialCharRG = new RegExp(safeSpecialChar, 'g'),
  safeSpecialCharRG = new RegExp(escapedSafeSpecialChar, 'g'),

  safeStartWithSpecialCharRG = new RegExp('(?:^|([^\\\\]))' + escapedSafeSpecialChar),

  indexOf = [].indexOf || function(v){
    for(var i=this.length;i--&&this[i]!==v;);
    return i;
  },
  $String = String  // there's no way to drop warnings in JSHint
                    // about new String ... well, I need that here!
                    // faked, and happy linter!
;

function generateReplacer(value, replacer, resolve) {
  var
    doNotIgnore = false,
    inspect = !!replacer,
    path = [],
    all  = [value],
    seen = [value],
    mapp = [resolve ? specialChar : '[Circular]'],
    last = value,
    lvl  = 1,
    i, fn
  ;
  if (inspect) {
    fn = typeof replacer === 'object' ?
      function (key, value) {
        return key !== '' && replacer.indexOf(key) < 0 ? void 0 : value;
      } :
      replacer;
  }
  return function(key, value) {
    // the replacer has rights to decide
    // if a new object should be returned
    // or if there's some key to drop
    // let's call it here rather than "too late"
    if (inspect) value = fn.call(this, key, value);

    // first pass should be ignored, since it's just the initial object
    if (doNotIgnore) {
      if (last !== this) {
        i = lvl - indexOf.call(all, this) - 1;
        lvl -= i;
        all.splice(lvl, all.length);
        path.splice(lvl - 1, path.length);
        last = this;
      }
      // console.log(lvl, key, path);
      if (typeof value === 'object' && value) {
    	// if object isn't referring to parent object, add to the
        // object path stack. Otherwise it is already there.
        if (indexOf.call(all, value) < 0) {
          all.push(last = value);
        }
        lvl = all.length;
        i = indexOf.call(seen, value);
        if (i < 0) {
          i = seen.push(value) - 1;
          if (resolve) {
            // key cannot contain specialChar but could be not a string
            path.push(('' + key).replace(specialCharRG, safeSpecialChar));
            mapp[i] = specialChar + path.join(specialChar);
          } else {
            mapp[i] = mapp[0];
          }
        } else {
          value = mapp[i];
        }
      } else {
        if (typeof value === 'string' && resolve) {
          // ensure no special char involved on deserialization
          // in this case only first char is important
          // no need to replace all value (better performance)
          value = value .replace(safeSpecialChar, escapedSafeSpecialChar)
                        .replace(specialChar, safeSpecialChar);
        }
      }
    } else {
      doNotIgnore = true;
    }
    return value;
  };
}

function retrieveFromPath(current, keys) {
  for(var i = 0, length = keys.length; i < length; current = current[
    // keys should be normalized back here
    keys[i++].replace(safeSpecialCharRG, specialChar)
  ]);
  return current;
}

function generateReviver(reviver) {
  return function(key, value) {
    var isString = typeof value === 'string';
    if (isString && value.charAt(0) === specialChar) {
      return new $String(value.slice(1));
    }
    if (key === '') value = regenerate(value, value, {});
    // again, only one needed, do not use the RegExp for this replacement
    // only keys need the RegExp
    if (isString) value = value .replace(safeStartWithSpecialCharRG, '$1' + specialChar)
                                .replace(escapedSafeSpecialChar, safeSpecialChar);
    return reviver ? reviver.call(this, key, value) : value;
  };
}

function regenerateArray(root, current, retrieve) {
  for (var i = 0, length = current.length; i < length; i++) {
    current[i] = regenerate(root, current[i], retrieve);
  }
  return current;
}

function regenerateObject(root, current, retrieve) {
  for (var key in current) {
    if (current.hasOwnProperty(key)) {
      current[key] = regenerate(root, current[key], retrieve);
    }
  }
  return current;
}

function regenerate(root, current, retrieve) {
  return current instanceof Array ?
    // fast Array reconstruction
    regenerateArray(root, current, retrieve) :
    (
      current instanceof $String ?
        (
          // root is an empty string
          current.length ?
            (
              retrieve.hasOwnProperty(current) ?
                retrieve[current] :
                retrieve[current] = retrieveFromPath(
                  root, current.split(specialChar)
                )
            ) :
            root
        ) :
        (
          current instanceof Object ?
            // dedicated Object parser
            regenerateObject(root, current, retrieve) :
            // value as it is
            current
        )
    )
  ;
}

var CircularJSON = {
  stringify: function stringify(value, replacer, space, doNotResolve) {
    return CircularJSON.parser.stringify(
      value,
      generateReplacer(value, replacer, !doNotResolve),
      space
    );
  },
  parse: function parse(text, reviver) {
    return CircularJSON.parser.parse(
      text,
      generateReviver(reviver)
    );
  },
  // A parser should be an API 1:1 compatible with JSON
  // it should expose stringify and parse methods.
  // The default parser is the native JSON.
  parser: JSON
};

module.exports = CircularJSON;


/***/ }),

/***/ "./node_modules/decode-uri-component/index.js":
/*!****************************************************!*\
  !*** ./node_modules/decode-uri-component/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp(token, 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');

function decodeComponents(components, split) {
	try {
		// Try to decode the entire string first
		return decodeURIComponent(components.join(''));
	} catch (err) {
		// Do nothing
	}

	if (components.length === 1) {
		return components;
	}

	split = split || 1;

	// Split the array in 2 parts
	var left = components.slice(0, split);
	var right = components.slice(split);

	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode(input) {
	try {
		return decodeURIComponent(input);
	} catch (err) {
		var tokens = input.match(singleMatcher);

		for (var i = 1; i < tokens.length; i++) {
			input = decodeComponents(tokens, i).join('');

			tokens = input.match(singleMatcher);
		}

		return input;
	}
}

function customDecodeURIComponent(input) {
	// Keep track of all the replacements and prefill the map with the `BOM`
	var replaceMap = {
		'%FE%FF': '\uFFFD\uFFFD',
		'%FF%FE': '\uFFFD\uFFFD'
	};

	var match = multiMatcher.exec(input);
	while (match) {
		try {
			// Decode as big chunks as possible
			replaceMap[match[0]] = decodeURIComponent(match[0]);
		} catch (err) {
			var result = decode(match[0]);

			if (result !== match[0]) {
				replaceMap[match[0]] = result;
			}
		}

		match = multiMatcher.exec(input);
	}

	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
	replaceMap['%C2'] = '\uFFFD';

	var entries = Object.keys(replaceMap);

	for (var i = 0; i < entries.length; i++) {
		// Replace all decoded components
		var key = entries[i];
		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
	}

	return input;
}

module.exports = function (encodedURI) {
	if (typeof encodedURI !== 'string') {
		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
	}

	try {
		encodedURI = encodedURI.replace(/\+/g, ' ');

		// Try the built in decoder first
		return decodeURIComponent(encodedURI);
	} catch (err) {
		// Fallback to a more advanced decoder
		return customDecodeURIComponent(encodedURI);
	}
};


/***/ }),

/***/ "./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ "./node_modules/fast-json-stable-stringify/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-json-stable-stringify/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for (i = 0; i < node.length; i++) {
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = stringify(node[key]);

            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    })(data);
};


/***/ }),

/***/ "./node_modules/howler/dist/howler.js":
/*!********************************************!*\
  !*** ./node_modules/howler/dist/howler.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 *  howler.js v2.1.3
 *  howlerjs.com
 *
 *  (c) 2013-2019, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function() {

  'use strict';

  /** Global Methods **/
  /***************************************************************************/

  /**
   * Create the global controller. All contained methods and properties apply
   * to all sounds that are currently playing or will be in the future.
   */
  var HowlerGlobal = function() {
    this.init();
  };
  HowlerGlobal.prototype = {
    /**
     * Initialize the global Howler object.
     * @return {Howler}
     */
    init: function() {
      var self = this || Howler;

      // Create a global ID counter.
      self._counter = 1000;

      // Pool of unlocked HTML5 Audio objects.
      self._html5AudioPool = [];
      self.html5PoolSize = 10;

      // Internal properties.
      self._codecs = {};
      self._howls = [];
      self._muted = false;
      self._volume = 1;
      self._canPlayEvent = 'canplaythrough';
      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;

      // Public properties.
      self.masterGain = null;
      self.noAudio = false;
      self.usingWebAudio = true;
      self.autoSuspend = true;
      self.ctx = null;

      // Set to false to disable the auto audio unlocker.
      self.autoUnlock = true;

      // Setup the various state values for global tracking.
      self._setup();

      return self;
    },

    /**
     * Get/set the global volume for all sounds.
     * @param  {Float} vol Volume from 0.0 to 1.0.
     * @return {Howler/Float}     Returns self or current volume.
     */
    volume: function(vol) {
      var self = this || Howler;
      vol = parseFloat(vol);

      // If we don't have an AudioContext created yet, run the setup.
      if (!self.ctx) {
        setupAudioContext();
      }

      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        self._volume = vol;

        // Don't update any of the nodes if we are muted.
        if (self._muted) {
          return self;
        }

        // When using Web Audio, we just need to adjust the master gain.
        if (self.usingWebAudio) {
          self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);
        }

        // Loop through and change volume for all HTML5 audio nodes.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and change the volumes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node) {
                sound._node.volume = sound._volume * vol;
              }
            }
          }
        }

        return self;
      }

      return self._volume;
    },

    /**
     * Handle muting and unmuting globally.
     * @param  {Boolean} muted Is muted or not.
     */
    mute: function(muted) {
      var self = this || Howler;

      // If we don't have an AudioContext created yet, run the setup.
      if (!self.ctx) {
        setupAudioContext();
      }

      self._muted = muted;

      // With Web Audio, we just need to mute the master gain.
      if (self.usingWebAudio) {
        self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);
      }

      // Loop through and mute all HTML5 Audio nodes.
      for (var i=0; i<self._howls.length; i++) {
        if (!self._howls[i]._webAudio) {
          // Get all of the sounds in this Howl group.
          var ids = self._howls[i]._getSoundIds();

          // Loop through all sounds and mark the audio node as muted.
          for (var j=0; j<ids.length; j++) {
            var sound = self._howls[i]._soundById(ids[j]);

            if (sound && sound._node) {
              sound._node.muted = (muted) ? true : sound._muted;
            }
          }
        }
      }

      return self;
    },

    /**
     * Unload and destroy all currently loaded Howl objects.
     * @return {Howler}
     */
    unload: function() {
      var self = this || Howler;

      for (var i=self._howls.length-1; i>=0; i--) {
        self._howls[i].unload();
      }

      // Create a new AudioContext to make sure it is fully reset.
      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {
        self.ctx.close();
        self.ctx = null;
        setupAudioContext();
      }

      return self;
    },

    /**
     * Check for codec support of specific extension.
     * @param  {String} ext Audio file extention.
     * @return {Boolean}
     */
    codecs: function(ext) {
      return (this || Howler)._codecs[ext.replace(/^x-/, '')];
    },

    /**
     * Setup various state values for global tracking.
     * @return {Howler}
     */
    _setup: function() {
      var self = this || Howler;

      // Keeps track of the suspend/resume state of the AudioContext.
      self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';

      // Automatically begin the 30-second suspend process
      self._autoSuspend();

      // Check if audio is available.
      if (!self.usingWebAudio) {
        // No audio is available on this system if noAudio is set to true.
        if (typeof Audio !== 'undefined') {
          try {
            var test = new Audio();

            // Check if the canplaythrough event is available.
            if (typeof test.oncanplaythrough === 'undefined') {
              self._canPlayEvent = 'canplay';
            }
          } catch(e) {
            self.noAudio = true;
          }
        } else {
          self.noAudio = true;
        }
      }

      // Test to make sure audio isn't disabled in Internet Explorer.
      try {
        var test = new Audio();
        if (test.muted) {
          self.noAudio = true;
        }
      } catch (e) {}

      // Check for supported codecs.
      if (!self.noAudio) {
        self._setupCodecs();
      }

      return self;
    },

    /**
     * Check for browser support for various codecs and cache the results.
     * @return {Howler}
     */
    _setupCodecs: function() {
      var self = this || Howler;
      var audioTest = null;

      // Must wrap in a try/catch because IE11 in server mode throws an error.
      try {
        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;
      } catch (err) {
        return self;
      }

      if (!audioTest || typeof audioTest.canPlayType !== 'function') {
        return self;
      }

      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');

      // Opera version <33 has mixed MP3 support, so we need to check for and block it.
      var checkOpera = self._navigator && self._navigator.userAgent.match(/OPR\/([0-6].)/g);
      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);

      self._codecs = {
        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),
        mpeg: !!mpegTest,
        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        wav: !!audioTest.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''),
        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),
        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        weba: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
        webm: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
        dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ''),
        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')
      };

      return self;
    },

    /**
     * Some browsers/devices will only allow audio to be played after a user interaction.
     * Attempt to automatically unlock audio on the first user interaction.
     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     * @return {Howler}
     */
    _unlockAudio: function() {
      var self = this || Howler;

      // Only run this if Web Audio is supported and it hasn't already been unlocked.
      if (self._audioUnlocked || !self.ctx) {
        return;
      }

      self._audioUnlocked = false;
      self.autoUnlock = false;

      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.
      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
        self._mobileUnloaded = true;
        self.unload();
      }

      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
      // http://stackoverflow.com/questions/24119684
      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);

      // Call this method on touch start to create and play a buffer,
      // then check if the audio actually played to determine if
      // audio has now been unlocked on iOS, Android, etc.
      var unlock = function(e) {
        // Create a pool of unlocked HTML5 Audio objects that can
        // be used for playing sounds without user interaction. HTML5
        // Audio objects must be individually unlocked, as opposed
        // to the WebAudio API which only needs a single activation.
        // This must occur before WebAudio setup or the source.onended
        // event will not fire.
        for (var i=0; i<self.html5PoolSize; i++) {
          try {
            var audioNode = new Audio();

            // Mark this Audio object as unlocked to ensure it can get returned
            // to the unlocked pool when released.
            audioNode._unlocked = true;

            // Add the audio node to the pool.
            self._releaseHtml5Audio(audioNode);
          } catch (e) {
            self.noAudio = true;
          }
        }

        // Loop through any assigned audio nodes and unlock them.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and unlock the audio nodes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node && !sound._node._unlocked) {
                sound._node._unlocked = true;
                sound._node.load();
              }
            }
          }
        }

        // Fix Android can not play in suspend state.
        self._autoResume();

        // Create an empty buffer.
        var source = self.ctx.createBufferSource();
        source.buffer = self._scratchBuffer;
        source.connect(self.ctx.destination);

        // Play the empty buffer.
        if (typeof source.start === 'undefined') {
          source.noteOn(0);
        } else {
          source.start(0);
        }

        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.
        if (typeof self.ctx.resume === 'function') {
          self.ctx.resume();
        }

        // Setup a timeout to check that we are unlocked on the next event loop.
        source.onended = function() {
          source.disconnect(0);

          // Update the unlocked state and prevent this check from happening again.
          self._audioUnlocked = true;

          // Remove the touch start listener.
          document.removeEventListener('touchstart', unlock, true);
          document.removeEventListener('touchend', unlock, true);
          document.removeEventListener('click', unlock, true);

          // Let all sounds know that audio has been unlocked.
          for (var i=0; i<self._howls.length; i++) {
            self._howls[i]._emit('unlock');
          }
        };
      };

      // Setup a touch start listener to attempt an unlock in.
      document.addEventListener('touchstart', unlock, true);
      document.addEventListener('touchend', unlock, true);
      document.addEventListener('click', unlock, true);

      return self;
    },

    /**
     * Get an unlocked HTML5 Audio object from the pool. If none are left,
     * return a new Audio object and throw a warning.
     * @return {Audio} HTML5 Audio object.
     */
    _obtainHtml5Audio: function() {
      var self = this || Howler;

      // Return the next object from the pool if one exists.
      if (self._html5AudioPool.length) {
        return self._html5AudioPool.pop();
      }

      //.Check if the audio is locked and throw a warning.
      var testPlay = new Audio().play();
      if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) {
        testPlay.catch(function() {
          console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');
        });
      }

      return new Audio();
    },

    /**
     * Return an activated HTML5 Audio object to the pool.
     * @return {Howler}
     */
    _releaseHtml5Audio: function(audio) {
      var self = this || Howler;

      // Don't add audio to the pool if we don't know if it has been unlocked.
      if (audio._unlocked) {
        self._html5AudioPool.push(audio);
      }

      return self;
    },

    /**
     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
     * @return {Howler}
     */
    _autoSuspend: function() {
      var self = this;

      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      // Check if any sounds are playing.
      for (var i=0; i<self._howls.length; i++) {
        if (self._howls[i]._webAudio) {
          for (var j=0; j<self._howls[i]._sounds.length; j++) {
            if (!self._howls[i]._sounds[j]._paused) {
              return self;
            }
          }
        }
      }

      if (self._suspendTimer) {
        clearTimeout(self._suspendTimer);
      }

      // If no sound has played after 30 seconds, suspend the context.
      self._suspendTimer = setTimeout(function() {
        if (!self.autoSuspend) {
          return;
        }

        self._suspendTimer = null;
        self.state = 'suspending';
        self.ctx.suspend().then(function() {
          self.state = 'suspended';

          if (self._resumeAfterSuspend) {
            delete self._resumeAfterSuspend;
            self._autoResume();
          }
        });
      }, 30000);

      return self;
    },

    /**
     * Automatically resume the Web Audio AudioContext when a new sound is played.
     * @return {Howler}
     */
    _autoResume: function() {
      var self = this;

      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      if (self.state === 'running' && self._suspendTimer) {
        clearTimeout(self._suspendTimer);
        self._suspendTimer = null;
      } else if (self.state === 'suspended') {
        self.ctx.resume().then(function() {
          self.state = 'running';

          // Emit to all Howls that the audio has resumed.
          for (var i=0; i<self._howls.length; i++) {
            self._howls[i]._emit('resume');
          }
        });

        if (self._suspendTimer) {
          clearTimeout(self._suspendTimer);
          self._suspendTimer = null;
        }
      } else if (self.state === 'suspending') {
        self._resumeAfterSuspend = true;
      }

      return self;
    }
  };

  // Setup the global audio controller.
  var Howler = new HowlerGlobal();

  /** Group Methods **/
  /***************************************************************************/

  /**
   * Create an audio group controller.
   * @param {Object} o Passed in properties for this group.
   */
  var Howl = function(o) {
    var self = this;

    // Throw an error if no source is provided.
    if (!o.src || o.src.length === 0) {
      console.error('An array of source files must be passed with any new Howl.');
      return;
    }

    self.init(o);
  };
  Howl.prototype = {
    /**
     * Initialize a new Howl group object.
     * @param  {Object} o Passed in properties for this group.
     * @return {Howl}
     */
    init: function(o) {
      var self = this;

      // If we don't have an AudioContext created yet, run the setup.
      if (!Howler.ctx) {
        setupAudioContext();
      }

      // Setup user-defined default properties.
      self._autoplay = o.autoplay || false;
      self._format = (typeof o.format !== 'string') ? o.format : [o.format];
      self._html5 = o.html5 || false;
      self._muted = o.mute || false;
      self._loop = o.loop || false;
      self._pool = o.pool || 5;
      self._preload = (typeof o.preload === 'boolean') ? o.preload : true;
      self._rate = o.rate || 1;
      self._sprite = o.sprite || {};
      self._src = (typeof o.src !== 'string') ? o.src : [o.src];
      self._volume = o.volume !== undefined ? o.volume : 1;
      self._xhrWithCredentials = o.xhrWithCredentials || false;

      // Setup all other default properties.
      self._duration = 0;
      self._state = 'unloaded';
      self._sounds = [];
      self._endTimers = {};
      self._queue = [];
      self._playLock = false;

      // Setup event listeners.
      self._onend = o.onend ? [{fn: o.onend}] : [];
      self._onfade = o.onfade ? [{fn: o.onfade}] : [];
      self._onload = o.onload ? [{fn: o.onload}] : [];
      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];
      self._onplayerror = o.onplayerror ? [{fn: o.onplayerror}] : [];
      self._onpause = o.onpause ? [{fn: o.onpause}] : [];
      self._onplay = o.onplay ? [{fn: o.onplay}] : [];
      self._onstop = o.onstop ? [{fn: o.onstop}] : [];
      self._onmute = o.onmute ? [{fn: o.onmute}] : [];
      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];
      self._onrate = o.onrate ? [{fn: o.onrate}] : [];
      self._onseek = o.onseek ? [{fn: o.onseek}] : [];
      self._onunlock = o.onunlock ? [{fn: o.onunlock}] : [];
      self._onresume = [];

      // Web Audio or HTML5 Audio?
      self._webAudio = Howler.usingWebAudio && !self._html5;

      // Automatically try to enable audio.
      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) {
        Howler._unlockAudio();
      }

      // Keep track of this Howl group in the global controller.
      Howler._howls.push(self);

      // If they selected autoplay, add a play event to the load queue.
      if (self._autoplay) {
        self._queue.push({
          event: 'play',
          action: function() {
            self.play();
          }
        });
      }

      // Load the source file unless otherwise specified.
      if (self._preload) {
        self.load();
      }

      return self;
    },

    /**
     * Load the audio file.
     * @return {Howler}
     */
    load: function() {
      var self = this;
      var url = null;

      // If no audio is available, quit immediately.
      if (Howler.noAudio) {
        self._emit('loaderror', null, 'No audio support.');
        return;
      }

      // Make sure our source is in an array.
      if (typeof self._src === 'string') {
        self._src = [self._src];
      }

      // Loop through the sources and pick the first one that is compatible.
      for (var i=0; i<self._src.length; i++) {
        var ext, str;

        if (self._format && self._format[i]) {
          // If an extension was specified, use that instead.
          ext = self._format[i];
        } else {
          // Make sure the source is a string.
          str = self._src[i];
          if (typeof str !== 'string') {
            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');
            continue;
          }

          // Extract the file extension from the URL or base64 data URI.
          ext = /^data:audio\/([^;,]+);/i.exec(str);
          if (!ext) {
            ext = /\.([^.]+)$/.exec(str.split('?', 1)[0]);
          }

          if (ext) {
            ext = ext[1].toLowerCase();
          }
        }

        // Log a warning if no extension was found.
        if (!ext) {
          console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
        }

        // Check if this extension is available.
        if (ext && Howler.codecs(ext)) {
          url = self._src[i];
          break;
        }
      }

      if (!url) {
        self._emit('loaderror', null, 'No codec support for selected audio sources.');
        return;
      }

      self._src = url;
      self._state = 'loading';

      // If the hosting page is HTTPS and the source isn't,
      // drop down to HTML5 Audio to avoid Mixed Content errors.
      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {
        self._html5 = true;
        self._webAudio = false;
      }

      // Create a new sound object and add it to the pool.
      new Sound(self);

      // Load and decode the audio data for playback.
      if (self._webAudio) {
        loadBuffer(self);
      }

      return self;
    },

    /**
     * Play a sound or resume previous playback.
     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Number}          Sound ID.
     */
    play: function(sprite, internal) {
      var self = this;
      var id = null;

      // Determine if a sprite, sound id or nothing was passed
      if (typeof sprite === 'number') {
        id = sprite;
        sprite = null;
      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {
        // If the passed sprite doesn't exist, do nothing.
        return null;
      } else if (typeof sprite === 'undefined') {
        // Use the default sound sprite (plays the full audio length).
        sprite = '__default';

        // Check if there is a single paused sound that isn't ended. 
        // If there is, play that sound. If not, continue as usual.  
        if (!self._playLock) {
          var num = 0;
          for (var i=0; i<self._sounds.length; i++) {
            if (self._sounds[i]._paused && !self._sounds[i]._ended) {
              num++;
              id = self._sounds[i]._id;
            }
          }

          if (num === 1) {
            sprite = null;
          } else {
            id = null;
          }
        }
      }

      // Get the selected node, or get one from the pool.
      var sound = id ? self._soundById(id) : self._inactiveSound();

      // If the sound doesn't exist, do nothing.
      if (!sound) {
        return null;
      }

      // Select the sprite definition.
      if (id && !sprite) {
        sprite = sound._sprite || '__default';
      }

      // If the sound hasn't loaded, we must wait to get the audio's duration.
      // We also need to wait to make sure we don't run into race conditions with
      // the order of function calls.
      if (self._state !== 'loaded') {
        // Set the sprite value on this sound.
        sound._sprite = sprite;

        // Mark this sound as not ended in case another sound is played before this one loads.
        sound._ended = false;

        // Add the sound to the queue to be played on load.
        var soundId = sound._id;
        self._queue.push({
          event: 'play',
          action: function() {
            self.play(soundId);
          }
        });

        return soundId;
      }

      // Don't play the sound if an id was passed and it is already playing.
      if (id && !sound._paused) {
        // Trigger the play event, in order to keep iterating through queue.
        if (!internal) {
          self._loadQueue('play');
        }

        return sound._id;
      }

      // Make sure the AudioContext isn't suspended, and resume it if it is.
      if (self._webAudio) {
        Howler._autoResume();
      }

      // Determine how long to play for and where to start playing.
      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);
      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);
      var timeout = (duration * 1000) / Math.abs(sound._rate);
      var start = self._sprite[sprite][0] / 1000;
      var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
      sound._sprite = sprite;

      // Mark the sound as ended instantly so that this async playback
      // doesn't get grabbed by another call to play while this one waits to start.
      sound._ended = false;

      // Update the parameters of the sound.
      var setParams = function() {
        sound._paused = false;
        sound._seek = seek;
        sound._start = start;
        sound._stop = stop;
        sound._loop = !!(sound._loop || self._sprite[sprite][2]);
      };

      // End the sound instantly if seek is at the end.
      if (seek >= stop) {
        self._ended(sound);
        return;
      }

      // Begin the actual playback.
      var node = sound._node;
      if (self._webAudio) {
        // Fire this when the sound is ready to play to begin Web Audio playback.
        var playWebAudio = function() {
          self._playLock = false;
          setParams();
          self._refreshBuffer(sound);

          // Setup the playback params.
          var vol = (sound._muted || self._muted) ? 0 : sound._volume;
          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
          sound._playStart = Howler.ctx.currentTime;

          // Play the sound using the supported method.
          if (typeof node.bufferSource.start === 'undefined') {
            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
          } else {
            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
          }

          // Start a new timer if none is present.
          if (timeout !== Infinity) {
            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
          }

          if (!internal) {
            setTimeout(function() {
              self._emit('play', sound._id);
              self._loadQueue();
            }, 0);
          }
        };

        if (Howler.state === 'running') {
          playWebAudio();
        } else {
          self._playLock = true;

          // Wait for the audio context to resume before playing.
          self.once('resume', playWebAudio);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      } else {
        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
        var playHtml5 = function() {
          node.currentTime = seek;
          node.muted = sound._muted || self._muted || Howler._muted || node.muted;
          node.volume = sound._volume * Howler.volume();
          node.playbackRate = sound._rate;

          // Some browsers will throw an error if this is called without user interaction.
          try {
            var play = node.play();

            // Support older browsers that don't support promises, and thus don't have this issue.
            if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {
              // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().
              self._playLock = true;

              // Set param values immediately.
              setParams();

              // Releases the lock and executes queued actions.
              play
                .then(function() {
                  self._playLock = false;
                  node._unlocked = true;
                  if (!internal) {
                    self._emit('play', sound._id);
                    self._loadQueue();
                  }
                })
                .catch(function() {
                  self._playLock = false;
                  self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
                    'on mobile devices and Chrome where playback was not within a user interaction.');

                  // Reset the ended and paused values.
                  sound._ended = true;
                  sound._paused = true;
                });
            } else if (!internal) {
              self._playLock = false;
              setParams();
              self._emit('play', sound._id);
              self._loadQueue();
            }

            // Setting rate before playing won't work in IE, so we set it again here.
            node.playbackRate = sound._rate;

            // If the node is still paused, then we can assume there was a playback issue.
            if (node.paused) {
              self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
                'on mobile devices and Chrome where playback was not within a user interaction.');
              return;
            }

            // Setup the end timer on sprites or listen for the ended event.
            if (sprite !== '__default' || sound._loop) {
              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
            } else {
              self._endTimers[sound._id] = function() {
                // Fire ended on this audio node.
                self._ended(sound);

                // Clear this listener.
                node.removeEventListener('ended', self._endTimers[sound._id], false);
              };
              node.addEventListener('ended', self._endTimers[sound._id], false);
            }
          } catch (err) {
            self._emit('playerror', sound._id, err);
          }
        };

        // If this is streaming audio, make sure the src is set and load again.
        if (node.src === 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA') {
          node.src = self._src;
          node.load();
        }

        // Play immediately if ready, or wait for the 'canplaythrough'e vent.
        var loadedNoReadyState = (window && window.ejecta) || (!node.readyState && Howler._navigator.isCocoonJS);
        if (node.readyState >= 3 || loadedNoReadyState) {
          playHtml5();
        } else {
          self._playLock = true;

          var listener = function() {
            // Begin playback.
            playHtml5();

            // Clear this listener.
            node.removeEventListener(Howler._canPlayEvent, listener, false);
          };
          node.addEventListener(Howler._canPlayEvent, listener, false);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      }

      return sound._id;
    },

    /**
     * Pause playback and save current position.
     * @param  {Number} id The sound ID (empty to pause all in group).
     * @return {Howl}
     */
    pause: function(id) {
      var self = this;

      // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'pause',
          action: function() {
            self.pause(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be paused.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound && !sound._paused) {
          // Reset the seek position.
          sound._seek = self.seek(ids[i]);
          sound._rateSeek = 0;
          sound._paused = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound has been created.
              if (!sound._node.bufferSource) {
                continue;
              }

              if (typeof sound._node.bufferSource.stop === 'undefined') {
                sound._node.bufferSource.noteOff(0);
              } else {
                sound._node.bufferSource.stop(0);
              }

              // Clean up the buffer source.
              self._cleanBuffer(sound._node);
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.pause();
            }
          }
        }

        // Fire the pause event, unless `true` is passed as the 2nd argument.
        if (!arguments[1]) {
          self._emit('pause', sound ? sound._id : null);
        }
      }

      return self;
    },

    /**
     * Stop playback and reset to start.
     * @param  {Number} id The sound ID (empty to stop all in group).
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Howl}
     */
    stop: function(id, internal) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to stop when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'stop',
          action: function() {
            self.stop(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be stopped.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          // Reset the seek position.
          sound._seek = sound._start || 0;
          sound._rateSeek = 0;
          sound._paused = true;
          sound._ended = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound's AudioBufferSourceNode has been created.
              if (sound._node.bufferSource) {
                if (typeof sound._node.bufferSource.stop === 'undefined') {
                  sound._node.bufferSource.noteOff(0);
                } else {
                  sound._node.bufferSource.stop(0);
                }

                // Clean up the buffer source.
                self._cleanBuffer(sound._node);
              }
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.currentTime = sound._start || 0;
              sound._node.pause();

              // If this is a live stream, stop download once the audio is stopped.
              if (sound._node.duration === Infinity) {
                self._clearSound(sound._node);
              }
            }
          }

          if (!internal) {
            self._emit('stop', sound._id);
          }
        }
      }

      return self;
    },

    /**
     * Mute/unmute a single sound or all sounds in this Howl group.
     * @param  {Boolean} muted Set to true to mute and false to unmute.
     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
     * @return {Howl}
     */
    mute: function(muted, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to mute when capable.
      if (self._state !== 'loaded'|| self._playLock) {
        self._queue.push({
          event: 'mute',
          action: function() {
            self.mute(muted, id);
          }
        });

        return self;
      }

      // If applying mute/unmute to all sounds, update the group's value.
      if (typeof id === 'undefined') {
        if (typeof muted === 'boolean') {
          self._muted = muted;
        } else {
          return self._muted;
        }
      }

      // If no id is passed, get all ID's to be muted.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          sound._muted = muted;

          // Cancel active fade and set the volume to the end value.
          if (sound._interval) {
            self._stopFade(sound._id);
          }

          if (self._webAudio && sound._node) {
            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
          } else if (sound._node) {
            sound._node.muted = Howler._muted ? true : muted;
          }

          self._emit('mute', sound._id);
        }
      }

      return self;
    },

    /**
     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
     *   volume() -> Returns the group's volume value.
     *   volume(id) -> Returns the sound id's current volume.
     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
     *   volume(vol, id) -> Sets the volume of passed sound id.
     * @return {Howl/Number} Returns self or current volume.
     */
    volume: function() {
      var self = this;
      var args = arguments;
      var vol, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // Return the value of the groups' volume.
        return self._volume;
      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {
        // First check if this is an ID, and if not, assume it is a new volume.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          vol = parseFloat(args[0]);
        }
      } else if (args.length >= 2) {
        vol = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the volume or return the current volume.
      var sound;
      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        // If the sound hasn't loaded, add it to the load queue to change volume when capable.
        if (self._state !== 'loaded'|| self._playLock) {
          self._queue.push({
            event: 'volume',
            action: function() {
              self.volume.apply(self, args);
            }
          });

          return self;
        }

        // Set the group volume.
        if (typeof id === 'undefined') {
          self._volume = vol;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            sound._volume = vol;

            // Stop currently running fades.
            if (!args[2]) {
              self._stopFade(id[i]);
            }

            if (self._webAudio && sound._node && !sound._muted) {
              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
            } else if (sound._node && !sound._muted) {
              sound._node.volume = vol * Howler.volume();
            }

            self._emit('volume', sound._id);
          }
        }
      } else {
        sound = id ? self._soundById(id) : self._sounds[0];
        return sound ? sound._volume : 0;
      }

      return self;
    },

    /**
     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id (omit to fade all sounds).
     * @return {Howl}
     */
    fade: function(from, to, len, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to fade when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'fade',
          action: function() {
            self.fade(from, to, len, id);
          }
        });

        return self;
      }

      // Make sure the to/from/len values are numbers.
      from = parseFloat(from);
      to = parseFloat(to);
      len = parseFloat(len);

      // Set the volume to the start position.
      self.volume(from, id);

      // Fade the volume of one or all sounds.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        // Create a linear fade or fall back to timeouts with HTML5 Audio.
        if (sound) {
          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
          if (!id) {
            self._stopFade(ids[i]);
          }

          // If we are using Web Audio, let the native methods do the actual fade.
          if (self._webAudio && !sound._muted) {
            var currentTime = Howler.ctx.currentTime;
            var end = currentTime + (len / 1000);
            sound._volume = from;
            sound._node.gain.setValueAtTime(from, currentTime);
            sound._node.gain.linearRampToValueAtTime(to, end);
          }

          self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');
        }
      }

      return self;
    },

    /**
     * Starts the internal interval to fade a sound.
     * @param  {Object} sound Reference to sound to fade.
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id to fade.
     * @param  {Boolean} isGroup   If true, set the volume on the group.
     */
    _startFadeInterval: function(sound, from, to, len, id, isGroup) {
      var self = this;
      var vol = from;
      var diff = to - from;
      var steps = Math.abs(diff / 0.01);
      var stepLen = Math.max(4, (steps > 0) ? len / steps : len);
      var lastTick = Date.now();

      // Store the value being faded to.
      sound._fadeTo = to;

      // Update the volume value on each interval tick.
      sound._interval = setInterval(function() {
        // Update the volume based on the time since the last tick.
        var tick = (Date.now() - lastTick) / len;
        lastTick = Date.now();
        vol += diff * tick;

        // Make sure the volume is in the right bounds.
        vol = Math.max(0, vol);
        vol = Math.min(1, vol);

        // Round to within 2 decimal points.
        vol = Math.round(vol * 100) / 100;

        // Change the volume.
        if (self._webAudio) {
          sound._volume = vol;
        } else {
          self.volume(vol, sound._id, true);
        }

        // Set the group's volume.
        if (isGroup) {
          self._volume = vol;
        }

        // When the fade is complete, stop it and fire event.
        if ((to < from && vol <= to) || (to > from && vol >= to)) {
          clearInterval(sound._interval);
          sound._interval = null;
          sound._fadeTo = null;
          self.volume(to, sound._id);
          self._emit('fade', sound._id);
        }
      }, stepLen);
    },

    /**
     * Internal method that stops the currently playing fade when
     * a new fade starts, volume is changed or the sound is stopped.
     * @param  {Number} id The sound id.
     * @return {Howl}
     */
    _stopFade: function(id) {
      var self = this;
      var sound = self._soundById(id);

      if (sound && sound._interval) {
        if (self._webAudio) {
          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
        }

        clearInterval(sound._interval);
        sound._interval = null;
        self.volume(sound._fadeTo, id);
        sound._fadeTo = null;
        self._emit('fade', id);
      }

      return self;
    },

    /**
     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
     *   loop() -> Returns the group's loop value.
     *   loop(id) -> Returns the sound id's loop value.
     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
     *   loop(loop, id) -> Sets the loop value of passed sound id.
     * @return {Howl/Boolean} Returns self or current loop value.
     */
    loop: function() {
      var self = this;
      var args = arguments;
      var loop, id, sound;

      // Determine the values for loop and id.
      if (args.length === 0) {
        // Return the grou's loop value.
        return self._loop;
      } else if (args.length === 1) {
        if (typeof args[0] === 'boolean') {
          loop = args[0];
          self._loop = loop;
        } else {
          // Return this sound's loop value.
          sound = self._soundById(parseInt(args[0], 10));
          return sound ? sound._loop : false;
        }
      } else if (args.length === 2) {
        loop = args[0];
        id = parseInt(args[1], 10);
      }

      // If no id is passed, get all ID's to be looped.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        sound = self._soundById(ids[i]);

        if (sound) {
          sound._loop = loop;
          if (self._webAudio && sound._node && sound._node.bufferSource) {
            sound._node.bufferSource.loop = loop;
            if (loop) {
              sound._node.bufferSource.loopStart = sound._start || 0;
              sound._node.bufferSource.loopEnd = sound._stop;
            }
          }
        }
      }

      return self;
    },

    /**
     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   rate() -> Returns the first sound node's current playback rate.
     *   rate(id) -> Returns the sound id's current playback rate.
     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
     *   rate(rate, id) -> Sets the playback rate of passed sound id.
     * @return {Howl/Number} Returns self or the current playback rate.
     */
    rate: function() {
      var self = this;
      var args = arguments;
      var rate, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current rate of the first node.
        id = self._sounds[0]._id;
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new rate value.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          rate = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        rate = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the playback rate or return the current value.
      var sound;
      if (typeof rate === 'number') {
        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
        if (self._state !== 'loaded' || self._playLock) {
          self._queue.push({
            event: 'rate',
            action: function() {
              self.rate.apply(self, args);
            }
          });

          return self;
        }

        // Set the group rate.
        if (typeof id === 'undefined') {
          self._rate = rate;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            // Keep track of our position when the rate changed and update the playback
            // start position so we can properly adjust the seek position for time elapsed.
            if (self.playing(id[i])) {
              sound._rateSeek = self.seek(id[i]);
              sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;
            }
            sound._rate = rate;

            // Change the playback rate.
            if (self._webAudio && sound._node && sound._node.bufferSource) {
              sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);
            } else if (sound._node) {
              sound._node.playbackRate = rate;
            }

            // Reset the timers.
            var seek = self.seek(id[i]);
            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;
            var timeout = (duration * 1000) / Math.abs(sound._rate);

            // Start a new end timer if sound is already playing.
            if (self._endTimers[id[i]] || !sound._paused) {
              self._clearTimer(id[i]);
              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
            }

            self._emit('rate', sound._id);
          }
        }
      } else {
        sound = self._soundById(id);
        return sound ? sound._rate : self._rate;
      }

      return self;
    },

    /**
     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   seek() -> Returns the first sound node's current seek position.
     *   seek(id) -> Returns the sound id's current seek position.
     *   seek(seek) -> Sets the seek position of the first sound node.
     *   seek(seek, id) -> Sets the seek position of passed sound id.
     * @return {Howl/Number} Returns self or the current seek position.
     */
    seek: function() {
      var self = this;
      var args = arguments;
      var seek, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current position of the first node.
        id = self._sounds[0]._id;
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new seek position.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else if (self._sounds.length) {
          id = self._sounds[0]._id;
          seek = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        seek = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // If there is no ID, bail out.
      if (typeof id === 'undefined') {
        return self;
      }

      // If the sound hasn't loaded, add it to the load queue to seek when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'seek',
          action: function() {
            self.seek.apply(self, args);
          }
        });

        return self;
      }

      // Get the sound.
      var sound = self._soundById(id);

      if (sound) {
        if (typeof seek === 'number' && seek >= 0) {
          // Pause the sound and update position for restarting playback.
          var playing = self.playing(id);
          if (playing) {
            self.pause(id, true);
          }

          // Move the position of the track and cancel timer.
          sound._seek = seek;
          sound._ended = false;
          self._clearTimer(id);

          // Update the seek position for HTML5 Audio.
          if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {
            sound._node.currentTime = seek;
          }

          // Seek and emit when ready.
          var seekAndEmit = function() {
            self._emit('seek', id);

            // Restart the playback if the sound was playing.
            if (playing) {
              self.play(id, true);
            }
          };

          // Wait for the play lock to be unset before emitting (HTML5 Audio).
          if (playing && !self._webAudio) {
            var emitSeek = function() {
              if (!self._playLock) {
                seekAndEmit();
              } else {
                setTimeout(emitSeek, 0);
              }
            };
            setTimeout(emitSeek, 0);
          } else {
            seekAndEmit();
          }
        } else {
          if (self._webAudio) {
            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
          } else {
            return sound._node.currentTime;
          }
        }
      }

      return self;
    },

    /**
     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
     * @return {Boolean} True if playing and false if not.
     */
    playing: function(id) {
      var self = this;

      // Check the passed sound ID (if any).
      if (typeof id === 'number') {
        var sound = self._soundById(id);
        return sound ? !sound._paused : false;
      }

      // Otherwise, loop through all sounds and check if any are playing.
      for (var i=0; i<self._sounds.length; i++) {
        if (!self._sounds[i]._paused) {
          return true;
        }
      }

      return false;
    },

    /**
     * Get the duration of this sound. Passing a sound id will return the sprite duration.
     * @param  {Number} id The sound id to check. If none is passed, return full source duration.
     * @return {Number} Audio duration in seconds.
     */
    duration: function(id) {
      var self = this;
      var duration = self._duration;

      // If we pass an ID, get the sound and return the sprite length.
      var sound = self._soundById(id);
      if (sound) {
        duration = self._sprite[sound._sprite][1] / 1000;
      }

      return duration;
    },

    /**
     * Returns the current loaded state of this Howl.
     * @return {String} 'unloaded', 'loading', 'loaded'
     */
    state: function() {
      return this._state;
    },

    /**
     * Unload and destroy the current Howl object.
     * This will immediately stop all sound instances attached to this group.
     */
    unload: function() {
      var self = this;

      // Stop playing any active sounds.
      var sounds = self._sounds;
      for (var i=0; i<sounds.length; i++) {
        // Stop the sound if it is currently playing.
        if (!sounds[i]._paused) {
          self.stop(sounds[i]._id);
        }

        // Remove the source or disconnect.
        if (!self._webAudio) {
          // Set the source to 0-second silence to stop any downloading (except in IE).
          self._clearSound(sounds[i]._node);

          // Remove any event listeners.
          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);
          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);

          // Release the Audio object back to the pool.
          Howler._releaseHtml5Audio(sounds[i]._node);
        }

        // Empty out all of the nodes.
        delete sounds[i]._node;

        // Make sure all timers are cleared out.
        self._clearTimer(sounds[i]._id);
      }

      // Remove the references in the global Howler object.
      var index = Howler._howls.indexOf(self);
      if (index >= 0) {
        Howler._howls.splice(index, 1);
      }

      // Delete this sound from the cache (if no other Howl is using it).
      var remCache = true;
      for (i=0; i<Howler._howls.length; i++) {
        if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {
          remCache = false;
          break;
        }
      }

      if (cache && remCache) {
        delete cache[self._src];
      }

      // Clear global errors.
      Howler.noAudio = false;

      // Clear out `self`.
      self._state = 'unloaded';
      self._sounds = [];
      self = null;

      return null;
    },

    /**
     * Listen to a custom event.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
     * @return {Howl}
     */
    on: function(event, fn, id, once) {
      var self = this;
      var events = self['_on' + event];

      if (typeof fn === 'function') {
        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});
      }

      return self;
    },

    /**
     * Remove a custom event. Call without parameters to remove all events.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
     * @param  {Number}   id    (optional) Only remove events for this sound.
     * @return {Howl}
     */
    off: function(event, fn, id) {
      var self = this;
      var events = self['_on' + event];
      var i = 0;

      // Allow passing just an event and ID.
      if (typeof fn === 'number') {
        id = fn;
        fn = null;
      }

      if (fn || id) {
        // Loop through event store and remove the passed function.
        for (i=0; i<events.length; i++) {
          var isId = (id === events[i].id);
          if (fn === events[i].fn && isId || !fn && isId) {
            events.splice(i, 1);
            break;
          }
        }
      } else if (event) {
        // Clear out all events of this type.
        self['_on' + event] = [];
      } else {
        // Clear out all events of every type.
        var keys = Object.keys(self);
        for (i=0; i<keys.length; i++) {
          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {
            self[keys[i]] = [];
          }
        }
      }

      return self;
    },

    /**
     * Listen to a custom event and remove it once fired.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @return {Howl}
     */
    once: function(event, fn, id) {
      var self = this;

      // Setup the event listener.
      self.on(event, fn, id, 1);

      return self;
    },

    /**
     * Emit all events of a specific type and pass the sound id.
     * @param  {String} event Event name.
     * @param  {Number} id    Sound ID.
     * @param  {Number} msg   Message to go with event.
     * @return {Howl}
     */
    _emit: function(event, id, msg) {
      var self = this;
      var events = self['_on' + event];

      // Loop through event store and fire all functions.
      for (var i=events.length-1; i>=0; i--) {
        // Only fire the listener if the correct ID is used.
        if (!events[i].id || events[i].id === id || event === 'load') {
          setTimeout(function(fn) {
            fn.call(this, id, msg);
          }.bind(self, events[i].fn), 0);

          // If this event was setup with `once`, remove it.
          if (events[i].once) {
            self.off(event, events[i].fn, events[i].id);
          }
        }
      }

      // Pass the event type into load queue so that it can continue stepping.
      self._loadQueue(event);

      return self;
    },

    /**
     * Queue of actions initiated before the sound has loaded.
     * These will be called in sequence, with the next only firing
     * after the previous has finished executing (even if async like play).
     * @return {Howl}
     */
    _loadQueue: function(event) {
      var self = this;

      if (self._queue.length > 0) {
        var task = self._queue[0];

        // Remove this task if a matching event was passed.
        if (task.event === event) {
          self._queue.shift();
          self._loadQueue();
        }

        // Run the task if no event type is passed.
        if (!event) {
          task.action();
        }
      }

      return self;
    },

    /**
     * Fired when playback ends at the end of the duration.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _ended: function(sound) {
      var self = this;
      var sprite = sound._sprite;

      // If we are using IE and there was network latency we may be clipping
      // audio before it completes playing. Lets check the node to make sure it
      // believes it has completed, before ending the playback.
      if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
        setTimeout(self._ended.bind(self, sound), 100);
        return self;
      }

      // Should this sound loop?
      var loop = !!(sound._loop || self._sprite[sprite][2]);

      // Fire the ended event.
      self._emit('end', sound._id);

      // Restart the playback for HTML5 Audio loop.
      if (!self._webAudio && loop) {
        self.stop(sound._id, true).play(sound._id);
      }

      // Restart this timer if on a Web Audio loop.
      if (self._webAudio && loop) {
        self._emit('play', sound._id);
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        sound._playStart = Howler.ctx.currentTime;

        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);
        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
      }

      // Mark the node as paused.
      if (self._webAudio && !loop) {
        sound._paused = true;
        sound._ended = true;
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        self._clearTimer(sound._id);

        // Clean up the buffer source.
        self._cleanBuffer(sound._node);

        // Attempt to auto-suspend AudioContext if no sounds are still playing.
        Howler._autoSuspend();
      }

      // When using a sprite, end the track.
      if (!self._webAudio && !loop) {
        self.stop(sound._id, true);
      }

      return self;
    },

    /**
     * Clear the end timer for a sound playback.
     * @param  {Number} id The sound ID.
     * @return {Howl}
     */
    _clearTimer: function(id) {
      var self = this;

      if (self._endTimers[id]) {
        // Clear the timeout or remove the ended listener.
        if (typeof self._endTimers[id] !== 'function') {
          clearTimeout(self._endTimers[id]);
        } else {
          var sound = self._soundById(id);
          if (sound && sound._node) {
            sound._node.removeEventListener('ended', self._endTimers[id], false);
          }
        }

        delete self._endTimers[id];
      }

      return self;
    },

    /**
     * Return the sound identified by this ID, or return null.
     * @param  {Number} id Sound ID
     * @return {Object}    Sound object or null.
     */
    _soundById: function(id) {
      var self = this;

      // Loop through all sounds and find the one with this ID.
      for (var i=0; i<self._sounds.length; i++) {
        if (id === self._sounds[i]._id) {
          return self._sounds[i];
        }
      }

      return null;
    },

    /**
     * Return an inactive sound from the pool or create a new one.
     * @return {Sound} Sound playback object.
     */
    _inactiveSound: function() {
      var self = this;

      self._drain();

      // Find the first inactive node to recycle.
      for (var i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          return self._sounds[i].reset();
        }
      }

      // If no inactive node was found, create a new one.
      return new Sound(self);
    },

    /**
     * Drain excess inactive sounds from the pool.
     */
    _drain: function() {
      var self = this;
      var limit = self._pool;
      var cnt = 0;
      var i = 0;

      // If there are less sounds than the max pool size, we are done.
      if (self._sounds.length < limit) {
        return;
      }

      // Count the number of inactive sounds.
      for (i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          cnt++;
        }
      }

      // Remove excess inactive sounds, going in reverse order.
      for (i=self._sounds.length - 1; i>=0; i--) {
        if (cnt <= limit) {
          return;
        }

        if (self._sounds[i]._ended) {
          // Disconnect the audio source when using Web Audio.
          if (self._webAudio && self._sounds[i]._node) {
            self._sounds[i]._node.disconnect(0);
          }

          // Remove sounds until we have the pool size.
          self._sounds.splice(i, 1);
          cnt--;
        }
      }
    },

    /**
     * Get all ID's from the sounds pool.
     * @param  {Number} id Only return one ID if one is passed.
     * @return {Array}    Array of IDs.
     */
    _getSoundIds: function(id) {
      var self = this;

      if (typeof id === 'undefined') {
        var ids = [];
        for (var i=0; i<self._sounds.length; i++) {
          ids.push(self._sounds[i]._id);
        }

        return ids;
      } else {
        return [id];
      }
    },

    /**
     * Load the sound back into the buffer source.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _refreshBuffer: function(sound) {
      var self = this;

      // Setup the buffer source for playback.
      sound._node.bufferSource = Howler.ctx.createBufferSource();
      sound._node.bufferSource.buffer = cache[self._src];

      // Connect to the correct node.
      if (sound._panner) {
        sound._node.bufferSource.connect(sound._panner);
      } else {
        sound._node.bufferSource.connect(sound._node);
      }

      // Setup looping and playback rate.
      sound._node.bufferSource.loop = sound._loop;
      if (sound._loop) {
        sound._node.bufferSource.loopStart = sound._start || 0;
        sound._node.bufferSource.loopEnd = sound._stop || 0;
      }
      sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);

      return self;
    },

    /**
     * Prevent memory leaks by cleaning up the buffer source after playback.
     * @param  {Object} node Sound's audio node containing the buffer source.
     * @return {Howl}
     */
    _cleanBuffer: function(node) {
      var self = this;
      var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;

      if (Howler._scratchBuffer && node.bufferSource) {
        node.bufferSource.onended = null;
        node.bufferSource.disconnect(0);
        if (isIOS) {
          try { node.bufferSource.buffer = Howler._scratchBuffer; } catch(e) {}
        }
      }
      node.bufferSource = null;

      return self;
    },

    /**
     * Set the source to a 0-second silence to stop any downloading (except in IE).
     * @param  {Object} node Audio node to clear.
     */
    _clearSound: function(node) {
      var checkIE = /MSIE |Trident\//.test(Howler._navigator && Howler._navigator.userAgent);
      if (!checkIE) {
        node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';
      }
    }
  };

  /** Single Sound Methods **/
  /***************************************************************************/

  /**
   * Setup the sound object, which each node attached to a Howl group is contained in.
   * @param {Object} howl The Howl parent group.
   */
  var Sound = function(howl) {
    this._parent = howl;
    this.init();
  };
  Sound.prototype = {
    /**
     * Initialize a new Sound object.
     * @return {Sound}
     */
    init: function() {
      var self = this;
      var parent = self._parent;

      // Setup the default parameters.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a unique ID for this sound.
      self._id = ++Howler._counter;

      // Add itself to the parent's pool.
      parent._sounds.push(self);

      // Create the new node.
      self.create();

      return self;
    },

    /**
     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
     * @return {Sound}
     */
    create: function() {
      var self = this;
      var parent = self._parent;
      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;

      if (parent._webAudio) {
        // Create the gain node for controlling volume (the source will connect to this).
        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);
        self._node.paused = true;
        self._node.connect(Howler.masterGain);
      } else if (!Howler.noAudio) {
        // Get an unlocked Audio object from the pool.
        self._node = Howler._obtainHtml5Audio();

        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
        self._errorFn = self._errorListener.bind(self);
        self._node.addEventListener('error', self._errorFn, false);

        // Listen for 'canplaythrough' event to let us know the sound is ready.
        self._loadFn = self._loadListener.bind(self);
        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);

        // Setup the new audio node.
        self._node.src = parent._src;
        self._node.preload = 'auto';
        self._node.volume = volume * Howler.volume();

        // Begin loading the source.
        self._node.load();
      }

      return self;
    },

    /**
     * Reset the parameters of this sound to the original state (for recycle).
     * @return {Sound}
     */
    reset: function() {
      var self = this;
      var parent = self._parent;

      // Reset all of the parameters of this sound.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._rateSeek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a new ID so that it isn't confused with the previous sound.
      self._id = ++Howler._counter;

      return self;
    },

    /**
     * HTML5 Audio error listener callback.
     */
    _errorListener: function() {
      var self = this;

      // Fire an error event and pass back the code.
      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);

      // Clear the event listener.
      self._node.removeEventListener('error', self._errorFn, false);
    },

    /**
     * HTML5 Audio canplaythrough listener callback.
     */
    _loadListener: function() {
      var self = this;
      var parent = self._parent;

      // Round up the duration to account for the lower precision in HTML5 Audio.
      parent._duration = Math.ceil(self._node.duration * 10) / 10;

      // Setup a sprite if none is defined.
      if (Object.keys(parent._sprite).length === 0) {
        parent._sprite = {__default: [0, parent._duration * 1000]};
      }

      if (parent._state !== 'loaded') {
        parent._state = 'loaded';
        parent._emit('load');
        parent._loadQueue();
      }

      // Clear the event listener.
      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);
    }
  };

  /** Helper Methods **/
  /***************************************************************************/

  var cache = {};

  /**
   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
   * @param  {Howl} self
   */
  var loadBuffer = function(self) {
    var url = self._src;

    // Check if the buffer has already been cached and use it instead.
    if (cache[url]) {
      // Set the duration from the cache.
      self._duration = cache[url].duration;

      // Load the sound into this Howl.
      loadSound(self);

      return;
    }

    if (/^data:[^;]+;base64,/.test(url)) {
      // Decode the base64 data URI without XHR, since some browsers don't support it.
      var data = atob(url.split(',')[1]);
      var dataView = new Uint8Array(data.length);
      for (var i=0; i<data.length; ++i) {
        dataView[i] = data.charCodeAt(i);
      }

      decodeAudioData(dataView.buffer, self);
    } else {
      // Load the buffer from the URL.
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.withCredentials = self._xhrWithCredentials;
      xhr.responseType = 'arraybuffer';
      xhr.onload = function() {
        // Make sure we get a successful response back.
        var code = (xhr.status + '')[0];
        if (code !== '0' && code !== '2' && code !== '3') {
          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');
          return;
        }

        decodeAudioData(xhr.response, self);
      };
      xhr.onerror = function() {
        // If there is an error, switch to HTML5 Audio.
        if (self._webAudio) {
          self._html5 = true;
          self._webAudio = false;
          self._sounds = [];
          delete cache[url];
          self.load();
        }
      };
      safeXhrSend(xhr);
    }
  };

  /**
   * Send the XHR request wrapped in a try/catch.
   * @param  {Object} xhr XHR to send.
   */
  var safeXhrSend = function(xhr) {
    try {
      xhr.send();
    } catch (e) {
      xhr.onerror();
    }
  };

  /**
   * Decode audio data from an array buffer.
   * @param  {ArrayBuffer} arraybuffer The audio data.
   * @param  {Howl}        self
   */
  var decodeAudioData = function(arraybuffer, self) {
    // Fire a load error if something broke.
    var error = function() {
      self._emit('loaderror', null, 'Decoding audio data failed.');
    };

    // Load the sound on success.
    var success = function(buffer) {
      if (buffer && self._sounds.length > 0) {
        cache[self._src] = buffer;
        loadSound(self, buffer);
      } else {
        error();
      }
    };

    // Decode the buffer into an audio source.
    if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) {
      Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
    } else {
      Howler.ctx.decodeAudioData(arraybuffer, success, error);
    }
  }

  /**
   * Sound is now loaded, so finish setting everything up and fire the loaded event.
   * @param  {Howl} self
   * @param  {Object} buffer The decoded buffer sound source.
   */
  var loadSound = function(self, buffer) {
    // Set the duration.
    if (buffer && !self._duration) {
      self._duration = buffer.duration;
    }

    // Setup a sprite if none is defined.
    if (Object.keys(self._sprite).length === 0) {
      self._sprite = {__default: [0, self._duration * 1000]};
    }

    // Fire the loaded event.
    if (self._state !== 'loaded') {
      self._state = 'loaded';
      self._emit('load');
      self._loadQueue();
    }
  };

  /**
   * Setup the audio context when available, or switch to HTML5 Audio mode.
   */
  var setupAudioContext = function() {
    // If we have already detected that Web Audio isn't supported, don't run this step again.
    if (!Howler.usingWebAudio) {
      return;
    }

    // Check if we are using Web Audio and setup the AudioContext if we are.
    try {
      if (typeof AudioContext !== 'undefined') {
        Howler.ctx = new AudioContext();
      } else if (typeof webkitAudioContext !== 'undefined') {
        Howler.ctx = new webkitAudioContext();
      } else {
        Howler.usingWebAudio = false;
      }
    } catch(e) {
      Howler.usingWebAudio = false;
    }

    // If the audio context creation still failed, set using web audio to false.
    if (!Howler.ctx) {
      Howler.usingWebAudio = false;
    }

    // Check if a webview is being used on iOS8 or earlier (rather than the browser).
    // If it is, disable Web Audio as it causes crashing.
    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));
    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
    var version = appVersion ? parseInt(appVersion[1], 10) : null;
    if (iOS && version && version < 9) {
      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());
      if (Howler._navigator && Howler._navigator.standalone && !safari || Howler._navigator && !Howler._navigator.standalone && !safari) {
        Howler.usingWebAudio = false;
      }
    }

    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
    if (Howler.usingWebAudio) {
      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
      Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);
      Howler.masterGain.connect(Howler.ctx.destination);
    }

    // Re-run the setup on Howler.
    Howler._setup();
  };

  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return {
        Howler: Howler,
        Howl: Howl
      };
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }

  // Add support for CommonJS libraries such as browserify.
  if (true) {
    exports.Howler = Howler;
    exports.Howl = Howl;
  }

  // Define globally in case AMD is not available or unused.
  if (typeof window !== 'undefined') {
    window.HowlerGlobal = HowlerGlobal;
    window.Howler = Howler;
    window.Howl = Howl;
    window.Sound = Sound;
  } else if (typeof global !== 'undefined') { // Add to global in Node.js (for testing, etc).
    global.HowlerGlobal = HowlerGlobal;
    global.Howler = Howler;
    global.Howl = Howl;
    global.Sound = Sound;
  }
})();


/*!
 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
 *  
 *  howler.js v2.1.3
 *  howlerjs.com
 *
 *  (c) 2013-2019, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function() {

  'use strict';

  // Setup default properties.
  HowlerGlobal.prototype._pos = [0, 0, 0];
  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];

  /** Global Methods **/
  /***************************************************************************/

  /**
   * Helper method to update the stereo panning position of all current Howls.
   * Future Howls will not use this value unless explicitly set.
   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.
   * @return {Howler/Number}     Self or current stereo panning value.
   */
  HowlerGlobal.prototype.stereo = function(pan) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Loop through all Howls and update their stereo panning.
    for (var i=self._howls.length-1; i>=0; i--) {
      self._howls[i].stereo(pan);
    }

    return self;
  };

  /**
   * Get/set the position of the listener in 3D cartesian space. Sounds using
   * 3D position will be relative to the listener's position.
   * @param  {Number} x The x-position of the listener.
   * @param  {Number} y The y-position of the listener.
   * @param  {Number} z The z-position of the listener.
   * @return {Howler/Array}   Self or current listener position.
   */
  HowlerGlobal.prototype.pos = function(x, y, z) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? self._pos[1] : y;
    z = (typeof z !== 'number') ? self._pos[2] : z;

    if (typeof x === 'number') {
      self._pos = [x, y, z];

      if (typeof self.ctx.listener.positionX !== 'undefined') {
        self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);
        self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);
        self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);
      } else {
        self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
      }
    } else {
      return self._pos;
    }

    return self;
  };

  /**
   * Get/set the direction the listener is pointing in the 3D cartesian space.
   * A front and up vector must be provided. The front is the direction the
   * face of the listener is pointing, and up is the direction the top of the
   * listener is pointing. Thus, these values are expected to be at right angles
   * from each other.
   * @param  {Number} x   The x-orientation of the listener.
   * @param  {Number} y   The y-orientation of the listener.
   * @param  {Number} z   The z-orientation of the listener.
   * @param  {Number} xUp The x-orientation of the top of the listener.
   * @param  {Number} yUp The y-orientation of the top of the listener.
   * @param  {Number} zUp The z-orientation of the top of the listener.
   * @return {Howler/Array}     Returns self or the current orientation vectors.
   */
  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    var or = self._orientation;
    y = (typeof y !== 'number') ? or[1] : y;
    z = (typeof z !== 'number') ? or[2] : z;
    xUp = (typeof xUp !== 'number') ? or[3] : xUp;
    yUp = (typeof yUp !== 'number') ? or[4] : yUp;
    zUp = (typeof zUp !== 'number') ? or[5] : zUp;

    if (typeof x === 'number') {
      self._orientation = [x, y, z, xUp, yUp, zUp];

      if (typeof self.ctx.listener.forwardX !== 'undefined') {
        self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
      } else {
        self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
      }
    } else {
      return or;
    }

    return self;
  };

  /** Group Methods **/
  /***************************************************************************/

  /**
   * Add new properties to the core init.
   * @param  {Function} _super Core init method.
   * @return {Howl}
   */
  Howl.prototype.init = (function(_super) {
    return function(o) {
      var self = this;

      // Setup user-defined default properties.
      self._orientation = o.orientation || [1, 0, 0];
      self._stereo = o.stereo || null;
      self._pos = o.pos || null;
      self._pannerAttr = {
        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,
        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,
        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,
        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',
        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,
        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',
        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,
        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1
      };

      // Setup event listeners.
      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];
      self._onpos = o.onpos ? [{fn: o.onpos}] : [];
      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];

      // Complete initilization with howler.js core's init function.
      return _super.call(this, o);
    };
  })(Howl.prototype.init);

  /**
   * Get/set the stereo panning of the audio source for this sound or all in the group.
   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Number}    Returns self or the current stereo panning value.
   */
  Howl.prototype.stereo = function(pan, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'stereo',
        action: function() {
          self.stereo(pan, id);
        }
      });

      return self;
    }

    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.
    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';

    // Setup the group's stereo panning if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's stereo panning if no parameters are passed.
      if (typeof pan === 'number') {
        self._stereo = pan;
        self._pos = [pan, 0, 0];
      } else {
        return self._stereo;
      }
    }

    // Change the streo panning of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof pan === 'number') {
          sound._stereo = pan;
          sound._pos = [pan, 0, 0];

          if (sound._node) {
            // If we are falling back, make sure the panningModel is equalpower.
            sound._pannerAttr.panningModel = 'equalpower';

            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner || !sound._panner.pan) {
              setupPanner(sound, pannerType);
            }

            if (pannerType === 'spatial') {
              if (typeof sound._panner.positionX !== 'undefined') {
                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
              } else {
                sound._panner.setPosition(pan, 0, 0);
              }
            } else {
              sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
            }
          }

          self._emit('stereo', sound._id);
        } else {
          return sound._stereo;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.
   * @param  {Number} x  The x-position of the audio source.
   * @param  {Number} y  The y-position of the audio source.
   * @param  {Number} z  The z-position of the audio source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].
   */
  Howl.prototype.pos = function(x, y, z, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change position when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'pos',
        action: function() {
          self.pos(x, y, z, id);
        }
      });

      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? 0 : y;
    z = (typeof z !== 'number') ? -0.5 : z;

    // Setup the group's spatial position if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's spatial position if no parameters are passed.
      if (typeof x === 'number') {
        self._pos = [x, y, z];
      } else {
        return self._pos;
      }
    }

    // Change the spatial position of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof x === 'number') {
          sound._pos = [x, y, z];

          if (sound._node) {
            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner || sound._panner.pan) {
              setupPanner(sound, 'spatial');
            }

            if (typeof sound._panner.positionX !== 'undefined') {
              sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
              sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
              sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
            } else {
              sound._panner.setPosition(x, y, z);
            }
          }

          self._emit('pos', sound._id);
        } else {
          return sound._pos;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate
   * space. Depending on how direction the sound is, based on the `cone` attributes,
   * a sound pointing away from the listener can be quiet or silent.
   * @param  {Number} x  The x-orientation of the source.
   * @param  {Number} y  The y-orientation of the source.
   * @param  {Number} z  The z-orientation of the source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].
   */
  Howl.prototype.orientation = function(x, y, z, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'orientation',
        action: function() {
          self.orientation(x, y, z, id);
        }
      });

      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? self._orientation[1] : y;
    z = (typeof z !== 'number') ? self._orientation[2] : z;

    // Setup the group's spatial orientation if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's spatial orientation if no parameters are passed.
      if (typeof x === 'number') {
        self._orientation = [x, y, z];
      } else {
        return self._orientation;
      }
    }

    // Change the spatial orientation of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof x === 'number') {
          sound._orientation = [x, y, z];

          if (sound._node) {
            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner) {
              // Make sure we have a position to setup the node with.
              if (!sound._pos) {
                sound._pos = self._pos || [0, 0, -0.5];
              }

              setupPanner(sound, 'spatial');
            }

            if (typeof sound._panner.orientationX !== 'undefined') {
              sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
              sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
              sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
            } else {
              sound._panner.setOrientation(x, y, z);
            }
          }

          self._emit('orientation', sound._id);
        } else {
          return sound._orientation;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the panner node's attributes for a sound or group of sounds.
   * This method can optionall take 0, 1 or 2 arguments.
   *   pannerAttr() -> Returns the group's values.
   *   pannerAttr(id) -> Returns the sound id's values.
   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.
   *   pannerAttr(o, id) -> Set's the values of passed sound id.
   *
   *   Attributes:
   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      inside of which there will be no volume reduction.
   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.
   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the
   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.
   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from
   *                     listener. Can be `linear`, `inverse` or `exponential.
   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume
   *                   will not be reduced any further.
   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.
   *                   This is simply a variable of the distance model and has a different effect depending on which model
   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.
   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a
   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ∞]`
   *                     with `inverse` and `exponential`.
   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.
   *                     Can be `HRTF` or `equalpower`.
   *
   * @return {Howl/Object} Returns self or current panner attributes.
   */
  Howl.prototype.pannerAttr = function() {
    var self = this;
    var args = arguments;
    var o, id, sound;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // Determine the values based on arguments.
    if (args.length === 0) {
      // Return the group's panner attribute values.
      return self._pannerAttr;
    } else if (args.length === 1) {
      if (typeof args[0] === 'object') {
        o = args[0];

        // Set the grou's panner attribute values.
        if (typeof id === 'undefined') {
          if (!o.pannerAttr) {
            o.pannerAttr = {
              coneInnerAngle: o.coneInnerAngle,
              coneOuterAngle: o.coneOuterAngle,
              coneOuterGain: o.coneOuterGain,
              distanceModel: o.distanceModel,
              maxDistance: o.maxDistance,
              refDistance: o.refDistance,
              rolloffFactor: o.rolloffFactor,
              panningModel: o.panningModel
            };
          }

          self._pannerAttr = {
            coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,
            coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,
            coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,
            distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,
            maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,
            refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,
            rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,
            panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel
          };
        }
      } else {
        // Return this sound's panner attribute values.
        sound = self._soundById(parseInt(args[0], 10));
        return sound ? sound._pannerAttr : self._pannerAttr;
      }
    } else if (args.length === 2) {
      o = args[0];
      id = parseInt(args[1], 10);
    }

    // Update the values of the specified sounds.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      sound = self._soundById(ids[i]);

      if (sound) {
        // Merge the new values into the sound.
        var pa = sound._pannerAttr;
        pa = {
          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,
          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,
          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,
          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,
          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,
          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,
          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,
          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel
        };

        // Update the panner values or create a new panner if none exists.
        var panner = sound._panner;
        if (panner) {
          panner.coneInnerAngle = pa.coneInnerAngle;
          panner.coneOuterAngle = pa.coneOuterAngle;
          panner.coneOuterGain = pa.coneOuterGain;
          panner.distanceModel = pa.distanceModel;
          panner.maxDistance = pa.maxDistance;
          panner.refDistance = pa.refDistance;
          panner.rolloffFactor = pa.rolloffFactor;
          panner.panningModel = pa.panningModel;
        } else {
          // Make sure we have a position to setup the node with.
          if (!sound._pos) {
            sound._pos = self._pos || [0, 0, -0.5];
          }

          // Create a new panner node.
          setupPanner(sound, 'spatial');
        }
      }
    }

    return self;
  };

  /** Single Sound Methods **/
  /***************************************************************************/

  /**
   * Add new properties to the core Sound init.
   * @param  {Function} _super Core Sound init method.
   * @return {Sound}
   */
  Sound.prototype.init = (function(_super) {
    return function() {
      var self = this;
      var parent = self._parent;

      // Setup user-defined default properties.
      self._orientation = parent._orientation;
      self._stereo = parent._stereo;
      self._pos = parent._pos;
      self._pannerAttr = parent._pannerAttr;

      // Complete initilization with howler.js core Sound's init function.
      _super.call(this);

      // If a stereo or position was specified, set it up.
      if (self._stereo) {
        parent.stereo(self._stereo);
      } else if (self._pos) {
        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
      }
    };
  })(Sound.prototype.init);

  /**
   * Override the Sound.reset method to clean up properties from the spatial plugin.
   * @param  {Function} _super Sound reset method.
   * @return {Sound}
   */
  Sound.prototype.reset = (function(_super) {
    return function() {
      var self = this;
      var parent = self._parent;

      // Reset all spatial plugin properties on this sound.
      self._orientation = parent._orientation;
      self._stereo = parent._stereo;
      self._pos = parent._pos;
      self._pannerAttr = parent._pannerAttr;

      // If a stereo or position was specified, set it up.
      if (self._stereo) {
        parent.stereo(self._stereo);
      } else if (self._pos) {
        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
      } else if (self._panner) {
        // Disconnect the panner.
        self._panner.disconnect(0);
        self._panner = undefined;
        parent._refreshBuffer(self);
      }

      // Complete resetting of the sound.
      return _super.call(this);
    };
  })(Sound.prototype.reset);

  /** Helper Methods **/
  /***************************************************************************/

  /**
   * Create a new panner node and save it on the sound.
   * @param  {Sound} sound Specific sound to setup panning on.
   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.
   */
  var setupPanner = function(sound, type) {
    type = type || 'spatial';

    // Create the new panner node.
    if (type === 'spatial') {
      sound._panner = Howler.ctx.createPanner();
      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
      sound._panner.distanceModel = sound._pannerAttr.distanceModel;
      sound._panner.maxDistance = sound._pannerAttr.maxDistance;
      sound._panner.refDistance = sound._pannerAttr.refDistance;
      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
      sound._panner.panningModel = sound._pannerAttr.panningModel;

      if (typeof sound._panner.positionX !== 'undefined') {
        sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
        sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
        sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
      } else {
        sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
      }

      if (typeof sound._panner.orientationX !== 'undefined') {
        sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
        sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
        sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
      } else {
        sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
      }
    } else {
      sound._panner = Howler.ctx.createStereoPanner();
      sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
    }

    sound._panner.connect(sound._node);

    // Update the connections.
    if (!sound._paused) {
      sound._parent.pause(sound._id, true).play(sound._id, true);
    }
  };
})();

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../gulp/node_modules/webpack/buildin/global.js */ "./gulp/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/json-schema-traverse/index.js":
/*!****************************************************!*\
  !*** ./node_modules/json-schema-traverse/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var traverse = module.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, '', schema);
};


traverse.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
};

traverse.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse.propsKeywords = {
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse.arrayKeywords) {
          for (var i=0; i<sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}


/***/ }),

/***/ "./node_modules/query-string/index.js":
/*!********************************************!*\
  !*** ./node_modules/query-string/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const strictUriEncode = __webpack_require__(/*! strict-uri-encode */ "./node_modules/strict-uri-encode/index.js");
const decodeComponent = __webpack_require__(/*! decode-uri-component */ "./node_modules/decode-uri-component/index.js");
const splitOnFirst = __webpack_require__(/*! split-on-first */ "./node_modules/split-on-first/index.js");

const isNullOrUndefined = value => value === null || value === undefined;

function encoderForArrayFormat(options) {
	switch (options.arrayFormat) {
		case 'index':
			return key => (result, value) => {
				const index = result.length;

				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), '[', index, ']'].join('')];
				}

				return [
					...result,
					[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')
				];
			};

		case 'bracket':
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), '[]'].join('')];
				}

				return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
			};

		case 'comma':
		case 'separator':
			return key => (result, value) => {
				if (value === null || value === undefined || value.length === 0) {
					return result;
				}

				if (result.length === 0) {
					return [[encode(key, options), '=', encode(value, options)].join('')];
				}

				return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
			};

		default:
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, encode(key, options)];
				}

				return [...result, [encode(key, options), '=', encode(value, options)].join('')];
			};
	}
}

function parserForArrayFormat(options) {
	let result;

	switch (options.arrayFormat) {
		case 'index':
			return (key, value, accumulator) => {
				result = /\[(\d*)\]$/.exec(key);

				key = key.replace(/\[\d*\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = {};
				}

				accumulator[key][result[1]] = value;
			};

		case 'bracket':
			return (key, value, accumulator) => {
				result = /(\[\])$/.exec(key);
				key = key.replace(/\[\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = [value];
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};

		case 'comma':
		case 'separator':
			return (key, value, accumulator) => {
				const isArray = typeof value === 'string' && value.split('').indexOf(options.arrayFormatSeparator) > -1;
				const newValue = isArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
				accumulator[key] = newValue;
			};

		default:
			return (key, value, accumulator) => {
				if (accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};
	}
}

function validateArrayFormatSeparator(value) {
	if (typeof value !== 'string' || value.length !== 1) {
		throw new TypeError('arrayFormatSeparator must be single character string');
	}
}

function encode(value, options) {
	if (options.encode) {
		return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
	}

	return value;
}

function decode(value, options) {
	if (options.decode) {
		return decodeComponent(value);
	}

	return value;
}

function keysSorter(input) {
	if (Array.isArray(input)) {
		return input.sort();
	}

	if (typeof input === 'object') {
		return keysSorter(Object.keys(input))
			.sort((a, b) => Number(a) - Number(b))
			.map(key => input[key]);
	}

	return input;
}

function removeHash(input) {
	const hashStart = input.indexOf('#');
	if (hashStart !== -1) {
		input = input.slice(0, hashStart);
	}

	return input;
}

function getHash(url) {
	let hash = '';
	const hashStart = url.indexOf('#');
	if (hashStart !== -1) {
		hash = url.slice(hashStart);
	}

	return hash;
}

function extract(input) {
	input = removeHash(input);
	const queryStart = input.indexOf('?');
	if (queryStart === -1) {
		return '';
	}

	return input.slice(queryStart + 1);
}

function parseValue(value, options) {
	if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
		value = Number(value);
	} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
		value = value.toLowerCase() === 'true';
	}

	return value;
}

function parse(input, options) {
	options = Object.assign({
		decode: true,
		sort: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ',',
		parseNumbers: false,
		parseBooleans: false
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const formatter = parserForArrayFormat(options);

	// Create an object with no prototype
	const ret = Object.create(null);

	if (typeof input !== 'string') {
		return ret;
	}

	input = input.trim().replace(/^[?#&]/, '');

	if (!input) {
		return ret;
	}

	for (const param of input.split('&')) {
		let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '=');

		// Missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		value = value === undefined ? null : ['comma', 'separator'].includes(options.arrayFormat) ? value : decode(value, options);
		formatter(decode(key, options), value, ret);
	}

	for (const key of Object.keys(ret)) {
		const value = ret[key];
		if (typeof value === 'object' && value !== null) {
			for (const k of Object.keys(value)) {
				value[k] = parseValue(value[k], options);
			}
		} else {
			ret[key] = parseValue(value, options);
		}
	}

	if (options.sort === false) {
		return ret;
	}

	return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
		const value = ret[key];
		if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
			// Sort object keys, not values
			result[key] = keysSorter(value);
		} else {
			result[key] = value;
		}

		return result;
	}, Object.create(null));
}

exports.extract = extract;
exports.parse = parse;

exports.stringify = (object, options) => {
	if (!object) {
		return '';
	}

	options = Object.assign({
		encode: true,
		strict: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ','
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const shouldFilter = key => (
		(options.skipNull && isNullOrUndefined(object[key])) ||
		(options.skipEmptyString && object[key] === '')
	);

	const formatter = encoderForArrayFormat(options);

	const objectCopy = {};

	for (const key of Object.keys(object)) {
		if (!shouldFilter(key)) {
			objectCopy[key] = object[key];
		}
	}

	const keys = Object.keys(objectCopy);

	if (options.sort !== false) {
		keys.sort(options.sort);
	}

	return keys.map(key => {
		const value = object[key];

		if (value === undefined) {
			return '';
		}

		if (value === null) {
			return encode(key, options);
		}

		if (Array.isArray(value)) {
			return value
				.reduce(formatter(key), [])
				.join('&');
		}

		return encode(key, options) + '=' + encode(value, options);
	}).filter(x => x.length > 0).join('&');
};

exports.parseUrl = (input, options) => {
	return {
		url: removeHash(input).split('?')[0] || '',
		query: parse(extract(input), options)
	};
};

exports.stringifyUrl = (input, options) => {
	const url = removeHash(input.url).split('?')[0] || '';
	const queryFromUrl = exports.extract(input.url);
	const parsedQueryFromUrl = exports.parse(queryFromUrl);
	const hash = getHash(input.url);
	const query = Object.assign(parsedQueryFromUrl, input.query);
	let queryString = exports.stringify(query, options);
	if (queryString) {
		queryString = `?${queryString}`;
	}

	return `${url}${queryString}${hash}`;
};


/***/ }),

/***/ "./node_modules/rusha/dist/rusha.js":
/*!******************************************!*\
  !*** ./node_modules/rusha/dist/rusha.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint-env commonjs, browser */

var RushaCore = __webpack_require__(5);

var _require = __webpack_require__(1),
    toHex = _require.toHex,
    ceilHeapSize = _require.ceilHeapSize;

var conv = __webpack_require__(6);

// Calculate the length of buffer that the sha1 routine uses
// including the padding.
var padlen = function (len) {
  for (len += 9; len % 64 > 0; len += 1) {}
  return len;
};

var padZeroes = function (bin, len) {
  var h8 = new Uint8Array(bin.buffer);
  var om = len % 4,
      align = len - om;
  switch (om) {
    case 0:
      h8[align + 3] = 0;
    case 1:
      h8[align + 2] = 0;
    case 2:
      h8[align + 1] = 0;
    case 3:
      h8[align + 0] = 0;
  }
  for (var i = (len >> 2) + 1; i < bin.length; i++) {
    bin[i] = 0;
  }
};

var padData = function (bin, chunkLen, msgLen) {
  bin[chunkLen >> 2] |= 0x80 << 24 - (chunkLen % 4 << 3);
  // To support msgLen >= 2 GiB, use a float division when computing the
  // high 32-bits of the big-endian message length in bits.
  bin[((chunkLen >> 2) + 2 & ~0x0f) + 14] = msgLen / (1 << 29) | 0;
  bin[((chunkLen >> 2) + 2 & ~0x0f) + 15] = msgLen << 3;
};

var getRawDigest = function (heap, padMaxChunkLen) {
  var io = new Int32Array(heap, padMaxChunkLen + 320, 5);
  var out = new Int32Array(5);
  var arr = new DataView(out.buffer);
  arr.setInt32(0, io[0], false);
  arr.setInt32(4, io[1], false);
  arr.setInt32(8, io[2], false);
  arr.setInt32(12, io[3], false);
  arr.setInt32(16, io[4], false);
  return out;
};

var Rusha = function () {
  function Rusha(chunkSize) {
    _classCallCheck(this, Rusha);

    chunkSize = chunkSize || 64 * 1024;
    if (chunkSize % 64 > 0) {
      throw new Error('Chunk size must be a multiple of 128 bit');
    }
    this._offset = 0;
    this._maxChunkLen = chunkSize;
    this._padMaxChunkLen = padlen(chunkSize);
    // The size of the heap is the sum of:
    // 1. The padded input message size
    // 2. The extended space the algorithm needs (320 byte)
    // 3. The 160 bit state the algoritm uses
    this._heap = new ArrayBuffer(ceilHeapSize(this._padMaxChunkLen + 320 + 20));
    this._h32 = new Int32Array(this._heap);
    this._h8 = new Int8Array(this._heap);
    this._core = new RushaCore({ Int32Array: Int32Array }, {}, this._heap);
  }

  Rusha.prototype._initState = function _initState(heap, padMsgLen) {
    this._offset = 0;
    var io = new Int32Array(heap, padMsgLen + 320, 5);
    io[0] = 1732584193;
    io[1] = -271733879;
    io[2] = -1732584194;
    io[3] = 271733878;
    io[4] = -1009589776;
  };

  Rusha.prototype._padChunk = function _padChunk(chunkLen, msgLen) {
    var padChunkLen = padlen(chunkLen);
    var view = new Int32Array(this._heap, 0, padChunkLen >> 2);
    padZeroes(view, chunkLen);
    padData(view, chunkLen, msgLen);
    return padChunkLen;
  };

  Rusha.prototype._write = function _write(data, chunkOffset, chunkLen, off) {
    conv(data, this._h8, this._h32, chunkOffset, chunkLen, off || 0);
  };

  Rusha.prototype._coreCall = function _coreCall(data, chunkOffset, chunkLen, msgLen, finalize) {
    var padChunkLen = chunkLen;
    this._write(data, chunkOffset, chunkLen);
    if (finalize) {
      padChunkLen = this._padChunk(chunkLen, msgLen);
    }
    this._core.hash(padChunkLen, this._padMaxChunkLen);
  };

  Rusha.prototype.rawDigest = function rawDigest(str) {
    var msgLen = str.byteLength || str.length || str.size || 0;
    this._initState(this._heap, this._padMaxChunkLen);
    var chunkOffset = 0,
        chunkLen = this._maxChunkLen;
    for (chunkOffset = 0; msgLen > chunkOffset + chunkLen; chunkOffset += chunkLen) {
      this._coreCall(str, chunkOffset, chunkLen, msgLen, false);
    }
    this._coreCall(str, chunkOffset, msgLen - chunkOffset, msgLen, true);
    return getRawDigest(this._heap, this._padMaxChunkLen);
  };

  Rusha.prototype.digest = function digest(str) {
    return toHex(this.rawDigest(str).buffer);
  };

  Rusha.prototype.digestFromString = function digestFromString(str) {
    return this.digest(str);
  };

  Rusha.prototype.digestFromBuffer = function digestFromBuffer(str) {
    return this.digest(str);
  };

  Rusha.prototype.digestFromArrayBuffer = function digestFromArrayBuffer(str) {
    return this.digest(str);
  };

  Rusha.prototype.resetState = function resetState() {
    this._initState(this._heap, this._padMaxChunkLen);
    return this;
  };

  Rusha.prototype.append = function append(chunk) {
    var chunkOffset = 0;
    var chunkLen = chunk.byteLength || chunk.length || chunk.size || 0;
    var turnOffset = this._offset % this._maxChunkLen;
    var inputLen = void 0;

    this._offset += chunkLen;
    while (chunkOffset < chunkLen) {
      inputLen = Math.min(chunkLen - chunkOffset, this._maxChunkLen - turnOffset);
      this._write(chunk, chunkOffset, inputLen, turnOffset);
      turnOffset += inputLen;
      chunkOffset += inputLen;
      if (turnOffset === this._maxChunkLen) {
        this._core.hash(this._maxChunkLen, this._padMaxChunkLen);
        turnOffset = 0;
      }
    }
    return this;
  };

  Rusha.prototype.getState = function getState() {
    var turnOffset = this._offset % this._maxChunkLen;
    var heap = void 0;
    if (!turnOffset) {
      var io = new Int32Array(this._heap, this._padMaxChunkLen + 320, 5);
      heap = io.buffer.slice(io.byteOffset, io.byteOffset + io.byteLength);
    } else {
      heap = this._heap.slice(0);
    }
    return {
      offset: this._offset,
      heap: heap
    };
  };

  Rusha.prototype.setState = function setState(state) {
    this._offset = state.offset;
    if (state.heap.byteLength === 20) {
      var io = new Int32Array(this._heap, this._padMaxChunkLen + 320, 5);
      io.set(new Int32Array(state.heap));
    } else {
      this._h32.set(new Int32Array(state.heap));
    }
    return this;
  };

  Rusha.prototype.rawEnd = function rawEnd() {
    var msgLen = this._offset;
    var chunkLen = msgLen % this._maxChunkLen;
    var padChunkLen = this._padChunk(chunkLen, msgLen);
    this._core.hash(padChunkLen, this._padMaxChunkLen);
    var result = getRawDigest(this._heap, this._padMaxChunkLen);
    this._initState(this._heap, this._padMaxChunkLen);
    return result;
  };

  Rusha.prototype.end = function end() {
    return toHex(this.rawEnd().buffer);
  };

  return Rusha;
}();

module.exports = Rusha;
module.exports._core = RushaCore;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

/* eslint-env commonjs, browser */

//
// toHex
//

var precomputedHex = new Array(256);
for (var i = 0; i < 256; i++) {
  precomputedHex[i] = (i < 0x10 ? '0' : '') + i.toString(16);
}

module.exports.toHex = function (arrayBuffer) {
  var binarray = new Uint8Array(arrayBuffer);
  var res = new Array(arrayBuffer.byteLength);
  for (var _i = 0; _i < res.length; _i++) {
    res[_i] = precomputedHex[binarray[_i]];
  }
  return res.join('');
};

//
// ceilHeapSize
//

module.exports.ceilHeapSize = function (v) {
  // The asm.js spec says:
  // The heap object's byteLength must be either
  // 2^n for n in [12, 24) or 2^24 * n for n ≥ 1.
  // Also, byteLengths smaller than 2^16 are deprecated.
  var p = 0;
  // If v is smaller than 2^16, the smallest possible solution
  // is 2^16.
  if (v <= 65536) return 65536;
  // If v < 2^24, we round up to 2^n,
  // otherwise we round up to 2^24 * n.
  if (v < 16777216) {
    for (p = 1; p < v; p = p << 1) {}
  } else {
    for (p = 16777216; p < v; p += 16777216) {}
  }
  return p;
};

//
// isDedicatedWorkerScope
//

module.exports.isDedicatedWorkerScope = function (self) {
  var isRunningInWorker = 'WorkerGlobalScope' in self && self instanceof self.WorkerGlobalScope;
  var isRunningInSharedWorker = 'SharedWorkerGlobalScope' in self && self instanceof self.SharedWorkerGlobalScope;
  var isRunningInServiceWorker = 'ServiceWorkerGlobalScope' in self && self instanceof self.ServiceWorkerGlobalScope;

  // Detects whether we run inside a dedicated worker or not.
  //
  // We can't just check for `DedicatedWorkerGlobalScope`, since IE11
  // has a bug where it only supports `WorkerGlobalScope`.
  //
  // Therefore, we consider us as running inside a dedicated worker
  // when we are running inside a worker, but not in a shared or service worker.
  //
  // When new types of workers are introduced, we will need to adjust this code.
  return isRunningInWorker && !isRunningInSharedWorker && !isRunningInServiceWorker;
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-env commonjs, worker */

module.exports = function () {
  var Rusha = __webpack_require__(0);

  var hashData = function (hasher, data, cb) {
    try {
      return cb(null, hasher.digest(data));
    } catch (e) {
      return cb(e);
    }
  };

  var hashFile = function (hasher, readTotal, blockSize, file, cb) {
    var reader = new self.FileReader();
    reader.onloadend = function onloadend() {
      if (reader.error) {
        return cb(reader.error);
      }
      var buffer = reader.result;
      readTotal += reader.result.byteLength;
      try {
        hasher.append(buffer);
      } catch (e) {
        cb(e);
        return;
      }
      if (readTotal < file.size) {
        hashFile(hasher, readTotal, blockSize, file, cb);
      } else {
        cb(null, hasher.end());
      }
    };
    reader.readAsArrayBuffer(file.slice(readTotal, readTotal + blockSize));
  };

  var workerBehaviourEnabled = true;

  self.onmessage = function (event) {
    if (!workerBehaviourEnabled) {
      return;
    }

    var data = event.data.data,
        file = event.data.file,
        id = event.data.id;
    if (typeof id === 'undefined') return;
    if (!file && !data) return;
    var blockSize = event.data.blockSize || 4 * 1024 * 1024;
    var hasher = new Rusha(blockSize);
    hasher.resetState();
    var done = function (err, hash) {
      if (!err) {
        self.postMessage({ id: id, hash: hash });
      } else {
        self.postMessage({ id: id, error: err.name });
      }
    };
    if (data) hashData(hasher, data, done);
    if (file) hashFile(hasher, 0, blockSize, file, done);
  };

  return function () {
    workerBehaviourEnabled = false;
  };
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-env commonjs, browser */

var work = __webpack_require__(4);
var Rusha = __webpack_require__(0);
var createHash = __webpack_require__(7);
var runWorker = __webpack_require__(2);

var _require = __webpack_require__(1),
    isDedicatedWorkerScope = _require.isDedicatedWorkerScope;

var isRunningInDedicatedWorker = typeof self !== 'undefined' && isDedicatedWorkerScope(self);

Rusha.disableWorkerBehaviour = isRunningInDedicatedWorker ? runWorker() : function () {};

Rusha.createWorker = function () {
  var worker = work(/*require.resolve*/(2));
  var terminate = worker.terminate;
  worker.terminate = function () {
    URL.revokeObjectURL(worker.objectURL);
    terminate.call(worker);
  };
  return worker;
};

Rusha.createHash = createHash;

module.exports = Rusha;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

function webpackBootstrapFunc (modules) {
/******/  // The module cache
/******/  var installedModules = {};

/******/  // The require function
/******/  function __webpack_require__(moduleId) {

/******/    // Check if module is in cache
/******/    if(installedModules[moduleId])
/******/      return installedModules[moduleId].exports;

/******/    // Create a new module (and put it into the cache)
/******/    var module = installedModules[moduleId] = {
/******/      i: moduleId,
/******/      l: false,
/******/      exports: {}
/******/    };

/******/    // Execute the module function
/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/    // Flag the module as loaded
/******/    module.l = true;

/******/    // Return the exports of the module
/******/    return module.exports;
/******/  }

/******/  // expose the modules object (__webpack_modules__)
/******/  __webpack_require__.m = modules;

/******/  // expose the module cache
/******/  __webpack_require__.c = installedModules;

/******/  // identity function for calling harmony imports with the correct context
/******/  __webpack_require__.i = function(value) { return value; };

/******/  // define getter function for harmony exports
/******/  __webpack_require__.d = function(exports, name, getter) {
/******/    if(!__webpack_require__.o(exports, name)) {
/******/      Object.defineProperty(exports, name, {
/******/        configurable: false,
/******/        enumerable: true,
/******/        get: getter
/******/      });
/******/    }
/******/  };

/******/  // define __esModule on exports
/******/  __webpack_require__.r = function(exports) {
/******/    Object.defineProperty(exports, '__esModule', { value: true });
/******/  };

/******/  // getDefaultExport function for compatibility with non-harmony modules
/******/  __webpack_require__.n = function(module) {
/******/    var getter = module && module.__esModule ?
/******/      function getDefault() { return module['default']; } :
/******/      function getModuleExports() { return module; };
/******/    __webpack_require__.d(getter, 'a', getter);
/******/    return getter;
/******/  };

/******/  // Object.prototype.hasOwnProperty.call
/******/  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/  // __webpack_public_path__
/******/  __webpack_require__.p = "/";

/******/  // on error function for async loading
/******/  __webpack_require__.oe = function(err) { console.error(err); throw err; };

  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE)
  return f.default || f // try to call default if defined to also support babel esmodule exports
}

var moduleNameReqExp = '[\\.|\\-|\\+|\\w|\/|@]+'
var dependencyRegExp = '\\((\/\\*.*?\\*\/)?\s?.*?(' + moduleNameReqExp + ').*?\\)' // additional chars when output.pathinfo is true

// http://stackoverflow.com/a/2593661/130442
function quoteRegExp (str) {
  return (str + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&')
}

function getModuleDependencies (sources, module, queueName) {
  var retval = {}
  retval[queueName] = []

  var fnString = module.toString()
  var wrapperSignature = fnString.match(/^function\s?\(\w+,\s*\w+,\s*(\w+)\)/)
  if (!wrapperSignature) return retval
  var webpackRequireName = wrapperSignature[1]

  // main bundle deps
  var re = new RegExp('(\\\\n|\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g')
  var match
  while ((match = re.exec(fnString))) {
    if (match[3] === 'dll-reference') continue
    retval[queueName].push(match[3])
  }

  // dll deps
  re = new RegExp('\\(' + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, 'g')
  while ((match = re.exec(fnString))) {
    if (!sources[match[2]]) {
      retval[queueName].push(match[1])
      sources[match[2]] = __webpack_require__(match[1]).m
    }
    retval[match[2]] = retval[match[2]] || []
    retval[match[2]].push(match[4])
  }

  return retval
}

function hasValuesInQueues (queues) {
  var keys = Object.keys(queues)
  return keys.reduce(function (hasValues, key) {
    return hasValues || queues[key].length > 0
  }, false)
}

function getRequiredModules (sources, moduleId) {
  var modulesQueue = {
    main: [moduleId]
  }
  var requiredModules = {
    main: []
  }
  var seenModules = {
    main: {}
  }

  while (hasValuesInQueues(modulesQueue)) {
    var queues = Object.keys(modulesQueue)
    for (var i = 0; i < queues.length; i++) {
      var queueName = queues[i]
      var queue = modulesQueue[queueName]
      var moduleToCheck = queue.pop()
      seenModules[queueName] = seenModules[queueName] || {}
      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue
      seenModules[queueName][moduleToCheck] = true
      requiredModules[queueName] = requiredModules[queueName] || []
      requiredModules[queueName].push(moduleToCheck)
      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName)
      var newModulesKeys = Object.keys(newModules)
      for (var j = 0; j < newModulesKeys.length; j++) {
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || []
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]])
      }
    }
  }

  return requiredModules
}

module.exports = function (moduleId, options) {
  options = options || {}
  var sources = {
    main: __webpack_require__.m
  }

  var requiredModules = options.all ? { main: Object.keys(sources) } : getRequiredModules(sources, moduleId)

  var src = ''

  Object.keys(requiredModules).filter(function (m) { return m !== 'main' }).forEach(function (module) {
    var entryModule = 0
    while (requiredModules[module][entryModule]) {
      entryModule++
    }
    requiredModules[module].push(entryModule)
    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'
    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[module][id].toString() }).join(',') + '});\n'
  })

  src = src + '(' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources.main[id].toString() }).join(',') + '})(self);'

  var blob = new window.Blob([src], { type: 'text/javascript' })
  if (options.bare) { return blob }

  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL

  var workerUrl = URL.createObjectURL(blob)
  var worker = new window.Worker(workerUrl)
  worker.objectURL = workerUrl

  return worker
}


/***/ }),
/* 5 */
/***/ (function(module, exports) {

// The low-level RushCore module provides the heart of Rusha,
// a high-speed sha1 implementation working on an Int32Array heap.
// At first glance, the implementation seems complicated, however
// with the SHA1 spec at hand, it is obvious this almost a textbook
// implementation that has a few functions hand-inlined and a few loops
// hand-unrolled.
module.exports = function RushaCore(stdlib$846, foreign$847, heap$848) {
    'use asm';
    var H$849 = new stdlib$846.Int32Array(heap$848);
    function hash$850(k$851, x$852) {
        // k in bytes
        k$851 = k$851 | 0;
        x$852 = x$852 | 0;
        var i$853 = 0, j$854 = 0, y0$855 = 0, z0$856 = 0, y1$857 = 0, z1$858 = 0, y2$859 = 0, z2$860 = 0, y3$861 = 0, z3$862 = 0, y4$863 = 0, z4$864 = 0, t0$865 = 0, t1$866 = 0;
        y0$855 = H$849[x$852 + 320 >> 2] | 0;
        y1$857 = H$849[x$852 + 324 >> 2] | 0;
        y2$859 = H$849[x$852 + 328 >> 2] | 0;
        y3$861 = H$849[x$852 + 332 >> 2] | 0;
        y4$863 = H$849[x$852 + 336 >> 2] | 0;
        for (i$853 = 0; (i$853 | 0) < (k$851 | 0); i$853 = i$853 + 64 | 0) {
            z0$856 = y0$855;
            z1$858 = y1$857;
            z2$860 = y2$859;
            z3$862 = y3$861;
            z4$864 = y4$863;
            for (j$854 = 0; (j$854 | 0) < 64; j$854 = j$854 + 4 | 0) {
                t1$866 = H$849[i$853 + j$854 >> 2] | 0;
                t0$865 = ((y0$855 << 5 | y0$855 >>> 27) + (y1$857 & y2$859 | ~y1$857 & y3$861) | 0) + ((t1$866 + y4$863 | 0) + 1518500249 | 0) | 0;
                y4$863 = y3$861;
                y3$861 = y2$859;
                y2$859 = y1$857 << 30 | y1$857 >>> 2;
                y1$857 = y0$855;
                y0$855 = t0$865;
                H$849[k$851 + j$854 >> 2] = t1$866;
            }
            for (j$854 = k$851 + 64 | 0; (j$854 | 0) < (k$851 + 80 | 0); j$854 = j$854 + 4 | 0) {
                t1$866 = (H$849[j$854 - 12 >> 2] ^ H$849[j$854 - 32 >> 2] ^ H$849[j$854 - 56 >> 2] ^ H$849[j$854 - 64 >> 2]) << 1 | (H$849[j$854 - 12 >> 2] ^ H$849[j$854 - 32 >> 2] ^ H$849[j$854 - 56 >> 2] ^ H$849[j$854 - 64 >> 2]) >>> 31;
                t0$865 = ((y0$855 << 5 | y0$855 >>> 27) + (y1$857 & y2$859 | ~y1$857 & y3$861) | 0) + ((t1$866 + y4$863 | 0) + 1518500249 | 0) | 0;
                y4$863 = y3$861;
                y3$861 = y2$859;
                y2$859 = y1$857 << 30 | y1$857 >>> 2;
                y1$857 = y0$855;
                y0$855 = t0$865;
                H$849[j$854 >> 2] = t1$866;
            }
            for (j$854 = k$851 + 80 | 0; (j$854 | 0) < (k$851 + 160 | 0); j$854 = j$854 + 4 | 0) {
                t1$866 = (H$849[j$854 - 12 >> 2] ^ H$849[j$854 - 32 >> 2] ^ H$849[j$854 - 56 >> 2] ^ H$849[j$854 - 64 >> 2]) << 1 | (H$849[j$854 - 12 >> 2] ^ H$849[j$854 - 32 >> 2] ^ H$849[j$854 - 56 >> 2] ^ H$849[j$854 - 64 >> 2]) >>> 31;
                t0$865 = ((y0$855 << 5 | y0$855 >>> 27) + (y1$857 ^ y2$859 ^ y3$861) | 0) + ((t1$866 + y4$863 | 0) + 1859775393 | 0) | 0;
                y4$863 = y3$861;
                y3$861 = y2$859;
                y2$859 = y1$857 << 30 | y1$857 >>> 2;
                y1$857 = y0$855;
                y0$855 = t0$865;
                H$849[j$854 >> 2] = t1$866;
            }
            for (j$854 = k$851 + 160 | 0; (j$854 | 0) < (k$851 + 240 | 0); j$854 = j$854 + 4 | 0) {
                t1$866 = (H$849[j$854 - 12 >> 2] ^ H$849[j$854 - 32 >> 2] ^ H$849[j$854 - 56 >> 2] ^ H$849[j$854 - 64 >> 2]) << 1 | (H$849[j$854 - 12 >> 2] ^ H$849[j$854 - 32 >> 2] ^ H$849[j$854 - 56 >> 2] ^ H$849[j$854 - 64 >> 2]) >>> 31;
                t0$865 = ((y0$855 << 5 | y0$855 >>> 27) + (y1$857 & y2$859 | y1$857 & y3$861 | y2$859 & y3$861) | 0) + ((t1$866 + y4$863 | 0) - 1894007588 | 0) | 0;
                y4$863 = y3$861;
                y3$861 = y2$859;
                y2$859 = y1$857 << 30 | y1$857 >>> 2;
                y1$857 = y0$855;
                y0$855 = t0$865;
                H$849[j$854 >> 2] = t1$866;
            }
            for (j$854 = k$851 + 240 | 0; (j$854 | 0) < (k$851 + 320 | 0); j$854 = j$854 + 4 | 0) {
                t1$866 = (H$849[j$854 - 12 >> 2] ^ H$849[j$854 - 32 >> 2] ^ H$849[j$854 - 56 >> 2] ^ H$849[j$854 - 64 >> 2]) << 1 | (H$849[j$854 - 12 >> 2] ^ H$849[j$854 - 32 >> 2] ^ H$849[j$854 - 56 >> 2] ^ H$849[j$854 - 64 >> 2]) >>> 31;
                t0$865 = ((y0$855 << 5 | y0$855 >>> 27) + (y1$857 ^ y2$859 ^ y3$861) | 0) + ((t1$866 + y4$863 | 0) - 899497514 | 0) | 0;
                y4$863 = y3$861;
                y3$861 = y2$859;
                y2$859 = y1$857 << 30 | y1$857 >>> 2;
                y1$857 = y0$855;
                y0$855 = t0$865;
                H$849[j$854 >> 2] = t1$866;
            }
            y0$855 = y0$855 + z0$856 | 0;
            y1$857 = y1$857 + z1$858 | 0;
            y2$859 = y2$859 + z2$860 | 0;
            y3$861 = y3$861 + z3$862 | 0;
            y4$863 = y4$863 + z4$864 | 0;
        }
        H$849[x$852 + 320 >> 2] = y0$855;
        H$849[x$852 + 324 >> 2] = y1$857;
        H$849[x$852 + 328 >> 2] = y2$859;
        H$849[x$852 + 332 >> 2] = y3$861;
        H$849[x$852 + 336 >> 2] = y4$863;
    }
    return { hash: hash$850 };
};

/***/ }),
/* 6 */
/***/ (function(module, exports) {

var _this = this;

/* eslint-env commonjs, browser */

var reader = void 0;
if (typeof self !== 'undefined' && typeof self.FileReaderSync !== 'undefined') {
  reader = new self.FileReaderSync();
}

// Convert a binary string and write it to the heap.
// A binary string is expected to only contain char codes < 256.
var convStr = function (str, H8, H32, start, len, off) {
  var i = void 0,
      om = off % 4,
      lm = (len + om) % 4,
      j = len - lm;
  switch (om) {
    case 0:
      H8[off] = str.charCodeAt(start + 3);
    case 1:
      H8[off + 1 - (om << 1) | 0] = str.charCodeAt(start + 2);
    case 2:
      H8[off + 2 - (om << 1) | 0] = str.charCodeAt(start + 1);
    case 3:
      H8[off + 3 - (om << 1) | 0] = str.charCodeAt(start);
  }
  if (len < lm + (4 - om)) {
    return;
  }
  for (i = 4 - om; i < j; i = i + 4 | 0) {
    H32[off + i >> 2] = str.charCodeAt(start + i) << 24 | str.charCodeAt(start + i + 1) << 16 | str.charCodeAt(start + i + 2) << 8 | str.charCodeAt(start + i + 3);
  }
  switch (lm) {
    case 3:
      H8[off + j + 1 | 0] = str.charCodeAt(start + j + 2);
    case 2:
      H8[off + j + 2 | 0] = str.charCodeAt(start + j + 1);
    case 1:
      H8[off + j + 3 | 0] = str.charCodeAt(start + j);
  }
};

// Convert a buffer or array and write it to the heap.
// The buffer or array is expected to only contain elements < 256.
var convBuf = function (buf, H8, H32, start, len, off) {
  var i = void 0,
      om = off % 4,
      lm = (len + om) % 4,
      j = len - lm;
  switch (om) {
    case 0:
      H8[off] = buf[start + 3];
    case 1:
      H8[off + 1 - (om << 1) | 0] = buf[start + 2];
    case 2:
      H8[off + 2 - (om << 1) | 0] = buf[start + 1];
    case 3:
      H8[off + 3 - (om << 1) | 0] = buf[start];
  }
  if (len < lm + (4 - om)) {
    return;
  }
  for (i = 4 - om; i < j; i = i + 4 | 0) {
    H32[off + i >> 2 | 0] = buf[start + i] << 24 | buf[start + i + 1] << 16 | buf[start + i + 2] << 8 | buf[start + i + 3];
  }
  switch (lm) {
    case 3:
      H8[off + j + 1 | 0] = buf[start + j + 2];
    case 2:
      H8[off + j + 2 | 0] = buf[start + j + 1];
    case 1:
      H8[off + j + 3 | 0] = buf[start + j];
  }
};

var convBlob = function (blob, H8, H32, start, len, off) {
  var i = void 0,
      om = off % 4,
      lm = (len + om) % 4,
      j = len - lm;
  var buf = new Uint8Array(reader.readAsArrayBuffer(blob.slice(start, start + len)));
  switch (om) {
    case 0:
      H8[off] = buf[3];
    case 1:
      H8[off + 1 - (om << 1) | 0] = buf[2];
    case 2:
      H8[off + 2 - (om << 1) | 0] = buf[1];
    case 3:
      H8[off + 3 - (om << 1) | 0] = buf[0];
  }
  if (len < lm + (4 - om)) {
    return;
  }
  for (i = 4 - om; i < j; i = i + 4 | 0) {
    H32[off + i >> 2 | 0] = buf[i] << 24 | buf[i + 1] << 16 | buf[i + 2] << 8 | buf[i + 3];
  }
  switch (lm) {
    case 3:
      H8[off + j + 1 | 0] = buf[j + 2];
    case 2:
      H8[off + j + 2 | 0] = buf[j + 1];
    case 1:
      H8[off + j + 3 | 0] = buf[j];
  }
};

module.exports = function (data, H8, H32, start, len, off) {
  if (typeof data === 'string') {
    return convStr(data, H8, H32, start, len, off);
  }
  if (data instanceof Array) {
    return convBuf(data, H8, H32, start, len, off);
  }
  // Safely doing a Buffer check using "this" to avoid Buffer polyfill to be included in the dist
  if (_this && _this.Buffer && _this.Buffer.isBuffer(data)) {
    return convBuf(data, H8, H32, start, len, off);
  }
  if (data instanceof ArrayBuffer) {
    return convBuf(new Uint8Array(data), H8, H32, start, len, off);
  }
  if (data.buffer instanceof ArrayBuffer) {
    return convBuf(new Uint8Array(data.buffer, data.byteOffset, data.byteLength), H8, H32, start, len, off);
  }
  if (data instanceof Blob) {
    return convBlob(data, H8, H32, start, len, off);
  }
  throw new Error('Unsupported data type.');
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint-env commonjs, browser */

var Rusha = __webpack_require__(0);

var _require = __webpack_require__(1),
    toHex = _require.toHex;

var Hash = function () {
  function Hash() {
    _classCallCheck(this, Hash);

    this._rusha = new Rusha();
    this._rusha.resetState();
  }

  Hash.prototype.update = function update(data) {
    this._rusha.append(data);
    return this;
  };

  Hash.prototype.digest = function digest(encoding) {
    var digest = this._rusha.rawEnd().buffer;
    if (!encoding) {
      return digest;
    }
    if (encoding === 'hex') {
      return toHex(digest);
    }
    throw new Error('unsupported digest encoding');
  };

  return Hash;
}();

module.exports = function () {
  return new Hash();
};

/***/ })
/******/ ]);
});

/***/ }),

/***/ "./node_modules/split-on-first/index.js":
/*!**********************************************!*\
  !*** ./node_modules/split-on-first/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = (string, separator) => {
	if (!(typeof string === 'string' && typeof separator === 'string')) {
		throw new TypeError('Expected the arguments to be of type `string`');
	}

	if (separator === '') {
		return [string];
	}

	const separatorIndex = string.indexOf(separator);

	if (separatorIndex === -1) {
		return [string];
	}

	return [
		string.slice(0, separatorIndex),
		string.slice(separatorIndex + separator.length)
	];
};


/***/ }),

/***/ "./node_modules/strict-uri-encode/index.js":
/*!*************************************************!*\
  !*** ./node_modules/strict-uri-encode/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);


/***/ }),

/***/ "./node_modules/uri-js/dist/es5/uri.all.js":
/*!*************************************************!*\
  !*** ./node_modules/uri-js/dist/es5/uri.all.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/** @license URI.js v4.2.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function (global, factory) {
	 true ? factory(exports) :
	undefined;
}(this, (function (exports) { 'use strict';

function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
    }

    if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join('');
    } else {
        return sets[0];
    }
}
function subexp(str) {
    return "(?:" + str + ")";
}
function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
}
function toUpperCase(str) {
    return str.toUpperCase();
}
function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
}
function assign(target, source) {
    var obj = target;
    if (source) {
        for (var key in source) {
            obj[key] = source[key];
        }
    }
    return obj;
}

function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
        CR$ = "[\\x0D]",
        DIGIT$$ = "[0-9]",
        DQUOTE$$ = "[\\x22]",
        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
        //case-insensitive
    LF$$ = "[\\x0A]",
        SP$$ = "[\\x20]",
        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$),
        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"),
        USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"),
        DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$),
        DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + "{1,4}"),
        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
        //                           6( h16 ":" ) ls32
    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
        //                      "::" 5( h16 ":" ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
        //[               h16 ] "::" 4( h16 ":" ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
        //[ *4( h16 ":" ) h16 ] "::"              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
        //[ *5( h16 ":" ) h16 ] "::"              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
        //[ *6( h16 ":" ) h16 ] "::"
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"),
        //RFC 6874
    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$),
        //RFC 6874
    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$),
        //RFC 6874, with relaxed parsing rules
    IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"),
        IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"),
        //RFC 6874
    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"),
        HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$),
        PORT$ = subexp(DIGIT$$ + "*"),
        AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"),
        PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")),
        SEGMENT$ = subexp(PCHAR$ + "*"),
        SEGMENT_NZ$ = subexp(PCHAR$ + "+"),
        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"),
        PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"),
        PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"),
        //simplified
    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
        //simplified
    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
        //simplified
    PATH_EMPTY$ = "(?!" + PCHAR$ + ")",
        PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"),
        FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"),
        HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$),
        RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$),
        ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"),
        GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$",
        SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
    return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
    };
}
var URI_PROTOCOL = buildExps(false);

var IRI_PROTOCOL = buildExps(true);

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/** Highest positive signed 32-bit float value */

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'

/** Regular expressions */
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error$1(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	var result = [];
	var length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	var parts = string.split('@');
	var result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\x2E');
	var labels = string.split('.');
	var encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			var extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) {
				// Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
var ucs2encode = function ucs2encode(array) {
	return String.fromCodePoint.apply(String, toConsumableArray(array));
};

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
var basicToDigit = function basicToDigit(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
var digitToBasic = function digitToBasic(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
var adapt = function adapt(delta, numPoints, firstTime) {
	var k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
var decode = function decode(input) {
	// Don't use UCS-2.
	var output = [];
	var inputLength = input.length;
	var i = 0;
	var n = initialN;
	var bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	var basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (var j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error$1('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		var oldi = i;
		for (var w = 1, k = base;; /* no condition */k += base) {

			if (index >= inputLength) {
				error$1('invalid-input');
			}

			var digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error$1('overflow');
			}

			i += digit * w;
			var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

			if (digit < t) {
				break;
			}

			var baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error$1('overflow');
			}

			w *= baseMinusT;
		}

		var out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error$1('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);
	}

	return String.fromCodePoint.apply(String, output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
var encode = function encode(input) {
	var output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	var inputLength = input.length;

	// Initialize the state.
	var n = initialN;
	var delta = 0;
	var bias = initialBias;

	// Handle the basic code points.
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _currentValue2 = _step.value;

			if (_currentValue2 < 0x80) {
				output.push(stringFromCharCode(_currentValue2));
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var basicLength = output.length;
	var handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		var m = maxInt;
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var currentValue = _step2.value;

				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		var handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error$1('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _currentValue = _step3.value;

				if (_currentValue < n && ++delta > maxInt) {
					error$1('overflow');
				}
				if (_currentValue == n) {
					// Represent delta as a generalized variable-length integer.
					var q = delta;
					for (var k = base;; /* no condition */k += base) {
						var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						var qMinusT = q - t;
						var baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}

		++delta;
		++n;
	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
var toUnicode = function toUnicode(input) {
	return mapDomain(input, function (string) {
		return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
var toASCII = function toASCII(input) {
	return mapDomain(input, function (string) {
		return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
var punycode = {
	/**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */
	'version': '2.1.0',
	/**
  * An object of methods to convert from JavaScript's internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode
  * @type Object
  */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */
/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */
var SCHEMES = {};
function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
}
function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;
    while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
        } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
                newStr += str.substr(i, 6);
            }
            i += 6;
        } else if (c >= 224) {
            if (il - i >= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16);
                var c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
                newStr += str.substr(i, 9);
            }
            i += 9;
        } else {
            newStr += str.substr(i, 3);
            i += 3;
        }
    }
    return newStr;
}
function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }
    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
}

function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
}
function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
        return host;
    }
}
function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
            last = _address$toLowerCase$2[0],
            first = _address$toLowerCase$2[1];

        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
        }
        if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function (acc, field, index) {
            if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                    lastLongest.length++;
                } else {
                    acc.push({ index: index, length: 1 });
                }
            }
            return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function (a, b) {
            return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
            newHost = fields.join(":");
        }
        if (zone) {
            newHost += "%" + zone;
        }
        return newHost;
    } else {
        return host;
    }
}
var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);
    if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
            //store each component
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            //fix port number
            if (isNaN(components.port)) {
                components.port = matches[5];
            }
        } else {
            //IE FIX for improper RegExp matching
            //store each component
            components.scheme = matches[1] || undefined;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
            //fix port number
            if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
            }
        }
        if (components.host) {
            //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        //determine reference type
        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
            components.reference = "same-document";
        } else if (components.scheme === undefined) {
            components.reference = "relative";
        } else if (components.fragment === undefined) {
            components.reference = "absolute";
        } else {
            components.reference = "uri";
        }
        //check for reference errors
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //check if scheme can't handle IRIs
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            //if host component is a domain name
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
            }
            //convert IRI -> URI
            _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
            //normalize encodings
            _normalizeComponentEncoding(components, protocol);
        }
        //perform scheme specific parsing
        if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
        }
    } else {
        components.error = components.error || "URI can not be parsed.";
    }
    return components;
}

function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
    }
    if (components.host !== undefined) {
        //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
    }
    if (typeof components.port === "number") {
        uriTokens.push(":");
        uriTokens.push(components.port.toString(10));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
}

var RDS1 = /^\.\.?\//;
var RDS2 = /^\/\.(\/|$)/;
var RDS3 = /^\/\.\.(\/|$)/;
var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
function removeDotSegments(input) {
    var output = [];
    while (input.length) {
        if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
        } else if (input === "." || input === "..") {
            input = "";
        } else {
            var im = input.match(RDS5);
            if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
            } else {
                throw new Error("Unexpected dot segment condition");
            }
        }
    }
    return output.join("");
}

function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    //find scheme handler
    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
    //perform scheme specific serialization
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
    if (components.host) {
        //if host component is an IPv6 address
        if (protocol.IPV6ADDRESS.test(components.host)) {}
        //TODO: normalize IPv6 address as per RFC 5952

        //if host component is a domain name
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                //convert IDN via punycode
                try {
                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
            }
    }
    //normalize encoding
    _normalizeComponentEncoding(components, protocol);
    if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
    }
    var authority = _recomposeAuthority(components, options);
    if (authority !== undefined) {
        if (options.reference !== "suffix") {
            uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
        }
    }
    if (components.path !== undefined) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined) {
            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
        }
        uriTokens.push(s);
    }
    if (components.query !== undefined) {
        uriTokens.push("?");
        uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
    }
    return uriTokens.join(""); //merge tokens into a string
}

function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];

    var target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, options), options); //normalize base components
        relative = parse(serialize(relative, options), options); //normalize relative components
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
    } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (!relative.path) {
                target.path = base.path;
                if (relative.query !== undefined) {
                    target.query = relative.query;
                } else {
                    target.query = base.query;
                }
            } else {
                if (relative.path.charAt(0) === "/") {
                    target.path = removeDotSegments(relative.path);
                } else {
                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                        target.path = "/" + relative.path;
                    } else if (!base.path) {
                        target.path = relative.path;
                    } else {
                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
            }
            //target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
        }
        target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
}

function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({ scheme: 'null' }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
}

function normalize(uri, options) {
    if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
        uri = parse(serialize(uri, options), options);
    }
    return uri;
}

function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
    }
    if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
    }
    return uriA === uriB;
}

function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
}

function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
}

var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
        //report missing host
        if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
    },
    serialize: function serialize(components, options) {
        //normalize the default port
        if (components.port === (String(components.scheme).toLowerCase() !== "https" ? 80 : 443) || components.port === "") {
            components.port = undefined;
        }
        //normalize the empty path
        if (!components.path) {
            components.path = "/";
        }
        //NOTE: We do not parse query strings for HTTP URIs
        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
        //and not the HTTP spec.
        return components;
    }
};

var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
};

var O = {};
var isIRI = true;
//RFC 3986
var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
//const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
//const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
//const VCHAR$$ = "[\\x21-\\x7E]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
//const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
//const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
var UNRESERVED = new RegExp(UNRESERVED$$, "g");
var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
var NOT_HFVALUE = NOT_HFNAME;
function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
}
var handler$2 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = undefined;
        if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split("=");
                switch (hfield[0]) {
                    case "to":
                        var toAddrs = hfield[1].split(",");
                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                            to.push(toAddrs[_x]);
                        }
                        break;
                    case "subject":
                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
                        break;
                    case "body":
                        mailtoComponents.body = unescapeComponent(hfield[1], options);
                        break;
                    default:
                        unknownHeaders = true;
                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                        break;
                }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
        }
        mailtoComponents.query = undefined;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
            } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
        }
        return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                //convert IDN via punycode
                try {
                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e) {
                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
                to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
            if (headers[name] !== O[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
        }
        if (fields.length) {
            components.query = fields.join("&");
        }
        return components;
    }
};

var URN_PARSE = /^([^\:]+)\:(.*)/;
//RFC 2141
var handler$3 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = undefined;
            if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
            }
        } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
    }
};

var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
//RFC 4122
var handler$4 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = undefined;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
        var urnComponents = uuidComponents;
        //normalize UUID
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
    }
};

SCHEMES[handler.scheme] = handler;
SCHEMES[handler$1.scheme] = handler$1;
SCHEMES[handler$2.scheme] = handler$2;
SCHEMES[handler$3.scheme] = handler$3;
SCHEMES[handler$4.scheme] = handler$4;

exports.SCHEMES = SCHEMES;
exports.pctEncChar = pctEncChar;
exports.pctDecChars = pctDecChars;
exports.parse = parse;
exports.removeDotSegments = removeDotSegments;
exports.serialize = serialize;
exports.resolveComponents = resolveComponents;
exports.resolve = resolve;
exports.normalize = normalize;
exports.equal = equal;
exports.escapeComponent = escapeComponent;
exports.unescapeComponent = unescapeComponent;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=uri.all.js.map


/***/ }),

/***/ "./node_modules/whatwg-fetch/fetch.js":
/*!********************************************!*\
  !*** ./node_modules/whatwg-fetch/fetch.js ***!
  \********************************************/
/*! exports provided: Headers, Request, Response, DOMException, fetch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Headers", function() { return Headers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Request", function() { return Request; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Response", function() { return Response; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOMException", function() { return DOMException; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetch", function() { return fetch; });
var support = {
  searchParams: 'URLSearchParams' in self,
  iterable: 'Symbol' in self && 'iterator' in Symbol,
  blob:
    'FileReader' in self &&
    'Blob' in self &&
    (function() {
      try {
        new Blob()
        return true
      } catch (e) {
        return false
      }
    })(),
  formData: 'FormData' in self,
  arrayBuffer: 'ArrayBuffer' in self
}

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj)
}

if (support.arrayBuffer) {
  var viewClasses = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]'
  ]

  var isArrayBufferView =
    ArrayBuffer.isView ||
    function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name)
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
    throw new TypeError('Invalid character in header field name')
  }
  return name.toLowerCase()
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value)
  }
  return value
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift()
      return {done: value === undefined, value: value}
    }
  }

  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator
    }
  }

  return iterator
}

function Headers(headers) {
  this.map = {}

  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value)
    }, this)
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      this.append(header[0], header[1])
    }, this)
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name])
    }, this)
  }
}

Headers.prototype.append = function(name, value) {
  name = normalizeName(name)
  value = normalizeValue(value)
  var oldValue = this.map[name]
  this.map[name] = oldValue ? oldValue + ', ' + value : value
}

Headers.prototype['delete'] = function(name) {
  delete this.map[normalizeName(name)]
}

Headers.prototype.get = function(name) {
  name = normalizeName(name)
  return this.has(name) ? this.map[name] : null
}

Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name))
}

Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value)
}

Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this)
    }
  }
}

Headers.prototype.keys = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push(name)
  })
  return iteratorFor(items)
}

Headers.prototype.values = function() {
  var items = []
  this.forEach(function(value) {
    items.push(value)
  })
  return iteratorFor(items)
}

Headers.prototype.entries = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push([name, value])
  })
  return iteratorFor(items)
}

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'))
  }
  body.bodyUsed = true
}

function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result)
    }
    reader.onerror = function() {
      reject(reader.error)
    }
  })
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsArrayBuffer(blob)
  return promise
}

function readBlobAsText(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsText(blob)
  return promise
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf)
  var chars = new Array(view.length)

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i])
  }
  return chars.join('')
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0)
  } else {
    var view = new Uint8Array(buf.byteLength)
    view.set(new Uint8Array(buf))
    return view.buffer
  }
}

function Body() {
  this.bodyUsed = false

  this._initBody = function(body) {
    this._bodyInit = body
    if (!body) {
      this._bodyText = ''
    } else if (typeof body === 'string') {
      this._bodyText = body
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString()
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer)
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer])
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body)
    } else {
      this._bodyText = body = Object.prototype.toString.call(body)
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8')
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type)
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
      }
    }
  }

  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob')
      } else {
        return Promise.resolve(new Blob([this._bodyText]))
      }
    }

    this.arrayBuffer = function() {
      if (this._bodyArrayBuffer) {
        return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
      } else {
        return this.blob().then(readBlobAsArrayBuffer)
      }
    }
  }

  this.text = function() {
    var rejected = consumed(this)
    if (rejected) {
      return rejected
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob)
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text')
    } else {
      return Promise.resolve(this._bodyText)
    }
  }

  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode)
    }
  }

  this.json = function() {
    return this.text().then(JSON.parse)
  }

  return this
}

// HTTP methods whose capitalization should be normalized
var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

function normalizeMethod(method) {
  var upcased = method.toUpperCase()
  return methods.indexOf(upcased) > -1 ? upcased : method
}

function Request(input, options) {
  options = options || {}
  var body = options.body

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read')
    }
    this.url = input.url
    this.credentials = input.credentials
    if (!options.headers) {
      this.headers = new Headers(input.headers)
    }
    this.method = input.method
    this.mode = input.mode
    this.signal = input.signal
    if (!body && input._bodyInit != null) {
      body = input._bodyInit
      input.bodyUsed = true
    }
  } else {
    this.url = String(input)
  }

  this.credentials = options.credentials || this.credentials || 'same-origin'
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers)
  }
  this.method = normalizeMethod(options.method || this.method || 'GET')
  this.mode = options.mode || this.mode || null
  this.signal = options.signal || this.signal
  this.referrer = null

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests')
  }
  this._initBody(body)
}

Request.prototype.clone = function() {
  return new Request(this, {body: this._bodyInit})
}

function decode(body) {
  var form = new FormData()
  body
    .trim()
    .split('&')
    .forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
  return form
}

function parseHeaders(rawHeaders) {
  var headers = new Headers()
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
  preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
    var parts = line.split(':')
    var key = parts.shift().trim()
    if (key) {
      var value = parts.join(':').trim()
      headers.append(key, value)
    }
  })
  return headers
}

Body.call(Request.prototype)

function Response(bodyInit, options) {
  if (!options) {
    options = {}
  }

  this.type = 'default'
  this.status = options.status === undefined ? 200 : options.status
  this.ok = this.status >= 200 && this.status < 300
  this.statusText = 'statusText' in options ? options.statusText : 'OK'
  this.headers = new Headers(options.headers)
  this.url = options.url || ''
  this._initBody(bodyInit)
}

Body.call(Response.prototype)

Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  })
}

Response.error = function() {
  var response = new Response(null, {status: 0, statusText: ''})
  response.type = 'error'
  return response
}

var redirectStatuses = [301, 302, 303, 307, 308]

Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code')
  }

  return new Response(null, {status: status, headers: {location: url}})
}

var DOMException = self.DOMException
try {
  new DOMException()
} catch (err) {
  DOMException = function(message, name) {
    this.message = message
    this.name = name
    var error = Error(message)
    this.stack = error.stack
  }
  DOMException.prototype = Object.create(Error.prototype)
  DOMException.prototype.constructor = DOMException
}

function fetch(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init)

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'))
    }

    var xhr = new XMLHttpRequest()

    function abortXhr() {
      xhr.abort()
    }

    xhr.onload = function() {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      }
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
      var body = 'response' in xhr ? xhr.response : xhr.responseText
      resolve(new Response(body, options))
    }

    xhr.onerror = function() {
      reject(new TypeError('Network request failed'))
    }

    xhr.ontimeout = function() {
      reject(new TypeError('Network request failed'))
    }

    xhr.onabort = function() {
      reject(new DOMException('Aborted', 'AbortError'))
    }

    xhr.open(request.method, request.url, true)

    if (request.credentials === 'include') {
      xhr.withCredentials = true
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false
    }

    if ('responseType' in xhr && support.blob) {
      xhr.responseType = 'blob'
    }

    request.headers.forEach(function(value, name) {
      xhr.setRequestHeader(name, value)
    })

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr)

      xhr.onreadystatechange = function() {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr)
        }
      }
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
  })
}

fetch.polyfill = true

if (!self.fetch) {
  self.fetch = fetch
  self.Headers = Headers
  self.Request = Request
  self.Response = Response
}


/***/ }),

/***/ "./node_modules/worker-loader/dist/workers/InlineWorker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string

var URL = window.URL || window.webkitURL;

module.exports = function (content, url) {
  try {
    try {
      var blob;

      try {
        // BlobBuilder = Deprecated, but widely implemented
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;

        blob = new BlobBuilder();

        blob.append(content);

        blob = blob.getBlob();
      } catch (e) {
        // The proposed API
        blob = new Blob([content]);
      }

      return new Worker(URL.createObjectURL(blob));
    } catch (e) {
      return new Worker('data:application/javascript,' + encodeURIComponent(content));
    }
  } catch (e) {
    if (!url) {
      throw Error('Inline worker is not supported');
    }

    return new Worker(url);
  }
};

/***/ }),

/***/ "./res_built/atlas sync .*\\.json/":
/*!*****************************************************!*\
  !*** ./res_built/atlas sync nonrecursive .*\.json/ ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./atlas0_10.json": "./res_built/atlas/atlas0_10.json",
	"./atlas0_100.json": "./res_built/atlas/atlas0_100.json",
	"./atlas0_25.json": "./res_built/atlas/atlas0_25.json",
	"./atlas0_50.json": "./res_built/atlas/atlas0_50.json",
	"./atlas0_75.json": "./res_built/atlas/atlas0_75.json"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./res_built/atlas sync .*\\.json/";

/***/ }),

/***/ "./res_built/atlas sync recursive ^\\.\\/.*$":
/*!***************************************!*\
  !*** ./res_built/atlas sync ^\.\/.*$ ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./atlas0_10": "./res_built/atlas/atlas0_10.json",
	"./atlas0_10.json": "./res_built/atlas/atlas0_10.json",
	"./atlas0_10.png": "./res_built/atlas/atlas0_10.png",
	"./atlas0_100": "./res_built/atlas/atlas0_100.json",
	"./atlas0_100.json": "./res_built/atlas/atlas0_100.json",
	"./atlas0_100.png": "./res_built/atlas/atlas0_100.png",
	"./atlas0_25": "./res_built/atlas/atlas0_25.json",
	"./atlas0_25.json": "./res_built/atlas/atlas0_25.json",
	"./atlas0_25.png": "./res_built/atlas/atlas0_25.png",
	"./atlas0_50": "./res_built/atlas/atlas0_50.json",
	"./atlas0_50.json": "./res_built/atlas/atlas0_50.json",
	"./atlas0_50.png": "./res_built/atlas/atlas0_50.png",
	"./atlas0_75": "./res_built/atlas/atlas0_75.json",
	"./atlas0_75.json": "./res_built/atlas/atlas0_75.json",
	"./atlas0_75.png": "./res_built/atlas/atlas0_75.png"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./res_built/atlas sync recursive ^\\.\\/.*$";

/***/ }),

/***/ "./res_built/atlas/atlas0_10.json":
/*!****************************************!*\
  !*** ./res_built/atlas/atlas0_10.json ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (function() {
        return JSON.parse(__webpack_require__(/*! global-compression */ "./src/js/core/lzstring.js").decompressX64("N4IgZgTghgtgpgZxALgATALAChsgQBwgEsAXRAegCM4AbE8sAewgHcoIATAfQAYA6fADsA5imyYsASHDR4KdCAAeKAEw8ALABoQAT1UA2bSxQBGAMzaAFqbMBfTdmkRGJKGQ7ywUGgjgOpICTEMPAeaF4+fo54hKRwAMqMAK4QAMYJRABecPKgysg82noFRjZWNvbRCMlpGdm5IMbI5uXNdtiVWDHEZAhUtPRMrOzcJgIiYlgS0pCwOWh5qiomRQalba3mnU4ubnBhqBG+-tJBRCH7nt7HVbFkiSnp8VnzCvmFuigfTS0g1m3bPA1J4vBo-Cx-CodfzdOJ9ah0BjMNicLgqcaiZDiaKzOQLJSqMwADlWyBUhkaZUhAJOIGcrncV0itLOFwORyiAQIPQSwLqr0WJU+QvBmzstOqj35YKp-y20Nw3Lh-URQxR3DMGMm0xkcwa+RUAFZDaTyetfnLxdF6Xt2ddOadgqEmTcuXdeVLnvV8e9Sd9ZRUJXyvQLKRtqfKsJ1Yb0VYNkSMuOotVipjjZKGDQB2FSmimiiNWgI2xnhe0sp2XMvM248h61EP6r5+80Qy2AyUN0H4gvthVdJWxhHx4aow0p7EBXGZ1TqE3CkwmXNhi2B627UuHcvRVnO6uu6SDj1d71vZvC-3h9tBz3dhS9qFRmFH+EDcg0OBgEi8CdpqcZpsyX0ZdikXZcHxpdcGSrLcawCXcYI5CV3XrEFT0FD5ikvVdIK5YM71ACDI2jF843fT9vzGIRMUnGYAJ9VQswATlJMDWzFQES0Q7d4MrO04MPFD8PQgkhSw9jCw7YTQyI9on0Vd1X0RD8vzRX8dWnQCVCYilQKXCTryg20XQdQI+JM5C62kwDMPPWSpNvET7P7GMKGHcjVM1ajtXTPUGOQMxfj08CA1wnZoP4g8zPOPdYKio9UOlfzbJFUKthvE8ZLSuSSMUsiVO-ZNvNTDT6LPMkiRY4UzRXNs12LDduIE6K2Qs2s4kSxtkpbWqOIytCsqvR9cp5JT6AKrhx2K2jdTxcqzB4XS1l6yTaS4yLTIQjbLI66zuovAz6sPPb72y2wXNI9ziGESxv34aa-zovz5oW1j9JWwyGoitreJipr4qExyZzEuyzv6pLTqGgELryq6iBuyj1N8ubBTMdQszekKofSozNyQndzP3UyEpOjCevs8GushnDiOfWG32u261Ie0rntRlQIWKGqKdx-7NsJuLicBzKbPJsGqlJj7hrp0ayMZ78vImErkeBsx9C0BdF0OsK6Ua7aCb+-W3SsoHRYOqWdc7AaZWxnKZeVOGEaTJH-zZ0TiRWTXPZ5r7jKJitDZ+wSTZF-bxItnG8NNnszph2XHaZqalZmzT-LRlKjW1yPwr9wWA9a-32vuSXfXNn3juj6m6uh+SB1hmgkjgWJBBIMauAKl2npR93DQx6qIXL3XvsL36C7zovj2tsPQdthzQ6rji44dhum+IFu2-lzvZtVrMNa5gfxd9vGeMdQOR+D3bK7JsvD4r+fCNj2vXPhFfm9buMuBIRh8C31P5qYz2+8s5FhzsfZqW0g6uU6gRUSKVsLV2zkCK+Ec7YKXjq-Ne79UhJBIGQCAABaAAjkkKAHBf5lUFESECKAD7ICzBSOUTFOJ60gRAtAQRG47WLsg-IgCZ70M2EwymMCmhZj7ow86T9LoYKIOvcg2DcFwAgOQt2BoeB92KOoWhatBHMOHuPUesUOFCxDlPcqfDUoBQYaYIREtkFNGJLopeQ4ZFyJgLIpR+DUiWCgLIqAlAPwqO7gaIk85ii0JMFVCRa0WHnxarFfGxtL731gWLZoUSbFzzMQ-dJTipH10bm-Po7jBBKKCcDFQc5SSVXNBk9Jejc6JNPmPJpUCS7nnDj8OpkSskQxyZEvJI1l6FMwcUogigyksxVoBEw+glrICqWGMw4jMkxP0a0thqBjFcMnn01JN8AorPqcIpyNCSQRiYc4tyrj374F8S3TxHBkgBLgOUwCRI94oCoesRx1JiQNLAVFTZrSSY8I6TPX5-x-knMGpCs5kihkuJGbI259y8FEJIWQqZrtgk0OqbQsRui1mNJPvEvmOzoEiVLp0lAhKLm9KpjkulEirkv2RXIu5KLJnJ0etvd51CFlVQcec6JvMjbNISaS0FKTqUQpFasuxKThWDPtki1eKK+hcQIakVILA3n+XJOc4oNSVzdNsUfclBsWlSuFtk-ZNLcn0phTbAZ9LWVUBuZqxqyjsVdwqaE0kczalErFawgWILbV7NlZY11oqo5KpsSqtBwz1VyIIDQUg6LUiMBgHc1IJB8GyIAG5KN8Pq8q2kLEmq6SGi14qyX1ulXa6N2EzUMpEYmt1+T0HsvfumzNnjs25qgPm8tgoVBEg0SgLRwanWhricCm1pio3gpjW251MdHUsu7Smop5B+2KJ9Ty1muKySLPCT86xxz50GIlTBbZE9KXAwsZeHRc7412uVV2xF1ze19AQK4VIABrblNFeV-3HRoUk2ijk9OJYC-mZ8tkQE4Y+9pINLHLNrXfT9Zyk11x7am9+QQoAIEsPggDzAoDCFeb6vl-klzzOYj8+cUKiQAstYY+9KGTHJObaoNJZhWPwo3ZDOFAV2PuoCX+8gJGyNjvdjwI1KAg2muw0PEl4Dw1Lr4yujDrb1NWz2TW79qrf1Eb6EkQQHAlHCGcFZ7gw4uBwBbhAHQ+CSBECUeiOjEH3b6BStWztcp2Pwc43eg4D6kncJlau72wXTChcVbhrdmSpOevIA52z9nrNcCcy5oIOgFP5CE58gKs65T6A4-WzZUWL4xf4xhiJ3Squif6W29LMmssQDs8kXL+XFCkA815iAPnj3TLToaeZ6gsaxtMK1m9GyBZ1baWC-TFX5vttOal+pnWLOZes9lvrjmBjOcGyQYrNC6XFGAht5oC261hqQytptem4F3dmVtwac3ds7qHEkIgNAOCyOEG3DuvmKGiXJAKtiKDqtPetc1V7jL7UzxpiApBCbZ5SYB0DkHG94a3UuwFV6mtZsIIx+tBHkqkeRpRy24BX2XUU4RWZ+EuPgciDbl-H+EPVGqCg9VfMt8NMIfzjTgGy76ervgX1ZLxnH4-vZ4DznoP5E4PRcQ0hxPvlC-WAI99oDwsNvkC9unMDeFpIN3GnDCu6GwcuX9tyHP8fq8PcTypYSVPC6sepqnC7ls8Ypehl9l7DOSy-dupXVAXdc-IJYJIlBieczxWGLMwm6EPaNzVwPqHou7Ol80Vi+uM-0KZ5u5ltKsys+Tf9lXruSmDp8X4l5yeTBlaCztuDi3SWLtp1Li3MuPvmttyjkzUe2cx-r3HxvR6wMntViYFKM61OG9F8bvvkvdOF-e6vm3mOUs-Z6Tj6fav3ETLnz5HFFTBc3fOQ4h38OA-PaD2htbu+H-h-sXh0ztfnen76E5QeQISeUT0CT51PVmQFW0XlQkyf1vRNziWR0H3WyWVgOhXlzHx-zYxrwIwdljzVyAM10xWT1YkWn10fzCxzyQwjQHypSHzT0oMwI7Xt3w2finzxzjyINAyvz9RmUqVJHUCFWwIVUe2f0Ry3waze0E1gO7w-Tt3E2Pyd2V04LVy1S8V1WT0CkDR9yPxH3X2oIkN4ykJ3zST0PL2pg62UI4NVy9Wgkv2Vmv0AjMCw2FE73MKoOp2N2QPoNQPH1ENHxYPMJP1UP-XwAzUPS8RzTzQLWLVLVo3GycLTiU2g2H3gKWxoJ0xMJQI-wS2vXkKwK70d2j0oAILCIiKzWiJHQuwgNVhcMEOaz91iQQM32MILxyLMPXWYO22COsNKIAP3XCIHQcJTkhwNHRgaLDzX39xaNzzaKfRmUEyvTkMCO20UOKMn36NCP3UAxAxGPAzGIFzKwAR+SYLENmJfzz3q3aN8NyMOS-yx3WNwPYK2NsNk2gDIwoy-mgBo2J1mS9zoSxiE1aAwPOIyLHjNzoIqUEwz1BNWNhXQMkz6LKPeNI0sGT0NDK1U38PyOzy8MbXN1uM6IeMPysJKJRO616wczy1OwKzc2G28y0IsUaIjCSzBN7zmOD3f2Lz30SwsPazYMugpMOx6xyxOzoGc1cyK1qOcKJBT2QF1xxM+08PEKMVf3zwWOnnK15Pu35J1KUPJIGMpLFJpIlLgHOwZNG2T2u1TyVKzwMPxNN3VOuM1PKjuKP3tKM0KN6MNO2ONOO1NO-HNNIGtKqk0QMwjHtJmPBLVKuNW1iz8LyOVO6O+zJMnxs1KOEHIBHXSHwG+K4AQBoBcB1wFRzHWCvSjOaJjO8MJOBjuIrL1KaAbPdQzKSCzLgAACs4B81mACyiyajEi+D-ImJSysYGyVSLijCuSEz6zWhPSI8VM5znjSIYAoB8AuBGAS0IAi0vMWAP41QRg-ieBRyfkQT0iOTMj+9t8OiDlq4McvSWC7zly8pVz1zNylEdy4A9ynNwdBz6NzEeAwzaUgSzyJzqyCSoSzYHUny2slkzz3VXyNytzPzvzTtN4ZSGNZlSQyy4K-lzytNLzJCbi6zBNQKUybYnyEKiAEBUhyAbMPxPNGBBAuBVyIA9i-jJ03oNYfgPg5QeB8KgVtMrzsiiSDkl9Nh+LYKeKJLnzZZ3EaL91+y8tSEuB2BnA9UMLzFOLNZuLTBeK9KBLEMpy38ZyzD9LmhJLyLN1xKIx+KqKFLCyXAuBhBGBGBuA1LGANK-y-M1ELFFxdKLKZKwKLzjKNT0N3TzKl9Gy9KZL7LaLKMfi4AkKlEaAoBpTvLDj7sAT-LzRYD9DoyQqJd5jwqzC8rormgyq4ryA2AdB8BGAUU-iOZsKQK8LgqCLQqXSSrbyyKCjHz4Koxox4BXBchog1z8B5A-hcF8AEBkByBqqWA9Vs0bMoBrMWA4Ak8h1ZNzSSAUgm4R09iQBaQtyEAiAmKJqxgeBDrohzhqNXgQA3BUqEAeAuAl8tRaQhhVySAJqAAlAAcQACEABBIkEGokK6rkFg9QdRTYCdDsVIbwO6-gEwcGw8Vina-ADgPYCagAEgABVtrdqAAFfapRZAeINGgAVQxr2GQDADgDgCgBHUoCzEqg4CzBMCoTgH0CgE-GNGJH0BMFSEiSYioXt3UFSBUCFuPKX0xKNCoX8UZqJE-FSCEONCXw4FppMENCYgASJA4A5jgG1sNBUHoX0FSH0H1rMH8WNpNqJHNuxpAA6CdqwCAA"));
    })()

/***/ }),

/***/ "./res_built/atlas/atlas0_10.png":
/*!***************************************!*\
  !*** ./res_built/atlas/atlas0_10.png ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./res_built/atlas/atlas0_100.json":
/*!*****************************************!*\
  !*** ./res_built/atlas/atlas0_100.json ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (function() {
        return JSON.parse(__webpack_require__(/*! global-compression */ "./src/js/core/lzstring.js").decompressX64("N4IgZgTghgtgpgZxALgATALAChsgQBwgEsAXRAegCM4AbE8sAewgHcoIATAfQAYA6fADsA5imyYsASHDR4KdCAAeKAIwAOAOwqANCACeqgKw8ALLpaqePXQAtVAJgBsAX23ZpERiShkO8sFA0CHBuUiAkxDDwfmgRAK4h7niEpHAAyoxxEADG6UQAXnDyoMrIKgDMugbI1iAWZVa2Di6h0giZOXmFxXXNTWVOztiuuATEZAhUtPRMrOzcKgIiYlgS0pCwRWglqpo6+ij2JrX1Ko0gdgMtSZ7evv6Bwa3hkdHy8YlhY6kZWblpBS2ClKFSqKBOllqlxUg2e7T+XSBoFOTn6MJcw1CyXGFGodAYzDYnC49iWomQ4iSGzk2yUuxMZgOyHKAE5GadztDYTcvD44DFUAEgp9pBEiFF+e8IAk4SkyL9OgDurSQZUmRCGlDmiMvh1-oCeijHGjBpjRnLcdMCXNieUySs1jJNj0QXswWVHOV2ZCTdcwrc+QKhU8kmKJQKPrKcQr9crgao1dUNWctVcdW09YjDX0LtqzVhsalJniZoT5lwTPaKasqbIkXSyiZyomUBo1IZzD7c2nngH7mhgyKXuK3rFpUPvvLM0r66r3cnOdq4dODbSjb6hlgdYWJlN8bMidxDFXKWFqbOUCyVBp3SpDI5vZqN73ef3BY8h2HR6hI0lJ+kVzjHYyhbGpOyfbt0XTPBAPrddINNLcsX-YsrRoOAwBIXgTxrM86xdSx7H2ao709cCVFBSCKmgvtJQHD9ni-Oif3HKMflggiwKZSjTko6FqOXBEZ2zK4N3zHdLXxdDMK4RYhHJU91nwlVVAqNRb3vNVeLVfjyho19mMHRjXmY38vgtGMsxUriSK01SdPs6D4UVVcFHgrkMSQ80cVQqSMKw0l5IdWtnWsmFDA7bjNPIvjHJfO5DIY0MTIjVi-wsjjrNqWyYocsoBL-TK3JzDzN23FC93oaSsLtILq0dc9OIqDR7A0xxWt6fK8oovT4sDB5hWMkdTLS8zoyK4DsoTXK0QK3UhNc5ESrzLyCwqktyGqiscIa5T40bNQWTajrtNm3qeQSoMkrCJjUpldLxoWoCGymkCZqo875pc573JW8qLV8qr-K4Y86sUp0aX2s4iNvRw1GTWKuv0y6BpDG6Uqle6xvYp6Lxs6bOp6s6nImwnUQQzz-p8yryGIYQbCw-gwdwpTQqhtTYfh97dOR-r6MG5LhruicMtxprQJ4+zicE764OWtNxPWq06YZ2SdpCyHgPCyKSLhhHurmjwDKugX0aFzGRce2XxdvOyuulwqxbXeWoMVgGaZVgL1bwtmtfKFrYY0I7CcRnrebfIzBfDC22KnJ2oYlu2iY+kn46W0SKbK5D3Y2z2uFq5Z6o1vGVBMQ7A+D06U76iPrtFDGxyxtpRetsLE+5uLHdb4qM9Kt3qdzoh6awytmd232GxURweGNbjHA0Weq55mvEtN+vzcby2ce7v3bY7pGZdjOXe7+7OB+VofVdBwvwcasKWol+fF6l6uLr5981+HaPN9jgC08n9uIcDafQzP-X6CtVoSWLDQBIKRBAkEBlwaq3tWaa0npoCW9gTqqUZPxEw4dV5o3Xt-FiTcJKWWEllW82D8q4JwanHeZNZ590getGBcA4EIMqlwT2KCIYlwwe6JOpdZqGAISbIhX9vxmWblbI+TUOokX2LxOh+UxGHysj3dEYlWE53YZwxBJBGD4D4XfKGbpuL+0fNDZ8b9a6f1ujHB6295FhUUeCciPAOqlQ0ZQrR5MWFUyLFQfRxB4GTGyHEEgZAIAAFoACOcQoAcFMXtYCGhyg6xQKySK9QMmphUFecRqNPwN1IVvOOjDSj2FAhqfJaIim+MWp1Be6lIIsnsFnbywTKChKIOE8gkTolwAgKkiepQWqz2qCyIO4EvT7GhI0uxhDSkb3Kb-ChzTqm1LmSYBZqgllfVcT3coahVGFM6f3HpfSBkwH6SM2J2QbBQH6VAXpcAxloJBMYV6FQ4bkTUN4g5PBin80kY4n+zjKnHOAlMjxhNAUNJBU0n6BygVlA6V0taejYFhK4XcwQIzPklybDeJkhgWTJkRe05FyyJGrJITI8hpNShwq4qcalizaVHM0enC5DTLm6IHjc-FRBFBErHsXTiGSsnIApRqL0ZLFkqFBR-cFZSmX-k2c9V085dlKoOSqlFx9TnnMxVc3cvTcX9K4fgF58CHkcEyO84lnFQIsnKMo7JZz+inM6SvelQ1GWjVkS43lL09WdVNb6wFDCYVRp9d2U1WKoEhOtQMu1NqHmJOSa66yMqhHgQ0CYZhaLVWRzNsGshWqWWtkjXkktAq43hryf89pgqgmWpFZMTNDrRmSp9l81QZdZV22je28tdcpErI2bW-G7LvVmv9V3eN9Rx2LI7Wfa56auG0TidkbILA83synrbNtHLg7KsnQ4jVIbmX-2qfW3Yl7DXNr8XyjpTaLW4m7bTAy-ab4s34dKo4bVrHl3aUaulJSg3SLvTWh9hwn1lAg1e41Il+UTu-dAndkwCA0FIDEx5jAYB2uyCQWJ-SABuIzgjHq1o4Qw7jmRsgBW06EsaA0wajnB6tLd42lFeuB9juxl08vfYTT9WGhXbo4XivD+ACPDP3SRsjJB6OT3aqBQwmgAWRQ42Jo2KMwUMt4xUv+VS61MnA-p0Tb7mmnCkxulNbDcPkHw4RiVgHx5DoaFod0MzK7ZOOA0qD-pjbccrWZ2diHkA1OQ16AphzQGMLXYm5z2G01yZtXh7w2QADWXmFJAbMVrHgag2Xyv1aF696q1mav4+G3V6pquQfs6i5k6Wy2ZatdlgZEQoAIBsLEhARjoDCA+QO1BeNWTEUvJ6uZC2k1nNq6ZkafG5FNcOMHJMi39mdfweh52B2Y34J67+gbQ2NMTNA5Y89aKm1cZM7BmdUKLMCfhbtyT6KLntePphjLMmu1ubiIIDgIzhCeFB9wEsXA4DwIgHoWJJAiAjMCt5qV98ry3h4JkgF3VHB+iM+-CtxDotve1XjWV5MOUE6JzBMBD3pOdp-SDsHEOodg64LD+HEQ9DXd2DCd0OmqU-bLqtl7wsYuWeQGyhkAKxdqD+xhpz3Wges761w6HHPMhc554oUgyPUcQHR8VnzJctPug0BkvTaJxdPbVWtqXFO52yqpbZg6yvjsA7VyznDmvJja4gJD3XMPphw4N+pqbwGwpqCF0yDJND1CK4lzx9b5nKecTZaLu3SujtaNVxizd3TLVxCIDQDg-ThCIOQdH0rk8vFzbKNFIBDtwvGcd5Lpx2NoVbfnZLe2r9xMOZdohP3VAy8V6r4g3hde0mTw5nPLmreh-E-sXVqtGe52URyiv5eK6W2j8plu0v5fK8iEMcYgXKH-NRVMJ4gp3J28k6nRC9ZLvYs7-hRyR-9PnKrqPxcxzkn3P2r0GSiSIxzRSTn3GWySt39iLXsBEwxW5TX1eyi3T2lw+zi0ZC+zySQKRS9x7laS-XV2LBAOn3AOU2v0mVvGvEfGbBfRQNTwwOdx73ez71uzwOyVZEIPz3TnXV9xP1xAoIv3IBsDiEoGv1AjthamQPyRYLJ0wI-xl3sFeiwUQPkPKFQIZ1S1bDbUuFaSAIHlELAIJQeSeXtTeXQmv1LkcB22yRZFyVUFmUgjUDz2g2ezTzYNDV7wk1KDaRInIlcI4w8OHw6x9yL2MJ6VMMmHMIAzN0xyhj2VlUC2CKYPUBZEUOnR8PvRl0CO-xcIyMOiII-R+3NTIInzP0oLuXFQSOCkHTxgLQT3bF2Q90KR0NokDW8O718I4P8IOQSxMHaMpVKITSXWiNPynzEN7SIydUkJsJgN80TmvDmS606zCzQO6NYN6LyOwNegVXWNOU2N0IAJO2WzO0qMoFiPIFmOzSSWgIx0aOlTx24hZCC2QGLQmId1JxyN2IQ3yOQy+MewPwk1bWQN+x6xuLuPqKLmeLCjLglneLWLNROK6MiyUNyIBP2IS3WMKROP-0P3OMB3H2uOqLEL3UeUPVsO0IcJAnuxvz4M8M7x6MhXYMz2sh2QRQNWYP4O+1INJJuL3VsL2WYwomLQBR5I6OyLfwa02wGOZGQ3UClNGL5Mc3KOL2xRMPJLAI82U2I1IygHI0o0EBowgDoyWJLgpQKOQA6WcMZLcM6Iiy8J2LZL6I5P2lentOVLRHhjGPVIFOEPIJ1IUyUyI2yFUyNKjyeOmyamngljOA+PUHOT9J+Nf1vQ2zDQVJtO9LxNTNBJHyL0DJLxEJDPc0U081hNvnnxBBnjpPFIYN4JpRlIzK31iy4MKOZCbK5X9MXWLK1JiLLNGyNMKyrJKxrMsETWqDbHtK9BGKdI71+NlPg0awVMKSGPnN7OJKEJLODOmLAMu2G1G2YCgAm2kOx0sXXKjXsCYOTTTJvXqxXPlK2WyQOLmRvNOy3MEIO0mNLP3MmEPOvw6V+XKAZMiPxJbMfMzL8JfP73IkLwgrVKZxJKDKqP-PICDxD2h253D150RyNzR1sKDibxhB4FzP2ynnUWZKXNbKwL7zJWqHsDJQ5QosYy3PAoqMFLLMws5zDzoDhwR350tLjIq1tglIRQopMA0Egs3zooVIYpQGGIBUkukqQqLOZ1QrJPQp4tDxwv4rgEjwIpN1sLj2Y3cPAzF1UuovTKgrbJlwUoXRQ0svYoQs4s0puJ0uwv11IFsLhjZTvHsHIrtysuf3Xyd3+NXNgocqpRUpco1N-MmHB2uOEHICNNyHwDGy4AQBoC8F8tx2oQ9XAmMH6AfBkvJ3ZLnWiqKtTFKrUofBKsuPHySriBSrgAACs4ByNmAsqcrozEj4SoZp5-L7waFiruxarrKHzZKVDsCqrOoxrLgJrwjj56rxrGrUKYAoB8AuBGAzSqNUcWBuEDx5hpDDAJYNAvFwJbtLhyhDMQB0SXTMSIrnydVFLkNrrsk7rCSwTPrfVNTU1NrtrdqRl9q4BDrYda8YyY9kjmwAs7wrrkCkCyrlCKrYshMEb+gka1Lbq-qEryBAadq9qDruFZ8ob68QQmx3UpKMbuwsbJqN9yr3S51cC3rOoCDaawiUszicak1-qKo7kEBshyBwd0IUdGBBAuBNqIBRzr8nAHLrxLrOpOUUBON6bwq3S9j6KrdwJlbkBVblqRIWRS1bTj9dz8aiBBb3NerudkkuB2BPAj1hLrI5bbwLqaFdb9atiMS-iNbsStaE8db0VPbTiiSjb+gja8aBahbsqvAuBhBGBGBuB7bGBHayaJyUNzrFb6hl9LgI77yGaUambYsbSNQc7Lw-9SZ6gw7uwI7Mso73MxtTy4BCaRkaAoAhK07YDFTuI3bgjjaKtkasTIrXru7qhrEF5+gB61L1BUxRi66Laha2A9B8BGAbUTL5dyVbt6gPrmQ7qHqWTXT39UaZcWbHKd7bqvz0UL7hhtx4BvBigkgtr8B5ALhol8AEBkByByAWAf6+AIzwcoAwcWA4ApCIyYByAyBFASAsgOERyRkQBngzSEAiBxaX7FgeAEGkhxQm6X6fA26EAeBZIrB7RnhZhNqSAX6AAlAAcQACEABBdw9wzBr4QswpGZX0ngAk7IQIIEEAFQFhtoKW6B-ADgPkF+gAEgABUDLoGIA4AAAFOBiAZANIYRgAVVEb5GQDADgDgCgCNMoDbBZA4C0EBTgEcCgAwgilOUcBUGyHYcBU+OLWyHsAccbzIpMECsBTeQMbUAwmyBMCcMMDOA4B0bvHePUA4BqTgApSYwXkcGyEcGifKDeSYyYrUCSYkZAGGFyawCAA"));
    })()

/***/ }),

/***/ "./res_built/atlas/atlas0_100.png":
/*!****************************************!*\
  !*** ./res_built/atlas/atlas0_100.png ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./res_built/atlas/atlas0_25.json":
/*!****************************************!*\
  !*** ./res_built/atlas/atlas0_25.json ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (function() {
        return JSON.parse(__webpack_require__(/*! global-compression */ "./src/js/core/lzstring.js").decompressX64("N4IgZgTghgtgpgZxALgATALAChsgQBwgEsAXRAegCM4AbE8sAewgHcoIATAfQAYA6fADsA5imyYsASHDR4KdCAAeKACwB2AJwAaEAE8UARh4BmHSxQAmABw6AFimMWAvluzSIjElDId5YKDQIcK5SICTEMPC+aOEArsFueISkcADKjLEQAMZpRABecPKgysgWOvrIPGaWNiD2yI4uiQgZ2bkFRSDmDWV1Ds7YTVhJxGQIVLT0TKzs3AYCImJYEtKQsIVoxaqa5YbG2l01dv1D7p7ecNGo-oEJoeFEkZfycXfSBKNprTmp+RsKJV6FSqh1KtXqjRC72+7X+oG6jmOPScgxCIxS42odAYzDYnC4FgWomQ4kSazkmyU2wOFQMagArNUwUjIYkPF4fH4AkEoWEIlEXhB4ryPil0pkfn9OoDdpUmdYWc4RTDfh1KQjehCBlghuixhNsdM8dxjESlisZOtpZYAGxAhzGAzy8EnXnsi5XG48xIPJ5XV4i5JkcVtVVwqmlWUg7oKvrI5US2GdDWKlE6tGi-VYqa42ZcFRmknLMmycOAqyMvQOKymUGxrWnEDuzloL1vPmPAUxIXtzNfRNh62Rqtyusu+PNFVS9X9VOo3B9zGTHEzfH0wuk0LkssOOmy4w152pt3nFvXbnt31d1AB5pB-uh6cAyxRo9x1mhFoDp-w2fv7W6ouBr0DQcBgCQvAbsWW6lkOxgqLWtL0gcCIghCPCNs2zythevJXthN49oGnwhpKarPqOFS9KhLIYQmj7kb+PRzumC73ku2KgeBXDzEIxKbqssGUiU8GIYYGi1jR750Wyp4EW2eH8gRt6fvepFJsJKAglRTLGGhDgyZ+U6MaCiL-mmgHscB5BcRBhJ8eaJZWppyDqGosoWAYTqmfpDSGWcHLybhPpKf6RF3iRxk7pRL4+bRjZfgx4YpuZ87DEB2Y2WBEGmg5RYWtuQ5uR5KiVlJ6GYXJnrBfcoWCsKEVilFQ7abF5UGQlzUzsxqWselVmZbZ+ZQQVQkUSoNo0pYOxxdJlWBdVtyKZ2ynhapkXfiZJStcO7V+Z1m3JX+DZpXqFCDdlXDrnlAmWhSFFiQ0jq6b5enzR6XJLSFK1hQ161NYdLUeS98X0WRR09SdfVnRx9DEMItgQfwN3QYJzkPe5I7GM9s0VSeC2fd6tU-fVvZqV1FH2rtBmg5OgPdWZUOWZ8sPkPDiM8SNTn3VsyBqN5FTY95e1vfjH04V9xN+qTxEA0lQ5U9RNNzWDGkKClTMZgNy7s3ZXMwejvOPRYGg2iDKuyQTEtE9I+G-WTG3yy5ivm3jdNO+rx0nKdGU60QCM5fraM8xGxiY1Rpuux1Ytngp33S92f3vOT9OU8DuPR+74PJl7yI+9r2K68NKOjYbEb8x5kcZ-tMdBZLtt1YnDty9nzvpyL-l4BTTGM970O+4X-sc9diz5dz0VGJWgs4x372xzVDck03svBt3EYu9XotZ2rPean3zMYlQNDxMkggkLDXC2UHd0T-s+4z8rbuhFhi02x2CeEUnZ3qYOLk7UrflaZGVTrvFiB8szHzgKfc+wEuC62voVFydJHpCyjjXS24tzz13fteFSydHatzTiOABekgHQhAaZPeed+4DUgdAi+JBGD4AQWNXmE1w6qAMGbMcx4MHz2wXbGWjVV4UJlCOaMRxzKq1-p7SG+8tYsyPifYgZ9xhZFiCQMgEAAC0ABHWIUAOAsLLiUAwGgBYoHpGVQwVgVBIhUFYOedc36COXsIh8hDeZTy0kyAwtj7GOOkT+UEZiqEOIsgow+lA6EqJgeozRcAIDGJDiUDQ3jSgqDsaCKwmN6jhNrq-S8jdP7NxER7Lxr5sm5NUIE7eMimJVzyY4-OijonKKIKo8gMAOmJO0VkWwUAOlQGiXAZJ0ULB2llCoMxTJ1ABKcYU5aH88HfzXqYyp3Q5lxnyXU4JmzxzhJaVEmJHSYHdMEIksZcEDCPWmShbY8yCmEyKUvEpK8PE7wjBY0cmzqmuVqcA8poIHHzKORA9pnTumKEuSXceQ4zHfM8sLFAVgDhNIWc8pZuC1r4Jbp8kSGyUVopqQdIF3RGkkrBedE5nT8CDLPr0jgGQRlXJcgeDhDQmQUuQKbDF1sXkfzjv9MpniIw7QkTy7h9ReVBJMuSqVKBeVUsxDSmBdLTm9P0YY1lD19y+KsAcgFAVMFCsXssnFqzRGGEJcgPxhrSWiu6KE0FNDWmqvGOqhlSTYUGxSeJb5BhkJcoVf8vlWCXHFNNZaoF20bXcp2YCx1iqQ2HNdcciFMCsI6KyFkFgOreYmwDUG4F9qnn8qxc40pHz6liptSC7ZRqu4UP2S68B1KM3jCzfmiMpUpoNBubM0tfDK0VsWe4n+wTY3iMHY83ZcqamtsieCqBsTxgEBoKQLRfTGAwDpVkEg2iOkADdElBG7YCIw+5A0zobWGqNrjw1VonVtHx06S2zsTZ8ltt7lVKJXactd+AN0JOzTuvdJBz2cPSdM7hvz7FqDvQvHBq0v59mfRPOtfz1AOq-Qun9abl30PIOuzdMLR63UQRRPx3CqI2kkiirDjaX6Yvjti1DKcY2WJtTkj95CyXJsXWxN1HbiNeCyAAazI-xVGN8Fb+OIRYTG3RUW8abFVFjUs2NPrWQ4bjxLQ2yohvG5pBH23-s6eEKACBbDaIQIw6AwhRk+uDtFFBNprHIArEiGVw6x2aZQ9pq1yAaOvuU5WaVNocM1vld5yLv62nmZgZZ6zkHbVWG+fsZF-zVPMfLaxkd46dMxR+Xh9Fhmc7Zfw22lVInYiCA4Ik4QHg6vcGzFwOAZ8IC6G0SQIgiT7LkZk5Ro2Uz3M3rycYRDAjikrLQ0VnaHn60Tai3s0rlLTM1cS+MFrjXmv1a4G1jr4RdCpaMCF1yY333viY+pvL-n7bvPQ0DEcl6rsQkbYlJNlX0XxfdeQHbEAmsZH24dxQpAet9YgAN6Tpc-W2vpLUCoE1FvjgPFNiNrzZscdFVO4E43qwrfnd99b1W-1EYB0DlrB3JjtbBxB5zsnnaTJHOoLLS2CdlsfaOoRwrq2TtfXjt7HO50Q3Z6G+LsQiA0A4B04QF8r4M+G6HBCspA33MARbZ+t2uf5Ye4VoL-80Fb0-dF3OjQJdS5lyIC+8DFesNDhy1Bm9O65Z1-dnnuKRX4tijpZ3hOIa92oaTygkvpey4YUw1L6g+1GHo8yKRvmNNmq049orVMJX1ldCLirgfzcbaoKHq3cvyDxK3VqoxduTH+tVzwJTNisllcT3d5PAXU9BfSRKvxDeSXle6s6qrS7zqF-DyXjRWjUuKY5Yp9XPHb2c-vTNi1c32-ccY-7irxmIlCaicP635BbCxEoKlx6Vj9Xd7S-SdHAqU-68465KZZ+kR+Mv732R-f6ihK3-1Vpu-i-nN6f0vSsMqBMfioH2sYJdnBnPk3m7i3nrrzk9kgphqpp9rhsTuLvniHpbiPv-t6oNrDq5jaFkkjnuMCmvvPkhg+ljgQt7rasgdASbqtugamsHr-uMFClJo5L6q5moFPqftkkOlrlbLAchvAZ7nzi+vfm+spoIXxl9pvhbmHnvp6lukyofiAZXnDmHDHiYMGrFlftzs3tGjjgLqFgJnGD5owUTtykqpgWweQCoZqgYhXvgXCkgmknqiEgajltrgvpjkvtjrQd8p3t4QwXIWge-iToPpiPYY4XgTDm4RjFProaCJvhQdNq8lGsvnfuKnoWEU2vxpKoJt-jvtgXvlmn0rmhPq9kjirkLgZjAX4YKkhtkSYcVhKmLgmuEabswSZqwWUcXl2poeMtjPuDaHXr0QYbrknsYbQbkfUV0QUV9p0X0dEQXgMYBsBlulkGBlAPuoeoICehAGesMUVDwDtBASjvBlMe7m4ggfNnWgcghq-kxCsV-jDOsUocXiRiBturunsfTq4dwUVPSFTJcbMlhs8Y0ZQYvuxjQTWustIQ8tslCVYaLvaooUXpsaRvEVwS5nBDaIjgZBMbPo3kISajCf4XCXigiVxkiZ5uQdnt1AoXYRsaJnsZJriWPMCWyiVFkjIT4cIU0TfvcUFsQWYZ5rIUsWgSyf0V8eMMljZnZswFAI5qlhoGCZASiuFsmjcXAR7rMbScFtxjqZKuvsySGrYXKVieQIqRPhoOKU9GzlKa7sKQVqKTkY8SgWvN+j9qyfKf9vVrtsDq1jTkdl1hDv1qlvwUjlqa5FhkqNCRkeatSV7kad8rBsiXkomWiRVm8ZiSPhTntqGXQO1p1idqcWygYI6azhCSyDdkKZSSmYFnfgGh0X8mji8QsasdvlmPYUWSGdTqWXAHTpGVDsfpdrGerlsu9nqaIQaa0UEfQbOV2b6VEb2UPmyQOVTqDqQFHlwqNhMTOcLuSfwhjs2W3q2cuSed0Uwfmfng1iHsIOQHsTkPgPZlwAgDQJ4FHrPoLL4uflwnOVQQEfCfznQfSdWU-pFquYYCGkBb+o+bEM+XAAAFZwD7rMCfnfmAkJE8njR-mWBx5QVxhAXpHnkiniGIFUY2okUf4wVMlv7wVxb54wBQD4BcCMBHFHp9YsCwJGizC-kcp1HKZIgNkUnJnXhZGBFGnzGiVxgfY+kopiXvFARsUcVcWJI8VwB8VtYK5An4kuRgF9oiXKUKXAWRotEyXgVyVmX1CKXNp2UoqqVWTqWcXcW8WwK24GWM4EUcr8HyX2UWWZFWVgWSG2WeYqWwWRXmW-rdIIBZDkANagS9aMCCBcBsUQCcmnbpZjEeYWBUIFXBUXm35tEBryiFU5m3lE4WDn61UuWKLxWJVfmeAHaGJcDsAeB5qVlUa5VYxxkFVIhFXkXX6t6lVLkvYVVDVVXSk9G1VDUqANWHxNXEY4VcDCCMCMDcCdWMDdU+VK6mI8DpImyZmlCFWLUjWGFvLjXpk2qDVxj1XRXzUPWLVxVEAJWiYqmObuWJI0BQAVn7X26mI4wRynWlRDWTaXXTFGGLmyV1qmkWCQ2MWvEI2TZvUfVsC6D4CMCnJR4aB9oBVOWebFVSWhU0k2XcZRXI3ZIqWDC6jwBeBFCJDsX4DyB1CaL4AIDIDkDkAsB818A7ENZQD1YsBwBH47EwC2kjkkCZBQIcmJIgC8hHEIBEBpVs3zA8CK2JCPCqn-AgDeB-UIA8AEgjyiC8jTBsUkBs0ABKAA4gAEIACCBqBqWtn4TB9Ir29QntM1CVAQet-AFg9Ibt7wmVMt+AHAFwbNAAJAACrS2y0AAK8tEAyAqQYdAAqhHRcMgGAHAHAFAHsZQGoKihwPzFYBYHADaFAGBFYgeDaAYFkGYhoBXXzGoCoFkBYE3TwJ5EdSoEHRXcMoXVYGBFkGAVYkYBwLnWruYlYBwIjXAMhKCWoDaDaFkDaPPcYMMqCYplYOvdHSAIMEfVgEAA"));
    })()

/***/ }),

/***/ "./res_built/atlas/atlas0_25.png":
/*!***************************************!*\
  !*** ./res_built/atlas/atlas0_25.png ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./res_built/atlas/atlas0_50.json":
/*!****************************************!*\
  !*** ./res_built/atlas/atlas0_50.json ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (function() {
        return JSON.parse(__webpack_require__(/*! global-compression */ "./src/js/core/lzstring.js").decompressX64("N4IgZgTghgtgpgZxALgATALAChsgQBwgEsAXRAegCM4AbE8sAewgHcoIATAfQAYA6fADsA5imyYsASHDR4KdCAAeKACwBOADQgAnigCMAdgBsAVi0sUJvVoAWKIwGYAvhuzSIjElDId5YKDQIcK5SICTEMPC+aOEArsFueISkcADKjLEQAMZpRABecPKgyshGWrrIPOaW1iB2pc4h0ggZ2bkFRSAWDbb2ztguuATEZAhUtPRMrOzcegIiYlgS0pCwhWjFKA7l+mo8AEzVyFa9DYOhHl4+fgFBTWERUfJxCaHDKemZOan56wolZR0KCqXRqp0c52arW+v063Uc4P6WHOSRGFGodAYzDYnC4+3momQ4kSqzkGyUlgAHDtkHo9odQcdavUIfdLt44NFUP5Aq9pOEiJFOc8IPF7u8yJ82j8OuSATSQd0TnU+pC8ND2n9QPDtiqzgMQqiUmMMZNsTMuA4CYtljI1p0Sno9LqKnpKZSDEdlSzGol2dc0Dy7okBUKuS9xclJRqZVqKaUFV7marxTHYeSdYinAahlH0RMsdNcSprUSliTZHHHUZqUDaZSHIqwXrWX7PByuUG+Q9BU8YqLuxK0mnZf97InGd6U4kWl9NXC+lmc1gjaNxpipjjuCZS8TQqSq-oazS3WpPZPk2c2e2A9zbt3Q33UBGZ3mpTDR5sE3Wm0ys6m51jBcehbJEUSHE0CxoOAwBIXhd3LfdKwdfQeBUE9jDMSdz3qEwDDVf1hUDe97kfIjnwHSM0Xfec5WBGlASVHDLHwgDpXTBRM1A7NkUNCD13oaDYK4OYhEJPcVmQujaVMDCjE0bDTjwgib3IrtSMeciXzeN8R0PSoGK9ZjjlYmc9OAhFuOXVd80xIS4PxMSbQre1pL0NCT0pfZGJYpTTIuVTOxIkNNPDSjX2o8zpJBCofJMvy1VndjP0ZSyfR48C80guyYLgq0nLLW0DxQ5B9m8jCvKMhLryuNTgtCMiwrFCKPiiscDLrOK8OqszAI47VFys3jczRbLBNyrgSwKiS7TJdr9g9CqGSYnqAtqoLeQ03stPCnTIr6lKShi8dFL1ZS2I-OMuPS6z+NNch7K4HdpsQyTXPahwVFrV0Gywlazv89xApuTaQu2prB10g79OO79-twwH1WhizdRu4aVzugtiGEGw4P4F6iqk9qVB4BSfocP7fIBlT1pB4MGtCkVmr21rkekwFYqq6mLtozjBrRzLRoE8hsdxkSEMJ96vzKl19EpNQuuM8621p4jQYZ8Gmch-bkv0jmTvhljEragaQIFvisuF0WHIlly5ulyl0LrN0VF1Q2TJpjs6YfRn+2Z5ood1kr9bhqmEeNtm+bN1Vbst+7rctW2kKl+MFqd109id93lbWr21fp-lfYo-2bJooD2cM07w558uo7SmP0ZssaRaIHG4KmhZCrt-TPqwn6Fa56uVbzu91cLzW-e11mg4rzrB6Nmv+tS1GG8F40rdbsXns7mbiukkmQ9PRXVqB1XR4Lnswy1qjp8u4PK+zxGkrvjN+dXi2hcoGh4mSQQSDGrg9kk5vXtvGQw319AGB4OeJUtZcKUk9redSYMr6TxvtGSOX5YaU2OHAqkEcZ51xXvqRud1v5wF-v-ASXBrbANmj3KBGEDBuypEpBBNUR7II1qg4uU8MGEK-H3SwXo8G4IIS-IhS5SFx3IZQgBJBGD4DoXvD6nkKZemIa2XOSD6rjx4dpAOOsJGCInEqTRvo3gm2XlItea4v4-2IH-MYWRYgkDIBAAAtAAR1iFADgyiiZflliZLOWwjCAnqArRBdUx6XyfAY0uVjHS1AqL+Bw4TThRMXilboDhHaZKMBlD+697EUMcVQlxbi4AQACSnEowS9AqFkoyQwDJImFI4To2JjVr4tX4cYsBKT6ItIMG0lAWTeoCJaWoMZyAomx0-rI8pYwYBEEENUjxWQbBQDWVAL+cBamgMdAYMm+gTDQKODMgp0SNoXx6Wgvpw5MHxmCb+K5eoJmWOed0AeHzCkLJKUstZVDVnrJqQTbuJVwEniMBcxk7z2k3O9ltfRu1DG315kE0x4zZmfKhN88ZETCVFJGoChxwKVlEEUNUw5+l9i-NdPsQwRxDBYURZ0mJdyi4JKHGXJeJQIEdW6Ky652Srq7Fxf86RizyVOPIPgHZf8NkcAyPs2lJVgkGAMKE2kCKJVIvzj7Ce58+FPKmUdbFurZl0n2OIzF0zrUzJJRjGRsqqEKuBRsnxfj1XSWCSw5ADhtWiuHl0rlxqeWBwGfUy1QanbssmQM3J+S-nOqblQIFcqPVKvBTvV69CNUnj0M04Veq5kdNDZyo1PCuHov6fai1P4WVlrxUjKZpbJVprIW6sYhFPFZCyCwX1H1mE0n2OoS5RLy0GpNSip8tbEnPMbakydIavntsJdcgFdjM1UL7cOoJo66yfQUj8qdrbCK3OrfO3Ri7zXDJXfC89Fb11Js3am7d6Jd1jAIDQUg7jNmMBgAqrIJAPFrIAG7VKCAel5jC6yO1PeMtl4yLGn04be+5vD0FmujQ+-QlyUNzLQ22t95at3SrJWUil5Bf3-o2VkIDIGSCwfqfJIt+w3nELUCRy9yKUHxLRXevDgaTyXO4yR5+9qz0UdsV+nttH8B-qqbm8S+aVFYudiYEtkDLwXuBoaudO0S68qSfoIZQrdNrvxRuq1snik7oUwgLwWQADWNKIXJyOSgelh8HDMpGUR-TZ8F1YcjUYhtKBBW-hFamsVwEbX2dJY56jcrwhQAQDYDxznmBQGEAczzID9J0lOcgLVOri3GRtTO0L3KhOmaXfodOwzhVGCq06+Lr87N6mq5+k037yDpcy6xrYR6KgqAnU+6zIA+OGYE1WnDfLDr4cs+RuLibpPvsRX1jNCnYiCA4NU4QHh9vcFNFwOAf8IDaA8SQIg1THJ5slt53VpW9DeVqD84hjsauYbqyZqNkXSonmWqh04P3OtR1+dtyjKW5HkFO0dk7B2uDncu+EbQI3XsnhPeJ04BgTC-e6f901S26Vjs+2DvUBO7W11NtD4lO3Snw8RxAY7GQUdo8UKQW792ICPbU89nu7HnZoUp3M+NKAaccqvUZiGi2zPA6bfCyXZXCeQ-p8+rtrrUtUNZ+z07qOJgXe5yxwrBa3KUgs40haePqfq8rbL+b8vHlk5KgyR9X38cO9fZttbMO5MmliEQGgHA1nCAAUA83GmwEeWdpheeHsZf8e4YJgHEW6fxlhsfbmG3M-XXfsl9EwfQ-h4AbQ6PgT4wkze79RPOd0NhuvcZ0niuQ456Hr7-Pb8SGB6oCXsPIh5GKKx5N10CeLz-kdynvRafW+Ne-J75s6UNfWKGn3ygA+y-kEqQB71-jK91K2AxYNjJ0la+T3N1PLeFcL6dLGjJ62u9L2Tar+ZsPi8h8HxHnfrj3FY-2AJxPCsBgSsyf0bwW2d16RZnrUz2SUtUMD0xfRszI0Sw-Q-yDy-23xsFiEoCx2CU4wDXP1OHSURlm1nSgIeRgNwyBzezSUf3qFINpxfy2BTUYJ+yZy3yH3IFBQY22V2TVUPxezyQswDTUD0x9wgKd2vxd2oLdz9UtXEMyUkNIz9wZ2nU4KwO4N4NU2ci8x7itxPAOEuQkKJ3DVRXTwxTgOP2Vx+VMNXxk3QI3y4J-1WWpV0K7n0PdwZSawC2FVPwTW0UgJkOgLrRoOsLmQQICOJQcIlSSxdU-hcLGGzQAxVVwOgnwJpDPBizLTpD0DMOb1kLCPkPalhhyMdXyNiO63qF6wwP7y0J-xSK9V8QPye0hQUNFyIOiOnUvwoJCKoOKMV1eSODjWmyk270DTYMZzqM3waOSMVX-yEJ7hBx02qJiOnyv1n2CMGIXzKObU7SqLQIDwc0-1L24L7U2UHXwLG3sEmx+SC2QJmwMz6K2KKOEyBwszeQeOYJyS22mOcLmJFlUg8N3ir3qRuLKzuOQ2m3INqwjXq0BwiM+MIzGKsUcOOKL0wLOJ-zoxU0A2AygFA3A0ECgwgBgyWI1XgwqDUCaUuTf0qI2JeLiRv1d0V1hlBwl0yQZOf1+P93+JOKxO-x-SU3o37SY0JLNzaK8LcjUDe2LTih4y5IKLl1CPeIiIILt0iW5JQLUK100OxOFOU0WKlKK0LWdnCRwUQJhOeLhIsPn3vVpGRJGSQJ+PFTWI0JmKSNoxc3cxBPUzBJsNdHSUtO6OCww2J3hMsNgP5XGSiLf0ePGJYPdPfwBINMG2gEy2ywUWgHyyxxKyyPg1aynWq16NtLn1vwdMaQQIYP1UONyKdX1KFPTIyxsGuOCRMChL5J6MZLLO2LVJjI6iXy7NbUTN5PUJTIFPqLTP12RzO2N3R2u15wewANP1dCMD8JxXB14xtL+0jPtJEwaTENmQbFdOAnHKlVTKbJnI5znLoAuyu0xwpL9SpKPA3LmVmW1WVMoOw1ZIXwII5LLU-KqPPO10SMBOvMNy5x5zu2XKfJHVhmLTUBwUApUC-P6J-LkKGMUI-NQuAr1M9PAoOyRxvKNzvLgFNxXOa1pCgR1RQrQteNVIawdOGPhRwtPK6xAp20O032EHIEJJyHwGzK4AQBoE8AAJJgwjhW6HKj1AcFtVLN3LtIrIPMtRksYPkrzyTLkpINtS4rgB4vIDgAACs4BQNmBhLRLJTBd2j5oJL49XYjg1KtgNKgjpCGKBj+zltRNbCfMp05L2Ko5tLZLdK6iYAoB8AuBGBSSIN7sWBqFNwZg8zDDnZgyWVVdi16LmS3imKRMnThV0qEy0SjxTgMqdswqIqorqkYq4A4rzso8TSLcPoVAPdzNH9hUiM9AVDYTFLyzfyHSEKWUOqVDRy3Ti0SqLzJzyrIrorYrqEK8GqY96lmqi1KRLShrMqwsESM8BzrdBqSrhqiqZJxrQL15VkEAshyBDtoI7tGBBAuAwqIBfSACfDHS2rVBZlmqNqSdlKgd-Ujhlq9RPqqivpTgvoTq1wzqLqRLPBUc-EuB2APAh04LpYXqnQ3rkAAb6ggaeyeqWTMK-yaQA1Mb3qArTYQbAaEEyqiBzraNLKuBhBGBGBuAEbGAkaFqAzvLx9KpGRiaMb2EcaIylK+qVKfKMaPr+aeS3TyasbKbQrqaobsy8s4BprqkaAoBHz2aj9JiLNONxd5ZQbcKBbzDer8bKyxNGR9bAbDbJazyQQsbCcqaaa2BtB8BGBgUkrrc8lLSCqvq9yfqkSECfbDjiyLyUR4AvAihEhwr8B5A6g3F8AEBkByByAWBU6+BGNDsoADsWB9L06gNBtyKSBMgKFCTfSQB7hSSEAiBbrY65geBy7EhBQlbY7vA1aEAeAnp8YFh7gpgwqSBY6AAlAAcQACEABBd0d0But4JMlQIAnrBWCW5oLIAIP4EAfgEwae5oB6ou-ADgDkWOgAEgABVC7i6AAFUu6pZAVIHegAVT3o5GQDADgDgCgEJMoAMHlg4AMDdH2DgCMCgBghMBMDyXXKyBKy8jK21SyH2AgYOHcg7P2BMC8j2XfspBgiyHUBAfcg4Gfs6tlLdA4H2AcDgBMCQsAPCSyCMGIYcD2RMDKi-uocPpAAGDYawCAA"));
    })()

/***/ }),

/***/ "./res_built/atlas/atlas0_50.png":
/*!***************************************!*\
  !*** ./res_built/atlas/atlas0_50.png ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./res_built/atlas/atlas0_75.json":
/*!****************************************!*\
  !*** ./res_built/atlas/atlas0_75.json ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (function() {
        return JSON.parse(__webpack_require__(/*! global-compression */ "./src/js/core/lzstring.js").decompressX64("N4IgZgTghgtgpgZxALgATALAChsgQBwgEsAXRAegCM4AbE8sAewgHcoIATAfQAYA6fADsA5imyYsASHDR4KdCAAeKAIwBOAMwA2ADQgAnqoCsKvSxQB2C3oAWKNUYC+O7NIiMSUMh3lgoNBDgXKRASYhh4HzQwgFcg1zxCUjgAZUYYiABjVKIALzh5UGVkNT1DZB4zS2sQOxKnYOkEdKyc-MKQc3rbeydsZ1wCYjIEKlp6JlZ2bhUBETEsCWlIWAK0ItVNXQMUACYjSs7qnvqBkPdPb19-QMbQ8Mj5WPiQoeS0jOyUvLWFYtKdhUqsgrCcHGcmi0vj8Ol0HGC+lgzolhhRqHQGMw2JwuLs5qJkOIEis5OslKotDxDuULDwABzA0G1XoQkAXLxwKKoPwBF7SMJECKcp4QOJ3N5kD6tb7tMn-MooQ5dJl1cHiqFtX6gOFGBGOfrBFHJUboiZY6ZcDT4hZLGSrDrFFRGAAszoVyDp9MZNVVDQS7KuaB5twSAqFXOe4qSko1Mq15JK7qVx2Zp3Vn01sN6eoNg2jaPGmKmOOd1sJi2Jsnjjq0+3dnpqyp9LLuAeFQZufPugse0VFXYlqVjMLl9iT3r16elI4UOpzSMNg5Nhcm2O4RjLRJCJOrxld7rUPEbKd9rLbXODXbDvdQkYSg6l0NlfzHgOTIObafvw+f2uzqfBXMsCNEYxgxGg4DAEheE3CttyrB0KU9d0jE0YE6W2OoMLPDwOQvTs7mvdtb37KNUUfTNRyBQEAS6DCTmwqcn3jOcAMRZElzA+gIKgrhZiEAkt2WBCqJUKxqRQVDdnQzCUEY-1cMDbkCNDB5iLvV58wouNEOo8paLk2SPS0VlmgzHSyVY08gJAgtwMg6C8QEm1K3tUSMIk5ApJkhiTNbRTiMvQi1IjUj7y0n9dz0186KM+TXkirNujY-UFzzVFl3s3irWc8tbR3XSVC0OlTEBYqNB81N4rcAL8N5YKe3UsLNPIxKqM8gzjN80y2tnf9rLS4DONNcgeOg0tcqEu1SRfZAxIsUrymK6Sji6qq-IUy5ApUkIiNCsVwta8yZw2aLE1W+j1p647f1W+EUps4bCzGrgN0muDhLc2aVAwxaUGWyqsI285auuerVMa-aBwim6oo6wHDOu6dbqsllHvzTL6GIYQbGg-h3vykTvtpbYaQsCqLri4Gaq2uqQ12kKRQOlr3l606AX0hHjKR5ikvugaOIxrjyGx3G+NgwmvtOsS1FJ6oVti7r-NpsH6f5Rm+2ZpoYeRqKOZiwyle-WG+d1B7BtszGRaIHHHIl1yZululLrJhXDau5W8NVq8NZIrXbO0k6E3187FY943ddN+dBYy4XRegnL5jyh2orEor6y0Cmw6BnCVY7cGGchpnoaOyOqJDzrLpzpjKL65KBcXIWRvjrgJqTqaCvcng5eMt21urzavfztXu3DYuyNZk3y4PLnqrwNm7rNhv0uNOObbFt724+6bU7pWWM77qvEc9pSgohsfNZLyey9mivZ+p+ep7r-m0Yt4aaDiJJBBITGuDG+34JSwTOoXYbpAQaGdJXT8dILC5yHspAu6si6XwnjGJ+p1PIMgutA2BNcLLPyXq-GOq9KAfzgF-H+XEuDxwAZ9R2wDaxm30t3dCOC4Gnx2kgi+fsr5oJvqdLB5QsF0TYXgoOqNTjo1jqQz+xBv6-xIIwfAtCd6FRMDUGkPBOoWABKeE+21EGjxvBpbWpdeZUUEYqRkuiWwR3MQQ6OjdpFkIoaMTIMQSBkAgAAWgAI4xCgBwFRndZoU3KEYIw2wuguiwXUFQrp2EGJHntceh1r72Olhoqxq0YknHic6Hmtc-xeQsEZfJqViGgRkeQuRlD3GeLgBAYJRNpbOhUH9OaBxgT7DKQk-RdMfbIJ4agoc6DgFZOol0HpeS+l2KKatXYzsZkFKkSQlxtTRgwCIIIRp3jMg2CgNsqApC4DNKAY6CwdIwHlF2GoTqKhtAzI0IkgZDVuEmIDgvYoTDsldAeb055YiUaqH3KmcpqyqnrO2ZQrZOymkExTmo0F5RXRRNUI8sFzpAWDw4YYlJKC0l8IyQmH5kz0UAsKfg4p+TlkVKcWs2R0LNlEEUI0s59CawLXdE6UqUytClTibMkGecEHJN9h8h8Xz0XjgWfy2lQKWJ7CWZilZb8m5QvkeQfAhzv67I4OkE57KooRNJbczqizYlKtwTipJgz3nNVMek+ZxRPLvgtScRZ1qEpjKmcquoFq6Ur0hYyzV2roW7P8YEo1ukTXuizpJSk8qbWvPPsYh1nyxnfJldExNKrKXiMkqU2lEK0QasoWG3V8Kt6Sw5aodpIcnRur9SCgp-TvZvJvGfFmRLnXZPKE2y1c0hWQh9Uqwd4K1XOJDZQtsPjMiZBYNG0SGg1ATNdGbP5WKk3CvgV2rhab-aSszaobNIKKaCtbXMqlq0aV5pLSaMtoxZ1Lu+vSa5kk1BgM3eeltLz22pqaoenWxLHSnqHT+odl7vX8JvaCi9gahrqunaMAgNBSBeL2YwGA2rMgkG8dsgAbo0wIL7pZHg6RYZ0fd4krTiRoOkf7h52oPbw0ZMGXXumo1RvJ9H83Asg8WydDKalMvIKh9DuzMhYZwyQUjwDdhiXdJR6jK6eMMbbUxjtgHWOB1ulmwEKmbFzV4wqpKt74P3qoI+sT+A0MNKrYJbeITpb1s42oYRexInbppruzhRjtMjN06nCZbqvN5tM5ZMdgnKmluQ2JzwmQADWbKEWANrV5CJKFDzdLleF5N-7C72qA2Y3txmwO7Fy-BiLdd3V3qE8GkTmqwhQAQDYbxCBFHQGEKc1LdCopXImWa7pXTUwBo06K5jAXCVsZA3sDpoXDj+udnxxVyBatLYY5Z6prjyDNda3Jx0KgeAdNRcCczv7xt7v8ym7tM3SuurO3Bi7V6C0CbqzFh9cWYiCA4I04Q7hvvcFNFwOA38ID6G8SQIgjSnLVsRRYjQpLnYbvReO-YjGJtaahoFqVyB31zXufRvJ6PqvUqe5BhDlsrNfZ+39gHP2uDA9B2EfQB3VAVY6c7L9qO8kqF2Bjq7+LhnTaC7pfHGgVPjr5ytsz5OJ0fep41yhgO6fpAZ0zxQpBIfQ4gLDxzNbU7tMsR6K5Z3VNgul5dvzQuJXAdK-j98DyjPtP56T2DYCLP1di0r0YKuID-bV0D8YIPNeyd66o5dq6svxuM1L13+XNMAexyL3HDuzdx5l5Ft7nuFeUBiEQGgHBtnCF-v-cPzmGHIUBKhGPR9uZW7xeK9NR72N9oNv3Y+L3+Mv0kV7k0+fC-F9-jQ8vLTxksMBFYWvVMBfW6b8Vp1175Q0Xvpnhx5tc8D6LyIBRSi2cE4xeUHlE4UoN7FUM23JWl+vn7SfvRXfVs98An3qgW+h-kHqRhyNQTR-nLreoONYEXJTFbFHdXFc-IrHTXHRTN8IA50cdLFNfYpIwItd7elKpN-HfD-DxLxffEqCjInBZMLQVUAnzcAybZPW7UXUSELYbClN3X1BA1VTfAvbfEvcgGwGISgffMJFAGPYAuoF0NQWfRvC-ZvO3a-IdblNFLyeAk4IQpAnJVAwQ0pSnYaTA9g2FSTA5I5Q1X-dLIqU3QEU7G9DFQVePMA21LHVJKg3HUlR3MwkFCwkdGDTdD3X9LbDQ5lOFffH6UBd0Ewv5RwodZwtkUGRPQrFjHHY9LyMDf5GZUIsyVwltaLdAtELw8gLZVlBzFyNLY1Z0CZcmDzNbXNEgkQiAqIlPGI+JcrUos9RQxg1IoNdI1g9-CtDDfVLgiCHgpTHgbnNbZtAYh+c8ArfdKbWwmIh7BZQYxZB+JI4lRo0bZbTw1orA9oiNAJH-OHPImNTLQEY-HJOoinM-Cgmwx1HtSQ+woAo48pBgwtXpZgtI-vVY9g9YnI5OHY0SLQLlcBbpQY24hPTHJPUYjNVvM6AdbzR+ZIgYpgtQpuDI2dPZBdXw3YDQDpVCfo+JAVeok46wglCYsElaW-WDbE8DBolItA5o54wfLA59fQ1OTOEOIbEkp5co04-E84u7SQok35EFUk+JUgqEhYiknPJ41-F4lDWzCTOdaTKAXDfDQQIjCAEjekmNAo+sOkFHIdfk7QNkvE4XAk2bM6GPLEnjOYheNwpoxDaRDI8TezTDbDOUsPbYvrXSLQNQHkk3LUp3M0vU4Ejk0Eo00lE083Ojc00dbPDwl-PPCUmzOzXA1U5dHRNzYo6ZEAv0yI8Yzk6g4mcrYgnEh-JKdbKMlgmk9gjrOU5Ld4juMfYoOkXYTyVCXlPYG4xA3E-0g07M6AtPWVRbAs6DYUmEq0qnGMss0YPbNrDrZgKAbrffW5UlWkfo0BQdMbQEwXefKAmI3YT0t1OQpY9TQsrPYsmEuEm02MiclEyBAI50GQ87Y4tcufIZK7FvI0qYy0vLAc+Zd80Uqk8Usc8gP3APQHRnYPZncHbXGHffVdCZZHM3T8PnKDMgqwjsy-RfIOfTG5Bw+C0BckyMinFY-8wC+nIPOgEHMHVnRM76Iwc3cJNCUw+C9pDMsYygrsmI4MkMhilQXCu8+XMU0ctg33Wnf3YikC0iuAUPCC3XXwjQVAzRQnTipi67M4wM0rK4+i3nLiu4vC3i38-i9-IiwPUS6CcS0gXw50HgXgj0fw9Si3TSh80QyA6IsEtSoIhSrSnihJSzX7PPYQcgOU7IfATrLgBAGgDwXw2WSymPQguoeAxSm3cQq-dCySMDaKlAWKrSvcmKzbF-bymIXyuAAAKzgFw2YGCtCudP13h2+gipQi1NSrxwPMsJu2YuUpfNUpSsHXSsPLrkyrSuyoVxgCgHwC4EYCVII2hxYCoVXGmF8MYQPCjwWT7LW0QrCJFXXLEIXwuKSrW3KyWpwq0usv9UeN-MGuGtGsaXGrgEmuBzLxdIj1CXmqXNoz2FCJGIiJaoDLaskM8j7m3I9USItL2HcOWtPNXlOpGrGomqoRHzuor0dBqv2KPG6WerW1evCKBMzJYpUu5M42Rv+twsOqBtBtAi2QQEyHIF+wgih0YEEC4EGogCrN8IWh7gcBj1rBOFrDio3KcqDJQmBHZtTE5q0osBRpFuJooFJvJpCo8EZ0CS4HYHcEXUosyXThomov5pRqFvsoqKzOxu2tJS1IFrqC1s-OvWVFFv50s0lrE3Kq4GEEYEYG4AVsYCVthtrM2BG1or7iNssDRrWsfMcqqOcrAx9pBABojJFpODFqtqIDJvi2nO6whsaRoCgAordr-yHQsoPHNyCIgy0GGPRvWsDsNNK09JUzzvDOhIeUIWQGKnFuZTjrYH0HwEYGhVmqvJogWqmT2pWreoxo+s7L1r0z2F2o9RWvmK-KBrHoqWRHgE8EKASCGvwHkFqE8XwAQGQHIHIBYB3r4Ck1+ygB+xYDgG4KkxgF23EpIAyHIUrMaRADuCVIQCIBppXtmB4HvoSEFBnN+BAC8BToQB4C4AsE3lEDuEmEGpIBXoACUABxAAIQAEFnZnYP7XhXsGzVa4keB9r7xMh-Af7+BgHUGmh6ar78AOAOQV6AASAAFUvuvoAAVb6IBkAUhSGABVchjkZAMAOAOAKAOUygS5NQDgBaesuALQKASCCJejflTIdQdzXYD8Z0TIXYeR7Bo7F0fYes45ARukSCTISBCJI7DgHhp0O5H6DgVEuAVCIwXYUpLQTILQKxjQY5Ox+xukJxqhkAfoXxrAIAA"));
    })()

/***/ }),

/***/ "./res_built/atlas/atlas0_75.png":
/*!***************************************!*\
  !*** ./res_built/atlas/atlas0_75.png ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./src/js/application.js":
/*!*******************************!*\
  !*** ./src/js/application.js ***!
  \*******************************/
/*! exports provided: Application */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Application", function() { return Application; });
/* harmony import */ var _core_animation_frame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/animation_frame */ "./src/js/core/animation_frame.js");
/* harmony import */ var _core_background_resources_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/background_resources_loader */ "./src/js/core/background_resources_loader.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_game_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/game_state */ "./src/js/core/game_state.js");
/* harmony import */ var _core_globals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/globals */ "./src/js/core/globals.js");
/* harmony import */ var _core_input_distributor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core/input_distributor */ "./src/js/core/input_distributor.js");
/* harmony import */ var _core_loader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./core/loader */ "./src/js/core/loader.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_state_manager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core/state_manager */ "./src/js/core/state_manager.js");
/* harmony import */ var _core_tracked_state__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core/tracked_state */ "./src/js/core/tracked_state.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _platform_ad_provider__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./platform/ad_provider */ "./src/js/platform/ad_provider.js");
/* harmony import */ var _platform_ad_providers_no_ad_provider__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./platform/ad_providers/no_ad_provider */ "./src/js/platform/ad_providers/no_ad_provider.js");
/* harmony import */ var _platform_analytics__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./platform/analytics */ "./src/js/platform/analytics.js");
/* harmony import */ var _platform_browser_game_analytics__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./platform/browser/game_analytics */ "./src/js/platform/browser/game_analytics.js");
/* harmony import */ var _platform_browser_google_analytics__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./platform/browser/google_analytics */ "./src/js/platform/browser/google_analytics.js");
/* harmony import */ var _platform_browser_sound__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./platform/browser/sound */ "./src/js/platform/browser/sound.js");
/* harmony import */ var _platform_browser_storage__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./platform/browser/storage */ "./src/js/platform/browser/storage.js");
/* harmony import */ var _platform_browser_storage_indexed_db__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./platform/browser/storage_indexed_db */ "./src/js/platform/browser/storage_indexed_db.js");
/* harmony import */ var _platform_browser_wrapper__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./platform/browser/wrapper */ "./src/js/platform/browser/wrapper.js");
/* harmony import */ var _platform_electron_storage__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./platform/electron/storage */ "./src/js/platform/electron/storage.js");
/* harmony import */ var _platform_electron_wrapper__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./platform/electron/wrapper */ "./src/js/platform/electron/wrapper.js");
/* harmony import */ var _platform_game_analytics__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./platform/game_analytics */ "./src/js/platform/game_analytics.js");
/* harmony import */ var _platform_sound__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./platform/sound */ "./src/js/platform/sound.js");
/* harmony import */ var _platform_storage__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./platform/storage */ "./src/js/platform/storage.js");
/* harmony import */ var _platform_wrapper__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./platform/wrapper */ "./src/js/platform/wrapper.js");
/* harmony import */ var _profile_application_settings__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./profile/application_settings */ "./src/js/profile/application_settings.js");
/* harmony import */ var _savegame_savegame_manager__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./savegame/savegame_manager */ "./src/js/savegame/savegame_manager.js");
/* harmony import */ var _states_about__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./states/about */ "./src/js/states/about.js");
/* harmony import */ var _states_changelog__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./states/changelog */ "./src/js/states/changelog.js");
/* harmony import */ var _states_ingame__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./states/ingame */ "./src/js/states/ingame.js");
/* harmony import */ var _states_keybindings__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./states/keybindings */ "./src/js/states/keybindings.js");
/* harmony import */ var _states_main_menu__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./states/main_menu */ "./src/js/states/main_menu.js");
/* harmony import */ var _states_mobile_warning__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./states/mobile_warning */ "./src/js/states/mobile_warning.js");
/* harmony import */ var _states_preload__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./states/preload */ "./src/js/states/preload.js");
/* harmony import */ var _states_settings__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./states/settings */ "./src/js/states/settings.js");







































const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_8__["createLogger"])("application");

// Set the name of the hidden property and the change event for visibility
let pageHiddenPropName, pageVisibilityEventName;
if (typeof document.hidden !== "undefined") {
    // Opera 12.10 and Firefox 18 and later support
    pageHiddenPropName = "hidden";
    pageVisibilityEventName = "visibilitychange";
    // @ts-ignore
} else if (typeof document.msHidden !== "undefined") {
    pageHiddenPropName = "msHidden";
    pageVisibilityEventName = "msvisibilitychange";
    // @ts-ignore
} else if (typeof document.webkitHidden !== "undefined") {
    pageHiddenPropName = "webkitHidden";
    pageVisibilityEventName = "webkitvisibilitychange";
}

class Application {
    constructor() {
        window.assert(!_core_globals__WEBPACK_IMPORTED_MODULE_5__["GLOBAL_APP"], "Tried to construct application twice");
        logger.log("Creating application, platform =", Object(_core_utils__WEBPACK_IMPORTED_MODULE_11__["getPlatformName"])());
        Object(_core_globals__WEBPACK_IMPORTED_MODULE_5__["setGlobalApp"])(this);

        this.unloaded = false;

        // Global stuff
        this.settings = new _profile_application_settings__WEBPACK_IMPORTED_MODULE_28__["ApplicationSettings"](this);
        this.ticker = new _core_animation_frame__WEBPACK_IMPORTED_MODULE_0__["AnimationFrame"]();
        this.stateMgr = new _core_state_manager__WEBPACK_IMPORTED_MODULE_9__["StateManager"](this);
        this.savegameMgr = new _savegame_savegame_manager__WEBPACK_IMPORTED_MODULE_29__["SavegameManager"](this);
        this.inputMgr = new _core_input_distributor__WEBPACK_IMPORTED_MODULE_6__["InputDistributor"](this);
        this.backgroundResourceLoader = new _core_background_resources_loader__WEBPACK_IMPORTED_MODULE_1__["BackgroundResourcesLoader"](this);

        // Platform dependent stuff

        /** @type {StorageInterface} */
        this.storage = null;

        /** @type {SoundInterface} */
        this.sound = null;

        /** @type {PlatformWrapperInterface} */
        this.platformWrapper = null;

        /** @type {AdProviderInterface} */
        this.adProvider = null;

        /** @type {AnalyticsInterface} */
        this.analytics = null;

        /** @type {GameAnalyticsInterface} */
        this.gameAnalytics = null;

        this.initPlatformDependentInstances();

        // Track if the window is focused (only relevant for browser)
        this.focused = true;

        // Track if the window is visible
        this.pageVisible = true;

        // Track if the app is paused (cordova)
        this.applicationPaused = false;

        /** @type {TypedTrackedState<boolean>} */
        this.trackedIsRenderable = new _core_tracked_state__WEBPACK_IMPORTED_MODULE_10__["TrackedState"](this.onAppRenderableStateChanged, this);

        // Dimensions
        this.screenWidth = 0;
        this.screenHeight = 0;

        // Store the timestamp where we last checked for a screen resize, since orientationchange is unreliable with cordova
        this.lastResizeCheck = null;

        // Store the mouse position, or null if not available
        /** @type {Vector|null} */
        this.mousePosition = null;
    }

    /**
     * Initializes all platform instances
     */
    initPlatformDependentInstances() {
        logger.log("Creating platform dependent instances");

        // Start with empty ad provider
        this.adProvider = new _platform_ad_providers_no_ad_provider__WEBPACK_IMPORTED_MODULE_14__["NoAdProvider"](this);

        if (false) {} else {
            if (window.indexedDB) {
                this.storage = new _platform_browser_storage_indexed_db__WEBPACK_IMPORTED_MODULE_20__["StorageImplBrowserIndexedDB"](this);
            } else {
                this.storage = new _platform_browser_storage__WEBPACK_IMPORTED_MODULE_19__["StorageImplBrowser"](this);
            }
        }
        this.sound = new _platform_browser_sound__WEBPACK_IMPORTED_MODULE_18__["SoundImplBrowser"](this);

        if (false) {} else {
            this.platformWrapper = new _platform_browser_wrapper__WEBPACK_IMPORTED_MODULE_21__["PlatformWrapperImplBrowser"](this);
        }
        this.analytics = new _platform_browser_google_analytics__WEBPACK_IMPORTED_MODULE_17__["GoogleAnalyticsImpl"](this);

        this.gameAnalytics = new _platform_browser_game_analytics__WEBPACK_IMPORTED_MODULE_16__["ShapezGameAnalytics"](this);
    }

    /**
     * Registers all game states
     */
    registerStates() {
        /** @type {Array<typeof GameState>} */
        const states = [
            _states_preload__WEBPACK_IMPORTED_MODULE_36__["PreloadState"],
            _states_mobile_warning__WEBPACK_IMPORTED_MODULE_35__["MobileWarningState"],
            _states_main_menu__WEBPACK_IMPORTED_MODULE_34__["MainMenuState"],
            _states_ingame__WEBPACK_IMPORTED_MODULE_32__["InGameState"],
            _states_settings__WEBPACK_IMPORTED_MODULE_37__["SettingsState"],
            _states_keybindings__WEBPACK_IMPORTED_MODULE_33__["KeybindingsState"],
            _states_about__WEBPACK_IMPORTED_MODULE_30__["AboutState"],
            _states_changelog__WEBPACK_IMPORTED_MODULE_31__["ChangelogState"],
        ];

        for (let i = 0; i < states.length; ++i) {
            this.stateMgr.register(states[i]);
        }
    }

    /**
     * Registers all event listeners
     */
    registerEventListeners() {
        window.addEventListener("focus", this.onFocus.bind(this));
        window.addEventListener("blur", this.onBlur.bind(this));

        window.addEventListener("resize", () => this.checkResize(), true);
        window.addEventListener("orientationchange", () => this.checkResize(), true);

        if ( true && !_core_config__WEBPACK_IMPORTED_MODULE_3__["IS_MOBILE"]) {
            window.addEventListener("mousemove", this.handleMousemove.bind(this));
        }

        // Unload events
        window.addEventListener("beforeunload", this.onBeforeUnload.bind(this), true);
        window.addEventListener("unload", this.onUnload.bind(this), true);

        document.addEventListener(pageVisibilityEventName, this.handleVisibilityChange.bind(this), false);

        // Track touches so we can update the focus appropriately
        document.addEventListener("touchstart", this.updateFocusAfterUserInteraction.bind(this), true);
        document.addEventListener("touchend", this.updateFocusAfterUserInteraction.bind(this), true);
    }

    /**
     * Checks the focus after a touch
     * @param {TouchEvent} event
     */
    updateFocusAfterUserInteraction(event) {
        const target = /** @type {HTMLElement} */ (event.target);
        if (!target || !target.tagName) {
            // Safety check
            logger.warn("Invalid touchstart/touchend event:", event);
            return;
        }

        // When clicking an element which is not the currently focused one, defocus it
        if (target !== document.activeElement) {
            // @ts-ignore
            if (document.activeElement.blur) {
                // @ts-ignore
                document.activeElement.blur();
            }
        }

        // If we click an input field, focus it now
        if (target.tagName.toLowerCase() === "input") {
            // We *really* need the focus
            Object(_core_utils__WEBPACK_IMPORTED_MODULE_11__["waitNextFrame"])().then(() => target.focus());
        }
    }

    /**
     * Handles a page visibility change event
     * @param {Event} event
     */
    handleVisibilityChange(event) {
        window.focus();
        const pageVisible = !document[pageHiddenPropName];
        if (pageVisible !== this.pageVisible) {
            this.pageVisible = pageVisible;
            logger.log("Visibility changed:", this.pageVisible);
            this.trackedIsRenderable.set(this.isRenderable());
        }
    }

    /**
     * Handles a mouse move event
     * @param {MouseEvent} event
     */
    handleMousemove(event) {
        this.mousePosition = new _core_vector__WEBPACK_IMPORTED_MODULE_12__["Vector"](event.clientX, event.clientY);
    }

    /**
     * Internal on focus handler
     */
    onFocus() {
        this.focused = true;
    }

    /**
     * Internal blur handler
     */
    onBlur() {
        this.focused = false;
    }

    /**
     * Returns if the app is currently visible
     */
    isRenderable() {
        return !this.applicationPaused && this.pageVisible;
    }

    onAppRenderableStateChanged(renderable) {
        logger.log("Application renderable:", renderable);
        window.focus();
        if (!renderable) {
            this.stateMgr.getCurrentState().onAppPause();
        } else {
            // Got resume
            this.stateMgr.getCurrentState().onAppResume();
            this.checkResize();
        }

        this.sound.onPageRenderableStateChanged(renderable);
    }

    /**
     * Internal unload handler
     */
    onUnload(event) {
        if (!this.unloaded) {
            Object(_core_logging__WEBPACK_IMPORTED_MODULE_8__["logSection"])("UNLOAD HANDLER", "#f77");
            this.unloaded = true;
            this.stateMgr.getCurrentState().onBeforeExit();
            this.deinitialize();
        }
    }

    /**
     * Internal before-unload handler
     */
    onBeforeUnload(event) {
        Object(_core_logging__WEBPACK_IMPORTED_MODULE_8__["logSection"])("BEFORE UNLOAD HANDLER", "#f77");

        if (false) {}
    }

    /**
     * Boots the application
     */
    boot() {
        console.log("Booting ...");
        this.registerStates();
        this.registerEventListeners();

        _core_loader__WEBPACK_IMPORTED_MODULE_7__["Loader"].linkAppAfterBoot(this);

        // Check for mobile
        if (_core_config__WEBPACK_IMPORTED_MODULE_3__["IS_MOBILE"]) {
            this.stateMgr.moveToState("MobileWarningState");
        } else {
            this.stateMgr.moveToState("PreloadState");
        }

        // Starting rendering
        this.ticker.frameEmitted.add(this.onFrameEmitted, this);
        this.ticker.bgFrameEmitted.add(this.onBackgroundFrame, this);
        this.ticker.start();

        window.focus();
    }

    /**
     * Deinitializes the application
     */
    deinitialize() {
        return this.sound.deinitialize();
    }

    /**
     * Background frame update callback
     * @param {number} dt
     */
    onBackgroundFrame(dt) {
        if (this.isRenderable()) {
            return;
        }

        this.stateMgr.getCurrentState().onBackgroundTick(dt);
    }

    /**
     * Frame update callback
     * @param {number} dt
     */
    onFrameEmitted(dt) {
        if (!this.isRenderable()) {
            return;
        }

        const time = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_2__["performanceNow"])();

        // Periodically check for resizes, this is expensive (takes 2-3ms so only do it once in a while!)
        if (!this.lastResizeCheck || time - this.lastResizeCheck > 1000) {
            this.checkResize();
            this.lastResizeCheck = time;
        }

        this.stateMgr.getCurrentState().onRender(dt);
    }

    /**
     * Checks if the app resized. Only does this once in a while
     * @param {boolean} forceUpdate Forced update of the dimensions
     */
    checkResize(forceUpdate = false) {
        const w = window.innerWidth;
        const h = window.innerHeight;
        if (this.screenWidth !== w || this.screenHeight !== h || forceUpdate) {
            this.screenWidth = w;
            this.screenHeight = h;
            this.stateMgr.getCurrentState().onResized(this.screenWidth, this.screenHeight);

            const scale = this.getEffectiveUiScale();
            Object(_core_utils__WEBPACK_IMPORTED_MODULE_11__["waitNextFrame"])().then(() => document.documentElement.style.setProperty("--ui-scale", scale));
            window.focus();
        }
    }

    /**
     * Returns the effective ui sclae
     */
    getEffectiveUiScale() {
        return this.platformWrapper.getUiScale() * this.settings.getInterfaceScaleValue();
    }

    /**
     * Callback after ui scale has changed
     */
    updateAfterUiScaleChanged() {
        this.checkResize(true);
    }
}


/***/ }),

/***/ "./src/js/built-temp/base-en.json":
/*!****************************************!*\
  !*** ./src/js/built-temp/base-en.json ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (function() {
        return JSON.parse(__webpack_require__(/*! global-compression */ "./src/js/core/lzstring.js").decompressX64("N4KABGBEDmA2D2AjAhrSAuMoIUg5AJgJYB20GUAMvIaeQDTg6QCmATm-GxZAKIddIjHFAAuAC3gBXAM7ISBGQBEiANyIF2PekKa4ZUgGaGiADwrYRYybPmKeAa11WoAWyKxYReCRk8Ass5WkIgeXj5+mJAAQkEikKJsYd6+PAAqkHpgAL7CzKQmJESiLDwFcWJErqWYlvE+LADKLADGPgQAgtDwPA1gMq3tYMjdFbimzW0KMl09UQA8pgB8-YPTw6N59SQs-qRSJbO9O2DuJAcsGz1bzKZ75yUzowvLp-uPV2NQDQAS0mxHKJ9GxsT43cZ-KRsJ5zKCLFYgmRgrK4BpKZAAT0B3xOBExyJckFM6IxMJ48LAeNJBOCAymikakjYonJdPaMiWfnBbneLBmCkm7MZXBZCzOFw5rjA8zZ005X0giI6CnuEuFzPJiKW4ml4se8u5RNVj3Jrz1fMyIlyWUgDhYpIsKLEyEQ6Q6sUNU0S8DQUQAwmkAEqUBWoUVQDqUDKGvktZAABxqUF4jT9Cpk4iIhnDkEaPwAkgAxaNOyAyePIFpJ3MABQ6ft4lpw2SY1twmlc8Gi8h20Md8VExVg1Z+9oAhBVIKRvTx84YwBjpGAWCQAFbwDFgCREJHQZDVehgePD5ADMBTGQadhgRBSDF0LfiS6GKSeMCqdiXnwTm6QQiqeRRBGC1MAAbVLABVEgvHcEoCH6ZAPz3aouVLAB1TF43gadUMJdE2AcU54E0MAADIiLYUpDQ6Tx4AAd1OS5RHgMAX2ZJ9QU0D8EHjfpxATFgAC8ADpvDAQATckAeD+mwgABdVs8kgVxkFIfwVykftmGPTEeBrWAdN-Fp+LIFgEHIf1jOgUz4AYG0qiw5lGkQlhkOrfNXAcllf3gRMSEaf4qx+ad0kzXd90uHcwB8ld+gClgfxtYgZDaNgCEoUgnCiAB5YwiBaIhUDAFRkq4eDmjYD9uF-RBODogY2AwtgijIHh-I4DFD1vURH0uVywEihwSHokgtxYtgpBGmQEAYnwF3+G9avqscwAAcRYbqJEuGQgIUVA+kqr8Rq4SlhvweCjM4apWOOzbWNfWBl1MRMkhXKthMnOQkPCygWG4ngfu46Vlg+5zXIB0yoMG4aeEhoa6JG8G0AUphIGIPboEiLAbS65jUlqUt4EyqAsoAaQVTRhxKHglFM9aqNLOMSCrX0oD9eRmYVfSSm4KJKGQbmFUo7bkA1KJAz5ICNUNIX1p4cWBi80srNERodrxBAdh4NbutVuw9s1w0KbplbwtnMAoYYuj+O6-MToVdQWDoiD4zxKmogANSIR2wGd136cJDN6Od6A2EIECoGFBjg9DzRcNpSQ6JJ+1QgUOhMdzBOwCTjEU+IMg-CyNt8g8kUnK+6p+E4HmscJQdRGHWcS+ZMBK8EQ0SlMHNCxU4d4OY-qm+6xcoQQ8uWHQGScl-ezS9B8LGikFoqxkTG6mYOuG6iMuXPCsB3M8lgCAVDucwATXmz6d6u-ikUQFgYoMJe+RkF9PE3GfmUP97C9-MGaAIbuHgoRJjXrgDe1YTZXUijVQmK5j4sE7jwQBvdRpgDOnNEel9XITx-jaKYJg2CuG3q5GmlMQGlnATwP0PgCFSiNoOHw8DEFRA6JRDB-RgHsLooBVB9CmJPjAK5AA-JPIu+g57VFIetFIrdq6gMqPXasyDD68NplTduCCu49xUf3PhPVR5X3HqI38QtJaiHFgARykEQSiR98a1yHNWeWZiwCUSsTYw+TCz5Lh2DosaEsRYbQEX1fuCZjyblugrQc+dv5Wl-IfYo2dc50E0gORxVDLKXCSaQPOtlCSxxaLpIWSJbp2k3MdTsshLg41msPMA3CSAbRYqeS80ASCHmOrGASqDGbM1ic2ExfJ1rZNTvnahJBaH8xSKk9e6SxZDO6mU5J+dyaxhCpFOiYRXELOGG+JZOS06oM2jYykLBDDIFfN1ACsApB8mEmAPSLBTyXHwTY1w-SIBiKgPs0ZGN5brSykTeRCQ5lQBGbkpEMtFb5LWVENIAifkQrAPxD8N574jShUcp8JyhaJhaIOVFmhzmXJkBOXB8RDBPNEMA5xSR8XTPscEShUQaadjAO7T80zDawqgOfKQW4Xp92aU-FewxWJUs4QACnmJS-mwClgAEp6mZiMv1JEQ1uqIR7i6Yc-URq3Q7PAe54zLyaFBP3ZW+jha7Q1s+G6AjX4PQQc9L2TN4rGJtJfAAcvAUQNZ4AryIIgYc+YSCsthMCgpPA+Wgj6jfNFD9nIEE6gcbZ20uAPmKGqqK0FNxYUDcGiK+qBHWvVvtTlPhjURCvOalilrIlq31na81Dr7qPRda9d15LmAng-D6v1AbLyFtDeGmZYDQWQHDe+CtJBVnJWjfNPq3CkSX3gl1LhWyNVouGIW1BpiuARW6qQfRhr7nOIzWQDBoIsHhSRJFHwsA82DqDbq49t1HXTuhCke5rDLh1IMJRER3bcA7Cdi7fm5CHGKJhuBkowwAIeB1f7YIUa4UcQikieQYApCwebY+SKfUtWIcLWSuJiUWCdl4E9fSJApmMMZWk6DUR+15WfJdfRNNuLRSqqWVDUBbb7lOVx+MD5txhSgSNVwm5DCUSYlUFgh47B72RdFdhK51zv1EMtOc7CCDwEPMeJ5Z4Lw1tQbeCJJbG22s-YdUjAybQNGId9KoxQx0KM3lQFzcEDGuTjvEPjkA+Xniww+zcKLLh9BvVdfmYrBwSZPRRliB1v0PJPGeSinZUW3QQTuaJ0Ac0RdjetK1VmGh2c+b+HDfsF6uGUmwDEbmQVMagF672VWIMJRhfOqIo42Ei34S8zJK7SBVnYfpbaR59IYkPjgsj8RMyNJpslJI8YGGzoY7M5rkA0gHAzagOdhSohoSfDsSq7DfHwSfLAXix1+v9GpS0Bwh4jKtEItIIJlwADkkdkXTk+zeA4uM9X6OmteYc2ZhgKD3p9t80A1CXCk2iib-cru8WHuVqeNocMhzDjIUN3oCCLzW415lUAoIIEez7eMOPY4HZ4DRB6GYBJIjqfGTghPRuM23VUoV2HoLwEp9jmOfIwAAFppTbU4GQJYSgfCfe6rHb0m5h6gh9PBc5+KM18jHPMAA9JLnw0AVjwsuEL3HW4XTBZGnfa6E14KzVusxXiSRoDiG6ilXsUV5yRJaLJkgHzMfxGUivKRJRxm0JJxO8PbzTlkLp1EILd36EPmQGg31XuAceCRdKtoE1RArH7jbhBlZRAKuWr+9hAG-1LgaU0k6+GZBAbm8wYNty2c4X7eTgXdo7E1yZRO-tfOKc94XLLbl3WoDRBuSwdvjSkThbAFuu+MUJrD5UdNrTYBqEeTIRRS4w5uIlJYqv7vPV3keviIitO+P2dE4ZX3xjHnIAQQGK-c2ycDkrPH4dqA8KCO73jVTwQG6ngHnCv3zmVTyh1GUjtH6m6iMy9lrUz1gDXSIHyw12YhehkHuV60uDu1T0pTohTW6htyr1QRlG9Glxe0p3e30XAIxj1wN2lx1xqiWHmFYOlDaBIhaHGxkAAF5Pt6DPslgAxgw9cuCWAVgABqIqUOaATAZoYcfFYYSiVPfuNoeMTcXXWPOmYSdgtgFYeYCQ88XggQoQpYPMIsNIcQ4iSQzAP4FA1BbSUbVwS5IgQzDPPoW8LPOgPQjgow2wkwlpMwj-X5YQyMaw3XCQpYTAUNSqEAl6RpOjI6ecZwlRO+WAUQbA-QpYC-ZgX3KlXYEWO0ORChAfb2fwYorQb-LWeHOAsVaoeQOgN-WjaoURZGXAOgU2DbW0UIiFLKSqKbRrTLIo+MAIeAD8dMWmfFaIaxFAtOVqaYzVVQ9MJ3PSSsCjFcHMVWHySbDY6oRpQWX1CDWYnwlqMWY4uDbw+YlqQ0NI-wNwwzXSfSFwx4huaWX6T8FgLKRIoCYneZA6QrV1P4rlXjHcJDDoXbH44E5I6mcE3dC5fuLXJI4nduGyOAFgH4KQXvbbdE3VH4CCJQBUNI04m48yKAdY0ba43JBUAoiDSogiLQf0VQuDBkkovI3AakugSkzYw4jbXAFoDEHglgUk3Jd2EWAqOfIpZ+aUMpAvFiQU4U98CUwCbAhUSQUQMpPmDIngP4TU+0TAeYOUhUAoeANITRVeJ0fQRMTxLeG0o+bkXAUOEyOWeQKyL4fQTA4CVqL090x0nEFgfMEoVwGsdgQUBQHgAARjgIozAG0NlAdKtKgGKAoxkFDLYHDJxIpBTNcCRHjI9OTODLTLDLWAIFlykELR4ElVMAACYFUCyQVhx04KRBwmzJ5PlgMoAD9TJt9DMSgWMTA4x-iH8e1PjYA0gJ1EZpRuzYBcjPR4Ad86YcTeyyFEzCQT9HtzTmEyd+dHsVF5hKJuFUolhOtggakSBWtO5EYeBLzuprzOzIANUsw8pkjLTCRQNo4w56dF82tqdhds0iN9ISMFRXJt4cSY1BEADTwE1Jok0A8vklIWlFDWhwxgVTStycwaxilZT7RqFND5TzwfIOocKMRQ9JC91EtUUlMjTcL2ZTICLelTJ4LfxA4xj+T3NqxPzadDRzyu9HsYMadkM0kmTf9ECgY5yyj2BtTTJMZwIXBcB8wGz8xFL-TIBlKVKky1L3YGztLVL3YNL5KoB9KDL5LIBjKTLCR8wAANBsmyp0WSQ0ZSUwKoKQVwa8qIfwDoKy-MfwCCfwMASgXgd2XgSgMASVRoe0sAUwIwqESiRpB4zIxVDkqAYWQcbaPKN8-vLbXWNKwcFoPzZgV2ZAfyKEZeNzT0g9XveRR-asHY2xAs9sWMFbYcydHcbSe8S9fcaQRpDPdNWxPiZnYHFXc8LY0OB6LksgAPZvQkNnYiReW0kcqDJ-LCuaqsNcwyqAApZq+-Vq8sKbFPN8JnRMFneaK2H0Z8EvLgPNW-ZeQ8EbG5XJPVbmaoNGODWajnLIqa+zQy1GUyeHeq9imq6mP6yqTxf0xq5bdwlq4qdqh8I6kXK2KAlQy4Cmf6vxK9EaxpMa5A3JL6jslwL5EDeARkZnFajnBayAH1Aa465FZyGCo8G6lRGQFic5Ngd6Q0eG4stgY0asGUfiY6lYbQ1wZKssdaPLGQNSc4RrdquLasdYjEWWhUCajGHknE0UhYni0yLI1WngaILWgqzkwHCIcqqAL0fYascZaJW5BsqJBYreMWjWzSg4jSeZalJqVBZ29snIB86lTAgqWAIKKU9iprJ-VrFRVHERDmhOQO7YzOBbaFYITMTQGOqhBAAYEW1vGfJIRpHk0owkNobaKhANFkB87hDELCHCRrMuiuoOqANkz8dUis3UiCD0XjJqqGnan6bMUXHgvKQiVPOrEo1BVcVy3ifuYoQ8F3N3HurwSnXRNRQ9PwgwnIrCmUminOT-I3HpFkvA04Ko0EGTBc-RFoWKrY98L2IgqKUECgqXI3Ke0QGevuxgygre9Qneho-e4YD7VYJQ7zCnZI9mhmFklIBeEVGQAcl8lq+u0EeNZfEaOkuCeCjolKyQeMLi8ONeEILWxrVo6sPWzImQQ8YqRIINXbUEciHbEgHYWAA2za9u1bHaiK++eCaKk+jgLYhK-PMAQAJMIor5hQNOHciHyzgRLgVcGeAqNEgS9QSutfcO76MI5IrWHT74rLkVheHoqBG1GRbZrl5ma+xg7xH-RAc6BDxAxLiHxyJdZHsUlv9tqFHcwlGYr2HVHEqeG+GtHEqdGVJGkUlDHui66zBLGHkfG8sDt7H1tFHmG+G2G4rRBBH3HNHHZBH2iKsUZlbMrOTsHg6iULlMiTbHyAnIBxkPxFxQR8GE7ZGIn0hnTywRQ70izDxJBHClMCA5CnCXiEc3iWAvqWxpqeRexGtcnLkCmjHkxO5Q5NceMfqtr5HInIAeSooztU94ar7CKEAkDNFJmj1RBenPR+JSAkNRminJHtnjpJU-QDmSB6zVLZmGGHHFmJjrwVn+bCt1mboWItmS84DjUsMbcjIfGv4va+nvrmA7d2AQ5uqCAAB9DI1Ctu4lfJwGqAMZ7bCaahhsu5lqhneiI-LcdF0yNNOKJEcF0EDJyHNdfWvZyStgGs45touFAlh6Cc68ZSzF+h7F2iOqI5Jlol0qkXUlnGw5JTOFtUp0EFtJ+IPa4oAWHJs5PJ+Fn61F7sGjKsaZ0yrFnazhrMCaelHwQqcXXgD8XNSkXLJILqEXVAB6UgeMA4JEHwUJN8d7W1z64F+cjyEvel6sNSNgKyUESVNoD1-FG5zSzVhxn1qyEpOiBUnwUp46UVp6liBoal-OhcisfFUXUgQEr1gICF68ANtNkvENmZjlrVvNqNmNkgONsl-WxNgrXph8k+0QWVxauhxFxV0y1Fv0QHao0N0thx7trI6mkXQ+qUJ3MzX1ZiKUJTZ1u1m8X1HUfiWAQwbAiXF+pYHTOpKpHNR9ArI8QJTqLaTheeg3CzCLTaUECsZuY6LNTZQ6oCTwHXfXddt10sKxQgHN4x5t-NgARSkEIGLY1f7fmcHZXVebvUaRZvmivc+rXdvo3fnC3bPFCz3Zg8PY4TYRPaV30QXevBg7Wdva2WFkfefvg+BYfM4D+NEYRYVc-agHMao-ZchvufmYY4gzA8Gp4O702TPEQE3AAE4AAGU5EOe+MVgmz0FoOiOjyANjuDC5v0NCQDqpuZuWS4kXTmwivPa8Ljx7Hj6pAT4TzQUTu5cj-pssICPcvOlDeVkZ5FwphliOSz9k254Dn0ysBwW+BdmM3M+5HTTaTcLnJfBHPN5NfRe+nz7NNI+CF0J5kHM5HZijBt8z9wUwajmFdtmT6hDZsAPYNL9VlTljgIMwEXUQaN956EbDS8TqggYgAlapYcX5ZL0F3ACsacdLmzzL+z1FmsUJ3tkt5jlq7LrgEpARM63VVZh3ARcHI9EgF1+pYoHUW6NoHL0d8LtAt3PVF1lNlDaQSs7rop3r9r-18swtZTmzwbna4byr26RAbzzTqb-fBLrb1NTZCQY+n0Y6Nb26CLm1g4Hb+Id9qqzSnrvr-1v9gDpjuRorlhLlvFlbzpSsHUIH50kA73EtV5hb971PYgYwdgM+hHtmszlrsQUODMIZ2zpF1tkDIptIMn8QKH6plhJ+VbCDl1pENbq1-oK8TDKHRXTgakTad5MAQsA9SqAH5gPq70g7xz3MX0oSi76HlquqkXBBPRnzwh7DMe5pQReHeBhMSsYoDEX563U3AYGL3npZ9gQwaaSCkoZryVyXkUDr-zSnjt98optqAWVzy7hxr3hp1M+5ZiFifSQSCJT56jHx4n-GwPFKzAjEcWI8+wHow8kWGFpt7maFuwaFqR8n4O0nYpkxy9Em46+PXlJcEeibDckfW6G+w3JYDP9gUj+vsXeoptjjmmpd+cNbuv6XcdwvSdhc5v6XbZPcVKJs+1+cYoe1345Ilg5e1gvWjDpiOtYrJIe3dHy4ZdEoDpVXC9-TuD+vwj+9q14fre8XUXltSKW1tgfNS4W2PcVFOpNQ+nw8RG1VfnjcJET4+rbcS9VnVNNOBYjFAMcCFVPqlGhaUcIM1nIGhcRBK3E26E+bbAIl75311ObAM-giGgpwMh83eQ+Npm6hQCPgmnXTg4AP58cwAQnETrJnE4k9IA4AmFm10aQu9Nsy1UJrY0QE-5kBlwVAUsCYHcxMBtNW+OilwF7l4IhrCZt82ZpXRCe06UgEiElSV9NUJ1flHpix46hOaSqJTIGxTiHp1BYqVZm+gET8Drw6hT7i2gozz82CrBGsI0FiKIclwd2QnsGhySHh8wn2KUNGwIgPhZoKzH0AcBSC7JVCBADEKAMGRJ9oWqXFgeOi2zXdcuQTBAbIxCg8CmCRuKIRgOfbwchB9NavionFzb5dBW4croTxJbVd8svAwgHVzqKFpfkggt7kt1ChCsyAYQm0AwOhbCwrOkeWIQuV0EFdCqPKQLEuCC70RCKrgQoZp3qH6JeBOg0gE30yH19lo0Qbzn9yHZOCehswsLkpizA9RAufzS4PNx2CdxUETyVVLhzYCHgAuC3N8Dbl4EvhzemAvzvOA1QXCBEv3OboAKRC8COhI+B3D5EEGgF4uEOFYS0PiBtDpW37GAawNqrHgZW7AXXBG366K9khpwNwi+CZhrZCovAlAKqzmGpCsBwglfLuRHzi4gyVubnObzMxzFUC0AP1qxEupYEbwm4L4TCObYp4oc1QX1pmiLL-DIOKIzIu4V1SisrBOREWm0OpRUNTIXQp-JQwxY1E0MKQ9duKOoaCDYGIg3IeILABBZhhDEETImA16PhOAUgV3GigIYUsmhGMfQSANFGOw0+kA9AdCyXjSd8+UeRTmADk4cCkhCeJcAvnVFioAISQHhACNr54iiBuI9dq31JFWtcWe6dTlp2YGghSB+nZaGkBYjUk4Ch4AYL-XC7oCzRvAtnDKU+xpB-s6hIUq+iHb+jJSWRTASCOYBtCRGbAB0VcyObOjYhVzB8Kc3pFl9Bh-KH0USJ0QoC8RALUgA+C+ZTNqxe8d3FhluFcAk+cBSFHyGJaCCkSF7R6FIymYroWIdSLnJ2DYRnJBywJXdqOMIELj+WpKa0RENJaQs7csLLWjn0QLQs6WLY6UbyxZagg2Wco8vj2Lpq+jU8oGZUgGJ6pBiBxioploIJJHdRACh-aXKEBpHXhnSVkTAYpihxbisMqAZmm8FMCi4SAouZSKIFVQSAA0TEJluqnog1inSNoiAeCMz6Bt027vKEUXSDbdQVWdFPoRDS4FBZexa+GLqMNon-jKxGeYMeu2xEsSwJE44YCzyHZldgB7w1YeyPLZn462ZWc8baMb4NigeUo6sBD3giDswmH47sbTVRQ-i+JgYzflBKNyqTRJkYuHuwnUKppNOx6acSPBg4yBBB8gkoIQAzxKCih8AMiVADaEmCGxemCsh5mBQF9TuuqI7r40SFIivRX4wyX2O4kViTJUwvEQFMsndQvBnnYYKN0uCURoAr4EWPu2O4A5uoujZ+CLl4FSTh2mGEAm6kEEXhXKD4LyX0FkFuSnkG-byb5PoEUTGBYPaFupKfGaT-28ESKbpM4ELo4ppuBKX6JVKATTJeYsHulN2TTQ8W-A5cEj33bXtTJhg1OOoEJxWtQhykyifLw0k+kuAwEMALMTx6sS6GSAjid+Ommp4kpc0lKYqPp5LSox3LfuH1UPSpkteqCVPHDmNbBZ02RvLqW0Jkz3x2qp0qIIWFkzQy9JQWYgPBBAGailwvowSfB0hksBRc7VIiJoHHF-4kQjRXwI+Biyac7scMVxHYAXK7srIvYCDAQGWiSoqaXgrAoeB3EvIHWZ9a-jRh2Dq57UW0UrDsDHD1kKOPU2FtPlnxZEYZk+KWdnRlmIyhhWGKmdMKIpmiKw20FgIIOckZ5hqGBK6stGQrKFUJqhMKg4W0lBhKALwmKG0xGD6DhqlSAYAqiQnwR8xoqT7H6GLExtNCPzHIivVPB5Z6ikUXgVumxmITzs0TfuO9XmpmSlgmdaWdVKXHNJjApUOAszPhSET2EXk1GqDQIAKpmKNoIaJAJ6myzKamiNBGOS7FEzK5gMR-tXn5RDRtkSfYgvokOG1St+YQZaP7I4K2DMAetCESdBIDy5Tkp7DGjlnSqXoDZ9WVvkFguxxzT+8wkfgRLPCacuYzzPcG+hYi8Dq+WvQSi5KXlG4upxciGfDKGKDSbyFcmcl2PGQ45qUXMFIKSkulnt6kmIDmQekIrMCeqvMnsCokMCCz7sesW1KAOQai1WRKyHogX2aDgKMYk4Ici5C1yZNmArkLWKbENBhJ6c8YGEUORkY2dbw5JSdCwHwUi1ksPgbsAQEjYU9VAwNYTAcUqaS8gIcOc4k5xGAejgg71IpKtWJwPlqS6IN2JPjmLdR5g-MUXH7AkrxAgKMlRrNYkaBxgQpmlAvvjmt4bF+gcihXq7194gchsVqIgIJAiymSqkoIY7hrh6ZgATcT1ZRaNjvaM5WyjONRTeGeT24Row1LiKxiJY3I1srcsTKsBgWfzvQNDfRF1Tzy9U1FgDH6slFQAYMky+gHDOwHaHKRPArUWJdegSVoBwaKVVJa1EyXpLup+U-SNXFk4uQCpN0iRSLHdK8wyl6ixOkaJHA1KvaMffpvoF9w+hYAx2e+LAGaC+BigagI3gUwL4AAteAEfQGBdKCUvSn3kryu7aLM4Iyy8PV30SCQhlUoSKJKl4CLdrwTsrfk+EJY3RJmDgCsPnLCWmVZl3S9QKIAazIsYlz0dodNCSXPR+gtynJVNHoitRHl0SvyUUvyVyxPlIsBqlAHOSF1YZgcv5WWGSXQsAV2xZJXSMLpJkJWJPXAI6mWzoo+lE6QsPdCRVwIJlTPfjEennGBsDimgXnHjNuh9Rj0iKgojFAtTFZbuEsdtOwFdRvQwAWUE1oBSQzA4G0QC5Nq+wDhQsJaFwYHj9QL4PE4MJVaYIz1U5RAdMK4JDGF1cIfAuezNO3MuDx74paBjStwLIDyjCqFq1VDigEAuC5dNVhSLFRKv4zzhpVhaWVRKGWkojLwLQCXmAifCOddVIdCBLvCF5VK2J2K4ppICzkkr3VTqy4JKi8Cu5uo2hPEARALncrgglESGRmEDAQYUV2VFyg-NmhpBKl9CjRZMocabtvRdNVPJGQAAsha8QIJCIhFBMCz2TJOFzORCwdQocODOhlij6Il0WyWas9F3aXhXC68r+r9ldxwTa1fIetex3uQ1z3Aoa8SdSgOmnI6SZ4W6IWFsH9QHBI8GiRcCMVH4WIzyuiA6qgCoAy6fK-kWkSTVP5tWR6k1TDzNXLhaMlqxTNcKpGHJrFgCzcJmJQoqJkA2YPDp0zoV85Wy7CRita12ZmLGhkUFgO4muRn0UcauB8JYWLBHh2AykHYI0kfQ7rIAoBSlGwBjpILYBUATDWRDMVkN-atDL1aasgBtKVxSJa6b9jnxmjfae2AJYjV1Sw1Jq0a13vguhYWrhwNMfBdAvFrHrqwSgXgNEAggrQ4yLca9bqi41GiwAPGx2gN2zXzMOgWC3dtcluTCDpojw01nIBvX9Q2kH8lTSLgyL0QUNmgNjdwmKCX93IwELDfRKiAQRbY2hDCFmkv57xlIlC89di3xT-s34r8rNP-KMWubSuIff+PckgQvJ6eIuM4fp2M1EKjR7QhOJcwmgOAlhqUBuvZwL52bRNP2BLSQEIjJazURG26fJupihwGIRkRLdsnxRukmy0WtjUlCQyDKFy6UWCNZpiFP4Mt2hYqGyoa1Sgmt0-cVResgDdaVMdEH-hugzA1bYtdWwtOqFEBepXKd8AxtTz1W2b7NRUeErqhm1gA5tYwhuu5p2rbaFtSIR9XusxDz46aH6fMflEOgTboA4KwOaFt4Dxi+NSCXgB0DSAQRAwvAUTd3AmyhaxN3vPtpov+j-xRo8YTsBNkvg5p92VkNPIQHuSdbC0xMnxoxHOA3boWU24cE5mqBoQkg-C84J4G5S1b1tLAPig4BUDowKA+O2AITsm3E6dsftVAJhsp33Qadt2jHSTr-JhwIGOChRlTtZ3o7idSgDEK0TygTlHsDayDKZQL6FhXt72z7aJoR0Sbhd+4PKGYr7oS7+tUDZALAX9VXRxoI0GLAADZhOEERdZ8RGjbCs0emEXFulrxo72dSipqKgEuavYJy8iwVROg6Arx2AYatbVpt1Qu7NyHgS4F7vqiKzAdRWu0tExww5TIK0Wb+gXTR6L5081BBwD4MQDqBpAo3NOPbuJ3aw3dLAUPT7pa3LaIw3u5uB1uJ2rR1oBesAEXuZAFbfqQOqPSohj0trd4MWZbsXQzxbpU96ezPbIHwwxIWN-Qonf7pFJa169MstLZ7vL2+7FdlwCpnXrn2N6w28zJhq3vjCx7CMCe7vQCN71PgbGl6JAAPuz3D7xW-OhgXjl8A7RwwfOtumxqtbq184pOhavfphRsaE5Cs8BvAGoSArF8LOh-bFrNyxwfUf+u-YAY-2xa3JgECppjHf14LoDN+wCCtT0YjdmdBOoA7dpgPxVZhi2hA6xti1DRWEg4fcagFISnaMD1OrA3FvoiPa64GIJYXbngOQHEDt2wOHRA6ASSuAvAVcChXQOYACDo+2nePoeJ2qqD-OvTP2nFgKAwyIJfKhIZoPs7qAcOFoGLs86KGoDt2x4KID9BeAsFfjAA5ga0M58JYdPeQFNFfKaG2D7G8TSwHoNG9Q05Yfg9XCEONU2NOhjoMnyMPUGTD7OyovGAGLsAHYTonw5IeJ2zFYADgLKM9CsOCHWDoIlcGakv7mHg9rh+6IXFAX0EkFrqngOClk3MB466Qdwv3KPaYcWIMBM3voq3xWzDwMGtIGaIiLJinwm4DjSjSzDoaz6aRb9T5DWxqlBkCsfIxAvo47Js4pAZZLAsMgQZug9WaSjQ0az0z2A+2FhEpsga4L4gXRWXqFoVC0Z1Ae4Fql6kQhoEpk0U+IN0a2LPF9iFxxykhSWIBAWk0mu4zxXvXDGYgLx-LDNvb7Ekv1HDYiM+VS0UkfjPVfwH8ZMAN1hGYSO2q20gCvJCERdCZG8iVoeddayJm4-GBBMfhnY4xVFFibRMYmWAgYDbjmHxNuiiTCoZSOiaeay54Y2Jy4NSdnR4mnmXdYk3F2ZO0kti7AAI1Qg5OgguTaJ7raGh4BDbSA5JhMN1qygHAhTSyqKJKc9A71oGVCd+gqccrqQYjK4YUGxTJyc7uKpYZ2mqb8h-F04OVXLBlWPh4lMS2JdIOabAAEkiSaJGkcOAXWNBQ0-8q0w6cuBOmzRkm-LC6euClg4W8J6tpdOwYc0WRLbGIKgBYkKhLxhohQDeKp5osJRaS3U3gYkaSCpmtJHtgUp0mIjQR6AtToxw5rOcRKcvDzrmeYDpCi6OXPLuWda5g9dI9Z9uPTxqangGe6Cu7syGf3QAeSdC+nB2e6g9nrjpYUMcdmD2UlDDsndTkcSo5xEviIJ3HogXGILn2AmAOTpcD9Cui2pH7T0KWJFLvHxSAE6fazF3PspZp4e1NgicISVEQ8C9eE7Qly4PGyKtJXc12fTh+gTzr54ku4UTD8KFm7hMWkGpfXKFJAec87rgGDwyBjZKsMxLqTVxmi7Z+Wb6TBZuMrwoLUF09U-igt8jBwHhfrKeFFOoWlieFC5azHVl4XvjVxxbMTshLMRoSWxWEiyir2IkFyUyFoFfRhKolSw9xbpu53fgjRzjPVTsJoAotVhZz0INyFWx93DBdsuE1XXC3Yv0XuFVoUBbF0lOQLPdd3VNN4u2OgKAWJkMyDMlyMWQ3S1kcgKAsNSGXZUbtKJYSH3TZ1oAoW9OOenss+Zb0JpQeHQEcuNxPIcNCRBaENANBQtvWnMMFfRqRY-LmZ9NO4D0VDHYFxjKK7oofCxXaGMJ4BmQGgZvn36J9KK3vUZJ9gHyttMgP2g6AIYgKoddPKyt3RGCUaiWfpC2GyBAA"));
    })()

/***/ }),

/***/ "./src/js/built-temp/sfx.json":
/*!************************************!*\
  !*** ./src/js/built-temp/sfx.json ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (function() {
        return JSON.parse(__webpack_require__(/*! global-compression */ "./src/js/core/lzstring.js").decompressX64("N4KABGBECuBOA2BnSAuMBtcEqIGYA8A6AWwAcBmSLAXQBotJFTYBLAFwFNUxRsoAjAIYATAOYcA+gDsA9mxa4WAY0HyZU7pj4QADPW1gAnADYA7IQCsAJgAc5ACz2zARis7nNrBDpeowloLwMqISHLCwMrCavhDOzjp6MWDOhhaEOqaG5MYWGVk5Hr4+fJD+gcESMgDW0QZWbokGNjY6hPYW5BbO9qbkhvWGzkX62JDwHABuHPASSjJk45y12uTkCekJm1sJFiN8a+vbRzoWw76QpPCCSpL802zLfMb2CXvYxuSELalW5N-W5FMxjOJUu11u0BY8H8UlEj2wplyjRWOkMX3srmMhhsGKsWM8fGKo0hs3gyhqaC02hsxleSTiVkIhlMJyszgsGMM9mxwMJbxgLFC4Ui8IgzLpBjWaV6WOM3S6Vh6JxBxMFiAA7ixEAALCTaljCLiU+l5NGGc0Wy3Yt4QGxpTm5OKrUw0mxWFUQAUSDVa3U6mTq0XJDzmplWq02G3Bxkuwbs57GKwWGzsopYAC+I0YsCU8MYBBIFCo3hA6aAA"));
    })()

/***/ }),

/***/ "./src/js/changelog.js":
/*!*****************************!*\
  !*** ./src/js/changelog.js ***!
  \*****************************/
/*! exports provided: CHANGELOG */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CHANGELOG", function() { return CHANGELOG; });
const CHANGELOG = [
    {
        version: "1.1.3",
        date: "unreleased",
        entries: [
            "Added setting to configure zoom / mouse wheel / touchpad sensitivity",
            "Fix belts being too slow when copied via blueprint (by Dimava)",
            "Allow binding mouse buttons to actions (by Dimava)",
            "Increase readability of certain HUD elements",
        ],
    },
    {
        version: "1.1.2",
        date: "30.05.2020",
        entries: [
            "The official trailer is now ready! Check it out <a href='https://www.youtube.com/watch?v=KyorY1uIqiQ' target='_blank'>here</a>!",
            "The <a href='https://steam.shapez.io' target='_blank'>steam page</a> is now live!",
            "Experimental linux builds are now available! Please give me feedback on them in the discord",
            "Allow hovering pinned shapes to enlarge them",
            "Allow deselecting blueprints with right click and 'Q'",
            "Move default key for deleting from 'X' to 'DEL'",
            "Show confirmation when deleting more than 100 buildings",
            "Reintroduce 'SPACE' keybinding to center on map",
            "Improved keybinding hints",
            "Fixed some keybindings showing as 'undefined'",
        ],
    },
    {
        version: "1.1.1",
        date: "28.05.2020",
        entries: ["Fix crash when 'Show Hints' setting was turned off"],
    },
    {
        version: "1.1.0",
        date: "28.05.2020",
        entries: [
            "BLUEPRINTS! They are unlocked at level 12 and cost a special shape to build.",
            "MAP MARKERS! Press 'M' to create a waypoint and be able to jump to it",
            "Savegame levels are now shown in the main menu. For existing games, save them again to make the level show up.",
            "Allow holding SHIFT to rotate counter clockwise",
            "Added confirmation when deleting more than 500 buildings at a time",
            "Added background to toolbar to increase contrast",
            "Further decerase requirements of first levels",
            "Pinned shapes now are saved",
            "Allow placing extractors anywhere again, but they don't work at all if not placed on a resource",
            "Show dialog explaining some keybindings after completing level 4",
            "Fix keys being stuck when opening a dialog",
            "Swapped shape order for painting upgrades",
            "Allow changing all keybindings, including CTRL, ALT and SHIFT (by Dimava)",
            "Fix cycling through keybindings selecting locked buildings as well (by Dimava)",
            "There is now a github action, checking all pull requests with eslint. (by mrHedgehog)",
        ],
    },
    {
        version: "1.0.4",
        date: "26.05.2020",
        entries: [
            "Reduce cost of first painting upgrade, and change 'Shape Processing' to 'Cutting, Rotating & Stacking'",
            "Add dialog after completing level 2 to check out the upgrades tab.",
            "Allow changing the keybindings in the demo version",
        ],
    },
    {
        version: "1.0.3",
        date: "24.05.2020",
        entries: [
            "Reduced the amount of shapes required for the first 5 levels to make it easier to get into the game.",
        ],
    },
    {
        version: "1.0.2",
        date: "23.05.2020",
        entries: [
            "Introduced changelog",
            "Removed 'early access' label because the game isn't actually early access - its in a pretty good state already! (No worries, a lot more updates will follow!)",
            "Added a 'Show hint' button which shows a small video for almost all levels to help out",
            "Now showing proper descriptions when completing levels, with instructions on what the gained reward does.",
            "Show a landing page on mobile devices about the game not being ready to be played on mobile yet",
            "Fix painters and mixers being affected by the shape processors upgrade and not the painter one",
            "Added 'multiplace' setting which is equivalent to holding SHIFT all the time",
            "Added keybindings to zoom in / zoom out",
            "Tunnels now also show connection lines to tunnel exits, instead of just tunnel entries",
            "Lots of minor fixes and improvements",
        ],
    },
    {
        version: "1.0.1",
        date: "21.05.2020",
        entries: ["Initial release!"],
    },
];


/***/ }),

/***/ "./src/js/core/animation_frame.js":
/*!****************************************!*\
  !*** ./src/js/core/animation_frame.js ***!
  \****************************************/
/*! exports provided: AnimationFrame */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationFrame", function() { return AnimationFrame; });
/* harmony import */ var _signal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signal */ "./src/js/core/signal.js");
/* harmony import */ var _webworkers_background_animation_frame_emittter_worker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webworkers/background_animation_frame_emittter.worker */ "./src/js/webworkers/background_animation_frame_emittter.worker.js");
/* harmony import */ var _webworkers_background_animation_frame_emittter_worker__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_webworkers_background_animation_frame_emittter_worker__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logging */ "./src/js/core/logging.js");
/* harmony import */ var _builtins__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./builtins */ "./src/js/core/builtins.js");


// @ts-ignore





const logger = Object(_logging__WEBPACK_IMPORTED_MODULE_2__["createLogger"])("animation_frame");

const maxDtMs = 1000;
const resetDtMs = 16;

class AnimationFrame {
    constructor() {
        this.frameEmitted = new _signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]();
        this.bgFrameEmitted = new _signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]();

        this.lastTime = null;
        this.bgLastTime = null;

        this.boundMethod = this.handleAnimationFrame.bind(this);

        /** @type {Worker} */
        this.backgroundWorker = new _webworkers_background_animation_frame_emittter_worker__WEBPACK_IMPORTED_MODULE_1___default.a();
        this.backgroundWorker.addEventListener("error", err => {
            logger.error("Error in background fps worker:", err);
        });
        this.backgroundWorker.addEventListener("message", this.handleBackgroundTick.bind(this));
    }

    /**
     *
     * @param {MessageEvent} event
     */
    handleBackgroundTick(event) {
        const time = Object(_builtins__WEBPACK_IMPORTED_MODULE_3__["performanceNow"])();
        if (!this.bgLastTime) {
            // First update, first delta is always 16ms
            this.bgFrameEmitted.dispatch(1000 / 60);
        } else {
            let dt = time - this.bgLastTime;
            if (dt > maxDtMs) {
                dt = resetDtMs;
            }
            this.bgFrameEmitted.dispatch(dt);
        }
        this.bgLastTime = time;
    }

    start() {
        window.assert(window.requestAnimationFrame, "requestAnimationFrame is not supported!");
        this.handleAnimationFrame();
    }

    handleAnimationFrame(time) {
        if (!this.lastTime) {
            // First update, first delta is always 16ms
            this.frameEmitted.dispatch(1000 / 60);
        } else {
            let dt = time - this.lastTime;
            if (dt > maxDtMs) {
                // warn(this, "Clamping", dt, "to", resetDtMs);
                dt = resetDtMs;
            }
            this.frameEmitted.dispatch(dt);
        }
        this.lastTime = time;
        window.requestAnimationFrame(this.boundMethod);
    }
}


/***/ }),

/***/ "./src/js/core/assert.js":
/*!*******************************!*\
  !*** ./src/js/core/assert.js ***!
  \*******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logging */ "./src/js/core/logging.js");


const logger = Object(_logging__WEBPACK_IMPORTED_MODULE_0__["createLogger"])("assert");

let assertionErrorShown = false;

function initAssert() {
    /**
     * Expects a given condition to be true
     * @param {Boolean} condition
     * @param  {...String} failureMessage
     */
    // @ts-ignore
    window.assert = function (condition, ...failureMessage) {
        if (!condition) {
            logger.error("assertion failed:", ...failureMessage);
            if (!assertionErrorShown) {
                // alert("Assertion failed (the game will try to continue to run): \n\n" + failureMessage);
                assertionErrorShown = true;
            }
            throw new Error("AssertionError: " + failureMessage.join(" "));
        }
    };
}

initAssert();


/***/ }),

/***/ "./src/js/core/async_compression.js":
/*!******************************************!*\
  !*** ./src/js/core/async_compression.js ***!
  \******************************************/
/*! exports provided: compressionPrefix, asyncCompressor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compressionPrefix", function() { return compressionPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asyncCompressor", function() { return asyncCompressor; });
/* harmony import */ var _webworkers_compression_worker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webworkers/compression.worker */ "./src/js/webworkers/compression.worker.js");
/* harmony import */ var _webworkers_compression_worker__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_webworkers_compression_worker__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logging */ "./src/js/core/logging.js");
/* harmony import */ var _lzstring__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lzstring */ "./src/js/core/lzstring.js");
/* harmony import */ var _builtins__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./builtins */ "./src/js/core/builtins.js");
// @ts-ignore





const logger = Object(_logging__WEBPACK_IMPORTED_MODULE_1__["createLogger"])("async_compression");

let compressionPrefix = String.fromCodePoint(1);

function checkCryptPrefix(prefix) {
    try {
        window.localStorage.setItem("prefix_test", prefix);
        window.localStorage.removeItem("prefix_test");
        return true;
    } catch (ex) {
        logger.warn("Prefix '" + prefix + "' not available");
        return false;
    }
}

if (!checkCryptPrefix(compressionPrefix)) {
    logger.warn("Switching to basic prefix");
    compressionPrefix = " ";
    if (!checkCryptPrefix(compressionPrefix)) {
        logger.warn("Prefix not available, ls seems to be unavailable");
    }
}

/**
 * @typedef {{
 *   errorHandler: function(any) : void,
 *   resolver: function(any) : void,
 *   startTime: number
 * }} JobEntry
 */

class AsynCompression {
    constructor() {
        /** @type {Worker} */
        this.worker = new _webworkers_compression_worker__WEBPACK_IMPORTED_MODULE_0___default.a();

        this.currentJobId = 1000;

        /** @type {Object.<number, JobEntry>} */
        this.currentJobs = {};

        this.worker.addEventListener("message", event => {
            const { jobId, result } = event.data;
            const jobData = this.currentJobs[jobId];
            if (!jobData) {
                logger.error("Failed to resolve job result, job id", jobId, "is not known");
                return;
            }

            const duration = Object(_builtins__WEBPACK_IMPORTED_MODULE_3__["performanceNow"])() - jobData.startTime;
            // log(this, "Got response from worker within", duration.toFixed(2), "ms");
            const resolver = jobData.resolver;
            delete this.currentJobs[jobId];
            resolver(result);
        });

        this.worker.addEventListener("error", err => {
            logger.error("Got error from webworker:", err, "aborting all jobs");
            const failureCalls = [];
            for (const jobId in this.currentJobs) {
                failureCalls.push(this.currentJobs[jobId].errorHandler);
            }
            this.currentJobs = {};
            for (let i = 0; i < failureCalls.length; ++i) {
                failureCalls[i](err);
            }
        });
    }

    /**
     * Compresses file
     * @param {string} text
     */
    compressFileAsync(text) {
        return this.internalQueueJob("compressFile", {
            text,
            compressionPrefix,
        });
    }

    /**
     * Queues a new job
     * @param {string} job
     * @param {any} data
     * @returns {Promise<any>}
     */
    internalQueueJob(job, data) {
        const jobId = ++this.currentJobId;
        return new Promise((resolve, reject) => {
            const errorHandler = err => {
                logger.error("Failed to compress job", jobId, ":", err);
                reject(err);
            };
            this.currentJobs[jobId] = {
                errorHandler,
                resolver: resolve,
                startTime: Object(_builtins__WEBPACK_IMPORTED_MODULE_3__["performanceNow"])(),
            };
            this.worker.postMessage({ jobId, job, data });
        });
    }
}

const asyncCompressor = new AsynCompression();


/***/ }),

/***/ "./src/js/core/atlas_definitions.js":
/*!******************************************!*\
  !*** ./src/js/core/atlas_definitions.js ***!
  \******************************************/
/*! exports provided: AtlasDefinition, atlasFiles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AtlasDefinition", function() { return AtlasDefinition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atlasFiles", function() { return atlasFiles; });
/**
 * @typedef {{
 *   frame: { x: number, y: number, w: number, h: number },
 *   rotated: false,
 *   spriteSourceSize: { x: number, y: number, w: number, h: number },
 *   sourceSize: { w: number, h: number},
 *   trimmed: true
 * }} SpriteDefinition
 */

class AtlasDefinition {
    constructor(sourceData) {
        this.sourceFileName = sourceData.meta.image;
        this.meta = sourceData.meta;

        /** @type {Object.<string, SpriteDefinition>} */
        this.sourceData = sourceData.frames;
    }

    getFullSourcePath() {
        return this.sourceFileName;
    }
}

const atlasFiles = __webpack_require__("./res_built/atlas sync .*\\.json/")
    .keys()
    .map(f => f.replace(/^\.\//gi, ""))
    .map(f => __webpack_require__("./res_built/atlas sync recursive ^\\.\\/.*$")("./" + f))
    .map(data => new AtlasDefinition(data));


/***/ }),

/***/ "./src/js/core/background_resources_loader.js":
/*!****************************************************!*\
  !*** ./src/js/core/background_resources_loader.js ***!
  \****************************************************/
/*! exports provided: BackgroundResourcesLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BackgroundResourcesLoader", function() { return BackgroundResourcesLoader; });
/* harmony import */ var _loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loader */ "./src/js/core/loader.js");
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logging */ "./src/js/core/logging.js");
/* harmony import */ var _signal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signal */ "./src/js/core/signal.js");
/* harmony import */ var _platform_sound__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../platform/sound */ "./src/js/platform/sound.js");
/* harmony import */ var _atlas_definitions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./atlas_definitions */ "./src/js/core/atlas_definitions.js");








const logger = Object(_logging__WEBPACK_IMPORTED_MODULE_1__["createLogger"])("background_loader");

const essentialMainMenuSprites = ["logo.png", ...["logo.png"].filter(src => src.startsWith("ui/"))];
const essentialMainMenuSounds = [
    _platform_sound__WEBPACK_IMPORTED_MODULE_3__["SOUNDS"].uiClick,
    _platform_sound__WEBPACK_IMPORTED_MODULE_3__["SOUNDS"].uiError,
    _platform_sound__WEBPACK_IMPORTED_MODULE_3__["SOUNDS"].dialogError,
    _platform_sound__WEBPACK_IMPORTED_MODULE_3__["SOUNDS"].dialogOk,
    _platform_sound__WEBPACK_IMPORTED_MODULE_3__["SOUNDS"].swishShow,
    _platform_sound__WEBPACK_IMPORTED_MODULE_3__["SOUNDS"].swishHide,
];

const essentialBareGameAtlases = _atlas_definitions__WEBPACK_IMPORTED_MODULE_4__["atlasFiles"];
const essentialBareGameSprites = ["logo.png"];
const essentialBareGameSounds = [_platform_sound__WEBPACK_IMPORTED_MODULE_3__["MUSIC"].theme];

const additionalGameSprites = [];
// @ts-ignore
const additionalGameSounds = [...Object.values(_platform_sound__WEBPACK_IMPORTED_MODULE_3__["SOUNDS"]), ...Object.values(_platform_sound__WEBPACK_IMPORTED_MODULE_3__["MUSIC"])];

class BackgroundResourcesLoader {
    /**
     *
     * @param {Application} app
     */
    constructor(app) {
        this.app = app;

        this.registerReady = false;
        this.mainMenuReady = false;
        this.bareGameReady = false;
        this.additionalReady = false;

        this.signalMainMenuLoaded = new _signal__WEBPACK_IMPORTED_MODULE_2__["Signal"]();
        this.signalBareGameLoaded = new _signal__WEBPACK_IMPORTED_MODULE_2__["Signal"]();
        this.signalAdditionalLoaded = new _signal__WEBPACK_IMPORTED_MODULE_2__["Signal"]();

        this.numAssetsLoaded = 0;
        this.numAssetsToLoadTotal = 0;

        // Avoid loading stuff twice
        this.spritesLoaded = [];
        this.soundsLoaded = [];
    }

    getNumAssetsLoaded() {
        return this.numAssetsLoaded;
    }

    getNumAssetsTotal() {
        return this.numAssetsToLoadTotal;
    }

    getPromiseForMainMenu() {
        if (this.mainMenuReady) {
            return Promise.resolve();
        }

        return new Promise(resolve => {
            this.signalMainMenuLoaded.add(resolve);
        });
    }

    getPromiseForBareGame() {
        if (this.bareGameReady) {
            return Promise.resolve();
        }

        return new Promise(resolve => {
            this.signalBareGameLoaded.add(resolve);
        });
    }

    startLoading() {
        this.internalStartLoadingEssentialsForMainMenu();
    }

    internalStartLoadingEssentialsForMainMenu() {
        logger.log("⏰ Start load: main menu");
        this.internalLoadSpritesAndSounds(essentialMainMenuSprites, essentialMainMenuSounds)
            .catch(err => {
                logger.warn("⏰ Failed to load essentials for main menu:", err);
            })
            .then(() => {
                logger.log("⏰ Finish load: main menu");
                this.mainMenuReady = true;
                this.signalMainMenuLoaded.dispatch();
                this.internalStartLoadingEssentialsForBareGame();
            });
    }

    internalStartLoadingEssentialsForBareGame() {
        logger.log("⏰ Start load: bare game");
        this.internalLoadSpritesAndSounds(
            essentialBareGameSprites,
            essentialBareGameSounds,
            essentialBareGameAtlases
        )
            .catch(err => {
                logger.warn("⏰ Failed to load essentials for bare game:", err);
            })
            .then(() => {
                logger.log("⏰ Finish load: bare game");
                _loader__WEBPACK_IMPORTED_MODULE_0__["Loader"].createAtlasLinks();
                this.bareGameReady = true;
                this.signalBareGameLoaded.dispatch();
                this.internalStartLoadingAdditionalGameAssets();
            });
    }

    internalStartLoadingAdditionalGameAssets() {
        const additionalAtlases = [];
        logger.log("⏰ Start load: additional assets (", additionalAtlases.length, "images)");
        this.internalLoadSpritesAndSounds(additionalGameSprites, additionalGameSounds, additionalAtlases)
            .catch(err => {
                logger.warn("⏰ Failed to load additional assets:", err);
            })
            .then(() => {
                logger.log("⏰ Finish load: additional assets");
                this.additionalReady = true;
                this.signalAdditionalLoaded.dispatch();
            });
    }

    /**
     * @param {Array<string>} sprites
     * @param {Array<string>} sounds
     * @param {Array<AtlasDefinition>} atlases
     * @returns {Promise<void>}
     */
    internalLoadSpritesAndSounds(sprites, sounds, atlases = []) {
        this.numAssetsToLoadTotal = sprites.length + sounds.length + atlases.length;
        this.numAssetsLoaded = 0;

        let promises = [];

        for (let i = 0; i < sounds.length; ++i) {
            if (this.soundsLoaded.indexOf(sounds[i]) >= 0) {
                // Already loaded
                continue;
            }

            this.soundsLoaded.push(sounds[i]);
            promises.push(
                this.app.sound
                    .loadSound(sounds[i])
                    .catch(err => {
                        logger.warn("Failed to load sound:", sounds[i]);
                    })
                    .then(() => {
                        this.numAssetsLoaded++;
                    })
            );
        }

        for (let i = 0; i < sprites.length; ++i) {
            if (this.spritesLoaded.indexOf(sprites[i]) >= 0) {
                // Already loaded
                continue;
            }
            this.spritesLoaded.push(sprites[i]);
            promises.push(
                _loader__WEBPACK_IMPORTED_MODULE_0__["Loader"].preloadCSSSprite(sprites[i])
                    .catch(err => {
                        logger.warn("Failed to load css sprite:", sprites[i]);
                    })
                    .then(() => {
                        this.numAssetsLoaded++;
                    })
            );
        }

        for (let i = 0; i < atlases.length; ++i) {
            const atlas = atlases[i];
            promises.push(
                _loader__WEBPACK_IMPORTED_MODULE_0__["Loader"].preloadAtlas(atlas)
                    .catch(err => {
                        logger.warn("Failed to load atlas:", atlas.sourceFileName);
                    })
                    .then(() => {
                        this.numAssetsLoaded++;
                    })
            );
        }

        return (
            Promise.all(promises)

                // // Remove some pressure by waiting a bit
                // .then(() => {
                //     return new Promise(resolve => {
                //         setTimeout(resolve, 200);
                //     });
                // })
                .then(() => {
                    this.numAssetsToLoadTotal = 0;
                    this.numAssetsLoaded = 0;
                })
        );
    }
}


/***/ }),

/***/ "./src/js/core/buffer_maintainer.js":
/*!******************************************!*\
  !*** ./src/js/core/buffer_maintainer.js ***!
  \******************************************/
/*! exports provided: BufferMaintainer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferMaintainer", function() { return BufferMaintainer; });
/* harmony import */ var _game_root__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/root */ "./src/js/game/root.js");
/* harmony import */ var _buffer_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer_utils */ "./src/js/core/buffer_utils.js");
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logging */ "./src/js/core/logging.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./src/js/core/utils.js");





/**
 * @typedef {{
 *  canvas: HTMLCanvasElement,
 *  context: CanvasRenderingContext2D,
 *  lastUse: number,
 * }} CacheEntry
 */

const logger = Object(_logging__WEBPACK_IMPORTED_MODULE_2__["createLogger"])("buffers");

const bufferGcDurationSeconds = 10;

class BufferMaintainer {
    /**
     * @param {GameRoot} root
     */
    constructor(root) {
        this.root = root;

        /** @type {Map<string, Map<string, CacheEntry>>} */
        this.cache = new Map();

        this.iterationIndex = 1;
        this.lastIteration = 0;
    }

    /**
     * Goes to the next buffer iteration, clearing all buffers which were not used
     * for a few iterations
     */
    garbargeCollect() {
        let totalKeys = 0;
        let deletedKeys = 0;
        const minIteration = this.iterationIndex;

        this.cache.forEach((subCache, key) => {
            let unusedSubKeys = [];

            // Filter sub cache
            subCache.forEach((cacheEntry, subKey) => {
                if (cacheEntry.lastUse < minIteration) {
                    unusedSubKeys.push(subKey);
                    Object(_buffer_utils__WEBPACK_IMPORTED_MODULE_1__["freeCanvas"])(cacheEntry.canvas);
                    ++deletedKeys;
                } else {
                    ++totalKeys;
                }
            });

            // Delete unused sub keys
            for (let i = 0; i < unusedSubKeys.length; ++i) {
                subCache.delete(unusedSubKeys[i]);
            }
        });

        // Make sure our backlog never gets too big
        Object(_buffer_utils__WEBPACK_IMPORTED_MODULE_1__["clearBufferBacklog"])();

        const bufferStats = Object(_buffer_utils__WEBPACK_IMPORTED_MODULE_1__["getBufferStats"])();
        const mbUsed = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["round1Digit"])(bufferStats.vramUsage / (1024 * 1024));
        logger.log(
            "GC: Remove",
            (deletedKeys + "").padStart(4),
            ", Remain",
            (totalKeys + "").padStart(4),
            "(",
            (bufferStats.bufferCount + "").padStart(4),
            "total",
            ")",

            "(",
            (bufferStats.backlog + "").padStart(4),
            "backlog",
            ")",

            "VRAM:",
            mbUsed,
            "MB"
        );

        ++this.iterationIndex;
    }

    update() {
        const now = this.root.time.realtimeNow();
        if (now - this.lastIteration > bufferGcDurationSeconds) {
            this.lastIteration = now;
            this.garbargeCollect();
        }
    }

    /**
     *
     * @param {string} key
     * @param {string} subKey
     * @param {function(HTMLCanvasElement, CanvasRenderingContext2D, number, number, number, object?) : void} redrawMethod
     * @param {object=} additionalParams
     * @returns {HTMLCanvasElement}
     *
     */
    getForKey(key, subKey, w, h, dpi, redrawMethod, additionalParams) {
        // First, create parent key
        let parent = this.cache.get(key);
        if (!parent) {
            parent = new Map();
            this.cache.set(key, parent);
        }

        // Now search for sub key
        const cacheHit = parent.get(subKey);
        if (cacheHit) {
            cacheHit.lastUse = this.iterationIndex;
            return cacheHit.canvas;
        }

        // Need to generate new buffer
        const effectiveWidth = w * dpi;
        const effectiveHeight = h * dpi;

        const [canvas, context] = Object(_buffer_utils__WEBPACK_IMPORTED_MODULE_1__["makeOffscreenBuffer"])(effectiveWidth, effectiveHeight, {
            reusable: true,
            label: "buffer-" + key + "/" + subKey,
            smooth: true,
        });

        redrawMethod(canvas, context, w, h, dpi, additionalParams);

        parent.set(subKey, {
            canvas,
            context,
            lastUse: this.iterationIndex,
        });
        return canvas;
    }
}


/***/ }),

/***/ "./src/js/core/buffer_utils.js":
/*!*************************************!*\
  !*** ./src/js/core/buffer_utils.js ***!
  \*************************************/
/*! exports provided: enableImageSmoothing, disableImageSmoothing, getBufferVramUsageBytes, getBufferStats, clearBufferBacklog, makeOffscreenBuffer, registerCanvas, freeCanvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableImageSmoothing", function() { return enableImageSmoothing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disableImageSmoothing", function() { return disableImageSmoothing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBufferVramUsageBytes", function() { return getBufferVramUsageBytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBufferStats", function() { return getBufferStats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearBufferBacklog", function() { return clearBufferBacklog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeOffscreenBuffer", function() { return makeOffscreenBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerCanvas", function() { return registerCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "freeCanvas", function() { return freeCanvas; });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ "./src/js/core/config.js");
/* harmony import */ var _builtins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/js/core/utils.js");
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./logging */ "./src/js/core/logging.js");





const logger = Object(_logging__WEBPACK_IMPORTED_MODULE_3__["createLogger"])("buffer_utils");

/**
 * Enables images smoothing on a context
 * @param {CanvasRenderingContext2D} context
 */
function enableImageSmoothing(context) {
    context.imageSmoothingEnabled = true;
    context.webkitImageSmoothingEnabled = true;

    // @ts-ignore
    context.imageSmoothingQuality = _config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].smoothing.quality;
}

/**
 * Disables image smoothing on a context
 * @param {CanvasRenderingContext2D} context
 */
function disableImageSmoothing(context) {
    context.imageSmoothingEnabled = false;
    context.webkitImageSmoothingEnabled = false;
}

const registeredCanvas = [];
const freeCanvasList = [];

let vramUsage = 0;
let bufferCount = 0;

/**
 *
 * @param {HTMLCanvasElement} canvas
 */
function getBufferVramUsageBytes(canvas) {
    return canvas.width * canvas.height * 4;
}

/**
 * Returns stats on the allocated buffers
 */
function getBufferStats() {
    return {
        vramUsage,
        bufferCount,
        backlog: freeCanvasList.length,
    };
}

function clearBufferBacklog() {
    while (freeCanvasList.length > 50) {
        freeCanvasList.pop();
    }
}

/**
 * Creates a new offscreen buffer
 * @param {Number} w
 * @param {Number} h
 * @returns {[HTMLCanvasElement, CanvasRenderingContext2D]}
 */
function makeOffscreenBuffer(w, h, { smooth = true, reusable = true, label = "buffer" }) {
    window.assert(w > 0 && h > 0, "W or H < 0");
    if (w % 1 !== 0 || h % 1 !== 0) {
        // console.warn("Subpixel offscreen buffer size:", w, h);
    }
    if (w < 1 || h < 1) {
        logger.error("Offscreen buffer size < 0:", w, "x", h);
        w = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(1, w);
        h = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(1, h);
    }

    const recommendedSize = 1024 * 1024;
    if (w * h > recommendedSize) {
        logger.warn("Creating huge buffer:", w, "x", h, "with label", label);
    }

    w = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(w);
    h = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(h);

    let canvas = null;
    let context = null;

    let bestMatchingOne = null;
    let bestMatchingPixelsDiff = 1e50;

    const currentPixels = w * h;

    // Ok, search in cache first
    for (let i = 0; i < freeCanvasList.length; ++i) {
        const { canvas: useableCanvas, context: useableContext } = freeCanvasList[i];
        if (useableCanvas.width === w && useableCanvas.height === h) {
            // Ok we found one
            canvas = useableCanvas;
            context = useableContext;

            Object(_utils__WEBPACK_IMPORTED_MODULE_2__["fastArrayDelete"])(freeCanvasList, i);
            break;
        }

        const otherPixels = useableCanvas.width * useableCanvas.height;
        const diff = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_abs"])(otherPixels - currentPixels);
        if (diff < bestMatchingPixelsDiff) {
            bestMatchingPixelsDiff = diff;
            bestMatchingOne = {
                canvas: useableCanvas,
                context: useableContext,
                index: i,
            };
        }
    }

    // Ok none matching, reuse one though
    if (!canvas && bestMatchingOne) {
        canvas = bestMatchingOne.canvas;
        context = bestMatchingOne.context;
        canvas.width = w;
        canvas.height = h;
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["fastArrayDelete"])(freeCanvasList, bestMatchingOne.index);
    }

    // Reset context
    if (context) {
        // Restore past state
        context.restore();
        context.save();
        context.clearRect(0, 0, canvas.width, canvas.height);

        delete canvas.style.width;
        delete canvas.style.height;
    }

    // None found , create new one
    if (!canvas) {
        canvas = document.createElement("canvas");
        context = canvas.getContext("2d" /*, { alpha } */);

        canvas.width = w;
        canvas.height = h;

        // Initial state
        context.save();
    }

    canvas.label = label;

    if (smooth) {
        enableImageSmoothing(context);
    } else {
        disableImageSmoothing(context);
    }

    if (reusable) {
        registerCanvas(canvas, context);
    }

    return [canvas, context];
}

/**
 * Frees a canvas
 * @param {HTMLCanvasElement} canvas
 */
function registerCanvas(canvas, context) {
    registeredCanvas.push({ canvas, context });

    bufferCount += 1;
    vramUsage += getBufferVramUsageBytes(canvas);
}

/**
 * Frees a canvas
 * @param {HTMLCanvasElement} canvas
 */
function freeCanvas(canvas) {
    window.assert(canvas, "Canvas is empty");

    let index = -1;
    let data = null;
    for (let i = 0; i < registeredCanvas.length; ++i) {
        if (registeredCanvas[i].canvas === canvas) {
            index = i;
            data = registeredCanvas[i];
            break;
        }
    }

    if (index < 0) {
        logger.error("Tried to free unregistered canvas of size", canvas.width, canvas.height);
        return;
    }
    Object(_utils__WEBPACK_IMPORTED_MODULE_2__["fastArrayDelete"])(registeredCanvas, index);
    freeCanvasList.push(data);

    bufferCount -= 1;
    vramUsage -= getBufferVramUsageBytes(canvas);
}


/***/ }),

/***/ "./src/js/core/builtins.js":
/*!*********************************!*\
  !*** ./src/js/core/builtins.js ***!
  \*********************************/
/*! exports provided: JSON_stringify, JSON_parse, Math_radians, Math_degrees, performanceNow, Math_abs, Math_ceil, Math_floor, Math_round, Math_sign, Math_sqrt, Math_min, Math_max, Math_sin, Math_cos, Math_tan, Math_hypot, Math_atan2, Math_pow, Math_random, Math_exp, Math_log10, Math_PI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSON_stringify", function() { return JSON_stringify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSON_parse", function() { return JSON_parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_radians", function() { return Math_radians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_degrees", function() { return Math_degrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "performanceNow", function() { return performanceNow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_abs", function() { return Math_abs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_ceil", function() { return Math_ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_floor", function() { return Math_floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_round", function() { return Math_round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_sign", function() { return Math_sign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_sqrt", function() { return Math_sqrt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_min", function() { return Math_min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_max", function() { return Math_max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_sin", function() { return Math_sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_cos", function() { return Math_cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_tan", function() { return Math_tan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_hypot", function() { return Math_hypot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_atan2", function() { return Math_atan2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_pow", function() { return Math_pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_random", function() { return Math_random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_exp", function() { return Math_exp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_log10", function() { return Math_log10; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math_PI", function() { return Math_PI; });
// Store the original version of all builtins to prevent modification

const JSON_stringify = JSON.stringify.bind(JSON);
const JSON_parse = JSON.parse.bind(JSON);

function Math_radians(degrees) {
    return (degrees * Math_PI) / 180.0;
}

function Math_degrees(radians) {
    return (radians * 180.0) / Math_PI;
}

const performanceNow = performance.now.bind(performance);

const Math_abs = Math.abs.bind(Math);
const Math_ceil = Math.ceil.bind(Math);
const Math_floor = Math.floor.bind(Math);
const Math_round = Math.round.bind(Math);
const Math_sign = Math.sign.bind(Math);
const Math_sqrt = Math.sqrt.bind(Math);
const Math_min = Math.min.bind(Math);
const Math_max = Math.max.bind(Math);
const Math_sin = Math.sin.bind(Math);
const Math_cos = Math.cos.bind(Math);
const Math_tan = Math.tan.bind(Math);
const Math_hypot = Math.hypot.bind(Math);
const Math_atan2 = Math.atan2.bind(Math);
const Math_pow = Math.pow.bind(Math);
const Math_random = Math.random.bind(Math);
const Math_exp = Math.exp.bind(Math);
const Math_log10 = Math.log10.bind(Math);

const Math_PI = 3.1415926;


/***/ }),

/***/ "./src/js/core/cachebust.js":
/*!**********************************!*\
  !*** ./src/js/core/cachebust.js ***!
  \**********************************/
/*! exports provided: cachebust */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cachebust", function() { return cachebust; });
/**
 * Generates a cachebuster string. This only modifies the path in the browser version
 * @param {string} path
 */
function cachebust(path) {
    if (false) {}
    return path;
}


/***/ }),

/***/ "./src/js/core/click_detector.js":
/*!***************************************!*\
  !*** ./src/js/core/click_detector.js ***!
  \***************************************/
/*! exports provided: MAX_MOVE_DISTANCE_PX, clickDetectorGlobals, ClickDetector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_MOVE_DISTANCE_PX", function() { return MAX_MOVE_DISTANCE_PX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clickDetectorGlobals", function() { return clickDetectorGlobals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClickDetector", function() { return ClickDetector; });
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_signal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/signal */ "./src/js/core/signal.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./src/js/core/utils.js");
/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vector */ "./src/js/core/vector.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config */ "./src/js/core/config.js");
/* harmony import */ var _platform_sound__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../platform/sound */ "./src/js/platform/sound.js");
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./globals */ "./src/js/core/globals.js");









const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_1__["createLogger"])("click_detector");

const MAX_MOVE_DISTANCE_PX = _config__WEBPACK_IMPORTED_MODULE_5__["IS_MOBILE"] ? 20 : 40;

// For debugging
const registerClickDetectors =  true && true;
if (registerClickDetectors) {
    /** @type {Array<ClickDetector>} */
    window.activeClickDetectors = [];
}

// Store active click detectors so we can cancel them
/** @type {Array<ClickDetector>} */
const ongoingClickDetectors = [];

// Store when the last touch event was registered, to avoid accepting a touch *and* a click event

let clickDetectorGlobals = {
    lastTouchTime: -1000,
};

/**
 * Click detector creation payload typehints
 * @typedef {{
 *  consumeEvents?: boolean,
 *  preventDefault?: boolean,
 *  applyCssClass?: string,
 *  captureTouchmove?: boolean,
 *  targetOnly?: boolean,
 *  maxDistance?: number,
 *  clickSound?: string,
 *  preventClick?: boolean,
 * }} ClickDetectorConstructorArgs
 */

// Detects clicks
class ClickDetector {
    /**
     *
     * @param {Element} element
     * @param {object} param1
     * @param {boolean=} param1.consumeEvents Whether to call stopPropagation
     *                                       (Useful for nested elements where the parent has a click handler as wel)
     * @param {boolean=} param1.preventDefault  Whether to call preventDefault (Usually makes the handler faster)
     * @param {string=} param1.applyCssClass The css class to add while the element is pressed
     * @param {boolean=} param1.captureTouchmove Whether to capture touchmove events as well
     * @param {boolean=} param1.targetOnly Whether to also accept clicks on child elements (e.target !== element)
     * @param {number=} param1.maxDistance The maximum distance in pixels to accept clicks
     * @param {string=} param1.clickSound Sound key to play on touchdown
     * @param {boolean=} param1.preventClick Whether to prevent click events
     */
    constructor(
        element,
        {
            consumeEvents = false,
            preventDefault = true,
            applyCssClass = "pressed",
            captureTouchmove = false,
            targetOnly = false,
            maxDistance = MAX_MOVE_DISTANCE_PX,
            clickSound = _platform_sound__WEBPACK_IMPORTED_MODULE_6__["SOUNDS"].uiClick,
            preventClick = false,
        }
    ) {
        window.assert(element, "No element given!");
        this.clickDownPosition = null;

        this.consumeEvents = consumeEvents;
        this.preventDefault = preventDefault;
        this.applyCssClass = applyCssClass;
        this.captureTouchmove = captureTouchmove;
        this.targetOnly = targetOnly;
        this.clickSound = clickSound;
        this.maxDistance = maxDistance;
        this.preventClick = preventClick;

        // Signals
        this.click = new _core_signal__WEBPACK_IMPORTED_MODULE_2__["Signal"]();
        this.rightClick = new _core_signal__WEBPACK_IMPORTED_MODULE_2__["Signal"]();
        this.touchstart = new _core_signal__WEBPACK_IMPORTED_MODULE_2__["Signal"]();
        this.touchmove = new _core_signal__WEBPACK_IMPORTED_MODULE_2__["Signal"]();
        this.touchend = new _core_signal__WEBPACK_IMPORTED_MODULE_2__["Signal"]();
        this.touchcancel = new _core_signal__WEBPACK_IMPORTED_MODULE_2__["Signal"]();

        // Simple signals which just receive the touch position
        this.touchstartSimple = new _core_signal__WEBPACK_IMPORTED_MODULE_2__["Signal"]();
        this.touchmoveSimple = new _core_signal__WEBPACK_IMPORTED_MODULE_2__["Signal"]();
        this.touchendSimple = new _core_signal__WEBPACK_IMPORTED_MODULE_2__["Signal"]();

        // Store time of touch start
        this.clickStartTime = null;

        // A click can be cancelled if another detector registers a click
        this.cancelled = false;

        this.internalBindTo(/** @type {HTMLElement} */ (element));
    }

    /**
     * Cleans up all event listeners of this detector
     */
    cleanup() {
        if (this.element) {
            if (registerClickDetectors) {
                const index = window.activeClickDetectors.indexOf(this);
                if (index < 0) {
                    logger.error("Click detector cleanup but is not active");
                } else {
                    window.activeClickDetectors.splice(index, 1);
                }
            }
            const options = this.internalGetEventListenerOptions();
            this.element.removeEventListener("touchstart", this.handlerTouchStart, options);
            this.element.removeEventListener("touchend", this.handlerTouchEnd, options);
            this.element.removeEventListener("touchcancel", this.handlerTouchCancel, options);

            this.element.removeEventListener("mouseup", this.handlerTouchStart, options);
            this.element.removeEventListener("mousedown", this.handlerTouchEnd, options);
            this.element.removeEventListener("mouseout", this.handlerTouchCancel, options);

            if (this.captureTouchmove) {
                this.element.removeEventListener("touchmove", this.handlerTouchMove, options);
                this.element.removeEventListener("mousemove", this.handlerTouchMove, options);
            }

            if (this.preventClick) {
                this.element.removeEventListener("click", this.handlerPreventClick, options);
            }

            this.click.removeAll();
            this.touchstart.removeAll();
            this.touchmove.removeAll();
            this.touchend.removeAll();
            this.touchcancel.removeAll();

            // TODO: Remove pointer captures

            this.element = null;
        }
    }

    // INTERNAL METHODS

    /**
     *
     * @param {Event} event
     */
    internalPreventClick(event) {
        window.focus();
        event.preventDefault();
    }

    /**
     * Internal method to get the options to pass to an event listener
     */
    internalGetEventListenerOptions() {
        return {
            capture: this.consumeEvents,
            passive: !this.preventDefault,
        };
    }

    /**
     * Binds the click detector to an element
     * @param {HTMLElement} element
     */
    internalBindTo(element) {
        const options = this.internalGetEventListenerOptions();

        this.handlerTouchStart = this.internalOnPointerDown.bind(this);
        this.handlerTouchEnd = this.internalOnPointerEnd.bind(this);
        this.handlerTouchMove = this.internalOnPointerMove.bind(this);
        this.handlerTouchCancel = this.internalOnTouchCancel.bind(this);

        if (this.preventClick) {
            this.handlerPreventClick = this.internalPreventClick.bind(this);
            element.addEventListener("click", this.handlerPreventClick, options);
        }

        element.addEventListener("touchstart", this.handlerTouchStart, options);
        element.addEventListener("touchend", this.handlerTouchEnd, options);
        element.addEventListener("touchcancel", this.handlerTouchCancel, options);

        element.addEventListener("mousedown", this.handlerTouchStart, options);
        element.addEventListener("mouseup", this.handlerTouchEnd, options);
        element.addEventListener("mouseout", this.handlerTouchCancel, options);

        if (this.captureTouchmove) {
            element.addEventListener("touchmove", this.handlerTouchMove, options);
            element.addEventListener("mousemove", this.handlerTouchMove, options);
        }

        if (registerClickDetectors) {
            window.activeClickDetectors.push(this);
        }
        this.element = element;
    }

    /**
     * Returns if the bound element is currently in the DOM.
     */
    internalIsDomElementAttached() {
        return this.element && document.documentElement.contains(this.element);
    }

    /**
     * Checks if the given event is relevant for this detector
     * @param {TouchEvent|MouseEvent} event
     */
    internalEventPreHandler(event, expectedRemainingTouches = 1) {
        if (!this.element) {
            // Already cleaned up
            return false;
        }

        if (this.targetOnly && event.target !== this.element) {
            // Clicked a child element
            return false;
        }

        // Stop any propagation and defaults if configured
        if (this.consumeEvents && event.cancelable) {
            event.stopPropagation();
        }

        if (this.preventDefault && event.cancelable) {
            event.preventDefault();
        }

        if (window.TouchEvent && event instanceof TouchEvent) {
            clickDetectorGlobals.lastTouchTime = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["performanceNow"])();

            // console.log("Got touches", event.targetTouches.length, "vs", expectedRemainingTouches);
            if (event.targetTouches.length !== expectedRemainingTouches) {
                return false;
            }
        }

        if (event instanceof MouseEvent) {
            if (Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["performanceNow"])() - clickDetectorGlobals.lastTouchTime < 1000.0) {
                return false;
            }
        }

        return true;
    }

    /**
     * Extracts the mous position from an event
     * @param {TouchEvent|MouseEvent} event
     * @returns {Vector} The client space position
     */
    static extractPointerPosition(event) {
        if (window.TouchEvent && event instanceof TouchEvent) {
            if (event.changedTouches.length !== 1) {
                logger.warn(
                    "Got unexpected target touches:",
                    event.targetTouches.length,
                    "->",
                    event.targetTouches
                );
                return new _vector__WEBPACK_IMPORTED_MODULE_4__["Vector"](0, 0);
            }

            const touch = event.changedTouches[0];
            return new _vector__WEBPACK_IMPORTED_MODULE_4__["Vector"](touch.clientX, touch.clientY);
        }

        if (event instanceof MouseEvent) {
            return new _vector__WEBPACK_IMPORTED_MODULE_4__["Vector"](event.clientX, event.clientY);
        }

        window.assert(false, "Got unknown event: " + event);

        return new _vector__WEBPACK_IMPORTED_MODULE_4__["Vector"](0, 0);
    }

    /**
     * Cacnels all ongoing events on this detector
     */
    cancelOngoingEvents() {
        if (this.applyCssClass && this.element) {
            this.element.classList.remove(this.applyCssClass);
        }
        this.clickDownPosition = null;
        this.clickStartTime = null;
        this.cancelled = true;
        Object(_utils__WEBPACK_IMPORTED_MODULE_3__["fastArrayDeleteValueIfContained"])(ongoingClickDetectors, this);
    }

    /**
     * Internal pointer down handler
     * @param {TouchEvent|MouseEvent} event
     */
    internalOnPointerDown(event) {
        window.focus();

        if (!this.internalEventPreHandler(event, 1)) {
            return false;
        }

        const position = /** @type {typeof ClickDetector} */ (this.constructor).extractPointerPosition(event);

        if (event instanceof MouseEvent) {
            const isRightClick = event.button === 2;
            if (isRightClick) {
                // Ignore right clicks
                this.rightClick.dispatch(position, event);
                this.cancelled = true;
                return;
            }
        }

        if (this.clickDownPosition) {
            logger.warn("Ignoring double click");
            return false;
        }

        this.cancelled = false;
        this.touchstart.dispatch(event);

        // Store where the touch started
        this.clickDownPosition = position;
        this.clickStartTime = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["performanceNow"])();
        this.touchstartSimple.dispatch(this.clickDownPosition.x, this.clickDownPosition.y);

        // If we are not currently within a click, register it
        if (ongoingClickDetectors.indexOf(this) < 0) {
            ongoingClickDetectors.push(this);
        } else {
            logger.warn("Click detector got pointer down of active pointer twice");
        }

        // If we should apply any classes, do this now
        if (this.applyCssClass) {
            this.element.classList.add(this.applyCssClass);
        }

        // If we should play any sound, do this
        if (this.clickSound) {
            _globals__WEBPACK_IMPORTED_MODULE_7__["GLOBAL_APP"].sound.playUiSound(this.clickSound);
        }

        return false;
    }

    /**
     * Internal pointer move handler
     * @param {TouchEvent|MouseEvent} event
     */
    internalOnPointerMove(event) {
        if (!this.internalEventPreHandler(event, 1)) {
            return false;
        }
        this.touchmove.dispatch(event);
        const pos = /** @type {typeof ClickDetector} */ (this.constructor).extractPointerPosition(event);
        this.touchmoveSimple.dispatch(pos.x, pos.y);
        return false;
    }

    /**
     * Internal pointer end handler
     * @param {TouchEvent|MouseEvent} event
     */
    internalOnPointerEnd(event) {
        window.focus();

        if (!this.internalEventPreHandler(event, 0)) {
            return false;
        }

        if (this.cancelled) {
            // warn(this, "Not dispatching touchend on cancelled listener");
            return false;
        }

        if (event instanceof MouseEvent) {
            const isRightClick = event.button === 2;
            if (isRightClick) {
                return;
            }
        }

        const index = ongoingClickDetectors.indexOf(this);
        if (index < 0) {
            logger.warn("Got pointer end but click detector is not in pressed state");
        } else {
            Object(_utils__WEBPACK_IMPORTED_MODULE_3__["fastArrayDelete"])(ongoingClickDetectors, index);
        }

        let dispatchClick = false;
        let dispatchClickPos = null;

        // Check for correct down position, otherwise must have pinched or so
        if (this.clickDownPosition) {
            const pos = /** @type {typeof ClickDetector} */ (this.constructor).extractPointerPosition(event);
            const distance = pos.distance(this.clickDownPosition);
            if (distance <= this.maxDistance) {
                dispatchClick = true;
                dispatchClickPos = pos;
            } else {
                // console.warn("[ClickDetector] Touch does not count as click: ms=", timeSinceStart, "-> tolerance:", tolerance, "(was", distance, ")");
            }
        }

        this.clickDownPosition = null;
        this.clickStartTime = null;

        if (this.applyCssClass) {
            this.element.classList.remove(this.applyCssClass);
        }

        // Dispatch in the end to avoid the element getting invalidated
        // Also make sure that the element is still in the dom
        if (this.internalIsDomElementAttached()) {
            this.touchend.dispatch(event);
            this.touchendSimple.dispatch();

            if (dispatchClick) {
                const detectors = ongoingClickDetectors.slice();
                for (let i = 0; i < detectors.length; ++i) {
                    detectors[i].cancelOngoingEvents();
                }
                this.click.dispatch(dispatchClickPos, event);
            }
        }
        return false;
    }

    /**
     * Internal touch cancel handler
     * @param {TouchEvent|MouseEvent} event
     */
    internalOnTouchCancel(event) {
        if (!this.internalEventPreHandler(event, 0)) {
            return false;
        }

        if (this.cancelled) {
            // warn(this, "Not dispatching touchcancel on cancelled listener");
            return false;
        }

        this.cancelOngoingEvents();
        this.touchcancel.dispatch(event);
        this.touchendSimple.dispatch(event);
        return false;
    }
}


/***/ }),

/***/ "./src/js/core/config.js":
/*!*******************************!*\
  !*** ./src/js/core/config.js ***!
  \*******************************/
/*! exports provided: IS_DEBUG, IS_DEMO, THIRDPARTY_URLS, globalConfig, IS_MOBILE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IS_DEBUG", function() { return IS_DEBUG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IS_DEMO", function() { return IS_DEMO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "THIRDPARTY_URLS", function() { return THIRDPARTY_URLS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalConfig", function() { return globalConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IS_MOBILE", function() { return IS_MOBILE; });
const IS_DEBUG =
    (typeof window !== "undefined" && window.location.search.indexOf("isdebug") >= 0) ||
    ( true &&
        typeof window !== "undefined" &&
        window.location.port === "3005" &&
        (window.location.host.indexOf("localhost:") >= 0 ||
            window.location.host.indexOf("192.168.0.") >= 0) &&
        window.location.search.indexOf("nodebug") < 0);

const IS_DEMO =
    ( false) ||
    (typeof window !== "undefined" && window.location.search.indexOf("isdemo") >= 0);

const smoothCanvas = true;

const THIRDPARTY_URLS = {
    discord: "https://discord.gg/HN7EVzV",
    github: "https://github.com/tobspr/shapez.io",

    // standaloneStorePage: "https://steam.shapez.io",
    standaloneStorePage: "https://tobspr.itch.io/shapez.io",
};

const globalConfig = {
    // Size of a single tile in Pixels.
    // NOTICE: Update webpack.production.config too!
    tileSize: 32,
    halfTileSize: 16,

    // Which dpi the assets have
    assetsDpi: 192 / 32,
    assetsSharpness: 1.2,
    shapesSharpness: 1.4,

    // Production analytics
    statisticsGraphDpi: 2.5,
    statisticsGraphSlices: 100,
    analyticsSliceDurationSeconds: 10,

    minimumTickRate: 25,
    maximumTickRate: 500,

    // Map
    mapChunkSize: 16,
    mapChunkPrerenderMinZoom: 1.15,
    mapChunkOverviewMinZoom: 0.7,

    // Belt speeds
    // NOTICE: Update webpack.production.config too!
    beltSpeedItemsPerSecond: 2,
    itemSpacingOnBelts: 0.63,
    minerSpeedItemsPerSecond: 0, // COMPUTED

    undergroundBeltMaxTilesByTier: [5, 8],

    buildingSpeeds: {
        cutter: 1 / 4,
        cutterQuad: 1 / 4,
        rotater: 1 / 1,
        rotaterCCW: 1 / 1,
        painter: 1 / 6,
        painterDouble: 1 / 8,
        sorter: 1 / 1,
        painterQuad: 1 / 8,
        mixer: 1 / 5,
        stacker: 1 / 6,
    },

    // Zooming
    initialZoom: 2,
    minZoomLevel: 0.125,
    maxZoomLevel: 4,

    // Global game speed
    gameSpeed: 1,

    warmupTimeSecondsFast: 0.1,
    warmupTimeSecondsRegular: 1,

    smoothing: {
        smoothMainCanvas: smoothCanvas && true,
        quality: "low", // Low is CRUCIAL for mobile performance!
    },

    rendering: {},

    debug: {
        /* dev:start */

        // Settings menu is generated *automatically*,
        // but does not changes globalConfig.debug if enableDebugSettings is off
        // DEFAULT VALUES:
        enableDebugSettings: true,
        
        // UI
        waitForImages: true,
        showChunkBorders: false,
        disableZoomLimits: false,
        disableShortNumbers: false,

        // FEATURE
        fastGameEnter: false,
        disableSavegameWrite: false,
        disableUnlockDialog: false,
        disableTutorialHints: false,
        disableUpgradeNotification: false,
        disableDynamicTickrate: false,

        // ASSERT
        disableInternalCheckTile: false,
        disableGetTileAsserts: false,
        disableBeltAsserts: false,

        // CHEATS
        rewardsInstant: false,
        allBuildingsUnlocked: false,
        blueprintsNoCost: true,
        upgradesNoCost: false,
        instantBelts: false,
        instantProcessors: false,
        instantMiners: false,

        // TEST
        noArtificialDelays: false,
        showEntityBounds: false,
        showAcceptorEjectors: false,
        disableMusic: false,
        doNotRenderStatics: false,
        disableLogicTicks: false,
        testClipping: false,
        testTranslations: false,
        enableEntityInspector: false,
        testAds: false,
        disableMapOverview: false,
        disableBulkOperations: false,

        // framePausesBetweenTicks: 40,

        renderForTrailer: false,
        /* dev:end */
    },

    // Secret vars
    info: {
        // Binary file salt
        file: "Ec'])@^+*9zMevK3uMV4432x9%iK'=",

        // Savegame salt
        sgSalt: "}95Q3%8/.837Lqym_BJx%q7)pAHJbF",

        // Analytics key
        analyticsApiKey: "baf6a50f0cc7dfdec5a0e21c88a1c69a4b34bc4a",
    },
};

const IS_MOBILE = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

// Automatic calculations

globalConfig.minerSpeedItemsPerSecond = globalConfig.beltSpeedItemsPerSecond / 5;

if (globalConfig.debug.disableMapOverview) {
    globalConfig.mapChunkOverviewMinZoom = 0;
    globalConfig.mapChunkPrerenderMinZoom = 0;
}

if ( true && globalConfig.debug.renderForTrailer) {
    globalConfig.debug.framePausesBetweenTicks = 32;
    // globalConfig.mapChunkOverviewMinZoom = 0.0;
    // globalConfig.mapChunkPrerenderMinZoom = globalConfig.mapChunkOverviewMinZoom;
    // globalConfig.debug.instantBelts = true;
    // globalConfig.debug.instantProcessors = true;
    // globalConfig.debug.instantMiners = true;
    globalConfig.debug.disableSavegameWrite = true;
    // globalConfig.beltSpeedItemsPerSecond *= 2;
}


/***/ }),

/***/ "./src/js/core/dpi_manager.js":
/*!************************************!*\
  !*** ./src/js/core/dpi_manager.js ***!
  \************************************/
/*! exports provided: getDeviceDPI, smoothenDpi, prepareHighDPIContext, resizeHighDPICanvas, resizeCanvas, resizeCanvasAndClear */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDeviceDPI", function() { return getDeviceDPI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "smoothenDpi", function() { return smoothenDpi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prepareHighDPIContext", function() { return prepareHighDPIContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resizeHighDPICanvas", function() { return resizeHighDPICanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resizeCanvas", function() { return resizeCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resizeCanvasAndClear", function() { return resizeCanvasAndClear; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _builtins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/js/core/utils.js");




/**
 * Returns the current dpi
 * @returns {number}
 */
function getDeviceDPI() {
    return window.devicePixelRatio || 1;
}

/**
 *
 * @param {number} dpi
 * @returns {number} Smoothed dpi
 */
function smoothenDpi(dpi) {
    if (dpi < 0.05) {
        return 0.05;
    } else if (dpi < 0.1) {
        return Object(_utils__WEBPACK_IMPORTED_MODULE_2__["round2Digits"])(dpi);
    } else if (dpi < 1) {
        return Object(_utils__WEBPACK_IMPORTED_MODULE_2__["round1Digit"])(dpi);
    } else {
        return Object(_utils__WEBPACK_IMPORTED_MODULE_2__["round1Digit"])(Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_round"])(dpi / 0.5) * 0.5);
    }
}

// Initial dpi
// setDPIMultiplicator(1);

/**
 * Prepares a context for hihg dpi rendering
 * @param {CanvasRenderingContext2D} context
 */
function prepareHighDPIContext(context, smooth = true) {
    const dpi = getDeviceDPI();
    context.scale(dpi, dpi);

    if (smooth) {
        context.imageSmoothingEnabled = true;
        context.webkitImageSmoothingEnabled = true;

        // @ts-ignore
        context.imageSmoothingQuality = _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].smoothing.quality;
    } else {
        context.imageSmoothingEnabled = false;
        context.webkitImageSmoothingEnabled = false;
    }
}

/**
 * Resizes a high dpi canvas
 * @param {HTMLCanvasElement} canvas
 * @param {number} w
 * @param {number} h
 */
function resizeHighDPICanvas(canvas, w, h, smooth = true) {
    const dpi = getDeviceDPI();

    const wNumber = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(w);
    const hNumber = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(h);

    const targetW = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(wNumber * dpi);
    const targetH = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(hNumber * dpi);

    if (targetW !== canvas.width || targetH !== canvas.height) {
        // console.log("Resize Canvas from", canvas.width, canvas.height, "to", targetW, targetH)
        canvas.width = targetW;
        canvas.height = targetH;
        canvas.style.width = wNumber + "px";
        canvas.style.height = hNumber + "px";
        prepareHighDPIContext(canvas.getContext("2d"), smooth);
    }
}

/**
 * Resizes a canvas
 * @param {HTMLCanvasElement} canvas
 * @param {number} w
 * @param {number} h
 */
function resizeCanvas(canvas, w, h, setStyle = true) {
    const actualW = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_ceil"])(w);
    const actualH = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_ceil"])(h);
    if (actualW !== canvas.width || actualH !== canvas.height) {
        canvas.width = actualW;
        canvas.height = actualH;
        if (setStyle) {
            canvas.style.width = actualW + "px";
            canvas.style.height = actualH + "px";
        }
        // console.log("Resizing canvas to", actualW, "x", actualH);
    }
}

/**
 * Resizes a canvas and makes sure its cleared
 * @param {HTMLCanvasElement} canvas
 * @param {CanvasRenderingContext2D} context
 * @param {number} w
 * @param {number} h
 */
function resizeCanvasAndClear(canvas, context, w, h) {
    const actualW = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_ceil"])(w);
    const actualH = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_ceil"])(h);
    if (actualW !== canvas.width || actualH !== canvas.height) {
        canvas.width = actualW;
        canvas.height = actualH;
        canvas.style.width = actualW + "px";
        canvas.style.height = actualH + "px";
        // console.log("Resizing canvas to", actualW, "x", actualH);
    } else {
        context.clearRect(0, 0, actualW, actualH);
    }
}


/***/ }),

/***/ "./src/js/core/draw_parameters.js":
/*!****************************************!*\
  !*** ./src/js/core/draw_parameters.js ***!
  \****************************************/
/*! exports provided: DrawParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawParameters", function() { return DrawParameters; });
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rectangle */ "./src/js/core/rectangle.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ "./src/js/core/config.js");





class DrawParameters {
    constructor({ context, visibleRect, desiredAtlasScale, zoomLevel, root }) {
        /** @type {CanvasRenderingContext2D} */
        this.context = context;

        /** @type {Rectangle} */
        this.visibleRect = visibleRect;

        /** @type {number} */
        this.desiredAtlasScale = desiredAtlasScale;

        /** @type {number} */
        this.zoomLevel = zoomLevel;

        // FIXME: Not really nice
        /** @type {GameRoot} */
        this.root = root;

        if ( true && _config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].debug.testClipping) {
            this.visibleRect = this.visibleRect.expandedInAllDirections(-100);
        }
    }
}


/***/ }),

/***/ "./src/js/core/draw_utils.js":
/*!***********************************!*\
  !*** ./src/js/core/draw_utils.js ***!
  \***********************************/
/*! exports provided: initDrawUtils, drawRotatedSprite, drawLineFast, drawLineFastClipped, hslToRgb, wrapText, rotateTrapezRightFaced, mapClampedColorValueToHex, rgbToHex */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initDrawUtils", function() { return initDrawUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawRotatedSprite", function() { return drawRotatedSprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawLineFast", function() { return drawLineFast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawLineFastClipped", function() { return drawLineFastClipped; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslToRgb", function() { return hslToRgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapText", function() { return wrapText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateTrapezRightFaced", function() { return rotateTrapezRightFaced; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapClampedColorValueToHex", function() { return mapClampedColorValueToHex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbToHex", function() { return rgbToHex; });
/* harmony import */ var _builtins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vector */ "./src/js/core/vector.js");
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rectangle */ "./src/js/core/rectangle.js");
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./logging */ "./src/js/core/logging.js");







const logger = Object(_logging__WEBPACK_IMPORTED_MODULE_3__["createLogger"])("draw_utils");

function initDrawUtils() {
    CanvasRenderingContext2D.prototype.beginRoundedRect = function (x, y, w, h, r) {
        if (r < 0.05) {
            this.beginPath();
            this.rect(x, y, w, h);
            return;
        }

        if (w < 2 * r) {
            r = w / 2;
        }
        if (h < 2 * r) {
            r = h / 2;
        }
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        // this.closePath();
    };

    CanvasRenderingContext2D.prototype.beginCircle = function (x, y, r) {
        if (r < 0.05) {
            this.beginPath();
            this.rect(x, y, 1, 1);
            return;
        }
        this.beginPath();
        this.arc(x, y, r, 0, 2.0 * _builtins__WEBPACK_IMPORTED_MODULE_0__["Math_PI"]);
    };
}

/**
 *
 * @param {object} param0
 * @param {DrawParameters} param0.parameters
 * @param {AtlasSprite} param0.sprite
 * @param {number} param0.x
 * @param {number} param0.y
 * @param {number} param0.angle
 * @param {number} param0.size
 * @param {number=} param0.offsetX
 * @param {number=} param0.offsetY
 */
function drawRotatedSprite({ parameters, sprite, x, y, angle, size, offsetX = 0, offsetY = 0 }) {
    parameters.context.translate(x, y);
    parameters.context.rotate(angle);
    sprite.drawCachedCentered(parameters, offsetX, offsetY, size, false);
    parameters.context.rotate(-angle);
    parameters.context.translate(-x, -y);
}

function drawLineFast(context, { x1, x2, y1, y2, color = null, lineSize = 1 }) {
    const dX = x2 - x1;
    const dY = y2 - y1;

    const angle = Object(_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_atan2"])(dY, dX) + 0.0 * _builtins__WEBPACK_IMPORTED_MODULE_0__["Math_PI"];
    const len = Object(_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_hypot"])(dX, dY);

    context.translate(x1, y1);
    context.rotate(angle);

    if (color) {
        context.fillStyle = color;
    }

    context.fillRect(0, -lineSize / 2, len, lineSize);

    context.rotate(-angle);
    context.translate(-x1, -y1);
}

const INSIDE = 0;
const LEFT = 1;
const RIGHT = 2;
const BOTTOM = 4;
const TOP = 8;

// https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm

function computeOutCode(x, y, xmin, xmax, ymin, ymax) {
    let code = INSIDE;

    if (x < xmin)
        // to the left of clip window
        code |= LEFT;
    else if (x > xmax)
        // to the right of clip window
        code |= RIGHT;
    if (y < ymin)
        // below the clip window
        code |= BOTTOM;
    else if (y > ymax)
        // above the clip window
        code |= TOP;

    return code;
}

// Cohen–Sutherland clipping algorithm clips a line from
// P0 = (x0, y0) to P1 = (x1, y1) against a rectangle with
// diagonal from (xmin, ymin) to (xmax, ymax).
/**
 *
 * @param {CanvasRenderingContext2D} context
 */
function drawLineFastClipped(context, rect, { x0, y0, x1, y1, color = null, lineSize = 1 }) {
    const xmin = rect.x;
    const ymin = rect.y;
    const xmax = rect.right();
    const ymax = rect.bottom();

    // compute outcodes for P0, P1, and whatever point lies outside the clip rectangle
    let outcode0 = computeOutCode(x0, y0, xmin, xmax, ymin, ymax);
    let outcode1 = computeOutCode(x1, y1, xmin, xmax, ymin, ymax);
    let accept = false;

    // eslint-disable-next-line no-constant-condition
    while (true) {
        if (!(outcode0 | outcode1)) {
            // bitwise OR is 0: both points inside window; trivially accept and exit loop
            accept = true;
            break;
        } else if (outcode0 & outcode1) {
            // bitwise AND is not 0: both points share an outside zone (LEFT, RIGHT, TOP,
            // or BOTTOM), so both must be outside window; exit loop (accept is false)
            break;
        } else {
            // failed both tests, so calculate the line segment to clip
            // from an outside point to an intersection with clip edge
            let x, y;

            // At least one endpoint is outside the clip rectangle; pick it.
            let outcodeOut = outcode0 ? outcode0 : outcode1;

            // Now find the intersection point;
            // use formulas:
            //   slope = (y1 - y0) / (x1 - x0)
            //   x = x0 + (1 / slope) * (ym - y0), where ym is ymin or ymax
            //   y = y0 + slope * (xm - x0), where xm is xmin or xmax
            // No need to worry about divide-by-zero because, in each case, the
            // outcode bit being tested guarantees the denominator is non-zero
            if (outcodeOut & TOP) {
                // point is above the clip window
                x = x0 + ((x1 - x0) * (ymax - y0)) / (y1 - y0);
                y = ymax;
            } else if (outcodeOut & BOTTOM) {
                // point is below the clip window
                x = x0 + ((x1 - x0) * (ymin - y0)) / (y1 - y0);
                y = ymin;
            } else if (outcodeOut & RIGHT) {
                // point is to the right of clip window
                y = y0 + ((y1 - y0) * (xmax - x0)) / (x1 - x0);
                x = xmax;
            } else if (outcodeOut & LEFT) {
                // point is to the left of clip window
                y = y0 + ((y1 - y0) * (xmin - x0)) / (x1 - x0);
                x = xmin;
            }

            // Now we move outside point to intersection point to clip
            // and get ready for next pass.
            if (outcodeOut == outcode0) {
                x0 = x;
                y0 = y;
                outcode0 = computeOutCode(x0, y0, xmin, xmax, ymin, ymax);
            } else {
                x1 = x;
                y1 = y;
                outcode1 = computeOutCode(x1, y1, xmin, xmax, ymin, ymax);
            }
        }
    }
    if (accept) {
        // Following functions are left for implementation by user based on
        // their platform (OpenGL/graphics.h etc.)
        // DrawRectangle(xmin, ymin, xmax, ymax);
        // LineSegment(x0, y0, x1, y1);
        drawLineFast(context, {
            x1: x0,
            y1: y0,
            x2: x1,
            y2: y1,
            color,
            lineSize,
        });
    }
}

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   {number}  h       The hue
 * @param   {number}  s       The saturation
 * @param   {number}  l       The lightness
 * @return  {Array}           The RGB representation
 */
function hslToRgb(h, s, l) {
    let r;
    let g;
    let b;

    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        // tslint:disable-next-line:no-shadowed-variable
        const hue2rgb = function (p, q, t) {
            if (t < 0) {
                t += 1;
            }
            if (t > 1) {
                t -= 1;
            }
            if (t < 1 / 6) {
                return p + (q - p) * 6 * t;
            }
            if (t < 1 / 2) {
                return q;
            }
            if (t < 2 / 3) {
                return p + (q - p) * (2 / 3 - t) * 6;
            }
            return p;
        };

        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        let p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [Object(_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_round"])(r * 255), Object(_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_round"])(g * 255), Object(_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_round"])(b * 255)];
}

function wrapText(context, text, x, y, maxWidth, lineHeight, stroke = false) {
    var words = text.split(" ");
    var line = "";

    for (var n = 0; n < words.length; n++) {
        var testLine = line + words[n] + " ";
        var metrics = context.measureText(testLine);
        var testWidth = metrics.width;
        if (testWidth > maxWidth && n > 0) {
            if (stroke) {
                context.strokeText(line, x, y);
            } else {
                context.fillText(line, x, y);
            }
            line = words[n] + " ";
            y += lineHeight;
        } else {
            line = testLine;
        }
    }

    if (stroke) {
        context.strokeText(line, x, y);
    } else {
        context.fillText(line, x, y);
    }
}

/**
 * Returns a rotated trapez, used for spotlight culling
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @param {number} leftHeight
 * @param {number} angle
 */
function rotateTrapezRightFaced(x, y, w, h, leftHeight, angle) {
    const halfY = y + h / 2;
    const points = [
        new _vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](x, halfY - leftHeight / 2),
        new _vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](x + w, y),
        new _vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](x, halfY + leftHeight / 2),
        new _vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](x + w, y + h),
    ];

    return _rectangle__WEBPACK_IMPORTED_MODULE_2__["Rectangle"].getAroundPointsRotated(points, angle);
}

/**
 * Converts values from 0 .. 255 to values like 07, 7f, 5d etc
 * @param {number} value
 * @returns {string}
 */
function mapClampedColorValueToHex(value) {
    const hex = "0123456789abcdef";
    return hex[Object(_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_floor"])(value / 16)] + hex[value % 16];
}

/**
 * Converts rgb to a hex string
 * @param {number} r
 * @param {number} g
 * @param {number} b
 * @returns {string}
 */
function rgbToHex(r, g, b) {
    return mapClampedColorValueToHex(r) + mapClampedColorValueToHex(g) + mapClampedColorValueToHex(b);
}


/***/ }),

/***/ "./src/js/core/error_handler.js":
/*!**************************************!*\
  !*** ./src/js/core/error_handler.js ***!
  \**************************************/
/*! exports provided: APPLICATION_ERROR_OCCURED */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "APPLICATION_ERROR_OCCURED", function() { return APPLICATION_ERROR_OCCURED; });
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logging */ "./src/js/core/logging.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/js/core/utils.js");




let APPLICATION_ERROR_OCCURED = false;

/**
 *
 * @param {Event|string} message
 * @param {string} source
 * @param {number} lineno
 * @param {number} colno
 * @param {Error} source
 */
function catchErrors(message, source, lineno, colno, error) {
    let fullPayload = JSON.parse(
        Object(_logging__WEBPACK_IMPORTED_MODULE_0__["stringifyObjectContainingErrors"])({
            message,
            source,
            lineno,
            colno,
            error,
        })
    );

    if (("" + message).indexOf("Script error.") >= 0) {
        console.warn("Thirdparty script error:", message);
        return;
    }

    if (("" + message).indexOf("NS_ERROR_FAILURE") >= 0) {
        console.warn("Firefox NS_ERROR_FAILURE error:", message);
        return;
    }

    if (("" + message).indexOf("Cannot read property 'postMessage' of null") >= 0) {
        console.warn("Safari can not read post message error:", message);
        return;
    }

    if (false) {}

    console.log("\n\n\n⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️\n\n\n");
    console.log("          APPLICATION CRASHED             ");
    console.log("\n\n⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️\n\n\n");

    Object(_logging__WEBPACK_IMPORTED_MODULE_0__["logSection"])("APPLICATION CRASH", "#e53935");
    console.log("Error:", message, "->", error);
    console.log("Payload:", fullPayload);

    if (window.Sentry && !window.anyModLoaded) {
        window.Sentry.withScope(scope => {
            window.Sentry.setTag("message", message);
            window.Sentry.setTag("source", source);

            window.Sentry.setExtra("message", message);
            window.Sentry.setExtra("source", source);
            window.Sentry.setExtra("lineno", lineno);
            window.Sentry.setExtra("colno", colno);
            window.Sentry.setExtra("error", error);
            window.Sentry.setExtra("fullPayload", fullPayload);

            try {
                const userName = window.localStorage.getItem("tracking_context") || null;
                window.Sentry.setTag("username", userName);
            } catch (ex) {
                // ignore
            }

            window.Sentry.captureException(error || source);
        });
    }

    if (APPLICATION_ERROR_OCCURED) {
        console.warn("ERROR: Only showing and submitting first error");
        return;
    }

    APPLICATION_ERROR_OCCURED = true;
    const element = document.createElement("div");
    element.id = "applicationError";

    const title = document.createElement("h1");
    title.innerText = "Whoops!";
    element.appendChild(title);

    const desc = document.createElement("div");
    desc.classList.add("desc");
    desc.innerHTML = `
        It seems the application crashed - I am sorry for that!<br /><br />
        An anonymized crash report has been sent, and I will have a look as soon as possible.<br /><br />
        If you have additional information how I can reproduce this error, please E-Mail me:&nbsp;
        <a href="mailto:bugs@shapez.io?title=Application+Crash">bugs@shapez.io</a>`;
    element.appendChild(desc);

    const details = document.createElement("pre");
    details.classList.add("details");
    details.innerText = (error && error.stack) || message;
    element.appendChild(details);

    const inject = function () {
        if (false) {}
        if (document.body.parentElement) {
            document.body.parentElement.appendChild(element);
        } else {
            document.body.appendChild(element);
        }
    };

    if (document.body) {
        inject();
    } else {
        setTimeout(() => {
            inject();
        }, 200);
    }

    return true;
}

window.onerror = catchErrors;


/***/ }),

/***/ "./src/js/core/explained_result.js":
/*!*****************************************!*\
  !*** ./src/js/core/explained_result.js ***!
  \*****************************************/
/*! exports provided: ExplainedResult */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExplainedResult", function() { return ExplainedResult; });
class ExplainedResult {
    constructor(result = true, reason = null, additionalProps = {}) {
        /** @type {boolean} */
        this.result = result;

        /** @type {string} */
        this.reason = reason;

        // Copy additional props
        for (const key in additionalProps) {
            this[key] = additionalProps[key];
        }
    }

    isGood() {
        return !!this.result;
    }

    isBad() {
        return !this.result;
    }

    static good() {
        return new ExplainedResult(true);
    }

    static bad(reason, additionalProps) {
        return new ExplainedResult(false, reason, additionalProps);
    }

    static requireAll(...args) {
        for (let i = 0; i < args.length; ++i) {
            const subResult = args[i].call();
            if (!subResult.isGood()) {
                return subResult;
            }
        }
        return this.good();
    }
}


/***/ }),

/***/ "./src/js/core/factory.js":
/*!********************************!*\
  !*** ./src/js/core/factory.js ***!
  \********************************/
/*! exports provided: Factory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Factory", function() { return Factory; });
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logging */ "./src/js/core/logging.js");


const logger = Object(_logging__WEBPACK_IMPORTED_MODULE_0__["createLogger"])("factory");

// simple factory pattern
class Factory {
    constructor(id) {
        this.id = id;

        // Store array as well as dictionary, to speed up lookups
        this.entries = [];
        this.entryIds = [];
        this.idToEntry = {};
    }

    getId() {
        return this.id;
    }

    register(entry) {
        // Extract id
        const id = entry.getId();
        window.assert(id, "Factory: Invalid id for class: " + entry);

        // Check duplicates
        window.assert(!this.idToEntry[id], "Duplicate factory entry for " + id);

        // Insert
        this.entries.push(entry);
        this.entryIds.push(id);
        this.idToEntry[id] = entry;
    }

    /**
     * Checks if a given id is registered
     * @param {string} id
     * @returns {boolean}
     */
    hasId(id) {
        return !!this.idToEntry[id];
    }

    /**
     * Finds an instance by a given id
     * @param {string} id
     * @returns {object}
     */
    findById(id) {
        const entry = this.idToEntry[id];
        if (!entry) {
            logger.error("Object with id", id, "is not registered on factory", this.id, "!");
            window.assert(false, "Factory: Object with id '" + id + "' is not registered!");
            return null;
        }
        return entry;
    }

    /**
     * Returns all entries
     * @returns {Array<object>}
     */
    getEntries() {
        return this.entries;
    }

    /**
     * Returns all registered ids
     * @returns {Array<string>}
     */
    getAllIds() {
        return this.entryIds;
    }

    /**
     * Returns amount of stored entries
     * @returns {number}
     */
    getNumEntries() {
        return this.entries.length;
    }
}


/***/ }),

/***/ "./src/js/core/game_state.js":
/*!***********************************!*\
  !*** ./src/js/core/game_state.js ***!
  \***********************************/
/*! exports provided: GameState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameState", function() { return GameState; });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ "./src/js/core/config.js");
/* harmony import */ var _click_detector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./click_detector */ "./src/js/core/click_detector.js");
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logging */ "./src/js/core/logging.js");
/* harmony import */ var _input_receiver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./input_receiver */ "./src/js/core/input_receiver.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ "./src/js/core/utils.js");
/* harmony import */ var _request_channel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./request_channel */ "./src/js/core/request_channel.js");
/* harmony import */ var _platform_sound__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../platform/sound */ "./src/js/platform/sound.js");










const logger = Object(_logging__WEBPACK_IMPORTED_MODULE_2__["createLogger"])("game_state");

/**
 * Basic state of the game state machine. This is the base of the whole game
 */
class GameState {
    /**
     * Constructs a new state with the given id
     * @param {string} key The id of the state. We use ids to refer to states because otherwise we get
     *                     circular references
     */
    constructor(key) {
        this.key = key;

        /** @type {StateManager} */
        this.stateManager = null;

        /** @type {Application} */
        this.app = null;

        // Store if we are currently fading out
        this.fadingOut = false;

        /** @type {Array<ClickDetector>} */
        this.clickDetectors = [];

        // Every state captures keyboard events by default
        this.inputReciever = new _input_receiver__WEBPACK_IMPORTED_MODULE_3__["InputReceiver"]("state-" + key);
        this.inputReciever.backButton.add(this.onBackButton, this);

        // A channel we can use to perform async ops
        this.asyncChannel = new _request_channel__WEBPACK_IMPORTED_MODULE_5__["RequestChannel"]();
    }

    //// GETTERS / HELPER METHODS ////

    /**
     * Returns the states key
     * @returns {string}
     */
    getKey() {
        return this.key;
    }

    /**
     * Returns the html element of the state
     * @returns {HTMLElement}
     */
    getDivElement() {
        return document.getElementById("state_" + this.key);
    }

    /**
     * Transfers to a new state
     * @param {string} stateKey The id of the new state
     */
    moveToState(stateKey, payload = {}, skipFadeOut = false) {
        if (this.fadingOut) {
            logger.warn("Skipping move to '" + stateKey + "' since already fading out");
            return;
        }

        // Clean up event listeners
        this.internalCleanUpClickDetectors();

        // Fading
        const fadeTime = this.internalGetFadeInOutTime();
        const doFade = !skipFadeOut && this.getHasFadeOut() && fadeTime !== 0;
        logger.log("Moving to", stateKey, "(fading=", doFade, ")");
        if (doFade) {
            this.htmlElement.classList.remove("arrived");
            this.fadingOut = true;
            setTimeout(() => {
                this.stateManager.moveToState(stateKey, payload);
            }, fadeTime);
        } else {
            this.stateManager.moveToState(stateKey, payload);
        }
    }

    /**
     *
     * @param {string} nextStateId
     * @param {object=} nextStatePayload
     */
    watchAdAndMoveToState(nextStateId, nextStatePayload = {}) {
        if (this.app.adProvider.getCanShowVideoAd() && this.app.isRenderable()) {
            this.moveToState(
                "WatchAdState",
                {
                    nextStateId,
                    nextStatePayload,
                },
                true
            );
        } else {
            this.moveToState(nextStateId, nextStatePayload);
        }
    }

    /**
     * Tracks clicks on a given element and calls the given callback *on this state*.
     * If you want to call another function wrap it inside a lambda.
     * @param {Element} element The element to track clicks on
     * @param {function():void} handler The handler to call
     * @param {import("./click_detector").ClickDetectorConstructorArgs=} args Click detector arguments
     */
    trackClicks(element, handler, args = {}) {
        const detector = new _click_detector__WEBPACK_IMPORTED_MODULE_1__["ClickDetector"](element, args);
        detector.click.add(handler, this);
        if (true) {
            // Append a source so we can check where the click detector is from
            // @ts-ignore
            detector._src = "state-" + this.key;
        }
        this.clickDetectors.push(detector);
    }

    /**
     * Cancels all promises on the api as well as our async channel
     */
    cancelAllAsyncOperations() {
        this.asyncChannel.cancelAll();
        // TODO
        // this.app.api.cancelRequests();
    }

    //// CALLBACKS ////

    /**
     * Callback when entering the state, to be overriddemn
     * @param {any} payload Arbitrary data passed from the state which we are transferring from
     */
    onEnter(payload) {}

    /**
     * Callback when leaving the state
     */
    onLeave() {}

    /**
     * Callback before leaving the game state or when the page is unloaded
     */
    onBeforeExit() {}

    /**
     * Callback when the app got paused (on android, this means in background)
     */
    onAppPause() {}

    /**
     * Callback when the app got resumed (on android, this means in foreground again)
     */
    onAppResume() {}

    /**
     * Render callback
     * @param {number} dt Delta time in ms since last render
     */
    onRender(dt) {}

    /**
     * Background tick callback, called while the game is inactiev
     * @param {number} dt Delta time in ms since last tick
     */
    onBackgroundTick(dt) {}

    /**
     * Called when the screen resized
     * @param {number} w window/screen width
     * @param {number} h window/screen height
     */
    onResized(w, h) {}

    /**
     * Internal backbutton handler, called when the hardware back button is pressed or
     * the escape key is pressed
     */
    onBackButton() {}

    //// INTERFACE ////

    /**
     * Should return how many mulliseconds to fade in / out the state. Not recommended to override!
     * @returns {number} Time in milliseconds to fade out
     */
    getInOutFadeTime() {
        if (_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug.noArtificialDelays) {
            return 0;
        }
        return 200;
    }

    /**
     * Should return whether to fade in the game state. This will then apply the right css classes
     * for the fadein.
     * @returns {boolean}
     */
    getHasFadeIn() {
        return true;
    }

    /**
     * Should return whether to fade out the game state. This will then apply the right css classes
     * for the fadeout and wait the delay before moving states
     * @returns {boolean}
     */
    getHasFadeOut() {
        return true;
    }

    /**
     * Returns if this state should get paused if it does not have focus
     * @returns {boolean} true to pause the updating of the game
     */
    getPauseOnFocusLost() {
        return true;
    }

    /**
     * Should return the html code of the state.
     * @returns {string}
     */
    getInnerHTML() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return "";
    }

    /**
     * Returns if the state has an unload confirmation, this is the
     * "Are you sure you want to leave the page" message.
     */
    getHasUnloadConfirmation() {
        return false;
    }

    /**
     * Should return the theme music for this state
     * @returns {string|null}
     */
    getThemeMusic() {
        return _platform_sound__WEBPACK_IMPORTED_MODULE_6__["MUSIC"].menu;
    }

    ////////////////////

    //// INTERNAL ////

    /**
     * Internal callback from the manager. Do not override!
     * @param {StateManager} stateManager
     */
    internalRegisterCallback(stateManager, app) {
        window.assert(stateManager, "No state manager");
        window.assert(app, "No app");
        this.stateManager = stateManager;
        this.app = app;
    }

    /**
     * Internal callback when entering the state. Do not override!
     * @param {any} payload Arbitrary data passed from the state which we are transferring from
     * @param {boolean} callCallback Whether to call the onEnter callback
     */
    internalEnterCallback(payload, callCallback = true) {
        Object(_logging__WEBPACK_IMPORTED_MODULE_2__["logSection"])(this.key, "#26a69a");
        this.app.inputMgr.pushReciever(this.inputReciever);

        this.htmlElement = this.getDivElement();
        this.htmlElement.classList.add("active");

        // Apply classes in the next frame so the css transition keeps up
        Object(_utils__WEBPACK_IMPORTED_MODULE_4__["waitNextFrame"])().then(() => {
            if (this.htmlElement) {
                this.htmlElement.classList.remove("fadingOut");
                this.htmlElement.classList.remove("fadingIn");
            }
        });

        // Call handler
        if (callCallback) {
            this.onEnter(payload);
        }
    }

    /**
     * Internal callback when the state is left. Do not override!
     */
    internalLeaveCallback() {
        this.onLeave();

        this.htmlElement.classList.remove("active");
        this.app.inputMgr.popReciever(this.inputReciever);
        this.internalCleanUpClickDetectors();
        this.asyncChannel.cancelAll();
    }

    /**
     * Internal callback *before* the state is left. Also is called on page unload
     */
    internalOnBeforeExitCallback() {
        this.onBeforeExit();
    }

    /**
     * Internal app pause callback
     */
    internalOnAppPauseCallback() {
        this.onAppPause();
    }

    /**
     * Internal app resume callback
     */
    internalOnAppResumeCallback() {
        this.onAppResume();
    }

    /**
     * Cleans up all click detectors
     */
    internalCleanUpClickDetectors() {
        if (this.clickDetectors) {
            for (let i = 0; i < this.clickDetectors.length; ++i) {
                this.clickDetectors[i].cleanup();
            }
            this.clickDetectors = [];
        }
    }

    /**
     * Internal method to get the HTML of the game state.
     * @returns {string}
     */
    internalGetFullHtml() {
        return this.getInnerHTML();
    }

    /**
     * Internal method to compute the time to fade in / out
     * @returns {number} time to fade in / out in ms
     */
    internalGetFadeInOutTime() {
        if ( true && _config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug.fastGameEnter) {
            return 1;
        }
        if ( true && _config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug.noArtificialDelays) {
            return 1;
        }
        return this.getInOutFadeTime();
    }
}


/***/ }),

/***/ "./src/js/core/global_registries.js":
/*!******************************************!*\
  !*** ./src/js/core/global_registries.js ***!
  \******************************************/
/*! exports provided: gMetaBuildingRegistry, gBuildingsByCategory, gComponentRegistry, gGameSpeedRegistry, gItemRegistry, initBuildingsByCategory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gMetaBuildingRegistry", function() { return gMetaBuildingRegistry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gBuildingsByCategory", function() { return gBuildingsByCategory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gComponentRegistry", function() { return gComponentRegistry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gGameSpeedRegistry", function() { return gGameSpeedRegistry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gItemRegistry", function() { return gItemRegistry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initBuildingsByCategory", function() { return initBuildingsByCategory; });
/* harmony import */ var _singleton_factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./singleton_factory */ "./src/js/core/singleton_factory.js");
/* harmony import */ var _factory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./factory */ "./src/js/core/factory.js");





// These factories are here to remove circular dependencies

/** @type {SingletonFactoryTemplate<MetaBuilding>} */
let gMetaBuildingRegistry = new _singleton_factory__WEBPACK_IMPORTED_MODULE_0__["SingletonFactory"]();

/** @type {Object.<string, Array<typeof MetaBuilding>>} */
let gBuildingsByCategory = null;

/** @type {FactoryTemplate<Component>} */
let gComponentRegistry = new _factory__WEBPACK_IMPORTED_MODULE_1__["Factory"]("component");

/** @type {FactoryTemplate<BaseGameSpeed>} */
let gGameSpeedRegistry = new _factory__WEBPACK_IMPORTED_MODULE_1__["Factory"]("gamespeed");

/** @type {FactoryTemplate<BaseItem>} */
let gItemRegistry = new _factory__WEBPACK_IMPORTED_MODULE_1__["Factory"]("item");

// Helpers

/**
 * @param {Object.<string, Array<typeof MetaBuilding>>} buildings
 */
function initBuildingsByCategory(buildings) {
    gBuildingsByCategory = buildings;
}


/***/ }),

/***/ "./src/js/core/globals.js":
/*!********************************!*\
  !*** ./src/js/core/globals.js ***!
  \********************************/
/*! exports provided: GLOBAL_APP, setGlobalApp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLOBAL_APP", function() { return GLOBAL_APP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setGlobalApp", function() { return setGlobalApp; });


/**
 * Used for the bug reporter, and the click detector which both have no handles to this.
 * It would be nicer to have no globals, but this is the only one. I promise!
 * @type {Application} */
let GLOBAL_APP = null;

/**
 * @param {Application} app
 */
function setGlobalApp(app) {
    window.assert(!GLOBAL_APP, "Create application twice!");
    GLOBAL_APP = app;
}


/***/ }),

/***/ "./src/js/core/input_distributor.js":
/*!******************************************!*\
  !*** ./src/js/core/input_distributor.js ***!
  \******************************************/
/*! exports provided: InputDistributor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InputDistributor", function() { return InputDistributor; });
/* harmony import */ var _signal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signal */ "./src/js/core/signal.js");
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logging */ "./src/js/core/logging.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/js/core/utils.js");






const logger = Object(_logging__WEBPACK_IMPORTED_MODULE_1__["createLogger"])("input_distributor");

class InputDistributor {
    /**
     *
     * @param {Application} app
     */
    constructor(app) {
        this.app = app;

        /** @type {Array<InputReceiver>} */
        this.recieverStack = [];

        /** @type {Array<function(any) : boolean>} */
        this.filters = [];

        /**
         * All keys which are currently down
         */
        this.keysDown = new Set();

        this.bindToEvents();
    }

    /**
     * Attaches a new filter which can filter and reject events
     * @param {function(any): boolean} filter
     */
    installFilter(filter) {
        this.filters.push(filter);
    }

    /**
     * Removes an attached filter
     * @param {function(any) : boolean} filter
     */
    dismountFilter(filter) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["fastArrayDeleteValue"])(this.filters, filter);
    }

    /**
     * @param {InputReceiver} reciever
     */
    pushReciever(reciever) {
        if (this.isRecieverAttached(reciever)) {
            window.assert(false, "Can not add reciever " + reciever.context + " twice");
            logger.error("Can not add reciever", reciever.context, "twice");
            return;
        }
        this.recieverStack.push(reciever);

        if (this.recieverStack.length > 10) {
            logger.error(
                "Reciever stack is huge, probably some dead receivers arround:",
                this.recieverStack.map(x => x.context)
            );
        }
    }

    /**
     * @param {InputReceiver} reciever
     */
    popReciever(reciever) {
        if (this.recieverStack.indexOf(reciever) < 0) {
            window.assert(false, "Can not pop reciever " + reciever.context + "  since its not contained");
            logger.error("Can not pop reciever", reciever.context, "since its not contained");
            return;
        }
        if (this.recieverStack[this.recieverStack.length - 1] !== reciever) {
            logger.warn(
                "Popping reciever",
                reciever.context,
                "which is not on top of the stack. Stack is: ",
                this.recieverStack.map(x => x.context)
            );
        }
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["arrayDeleteValue"])(this.recieverStack, reciever);
    }

    /**
     * @param {InputReceiver} reciever
     */
    isRecieverAttached(reciever) {
        return this.recieverStack.indexOf(reciever) >= 0;
    }

    /**
     * @param {InputReceiver} reciever
     */
    isRecieverOnTop(reciever) {
        return (
            this.isRecieverAttached(reciever) &&
            this.recieverStack[this.recieverStack.length - 1] === reciever
        );
    }

    /**
     * @param {InputReceiver} reciever
     */
    makeSureAttachedAndOnTop(reciever) {
        this.makeSureDetached(reciever);
        this.pushReciever(reciever);
    }

    /**
     * @param {InputReceiver} reciever
     */
    makeSureDetached(reciever) {
        if (this.isRecieverAttached(reciever)) {
            Object(_utils__WEBPACK_IMPORTED_MODULE_2__["arrayDeleteValue"])(this.recieverStack, reciever);
        }
    }

    /**
     *
     * @param {InputReceiver} reciever
     */
    destroyReceiver(reciever) {
        this.makeSureDetached(reciever);
        reciever.cleanup();
    }

    // Internal

    getTopReciever() {
        if (this.recieverStack.length > 0) {
            return this.recieverStack[this.recieverStack.length - 1];
        }
        return null;
    }

    bindToEvents() {
        window.addEventListener("popstate", this.handleBackButton.bind(this), false);
        document.addEventListener("backbutton", this.handleBackButton.bind(this), false);

        window.addEventListener("keydown", this.handleKeyMouseDown.bind(this));
        window.addEventListener("keyup", this.handleKeyMouseUp.bind(this));

        window.addEventListener("mousedown", this.handleKeyMouseDown.bind(this));
        window.addEventListener("mouseup", this.handleKeyMouseUp.bind(this));

        window.addEventListener("blur", this.handleBlur.bind(this));
    }

    forwardToReceiver(eventId, payload = null) {
        // Check filters
        for (let i = 0; i < this.filters.length; ++i) {
            if (!this.filters[i](eventId)) {
                return _signal__WEBPACK_IMPORTED_MODULE_0__["STOP_PROPAGATION"];
            }
        }

        const reciever = this.getTopReciever();
        if (!reciever) {
            logger.warn("Dismissing event because not reciever was found:", eventId);
            return;
        }
        const signal = reciever[eventId];
        window.assert(signal instanceof _signal__WEBPACK_IMPORTED_MODULE_0__["Signal"], "Not a valid event id");
        return signal.dispatch(payload);
    }

    /**
     * @param {Event} event
     */
    handleBackButton(event) {
        event.preventDefault();
        event.stopPropagation();
        this.forwardToReceiver("backButton");
    }

    /**
     * Handles when the page got blurred
     */
    handleBlur() {
        this.forwardToReceiver("pageBlur", {});
        this.keysDown.clear();
    }

    /**
     * @param {KeyboardEvent | MouseEvent} event
     */
    handleKeyMouseDown(event) {
        const keyCode = event instanceof MouseEvent ? event.button + 1 : event.keyCode;
        if (
            keyCode === 4 || // MB4
            keyCode === 5 || // MB5
            keyCode === 9 || // TAB
            keyCode === 16 || // SHIFT
            keyCode === 17 || // CTRL
            keyCode === 18 || // ALT
            (keyCode >= 112 && keyCode < 122) // F1 - F10
        ) {
            event.preventDefault();
        }

        const isInitial = !this.keysDown.has(keyCode);
        this.keysDown.add(keyCode);

        if (
            this.forwardToReceiver("keydown", {
                keyCode: keyCode,
                shift: event.shiftKey,
                alt: event.altKey,
                initial: isInitial,
                event,
            }) === _signal__WEBPACK_IMPORTED_MODULE_0__["STOP_PROPAGATION"]
        ) {
            return;
        }

        if (keyCode === 27) {
            // Escape key
            event.preventDefault();
            event.stopPropagation();
            return this.forwardToReceiver("backButton");
        }
    }

    /**
     * @param {KeyboardEvent | MouseEvent} event
     */
    handleKeyMouseUp(event) {
        const keyCode = event instanceof MouseEvent ? event.button + 1 : event.keyCode;
        this.keysDown.delete(keyCode);

        this.forwardToReceiver("keyup", {
            keyCode: keyCode,
            shift: event.shiftKey,
            alt: event.altKey,
        });
    }
}


/***/ }),

/***/ "./src/js/core/input_receiver.js":
/*!***************************************!*\
  !*** ./src/js/core/input_receiver.js ***!
  \***************************************/
/*! exports provided: InputReceiver */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InputReceiver", function() { return InputReceiver; });
/* harmony import */ var _signal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signal */ "./src/js/core/signal.js");


class InputReceiver {
    constructor(context = "unknown") {
        this.context = context;

        this.backButton = new _signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]();

        this.keydown = new _signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]();
        this.keyup = new _signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]();
        this.pageBlur = new _signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]();

        // Dispatched on destroy
        this.destroyed = new _signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]();
    }

    cleanup() {
        this.backButton.removeAll();
        this.keydown.removeAll();
        this.keyup.removeAll();

        this.destroyed.dispatch();
    }
}


/***/ }),

/***/ "./src/js/core/loader.js":
/*!*******************************!*\
  !*** ./src/js/core/loader.js ***!
  \*******************************/
/*! exports provided: Loader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Loader", function() { return Loader; });
/* harmony import */ var _atlas_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./atlas_definitions */ "./src/js/core/atlas_definitions.js");
/* harmony import */ var _buffer_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer_utils */ "./src/js/core/buffer_utils.js");
/* harmony import */ var _sprites__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sprites */ "./src/js/core/sprites.js");
/* harmony import */ var _cachebust__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cachebust */ "./src/js/core/cachebust.js");
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");









const logger = Object(_logging__WEBPACK_IMPORTED_MODULE_4__["createLogger"])("loader");

const missingSpriteIds = {};

class LoaderImpl {
    constructor() {
        /** @type {Application} */
        this.app = null;

        /** @type {Map<string, BaseSprite>} */
        this.sprites = new Map();

        this.rawImages = [];
    }

    linkAppAfterBoot(app) {
        this.app = app;
        this.makeSpriteNotFoundCanvas();
    }

    /**
     * Fetches a given sprite from the cache
     * @param {string} key
     * @returns {BaseSprite}
     */
    getSpriteInternal(key) {
        const sprite = this.sprites.get(key);
        if (!sprite) {
            if (!missingSpriteIds[key]) {
                // Only show error once
                missingSpriteIds[key] = true;
                logger.error("Sprite '" + key + "' not found!");
            }
            return this.spriteNotFoundSprite;
        }
        return sprite;
    }

    /**
     * Returns an atlas sprite from the cache
     * @param {string} key
     * @returns {AtlasSprite}
     */
    getSprite(key) {
        const sprite = this.getSpriteInternal(key);
        window.assert(sprite instanceof _sprites__WEBPACK_IMPORTED_MODULE_2__["AtlasSprite"] || sprite === this.spriteNotFoundSprite, "Not an atlas sprite");
        return /** @type {AtlasSprite} */ (sprite);
    }

    /**
     * Retursn a regular sprite from the cache
     * @param {string} key
     * @returns {RegularSprite}
     */
    getRegularSprite(key) {
        const sprite = this.getSpriteInternal(key);
        window.assert(
            sprite instanceof _sprites__WEBPACK_IMPORTED_MODULE_2__["RegularSprite"] || sprite === this.spriteNotFoundSprite,
            "Not a regular sprite"
        );
        return /** @type {RegularSprite} */ (sprite);
    }

    /**
     *
     * @param {string} key
     * @returns {Promise<HTMLImageElement|null>}
     */
    internalPreloadImage(key) {
        const url = Object(_cachebust__WEBPACK_IMPORTED_MODULE_3__["cachebust"])("res/" + key);
        const image = new Image();

        let triesSoFar = 0;

        return Promise.race([
            new Promise((resolve, reject) => {
                setTimeout(reject,  true && !_core_config__WEBPACK_IMPORTED_MODULE_5__["globalConfig"].debug.waitForImages ? 500 : 10000);
            }),

            new Promise(resolve => {
                image.onload = () => {
                    image.onerror = null;
                    image.onload = null;

                    if (typeof image.decode === "function") {
                        // SAFARI: Image.decode() fails on safari with svgs -> we dont want to fail
                        // on that
                        // FIREFOX: Decode never returns if the image is in cache, so call it in background
                        image.decode().then(
                            () => null,
                            () => null
                        );
                    }
                    resolve(image);
                };

                image.onerror = reason => {
                    logger.warn("Failed to load '" + url + "':", reason);
                    if (++triesSoFar < 4) {
                        logger.log("Retrying to load image from", url);
                        image.src = url + "?try=" + triesSoFar;
                    } else {
                        logger.warn("Failed to load", url, "after", triesSoFar, "tries with reason", reason);
                        image.onerror = null;
                        image.onload = null;
                        resolve(null);
                    }
                };

                image.src = url;
            }),
        ]);
    }

    /**
     * Preloads a sprite
     * @param {string} key
     * @returns {Promise<void>}
     */
    preloadCSSSprite(key) {
        return this.internalPreloadImage(key).then(image => {
            if (key.indexOf("game_misc") >= 0) {
                // Allow access to regular sprites
                this.sprites.set(key, new _sprites__WEBPACK_IMPORTED_MODULE_2__["RegularSprite"](image, image.width, image.height));
            }
            this.rawImages.push(image);
        });
    }

    /**
     * Preloads an atlas
     * @param {AtlasDefinition} atlas
     * @returns {Promise<void>}
     */
    preloadAtlas(atlas) {
        return this.internalPreloadImage(atlas.getFullSourcePath()).then(image => {
            // @ts-ignore
            image.label = atlas.sourceFileName;
            return this.internalParseAtlas(atlas, image);
        });
    }

    /**
     *
     * @param {AtlasDefinition} atlas
     * @param {HTMLImageElement} loadedImage
     */
    internalParseAtlas(atlas, loadedImage) {
        this.rawImages.push(loadedImage);

        for (const spriteKey in atlas.sourceData) {
            const spriteData = atlas.sourceData[spriteKey];

            let sprite = /** @type {AtlasSprite} */ (this.sprites.get(spriteKey));

            if (!sprite) {
                sprite = new _sprites__WEBPACK_IMPORTED_MODULE_2__["AtlasSprite"]({
                    spriteName: spriteKey,
                });
                this.sprites.set(spriteKey, sprite);
            }

            const link = new _sprites__WEBPACK_IMPORTED_MODULE_2__["SpriteAtlasLink"]({
                packedX: spriteData.frame.x,
                packedY: spriteData.frame.y,
                packedW: spriteData.frame.w,
                packedH: spriteData.frame.h,
                packOffsetX: spriteData.spriteSourceSize.x,
                packOffsetY: spriteData.spriteSourceSize.y,
                atlas: loadedImage,
                w: spriteData.sourceSize.w,
                h: spriteData.sourceSize.h,
            });
            sprite.linksByResolution[atlas.meta.scale] = link;
        }
    }

    /**
     * Creates the links for the sprites after the atlas has been loaded. Used so we
     * don't have to store duplicate sprites.
     */
    createAtlasLinks() {
        // NOT USED
    }

    /**
     * Makes the canvas which shows the question mark, shown when a sprite was not found
     */
    makeSpriteNotFoundCanvas() {
        const dims = 128;

        const [canvas, context] = Object(_buffer_utils__WEBPACK_IMPORTED_MODULE_1__["makeOffscreenBuffer"])(dims, dims, {
            smooth: false,
            label: "not-found-sprite",
        });
        context.fillStyle = "#f77";
        context.fillRect(0, 0, dims, dims);

        context.textAlign = "center";
        context.textBaseline = "middle";
        context.fillStyle = "#eee";
        context.font = "25px Arial";
        context.fillText("???", dims / 2, dims / 2);

        // TODO: Not sure why this is set here
        // @ts-ignore
        canvas.src = "not-found";

        const resolutions = ["0.1", "0.25", "0.5", "0.75", "1"];
        const sprite = new _sprites__WEBPACK_IMPORTED_MODULE_2__["AtlasSprite"]({
            spriteName: "not-found",
        });

        for (let i = 0; i < resolutions.length; ++i) {
            const res = resolutions[i];
            const link = new _sprites__WEBPACK_IMPORTED_MODULE_2__["SpriteAtlasLink"]({
                packedX: 0,
                packedY: 0,
                w: dims,
                h: dims,
                packOffsetX: 0,
                packOffsetY: 0,
                packedW: dims,
                packedH: dims,
                atlas: canvas,
            });
            sprite.linksByResolution[res] = link;
        }
        this.spriteNotFoundSprite = sprite;
    }
}

const Loader = new LoaderImpl();


/***/ }),

/***/ "./src/js/core/logging.js":
/*!********************************!*\
  !*** ./src/js/core/logging.js ***!
  \********************************/
/*! exports provided: createLogger, serializeError, stringifyObjectContainingErrors, globalDebug, globalLog, globalWarn, globalError, logSection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLogger", function() { return createLogger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serializeError", function() { return serializeError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stringifyObjectContainingErrors", function() { return stringifyObjectContainingErrors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalDebug", function() { return globalDebug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalLog", function() { return globalLog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalWarn", function() { return globalWarn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalError", function() { return globalError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSection", function() { return logSection; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _builtins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./builtins */ "./src/js/core/builtins.js");



const circularJson = __webpack_require__(/*! circular-json */ "./node_modules/circular-json/build/circular-json.node.js");

/*
Logging functions
- To be extended
*/

/**
 * Base logger class
 */
class Logger {
    constructor(context) {
        this.context = context;
    }

    debug(...args) {
        globalDebug(this.context, ...args);
    }

    log(...args) {
        globalLog(this.context, ...args);
    }

    warn(...args) {
        globalWarn(this.context, ...args);
    }

    error(...args) {
        globalError(this.context, ...args);
    }
}

function createLogger(context) {
    return new Logger(context);
}

function prepareObjectForLogging(obj, maxDepth = 1) {
    if (!window.Sentry) {
        // Not required without sentry
        return obj;
    }

    if (typeof obj !== "object" && !Array.isArray(obj)) {
        return obj;
    }
    const result = {};
    for (const key in obj) {
        const val = obj[key];

        if (typeof val === "object") {
            if (maxDepth > 0) {
                result[key] = prepareObjectForLogging(val, maxDepth - 1);
            } else {
                result[key] = "[object]";
            }
        } else {
            result[key] = val;
        }
    }
    return result;
}

/**
 * Serializes an error
 * @param {Error|ErrorEvent} err
 */
function serializeError(err) {
    if (!err) {
        return null;
    }
    const result = {
        type: err.constructor.name,
    };

    if (err instanceof Error) {
        result.message = err.message;
        result.name = err.name;
        result.stack = err.stack;
        result.type = "{type.Error}";
    } else if (err instanceof ErrorEvent) {
        result.filename = err.filename;
        result.message = err.message;
        result.lineno = err.lineno;
        result.colno = err.colno;
        result.type = "{type.ErrorEvent}";

        if (err.error) {
            result.error = serializeError(err.error);
        } else {
            result.error = "{not-provided}";
        }
    } else {
        result.type = "{unkown-type:" + typeof err + "}";
    }

    return result;
}

/**
 * Serializes an event
 * @param {Event} event
 */
function serializeEvent(event) {
    let result = {
        type: "{type.Event:" + typeof event + "}",
    };
    result.eventType = event.type;
    return result;
}

/**
 * Prepares a json payload
 * @param {string} key
 * @param {any} value
 */
function preparePayload(key, value) {
    if (value instanceof Error || value instanceof ErrorEvent) {
        return serializeError(value);
    }
    if (value instanceof Event) {
        return serializeEvent(value);
    }
    if (typeof value === "undefined") {
        return null;
    }
    return value;
}

/**
 * Stringifies an object containing circular references and errors
 * @param {any} payload
 */
function stringifyObjectContainingErrors(payload) {
    return circularJson.stringify(payload, preparePayload);
}

function globalDebug(context, ...args) {
    if (true) {
        logInternal(context, console.log, prepareArgsForLogging(args));
    }
}

function globalLog(context, ...args) {
    // eslint-disable-next-line no-console
    logInternal(context, console.log, prepareArgsForLogging(args));
}

function globalWarn(context, ...args) {
    // eslint-disable-next-line no-console
    logInternal(context, console.warn, prepareArgsForLogging(args));
}

function globalError(context, ...args) {
    args = prepareArgsForLogging(args);
    // eslint-disable-next-line no-console
    logInternal(context, console.error, args);

    if (window.Sentry) {
        window.Sentry.withScope(scope => {
            scope.setExtra("args", args);
            window.Sentry.captureMessage(internalBuildStringFromArgs(args), "error");
        });
    }
}

function prepareArgsForLogging(args) {
    let result = [];
    for (let i = 0; i < args.length; ++i) {
        result.push(prepareObjectForLogging(args[i]));
    }
    return result;
}

/**
 * @param {Array<any>} args
 */
function internalBuildStringFromArgs(args) {
    let result = [];

    for (let i = 0; i < args.length; ++i) {
        let arg = args[i];
        if (
            typeof arg === "string" ||
            typeof arg === "number" ||
            typeof arg === "boolean" ||
            arg === null ||
            arg === undefined
        ) {
            result.push("" + arg);
        } else if (arg instanceof Error) {
            result.push(arg.message);
        } else {
            result.push("[object]");
        }
    }
    return result.join(" ");
}

function logSection(name, color) {
    while (name.length <= 14) {
        name = " " + name + " ";
    }
    name = name.padEnd(19, " ");

    const lineCss =
        "letter-spacing: -3px; color: " + color + "; font-size: 6px; background: #eee; color: #eee;";
    const line = "%c----------------------------";
    console.log("\n" + line + " %c" + name + " " + line + "\n", lineCss, "color: " + color, lineCss);
}

function extractHandleContext(handle) {
    let context = handle || "unknown";
    if (handle && handle.constructor && handle.constructor.name) {
        context = handle.constructor.name;
        if (context === "String") {
            context = handle;
        }
    }

    if (handle && handle.name) {
        context = handle.name;
    }
    return context + "";
}

function logInternal(handle, consoleMethod, args) {
    const context = extractHandleContext(handle).padEnd(20, " ");
    const labelColor = handle && handle.LOG_LABEL_COLOR ? handle.LOG_LABEL_COLOR : "#aaa";

    if ( true && _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug.logTimestamps) {
        const timestamp = "⏱ %c" + (Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["performanceNow"])()) + "").padEnd(6, " ") + "";
        consoleMethod.call(
            console,
            timestamp + " %c" + context,
            "color: #7f7;",
            "color: " + labelColor + ";",
            ...args
        );
    } else {
        // if (G_IS_DEV && !globalConfig.debug.disableLoggingLogSources) {
        consoleMethod.call(console, "%c" + context, "color: " + labelColor, ...args);
        // } else {
        // consoleMethod.call(console, ...args);
        // }
    }
}


/***/ }),

/***/ "./src/js/core/lzstring.js":
/*!*********************************!*\
  !*** ./src/js/core/lzstring.js ***!
  \*********************************/
/*! exports provided: compressU8, compressU8WHeader, decompressU8WHeader, compressX64, decompressX64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compressU8", function() { return compressU8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compressU8WHeader", function() { return compressU8WHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decompressU8WHeader", function() { return decompressU8WHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compressX64", function() { return compressX64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decompressX64", function() { return decompressX64; });
// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
// This work is free. You can redistribute it and/or modify it
// under the terms of the WTFPL, Version 2
// For more information see LICENSE.txt or http://www.wtfpl.net/
//
// For more information, the home page:
// http://pieroxy.net/blog/pages/lz-string/testing.html
//
// LZ-based compression algorithm, version 1.4.4

const fromCharCode = String.fromCharCode;
const hasOwnProperty = Object.prototype.hasOwnProperty;

const keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
const baseReverseDic = {};

function getBaseValue(alphabet, character) {
    if (!baseReverseDic[alphabet]) {
        baseReverseDic[alphabet] = {};
        for (let i = 0; i < alphabet.length; i++) {
            baseReverseDic[alphabet][alphabet.charAt(i)] = i;
        }
    }
    return baseReverseDic[alphabet][character];
}

//compress into uint8array (UCS-2 big endian format)
function compressU8(uncompressed) {
    let compressed = compress(uncompressed);
    let buf = new Uint8Array(compressed.length * 2); // 2 bytes per character

    for (let i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
        let current_value = compressed.charCodeAt(i);
        buf[i * 2] = current_value >>> 8;
        buf[i * 2 + 1] = current_value % 256;
    }
    return buf;
}

// Compreses with header
/**
 * @param {string} uncompressed
 * @param {number} header
 */
function compressU8WHeader(uncompressed, header) {
    let compressed = compress(uncompressed);
    let buf = new Uint8Array(2 + compressed.length * 2); // 2 bytes per character

    buf[0] = header >>> 8;
    buf[1] = header % 256;
    for (let i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
        let current_value = compressed.charCodeAt(i);
        buf[2 + i * 2] = current_value >>> 8;
        buf[2 + i * 2 + 1] = current_value % 256;
    }
    return buf;
}

//decompress from uint8array (UCS-2 big endian format)
/**
 *
 * @param {Uint8Array} compressed
 */
function decompressU8WHeader(compressed) {
    // let buf = new Array(compressed.length / 2); // 2 bytes per character
    // for (let i = 0, TotalLen = buf.length; i < TotalLen; i++) {
    //     buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
    // }

    // let result = [];
    // buf.forEach(function (c) {
    //     result.push(fromCharCode(c));
    // });
    let result = [];
    for (let i = 2, n = compressed.length; i < n; i += 2) {
        const code = compressed[i] * 256 + compressed[i + 1];
        result.push(fromCharCode(code));
    }
    return decompress(result.join(""));
}

//compress into a string that is already URI encoded
function compressX64(input) {
    if (input == null) return "";
    return _compress(input, 6, function (a) {
        return keyStrUriSafe.charAt(a);
    });
}

//decompress from an output of compressToEncodedURIComponent
function decompressX64(input) {
    if (input == null) return "";
    if (input == "") return null;
    input = input.replace(/ /g, "+");
    return _decompress(input.length, 32, function (index) {
        return getBaseValue(keyStrUriSafe, input.charAt(index));
    });
}

function compress(uncompressed) {
    return _compress(uncompressed, 16, function (a) {
        return fromCharCode(a);
    });
}

function _compress(uncompressed, bitsPerChar, getCharFromInt) {
    if (uncompressed == null) return "";
    let i,
        value,
        context_dictionary = {},
        context_dictionaryToCreate = {},
        context_c = "",
        context_wc = "",
        context_w = "",
        context_enlargeIn = 2, // Compensate for the first entry which should not count
        context_dictSize = 3,
        context_numBits = 2,
        context_data = [],
        context_data_val = 0,
        context_data_position = 0,
        ii;

    for (ii = 0; ii < uncompressed.length; ii += 1) {
        context_c = uncompressed.charAt(ii);
        if (!hasOwnProperty.call(context_dictionary, context_c)) {
            context_dictionary[context_c] = context_dictSize++;
            context_dictionaryToCreate[context_c] = true;
        }

        context_wc = context_w + context_c;
        if (hasOwnProperty.call(context_dictionary, context_wc)) {
            context_w = context_wc;
        } else {
            if (hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                if (context_w.charCodeAt(0) < 256) {
                    for (i = 0; i < context_numBits; i++) {
                        context_data_val = context_data_val << 1;
                        if (context_data_position == bitsPerChar - 1) {
                            context_data_position = 0;
                            context_data.push(getCharFromInt(context_data_val));
                            context_data_val = 0;
                        } else {
                            context_data_position++;
                        }
                    }
                    value = context_w.charCodeAt(0);
                    for (i = 0; i < 8; i++) {
                        context_data_val = (context_data_val << 1) | (value & 1);
                        if (context_data_position == bitsPerChar - 1) {
                            context_data_position = 0;
                            context_data.push(getCharFromInt(context_data_val));
                            context_data_val = 0;
                        } else {
                            context_data_position++;
                        }
                        value = value >> 1;
                    }
                } else {
                    value = 1;
                    for (i = 0; i < context_numBits; i++) {
                        context_data_val = (context_data_val << 1) | value;
                        if (context_data_position == bitsPerChar - 1) {
                            context_data_position = 0;
                            context_data.push(getCharFromInt(context_data_val));
                            context_data_val = 0;
                        } else {
                            context_data_position++;
                        }
                        value = 0;
                    }
                    value = context_w.charCodeAt(0);
                    for (i = 0; i < 16; i++) {
                        context_data_val = (context_data_val << 1) | (value & 1);
                        if (context_data_position == bitsPerChar - 1) {
                            context_data_position = 0;
                            context_data.push(getCharFromInt(context_data_val));
                            context_data_val = 0;
                        } else {
                            context_data_position++;
                        }
                        value = value >> 1;
                    }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                    context_enlargeIn = Math.pow(2, context_numBits);
                    context_numBits++;
                }
                delete context_dictionaryToCreate[context_w];
            } else {
                value = context_dictionary[context_w];
                for (i = 0; i < context_numBits; i++) {
                    context_data_val = (context_data_val << 1) | (value & 1);
                    if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                    } else {
                        context_data_position++;
                    }
                    value = value >> 1;
                }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
            }
            // Add wc to the dictionary.
            context_dictionary[context_wc] = context_dictSize++;
            context_w = String(context_c);
        }
    }

    // Output the code for w.
    if (context_w !== "") {
        if (hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
            if (context_w.charCodeAt(0) < 256) {
                for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1;
                    if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                    } else {
                        context_data_position++;
                    }
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 8; i++) {
                    context_data_val = (context_data_val << 1) | (value & 1);
                    if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                    } else {
                        context_data_position++;
                    }
                    value = value >> 1;
                }
            } else {
                value = 1;
                for (i = 0; i < context_numBits; i++) {
                    context_data_val = (context_data_val << 1) | value;
                    if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                    } else {
                        context_data_position++;
                    }
                    value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 16; i++) {
                    context_data_val = (context_data_val << 1) | (value & 1);
                    if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                    } else {
                        context_data_position++;
                    }
                    value = value >> 1;
                }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
            }
            delete context_dictionaryToCreate[context_w];
        } else {
            value = context_dictionary[context_w];
            for (i = 0; i < context_numBits; i++) {
                context_data_val = (context_data_val << 1) | (value & 1);
                if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                } else {
                    context_data_position++;
                }
                value = value >> 1;
            }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
        }
    }

    // Mark the end of the stream
    value = 2;
    for (i = 0; i < context_numBits; i++) {
        context_data_val = (context_data_val << 1) | (value & 1);
        if (context_data_position == bitsPerChar - 1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
        } else {
            context_data_position++;
        }
        value = value >> 1;
    }

    // Flush the last char
    // eslint-disable-next-line no-constant-condition
    while (true) {
        context_data_val = context_data_val << 1;
        if (context_data_position == bitsPerChar - 1) {
            context_data.push(getCharFromInt(context_data_val));
            break;
        } else context_data_position++;
    }
    return context_data.join("");
}

function decompress(compressed) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    return _decompress(compressed.length, 32768, function (index) {
        return compressed.charCodeAt(index);
    });
}

function _decompress(length, resetValue, getNextValue) {
    let dictionary = [],
        next,
        enlargeIn = 4,
        dictSize = 4,
        numBits = 3,
        entry = "",
        result = [],
        i,
        w,
        bits,
        resb,
        maxpower,
        power,
        c,
        data = { val: getNextValue(0), position: resetValue, index: 1 };

    for (i = 0; i < 3; i += 1) {
        dictionary[i] = i;
    }

    bits = 0;
    maxpower = Math.pow(2, 2);
    power = 1;
    while (power != maxpower) {
        resb = data.val & data.position;
        data.position >>= 1;
        if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
        }
        bits |= (resb > 0 ? 1 : 0) * power;
        power <<= 1;
    }

    switch ((next = bits)) {
        case 0:
            bits = 0;
            maxpower = Math.pow(2, 8);
            power = 1;
            while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
            }
            c = fromCharCode(bits);
            break;
        case 1:
            bits = 0;
            maxpower = Math.pow(2, 16);
            power = 1;
            while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
            }
            c = fromCharCode(bits);
            break;
        case 2:
            return "";
    }
    dictionary[3] = c;
    w = c;
    result.push(c);

    // eslint-disable-next-line no-constant-condition
    while (true) {
        if (data.index > length) {
            return "";
        }

        bits = 0;
        maxpower = Math.pow(2, numBits);
        power = 1;
        while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
        }

        switch ((c = bits)) {
            case 0:
                bits = 0;
                maxpower = Math.pow(2, 8);
                power = 1;
                while (power != maxpower) {
                    resb = data.val & data.position;
                    data.position >>= 1;
                    if (data.position == 0) {
                        data.position = resetValue;
                        data.val = getNextValue(data.index++);
                    }
                    bits |= (resb > 0 ? 1 : 0) * power;
                    power <<= 1;
                }

                dictionary[dictSize++] = fromCharCode(bits);
                c = dictSize - 1;
                enlargeIn--;
                break;
            case 1:
                bits = 0;
                maxpower = Math.pow(2, 16);
                power = 1;
                while (power != maxpower) {
                    resb = data.val & data.position;
                    data.position >>= 1;
                    if (data.position == 0) {
                        data.position = resetValue;
                        data.val = getNextValue(data.index++);
                    }
                    bits |= (resb > 0 ? 1 : 0) * power;
                    power <<= 1;
                }
                dictionary[dictSize++] = fromCharCode(bits);
                c = dictSize - 1;
                enlargeIn--;
                break;
            case 2:
                return result.join("");
        }

        if (enlargeIn == 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
        }

        if (dictionary[c]) {
            // @ts-ignore
            entry = dictionary[c];
        } else {
            if (c === dictSize) {
                entry = w + w.charAt(0);
            } else {
                return null;
            }
        }
        result.push(entry);

        // Add w+entry[0] to the dictionary.
        dictionary[dictSize++] = w + entry.charAt(0);
        enlargeIn--;

        w = entry;

        if (enlargeIn == 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
        }
    }
}


/***/ }),

/***/ "./src/js/core/modal_dialog_elements.js":
/*!**********************************************!*\
  !*** ./src/js/core/modal_dialog_elements.js ***!
  \**********************************************/
/*! exports provided: Dialog, DialogLoading, DialogOptionChooser, DialogWithForm */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Dialog", function() { return Dialog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DialogLoading", function() { return DialogLoading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DialogOptionChooser", function() { return DialogOptionChooser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DialogWithForm", function() { return DialogWithForm; });
/* harmony import */ var _signal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signal */ "./src/js/core/signal.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/js/core/utils.js");
/* harmony import */ var _click_detector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./click_detector */ "./src/js/core/click_detector.js");
/* harmony import */ var _platform_sound__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../platform/sound */ "./src/js/platform/sound.js");
/* harmony import */ var _input_receiver__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./input_receiver */ "./src/js/core/input_receiver.js");
/* harmony import */ var _modal_dialog_forms__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modal_dialog_forms */ "./src/js/core/modal_dialog_forms.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./config */ "./src/js/core/config.js");
/* harmony import */ var _game_key_action_mapper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../game/key_action_mapper */ "./src/js/game/key_action_mapper.js");
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./logging */ "./src/js/core/logging.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../translations */ "./src/js/translations.js");













const kbEnter = 13;
const kbCancel = 27;

const logger = Object(_logging__WEBPACK_IMPORTED_MODULE_8__["createLogger"])("dialogs");

/**
 * Basic text based dialog
 */
class Dialog {
    /**
     *
     * Constructs a new dialog with the given options
     * @param {object} param0
     * @param {Application} param0.app
     * @param {string} param0.title Title of the dialog
     * @param {string} param0.contentHTML Inner dialog html
     * @param {Array<string>} param0.buttons
     *  Button list, each button contains of up to 3 parts seperated by ':'.
     *  Part 0: The id, one of the one defined in dialog_buttons.yaml
     *  Part 1: The style, either good, bad or misc
     *  Part 2 (optional): Additional parameters seperated by '/', available are:
     *    timeout: This button is only available after some waiting time
     *    kb_enter: This button is triggered by the enter key
     *    kb_escape This button is triggered by the escape key
     * @param {string=} param0.type The dialog type, either "info" or "warn"
     * @param {boolean=} param0.closeButton Whether this dialog has a close button
     */
    constructor({ app, title, contentHTML, buttons, type = "info", closeButton = false }) {
        this.app = app;
        this.title = title;
        this.contentHTML = contentHTML;
        this.type = type;
        this.buttonIds = buttons;
        this.closeButton = closeButton;

        this.closeRequested = new _signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]();
        this.buttonSignals = {};

        for (let i = 0; i < buttons.length; ++i) {
            if ( true && _config__WEBPACK_IMPORTED_MODULE_6__["globalConfig"].debug.disableTimedButtons) {
                this.buttonIds[i] = this.buttonIds[i].replace(":timeout", "");
            }

            const buttonId = this.buttonIds[i].split(":")[0];
            this.buttonSignals[buttonId] = new _signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]();
        }

        this.timeouts = [];
        this.clickDetectors = [];

        this.inputReciever = new _input_receiver__WEBPACK_IMPORTED_MODULE_4__["InputReceiver"]("dialog-" + this.title);

        this.inputReciever.keydown.add(this.handleKeydown, this);

        this.enterHandler = null;
        this.escapeHandler = null;
    }

    /**
     * Internal keydown handler
     * @param {object} param0
     * @param {number} param0.keyCode
     * @param {boolean} param0.shift
     * @param {boolean} param0.alt
     */
    handleKeydown({ keyCode, shift, alt }) {
        if (keyCode === kbEnter && this.enterHandler) {
            this.internalButtonHandler(this.enterHandler);
            return _signal__WEBPACK_IMPORTED_MODULE_0__["STOP_PROPAGATION"];
        }

        if (keyCode === kbCancel && this.escapeHandler) {
            this.internalButtonHandler(this.escapeHandler);
            return _signal__WEBPACK_IMPORTED_MODULE_0__["STOP_PROPAGATION"];
        }
    }

    internalButtonHandler(id, ...payload) {
        this.app.inputMgr.popReciever(this.inputReciever);

        if (id !== "close-button") {
            this.buttonSignals[id].dispatch(...payload);
        }
        this.closeRequested.dispatch();
    }

    createElement() {
        const elem = document.createElement("div");
        elem.classList.add("ingameDialog");

        this.dialogElem = document.createElement("div");
        this.dialogElem.classList.add("dialogInner");

        if (this.type) {
            this.dialogElem.classList.add(this.type);
        }
        elem.appendChild(this.dialogElem);

        const title = document.createElement("h1");
        title.innerText = this.title;
        title.classList.add("title");
        this.dialogElem.appendChild(title);

        if (this.closeButton) {
            this.dialogElem.classList.add("hasCloseButton");

            const closeBtn = document.createElement("button");
            closeBtn.classList.add("closeButton");

            this.trackClicks(closeBtn, () => this.internalButtonHandler("close-button"), {
                applyCssClass: "pressedSmallElement",
            });

            title.appendChild(closeBtn);
            this.inputReciever.backButton.add(() => this.internalButtonHandler("close-button"));
        }

        const content = document.createElement("div");
        content.classList.add("content");
        content.innerHTML = this.contentHTML;
        this.dialogElem.appendChild(content);

        if (this.buttonIds.length > 0) {
            const buttons = document.createElement("div");
            buttons.classList.add("buttons");

            // Create buttons
            for (let i = 0; i < this.buttonIds.length; ++i) {
                const [buttonId, buttonStyle, rawParams] = this.buttonIds[i].split(":");

                const button = document.createElement("button");
                button.classList.add("button");
                button.classList.add("styledButton");
                button.classList.add(buttonStyle);
                button.innerText = _translations__WEBPACK_IMPORTED_MODULE_9__["T"].dialogs.buttons[buttonId];

                const params = (rawParams || "").split("/");
                const useTimeout = params.indexOf("timeout") >= 0;

                const isEnter = params.indexOf("enter") >= 0;
                const isEscape = params.indexOf("escape") >= 0;

                if (isEscape && this.closeButton) {
                    logger.warn("Showing dialog with close button, and additional cancel button");
                }

                if (useTimeout) {
                    button.classList.add("timedButton");
                    const timeout = setTimeout(() => {
                        button.classList.remove("timedButton");
                        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["arrayDeleteValue"])(this.timeouts, timeout);
                    }, 5000);
                    this.timeouts.push(timeout);
                }
                if (isEnter || isEscape) {
                    // if (this.app.settings.getShowKeyboardShortcuts()) {
                    // Show keybinding
                    const spacer = document.createElement("code");
                    spacer.classList.add("keybinding");
                    spacer.innerHTML = Object(_game_key_action_mapper__WEBPACK_IMPORTED_MODULE_7__["getStringForKeyCode"])(isEnter ? kbEnter : kbCancel);
                    button.appendChild(spacer);
                    // }

                    if (isEnter) {
                        this.enterHandler = buttonId;
                    }
                    if (isEscape) {
                        this.escapeHandler = buttonId;
                    }
                }

                this.trackClicks(button, () => this.internalButtonHandler(buttonId));
                buttons.appendChild(button);
            }

            this.dialogElem.appendChild(buttons);
        } else {
            this.dialogElem.classList.add("buttonless");
        }

        this.element = elem;
        this.app.inputMgr.pushReciever(this.inputReciever);

        return this.element;
    }

    setIndex(index) {
        this.element.style.zIndex = index;
    }

    destroy() {
        if (!this.element) {
            window.assert(false, "Tried to destroy dialog twice");
            return;
        }
        // We need to do this here, because if the backbutton event gets
        // dispatched to the modal dialogs, it will not call the internalButtonHandler,
        // and thus our receiver stays attached the whole time
        this.app.inputMgr.destroyReceiver(this.inputReciever);

        for (let i = 0; i < this.clickDetectors.length; ++i) {
            this.clickDetectors[i].cleanup();
        }
        this.clickDetectors = [];

        this.element.remove();
        this.element = null;

        for (let i = 0; i < this.timeouts.length; ++i) {
            clearTimeout(this.timeouts[i]);
        }
        this.timeouts = [];
    }

    hide() {
        this.element.classList.remove("visible");
    }

    show() {
        this.element.classList.add("visible");
    }

    /**
     * Helper method to track clicks on an element
     * @param {Element} elem
     * @param {function():void} handler
     * @param {import("./click_detector").ClickDetectorConstructorArgs=} args
     * @returns {ClickDetector}
     */
    trackClicks(elem, handler, args = {}) {
        const detector = new _click_detector__WEBPACK_IMPORTED_MODULE_2__["ClickDetector"](elem, args);
        detector.click.add(handler, this);
        this.clickDetectors.push(detector);
        return detector;
    }
}

/**
 * Dialog which simply shows a loading spinner
 */
class DialogLoading extends Dialog {
    constructor(app) {
        super({
            app,
            title: "",
            contentHTML: "",
            buttons: [],
            type: "loading",
        });

        // Loading dialog can not get closed with back button
        this.inputReciever.backButton.removeAll();
        this.inputReciever.context = "dialog-loading";
    }

    createElement() {
        const elem = document.createElement("div");
        elem.classList.add("ingameDialog");
        elem.classList.add("loadingDialog");
        this.element = elem;

        const loader = document.createElement("div");
        loader.classList.add("prefab_LoadingTextWithAnim");
        loader.classList.add("loadingIndicator");
        loader.innerText = _translations__WEBPACK_IMPORTED_MODULE_9__["T"].global.loading;
        elem.appendChild(loader);

        this.app.inputMgr.pushReciever(this.inputReciever);

        return elem;
    }
}

class DialogOptionChooser extends Dialog {
    constructor({ app, title, options }) {
        let html = "<div class='optionParent'>";

        options.options.forEach(({ value, text, desc = null, iconPrefix = null }) => {
            const descHtml = desc ? `<span class="desc">${desc}</span>` : "";
            let iconHtml = iconPrefix ? `<span class="icon icon-${iconPrefix}-${value}"></span>` : "";
            html += `
                <div class='option ${value === options.active ? "active" : ""} ${
                iconPrefix ? "hasIcon" : ""
            }' data-optionvalue='${value}'>
                    ${iconHtml}    
                    <span class='title'>${text}</span>
                    ${descHtml}
                </div>
                `;
        });

        html += "</div>";
        super({
            app,
            title,
            contentHTML: html,
            buttons: [],
            type: "info",
            closeButton: true,
        });

        this.options = options;
        this.initialOption = options.active;

        this.buttonSignals.optionSelected = new _signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]();
    }

    createElement() {
        const div = super.createElement();
        this.dialogElem.classList.add("optionChooserDialog");

        div.querySelectorAll("[data-optionvalue]").forEach(handle => {
            const value = handle.getAttribute("data-optionvalue");
            if (!handle) {
                logger.error("Failed to bind option value in dialog:", value);
                return;
            }
            // Need click detector here to forward elements, otherwise scrolling does not work
            const detector = new _click_detector__WEBPACK_IMPORTED_MODULE_2__["ClickDetector"](handle, {
                consumeEvents: false,
                preventDefault: false,
                clickSound: null,
                applyCssClass: "pressedOption",
                targetOnly: true,
            });
            this.clickDetectors.push(detector);

            if (value !== this.initialOption) {
                detector.click.add(() => {
                    const selected = div.querySelector(".option.active");
                    if (selected) {
                        selected.classList.remove("active");
                    } else {
                        logger.warn("No selected option");
                    }
                    handle.classList.add("active");
                    this.app.sound.playUiSound(_platform_sound__WEBPACK_IMPORTED_MODULE_3__["SOUNDS"].uiClick);
                    this.internalButtonHandler("optionSelected", value);
                });
            }
        });
        return div;
    }
}

class DialogWithForm extends Dialog {
    /**
     *
     * @param {object} param0
     * @param {Application} param0.app
     * @param {string} param0.title
     * @param {string} param0.desc
     * @param {string=} param0.confirmButton
     * @param {Array<FormElement>} param0.formElements
     */
    constructor({ app, title, desc, formElements, confirmButton = "ok:good" }) {
        let html = "";
        html += desc + "<br>";
        for (let i = 0; i < formElements.length; ++i) {
            html += formElements[i].getHtml();
        }

        super({
            app,
            title: title,
            contentHTML: html,
            buttons: ["cancel:bad", confirmButton],
            type: "info",
            closeButton: true,
        });
        this.confirmButtonId = confirmButton.split(":")[0];
        this.formElements = formElements;

        this.enterHandler = "ok";
    }

    internalButtonHandler(id, ...payload) {
        if (id === this.confirmButtonId) {
            if (this.hasAnyInvalid()) {
                this.dialogElem.classList.remove("errorShake");
                Object(_utils__WEBPACK_IMPORTED_MODULE_1__["waitNextFrame"])().then(() => {
                    if (this.dialogElem) {
                        this.dialogElem.classList.add("errorShake");
                    }
                });
                this.app.sound.playUiSound(_platform_sound__WEBPACK_IMPORTED_MODULE_3__["SOUNDS"].uiError);
                return;
            }
        }

        super.internalButtonHandler(id, payload);
    }

    hasAnyInvalid() {
        for (let i = 0; i < this.formElements.length; ++i) {
            if (!this.formElements[i].isValid()) {
                return true;
            }
        }
        return false;
    }

    createElement() {
        const div = super.createElement();

        for (let i = 0; i < this.formElements.length; ++i) {
            const elem = this.formElements[i];
            elem.bindEvents(div, this.clickDetectors);
        }

        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["waitNextFrame"])().then(() => {
            this.formElements[0].focus();
        });

        return div;
    }
}


/***/ }),

/***/ "./src/js/core/modal_dialog_forms.js":
/*!*******************************************!*\
  !*** ./src/js/core/modal_dialog_forms.js ***!
  \*******************************************/
/*! exports provided: FormElement, FormElementInput, FormElementCheckbox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormElement", function() { return FormElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormElementInput", function() { return FormElementInput; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormElementCheckbox", function() { return FormElementCheckbox; });
/* harmony import */ var _click_detector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./click_detector */ "./src/js/core/click_detector.js");


class FormElement {
    constructor(id, label) {
        this.id = id;
        this.label = label;
    }

    getHtml() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return "";
    }

    getFormElement(parent) {
        return parent.querySelector("[data-formId='" + this.id + "']");
    }

    bindEvents(parent, clickTrackers) {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }

    focus(parent) {}

    isValid() {
        return true;
    }

    /** @returns {any} */
    getValue() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }
}

class FormElementInput extends FormElement {
    constructor({ id, label = null, placeholder, defaultValue = "", inputType = "text", validator = null }) {
        super(id, label);
        this.placeholder = placeholder;
        this.defaultValue = defaultValue;
        this.inputType = inputType;
        this.validator = validator;

        this.element = null;
    }

    getHtml() {
        let classes = [];
        let inputType = "text";
        let maxlength = 256;
        switch (this.inputType) {
            case "text": {
                classes.push("input-text");
                break;
            }

            case "email": {
                classes.push("input-email");
                inputType = "email";
                break;
            }

            case "token": {
                classes.push("input-token");
                inputType = "text";
                maxlength = 4;
                break;
            }
        }

        return `
            <div class="formElement input">
                ${this.label ? `<label>${this.label}</label>` : ""}
                <input
                    type="${inputType}"
                    value="${this.defaultValue.replace(/["\\]+/gi, "")}"
                    maxlength="${maxlength}"
                    autocomplete="off"
                    autocorrect="off"
                    autocapitalize="off"
                    spellcheck="false"
                    class="${classes.join(" ")}"
                    placeholder="${this.placeholder.replace(/["\\]+/gi, "")}"
                    data-formId="${this.id}">
            </div>
        `;
    }

    bindEvents(parent, clickTrackers) {
        this.element = this.getFormElement(parent);
        this.element.addEventListener("input", event => this.updateErrorState());
        this.updateErrorState();
    }

    updateErrorState() {
        this.element.classList.toggle("errored", !this.isValid());
    }

    isValid() {
        return !this.validator || this.validator(this.element.value);
    }

    getValue() {
        return this.element.value;
    }

    focus() {
        this.element.focus();
    }
}

class FormElementCheckbox extends FormElement {
    constructor({ id, label, defaultValue = true }) {
        super(id, label);
        this.defaultValue = defaultValue;
        this.value = this.defaultValue;

        this.element = null;
    }

    getHtml() {
        return `
            <div class="formElement checkBoxFormElem">
            ${this.label ? `<label>${this.label}</label>` : ""}
                <div class="checkbox ${this.defaultValue ? "checked" : ""}" data-formId='${this.id}'>
                    <span class="knob"></span >
                </div >
            </div>
        `;
    }

    bindEvents(parent, clickTrackers) {
        this.element = this.getFormElement(parent);
        const detector = new _click_detector__WEBPACK_IMPORTED_MODULE_0__["ClickDetector"](this.element, {
            consumeEvents: false,
            preventDefault: false,
        });
        clickTrackers.push(detector);
        detector.click.add(this.toggle, this);
    }

    getValue() {
        return this.value;
    }

    toggle() {
        this.value = !this.value;
        this.element.classList.toggle("checked", this.value);
    }

    focus(parent) {}
}


/***/ }),

/***/ "./src/js/core/polyfills.js":
/*!**********************************!*\
  !*** ./src/js/core/polyfills.js ***!
  \**********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var whatwg_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! whatwg-fetch */ "./node_modules/whatwg-fetch/fetch.js");
/* harmony import */ var _builtins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./builtins */ "./src/js/core/builtins.js");
function mathPolyfills() {
    // Converts from degrees to radians.
    Math.radians = function (degrees) {
        return (degrees * _builtins__WEBPACK_IMPORTED_MODULE_1__["Math_PI"]) / 180.0;
    };

    // Converts from radians to degrees.
    Math.degrees = function (radians) {
        return (radians * 180.0) / _builtins__WEBPACK_IMPORTED_MODULE_1__["Math_PI"];
    };
}

function stringPolyfills() {
    // https://github.com/uxitten/polyfill/blob/master/string.polyfill.js
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart
    if (!String.prototype.padStart) {
        String.prototype.padStart = function padStart(targetLength, padString) {
            targetLength = targetLength >> 0; //truncate if number, or convert non-number to 0;
            padString = String(typeof padString !== "undefined" ? padString : " ");
            if (this.length >= targetLength) {
                return String(this);
            } else {
                targetLength = targetLength - this.length;
                if (targetLength > padString.length) {
                    padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
                }
                return padString.slice(0, targetLength) + String(this);
            }
        };
    }

    // https://github.com/uxitten/polyfill/blob/master/string.polyfill.js
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd
    if (!String.prototype.padEnd) {
        String.prototype.padEnd = function padEnd(targetLength, padString) {
            targetLength = targetLength >> 0; //floor if number or convert non-number to 0;
            padString = String(typeof padString !== "undefined" ? padString : " ");
            if (this.length > targetLength) {
                return String(this);
            } else {
                targetLength = targetLength - this.length;
                if (targetLength > padString.length) {
                    padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
                }
                return String(this) + padString.slice(0, targetLength);
            }
        };
    }
}

function objectPolyfills() {
    // https://github.com/tc39/proposal-object-values-entries/blob/master/polyfill.js

    // @ts-ignore
    const reduce = Function.bind.call(Function.call, Array.prototype.reduce);
    // @ts-ignore
    const isEnumerable = Function.bind.call(Function.call, Object.prototype.propertyIsEnumerable);
    // @ts-ignore
    const concat = Function.bind.call(Function.call, Array.prototype.concat);
    const keys = Reflect.ownKeys;

    // @ts-ignore
    if (!Object.values) {
        // @ts-ignore
        Object.values = function values(O) {
            return reduce(
                keys(O),
                (v, k) => concat(v, typeof k === "string" && isEnumerable(O, k) ? [O[k]] : []),
                []
            );
        };
    }

    if (!Object.entries) {
        Object.entries = function entries(O) {
            return reduce(
                keys(O),
                (e, k) => concat(e, typeof k === "string" && isEnumerable(O, k) ? [[k, O[k]]] : []),
                []
            );
        };
    }
}

function initPolyfills() {
    mathPolyfills();
    stringPolyfills();
    objectPolyfills();
}

function initExtensions() {
    String.prototype.replaceAll = function (search, replacement) {
        var target = this;
        return target.split(search).join(replacement);
    };
}

// Fetch polyfill



// Other polyfills
initPolyfills();
initExtensions();


/***/ }),

/***/ "./src/js/core/query_parameters.js":
/*!*****************************************!*\
  !*** ./src/js/core/query_parameters.js ***!
  \*****************************************/
/*! exports provided: queryParamOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryParamOptions", function() { return queryParamOptions; });
const queryString = __webpack_require__(/*! query-string */ "./node_modules/query-string/index.js");
const options = queryString.parse(location.search);

let queryParamOptions = {
    embedProvider: null,
};

if (options.embed) {
    queryParamOptions.embedProvider = options.embed;
}


/***/ }),

/***/ "./src/js/core/read_write_proxy.js":
/*!*****************************************!*\
  !*** ./src/js/core/read_write_proxy.js ***!
  \*****************************************/
/*! exports provided: ReadWriteProxy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReadWriteProxy", function() { return ReadWriteProxy; });
/* harmony import */ var _sensitive_utils_encrypt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sensitive_utils.encrypt */ "./src/js/core/sensitive_utils.encrypt.js");
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logging */ "./src/js/core/logging.js");
/* harmony import */ var _platform_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform/storage */ "./src/js/platform/storage.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./src/js/core/utils.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config */ "./src/js/core/config.js");
/* harmony import */ var _builtins__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _explained_result__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./explained_result */ "./src/js/core/explained_result.js");
/* harmony import */ var _lzstring__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! .//lzstring */ "./src/js/core/lzstring.js");
/* harmony import */ var _async_compression__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./async_compression */ "./src/js/core/async_compression.js");
/* harmony import */ var _savegame_savegame_compressor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../savegame/savegame_compressor */ "./src/js/savegame/savegame_compressor.js");













const logger = Object(_logging__WEBPACK_IMPORTED_MODULE_1__["createLogger"])("read_write_proxy");

const salt = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["accessNestedPropertyReverse"])(_config__WEBPACK_IMPORTED_MODULE_4__["globalConfig"], ["file", "info"]);

// Helper which only writes / reads if verify() works. Also performs migration
class ReadWriteProxy {
    constructor(app, filename) {
        /** @type {Application} */
        this.app = app;

        this.filename = filename;

        /** @type {object} */
        this.currentData = null;

        // TODO: EXTREMELY HACKY! To verify we need to do this a step later
        if ( true && _config__WEBPACK_IMPORTED_MODULE_4__["IS_DEBUG"]) {
            setTimeout(() => {
                window.assert(
                    this.verify(this.getDefaultData()).result,
                    "Verify() failed for default data: " + this.verify(this.getDefaultData()).reason
                );
            });
        }
    }

    // -- Methods to override

    /** @returns {ExplainedResult} */
    verify(data) {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return _explained_result__WEBPACK_IMPORTED_MODULE_6__["ExplainedResult"].bad();
    }

    // Should return the default data
    getDefaultData() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return {};
    }

    // Should return the current version as an integer
    getCurrentVersion() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return 0;
    }

    // Should migrate the data (Modify in place)
    /** @returns {ExplainedResult} */
    migrate(data) {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return _explained_result__WEBPACK_IMPORTED_MODULE_6__["ExplainedResult"].bad();
    }

    // -- / Methods

    // Resets whole data, returns promise
    resetEverythingAsync() {
        logger.warn("Reset data to default");
        this.currentData = this.getDefaultData();
        return this.writeAsync();
    }

    getCurrentData() {
        return this.currentData;
    }

    /**
     *
     * @param {object} obj
     */
    static serializeObject(obj) {
        const jsonString = Object(_builtins__WEBPACK_IMPORTED_MODULE_5__["JSON_stringify"])(Object(_savegame_savegame_compressor__WEBPACK_IMPORTED_MODULE_9__["compressObject"])(obj));
        const checksum = Object(_sensitive_utils_encrypt__WEBPACK_IMPORTED_MODULE_0__["sha1"])(jsonString + salt);
        return _async_compression__WEBPACK_IMPORTED_MODULE_8__["compressionPrefix"] + Object(_lzstring__WEBPACK_IMPORTED_MODULE_7__["compressX64"])(checksum + jsonString);
    }

    /**
     *
     * @param {object} text
     */
    static deserializeObject(text) {
        const decompressed = Object(_lzstring__WEBPACK_IMPORTED_MODULE_7__["decompressX64"])(text.substr(_async_compression__WEBPACK_IMPORTED_MODULE_8__["compressionPrefix"].length));
        if (!decompressed) {
            // LZ string decompression failure
            throw new Error("bad-content / decompression-failed");
        }
        if (decompressed.length < 40) {
            // String too short
            throw new Error("bad-content / payload-too-small");
        }

        // Compare stored checksum with actual checksum
        const checksum = decompressed.substring(0, 40);
        const jsonString = decompressed.substr(40);
        const desiredChecksum = Object(_sensitive_utils_encrypt__WEBPACK_IMPORTED_MODULE_0__["sha1"])(jsonString + salt);
        if (desiredChecksum !== checksum) {
            // Checksum mismatch
            throw new Error("bad-content / checksum-mismatch");
        }

        const parsed = JSON.parse(jsonString);
        const decoded = Object(_savegame_savegame_compressor__WEBPACK_IMPORTED_MODULE_9__["decompressObject"])(parsed);
        return decoded;
    }

    /**
     * Writes the data asychronously, fails if verify() fails
     * @returns {Promise<string>}
     */
    writeAsync() {
        const verifyResult = this.internalVerifyEntry(this.currentData);

        if (!verifyResult.result) {
            logger.error("Tried to write invalid data to", this.filename, "reason:", verifyResult.reason);
            return Promise.reject(verifyResult.reason);
        }
        const jsonString = Object(_builtins__WEBPACK_IMPORTED_MODULE_5__["JSON_stringify"])(Object(_savegame_savegame_compressor__WEBPACK_IMPORTED_MODULE_9__["compressObject"])(this.currentData));

        // if (!this.app.pageVisible || this.app.unloaded) {
        //     logger.log("Saving file sync because in unload handler");
        //     const checksum = sha1(jsonString + salt);
        //     let compressed = compressionPrefix + compressX64(checksum + jsonString);
        //     if (G_IS_DEV && IS_DEBUG) {
        //         compressed = jsonString;
        //     }

        //     if (!this.app.storage.writeFileSyncIfSupported(this.filename, compressed)) {
        //         return Promise.reject("Failed to write " + this.filename + " sync!");
        //     } else {
        //         logger.log("📄 Wrote (sync!)", this.filename);
        //         return Promise.resolve(compressed);
        //     }
        // }

        return _async_compression__WEBPACK_IMPORTED_MODULE_8__["asyncCompressor"]
            .compressFileAsync(jsonString)
            .then(compressed => {
                if ( true && _config__WEBPACK_IMPORTED_MODULE_4__["IS_DEBUG"]) {
                    compressed = jsonString;
                }
                return this.app.storage.writeFileAsync(this.filename, compressed);
            })
            .then(() => {
                logger.log("📄 Wrote", this.filename);
                return jsonString;
            })
            .catch(err => {
                logger.error("Failed to write", this.filename, ":", err);
                throw err;
            });
    }

    // Reads the data asynchronously, fails if verify() fails
    readAsync() {
        // Start read request
        return (
            this.app.storage
                .readFileAsync(this.filename)

                // Check for errors during read
                .catch(err => {
                    if (err === _platform_storage__WEBPACK_IMPORTED_MODULE_2__["FILE_NOT_FOUND"]) {
                        logger.log("File not found, using default data");

                        // File not found or unreadable, assume default file
                        return Promise.resolve(null);
                    }

                    return Promise.reject("file-error: " + err);
                })

                // Decrypt data (if its encrypted)
                // @ts-ignore
                .then(rawData => {
                    if (rawData == null) {
                        // So, the file has not been found, use default data
                        return Object(_builtins__WEBPACK_IMPORTED_MODULE_5__["JSON_stringify"])(Object(_savegame_savegame_compressor__WEBPACK_IMPORTED_MODULE_9__["compressObject"])(this.getDefaultData()));
                    }

                    if (rawData.startsWith(_async_compression__WEBPACK_IMPORTED_MODULE_8__["compressionPrefix"])) {
                        const decompressed = Object(_lzstring__WEBPACK_IMPORTED_MODULE_7__["decompressX64"])(rawData.substr(_async_compression__WEBPACK_IMPORTED_MODULE_8__["compressionPrefix"].length));
                        if (!decompressed) {
                            // LZ string decompression failure
                            return Promise.reject("bad-content / decompression-failed");
                        }
                        if (decompressed.length < 40) {
                            // String too short
                            return Promise.reject("bad-content / payload-too-small");
                        }

                        // Compare stored checksum with actual checksum
                        const checksum = decompressed.substring(0, 40);
                        const jsonString = decompressed.substr(40);
                        const desiredChecksum = Object(_sensitive_utils_encrypt__WEBPACK_IMPORTED_MODULE_0__["sha1"])(jsonString + salt);
                        if (desiredChecksum !== checksum) {
                            // Checksum mismatch
                            return Promise.reject("bad-content / checksum-mismatch");
                        }
                        return jsonString;
                    } else {
                        if (false) {}
                    }
                    return rawData;
                })

                // Parse JSON, this could throw but thats fine
                .then(res => {
                    try {
                        return Object(_builtins__WEBPACK_IMPORTED_MODULE_5__["JSON_parse"])(res);
                    } catch (ex) {
                        logger.error(
                            "Failed to parse file content of",
                            this.filename,
                            ":",
                            ex,
                            "(content was:",
                            res,
                            ")"
                        );
                        throw new Error("invalid-serialized-data");
                    }
                })

                // Decompress
                .then(compressed => Object(_savegame_savegame_compressor__WEBPACK_IMPORTED_MODULE_9__["decompressObject"])(compressed))

                // Verify basic structure
                .then(contents => {
                    const result = this.internalVerifyBasicStructure(contents);
                    if (!result.isGood()) {
                        return Promise.reject("verify-failed: " + result.reason);
                    }
                    return contents;
                })

                // Check version and migrate if required
                .then(contents => {
                    if (contents.version > this.getCurrentVersion()) {
                        return Promise.reject("stored-data-is-newer");
                    }

                    if (contents.version < this.getCurrentVersion()) {
                        logger.log(
                            "Trying to migrate data object from version",
                            contents.version,
                            "to",
                            this.getCurrentVersion()
                        );
                        const migrationResult = this.migrate(contents); // modify in place
                        if (migrationResult.isBad()) {
                            return Promise.reject("migration-failed: " + migrationResult.reason);
                        }
                    }
                    return contents;
                })

                // Verify
                .then(contents => {
                    const verifyResult = this.internalVerifyEntry(contents);
                    if (!verifyResult.result) {
                        logger.error(
                            "Read invalid data from",
                            this.filename,
                            "reason:",
                            verifyResult.reason,
                            "contents:",
                            contents
                        );
                        return Promise.reject("invalid-data: " + verifyResult.reason);
                    }
                    return contents;
                })

                // Store
                .then(contents => {
                    this.currentData = contents;
                    logger.log("📄 Read data with version", this.currentData.version, "from", this.filename);
                    return contents;
                })

                // Catchall
                .catch(err => {
                    return Promise.reject("Failed to read " + this.filename + ": " + err);
                })
        );
    }

    /**
     * Deletes the file
     * @returns {Promise<void>}
     */
    deleteAsync() {
        return this.app.storage.deleteFileAsync(this.filename);
    }

    // Internal

    /** @returns {ExplainedResult} */
    internalVerifyBasicStructure(data) {
        if (!data) {
            return _explained_result__WEBPACK_IMPORTED_MODULE_6__["ExplainedResult"].bad("Data is empty");
        }
        if (!Number.isInteger(data.version) || data.version < 0) {
            return _explained_result__WEBPACK_IMPORTED_MODULE_6__["ExplainedResult"].bad(
                `Data has invalid version: ${data.version} (expected ${this.getCurrentVersion()})`
            );
        }

        return _explained_result__WEBPACK_IMPORTED_MODULE_6__["ExplainedResult"].good();
    }

    /** @returns {ExplainedResult} */
    internalVerifyEntry(data) {
        if (data.version !== this.getCurrentVersion()) {
            return _explained_result__WEBPACK_IMPORTED_MODULE_6__["ExplainedResult"].bad(
                "Version mismatch, got " + data.version + " and expected " + this.getCurrentVersion()
            );
        }

        const verifyStructureError = this.internalVerifyBasicStructure(data);
        if (!verifyStructureError.isGood()) {
            return verifyStructureError;
        }
        return this.verify(data);
    }
}


/***/ }),

/***/ "./src/js/core/rectangle.js":
/*!**********************************!*\
  !*** ./src/js/core/rectangle.js ***!
  \**********************************/
/*! exports provided: Rectangle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rectangle", function() { return Rectangle; });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ "./src/js/core/config.js");
/* harmony import */ var _builtins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/js/core/utils.js");
/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vector */ "./src/js/core/vector.js");





class Rectangle {
    constructor(x = 0, y = 0, w = 0, h = 0) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }

    /**
     * Creates a rectangle from top right bottom and left offsets
     * @param {number} top
     * @param {number} right
     * @param {number} bottom
     * @param {number} left
     */
    static fromTRBL(top, right, bottom, left) {
        return new Rectangle(left, top, right - left, bottom - top);
    }

    /**
     * Constructs a new square rectangle
     * @param {number} x
     * @param {number} y
     * @param {number} size
     */
    static fromSquare(x, y, size) {
        return new Rectangle(x, y, size, size);
    }

    /**
     *
     * @param {Vector} p1
     * @param {Vector} p2
     */
    static fromTwoPoints(p1, p2) {
        const left = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_min"])(p1.x, p2.x);
        const top = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_min"])(p1.y, p2.y);
        const right = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(p1.x, p2.x);
        const bottom = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(p1.y, p2.y);
        return new Rectangle(left, top, right - left, bottom - top);
    }

    /**
     * @param {Rectangle} a
     * @param {Rectangle} b
     */
    static intersects(a, b) {
        return a.left <= b.right && b.left <= a.right && a.top <= b.bottom && b.top <= a.bottom;
    }

    /**
     * Returns a rectangle arround a rotated point
     * @param {Array<Vector>} points
     * @param {number} angle
     * @returns {Rectangle}
     */
    static getAroundPointsRotated(points, angle) {
        let minX = 1e10;
        let minY = 1e10;
        let maxX = -1e10;
        let maxY = -1e10;
        for (let i = 0; i < points.length; ++i) {
            const rotated = points[i].rotated(angle);
            minX = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_min"])(minX, rotated.x);
            minY = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_min"])(minY, rotated.y);
            maxX = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(maxX, rotated.x);
            maxY = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(maxY, rotated.y);
        }
        return new Rectangle(minX, minY, maxX - minX, maxY - minY);
    }

    // Ensures the rectangle contains the given square
    extendBySquare(centerX, centerY, halfWidth, halfHeight) {
        if (this.isEmpty()) {
            // Just assign values since this rectangle is empty
            this.x = centerX - halfWidth;
            this.y = centerY - halfHeight;
            this.w = halfWidth * 2;
            this.h = halfHeight * 2;
        } else {
            this.setLeft(Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_min"])(this.x, centerX - halfWidth));
            this.setRight(Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(this.right(), centerX + halfWidth));
            this.setTop(Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_min"])(this.y, centerY - halfHeight));
            this.setBottom(Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(this.bottom(), centerY + halfHeight));
        }
    }

    isEmpty() {
        return Object(_utils__WEBPACK_IMPORTED_MODULE_2__["epsilonCompare"])(this.w * this.h, 0);
    }

    equalsEpsilon(other, epsilon) {
        return (
            Object(_utils__WEBPACK_IMPORTED_MODULE_2__["epsilonCompare"])(this.x, other.x, epsilon) &&
            Object(_utils__WEBPACK_IMPORTED_MODULE_2__["epsilonCompare"])(this.y, other.y, epsilon) &&
            Object(_utils__WEBPACK_IMPORTED_MODULE_2__["epsilonCompare"])(this.w, other.w, epsilon) &&
            Object(_utils__WEBPACK_IMPORTED_MODULE_2__["epsilonCompare"])(this.h, other.h, epsilon)
        );
    }

    left() {
        return this.x;
    }

    right() {
        return this.x + this.w;
    }

    top() {
        return this.y;
    }

    bottom() {
        return this.y + this.h;
    }

    trbl() {
        return [this.y, this.right(), this.bottom(), this.x];
    }

    getCenter() {
        return new _vector__WEBPACK_IMPORTED_MODULE_3__["Vector"](this.x + this.w / 2, this.y + this.h / 2);
    }

    setRight(right) {
        this.w = right - this.x;
    }

    setBottom(bottom) {
        this.h = bottom - this.y;
    }

    // Sets top while keeping bottom
    setTop(top) {
        const bottom = this.bottom();
        this.y = top;
        this.setBottom(bottom);
    }

    // Sets left while keeping right
    setLeft(left) {
        const right = this.right();
        this.x = left;
        this.setRight(right);
    }

    topLeft() {
        return new _vector__WEBPACK_IMPORTED_MODULE_3__["Vector"](this.x, this.y);
    }

    bottomRight() {
        return new _vector__WEBPACK_IMPORTED_MODULE_3__["Vector"](this.right(), this.bottom());
    }

    moveBy(x, y) {
        this.x += x;
        this.y += y;
    }

    moveByVector(vec) {
        this.x += vec.x;
        this.y += vec.y;
    }

    // Returns a scaled version which also scales the position of the rectangle
    allScaled(factor) {
        return new Rectangle(this.x * factor, this.y * factor, this.w * factor, this.h * factor);
    }

    /**
     * Expands the rectangle in all directions
     * @param {number} amount
     * @returns {Rectangle} new rectangle
     */

    expandedInAllDirections(amount) {
        return new Rectangle(this.x - amount, this.y - amount, this.w + 2 * amount, this.h + 2 * amount);
    }

    // Culling helpers
    getMinStartTile() {
        return new _vector__WEBPACK_IMPORTED_MODULE_3__["Vector"](this.x, this.y).snapWorldToTile();
    }

    /**
     * Returns if the given rectangle is contained
     * @param {Rectangle} rect
     * @returns {boolean}
     */
    containsRect(rect) {
        return (
            this.x <= rect.right() &&
            rect.x <= this.right() &&
            this.y <= rect.bottom() &&
            rect.y <= this.bottom()
        );
    }

    containsRect4Params(x, y, w, h) {
        return this.x <= x + w && x <= this.right() && this.y <= y + h && y <= this.bottom();
    }

    /**
     * Returns if the rectangle contains the given circle at (x, y) with the radius (radius)
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     */
    containsCircle(x, y, radius) {
        return (
            this.x <= x + radius &&
            x - radius <= this.right() &&
            this.y <= y + radius &&
            y - radius <= this.bottom()
        );
    }

    /**
     * Returns if hte rectangle contains the given point
     * @param {number} x
     * @param {number} y
     */
    containsPoint(x, y) {
        return x >= this.x && x < this.right() && y >= this.y && y < this.bottom();
    }

    /**
     * Returns the shared area with another rectangle, or null if there is no intersection
     * @param {Rectangle} rect
     * @returns {Rectangle|null}
     */
    getUnion(rect) {
        const left = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(this.x, rect.x);
        const top = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(this.y, rect.y);

        const right = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_min"])(this.x + this.w, rect.x + rect.w);
        const bottom = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_min"])(this.y + this.h, rect.y + rect.h);

        if (right <= left || bottom <= top) {
            return null;
        }
        return Rectangle.fromTRBL(top, right, bottom, left);
    }

    /**
     * Good for caching stuff
     */
    toCompareableString() {
        return (
            Object(_utils__WEBPACK_IMPORTED_MODULE_2__["round2Digits"])(this.x) +
            "/" +
            Object(_utils__WEBPACK_IMPORTED_MODULE_2__["round2Digits"])(this.y) +
            "/" +
            Object(_utils__WEBPACK_IMPORTED_MODULE_2__["round2Digits"])(this.w) +
            "/" +
            Object(_utils__WEBPACK_IMPORTED_MODULE_2__["round2Digits"])(this.h)
        );
    }

    /**
     * Returns a new recangle in tile space which includes all tiles which are visible in this rect
     * @param {boolean=} includeHalfTiles
     * @returns {Rectangle}
     */
    toTileCullRectangle(includeHalfTiles = true) {
        let scaled = this.allScaled(1.0 / _config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize);

        if (includeHalfTiles) {
            // Increase rectangle size
            scaled = Rectangle.fromTRBL(
                Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(scaled.y),
                Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_ceil"])(scaled.right()),
                Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_ceil"])(scaled.bottom()),
                Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(scaled.x)
            );
        }

        return scaled;
    }
}


/***/ }),

/***/ "./src/js/core/request_channel.js":
/*!****************************************!*\
  !*** ./src/js/core/request_channel.js ***!
  \****************************************/
/*! exports provided: PROMISE_ABORTED, RequestChannel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROMISE_ABORTED", function() { return PROMISE_ABORTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RequestChannel", function() { return RequestChannel; });
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/js/core/utils.js");



const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_0__["createLogger"])("request_channel");

// Thrown when a request is aborted
const PROMISE_ABORTED = "promise-aborted";

class RequestChannel {
    constructor() {
        /** @type {Array<Promise>} */
        this.pendingPromises = [];
    }

    /**
     *
     * @param {Promise<any>} promise
     * @returns {Promise<any>}
     */
    watch(promise) {
        // log(this, "Added new promise:", promise, "(pending =", this.pendingPromises.length, ")");
        let cancelled = false;
        const wrappedPromise = new Promise((resolve, reject) => {
            promise.then(
                result => {
                    // Remove from pending promises
                    Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["fastArrayDeleteValueIfContained"])(this.pendingPromises, wrappedPromise);

                    // If not cancelled, resolve promise with same payload
                    if (!cancelled) {
                        resolve.call(this, result);
                    } else {
                        logger.warn("Not resolving because promise got cancelled");
                        // reject.call(this, PROMISE_ABORTED);
                    }
                },
                err => {
                    // Remove from pending promises
                    Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["fastArrayDeleteValueIfContained"])(this.pendingPromises, wrappedPromise);

                    // If not cancelled, reject promise with same payload
                    if (!cancelled) {
                        reject.call(this, err);
                    } else {
                        logger.warn("Not rejecting because promise got cancelled");
                        // reject.call(this, PROMISE_ABORTED);
                    }
                }
            );
        });

        // Add cancel handler
        // @ts-ignore
        wrappedPromise.cancel = function () {
            cancelled = true;
        };

        this.pendingPromises.push(wrappedPromise);
        return wrappedPromise;
    }

    cancelAll() {
        if (this.pendingPromises.length > 0) {
            logger.log("Cancel all pending promises (", this.pendingPromises.length, ")");
        }
        for (let i = 0; i < this.pendingPromises.length; ++i) {
            // @ts-ignore
            this.pendingPromises[i].cancel();
        }
        this.pendingPromises = [];
    }
}


/***/ }),

/***/ "./src/js/core/rng.js":
/*!****************************!*\
  !*** ./src/js/core/rng.js ***!
  \****************************/
/*! exports provided: RandomNumberGenerator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RandomNumberGenerator", function() { return RandomNumberGenerator; });
/* harmony import */ var _builtins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./builtins */ "./src/js/core/builtins.js");


// ALEA RNG

function Mash() {
    var n = 0xefc8249d;
    return function (data) {
        data = data.toString();
        for (var i = 0; i < data.length; i++) {
            n += data.charCodeAt(i);
            var h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 0x100000000; // 2^32
        }
        return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
    };
}

/**
 * @param {number|string} seed
 */
function makeNewRng(seed) {
    // Johannes Baagøe <baagoe@baagoe.com>, 2010
    var c = 1;
    var mash = Mash();
    let s0 = mash(" ");
    let s1 = mash(" ");
    let s2 = mash(" ");

    s0 -= mash(seed);
    if (s0 < 0) {
        s0 += 1;
    }
    s1 -= mash(seed);
    if (s1 < 0) {
        s1 += 1;
    }
    s2 -= mash(seed);
    if (s2 < 0) {
        s2 += 1;
    }
    mash = null;

    var random = function () {
        var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32
        s0 = s1;
        s1 = s2;
        return (s2 = t - (c = t | 0));
    };

    random.exportState = function () {
        return [s0, s1, s2, c];
    };

    random.importState = function (i) {
        s0 = +i[0] || 0;
        s1 = +i[1] || 0;
        s2 = +i[2] || 0;
        c = +i[3] || 0;
    };

    return random;
}

class RandomNumberGenerator {
    /**
     *
     * @param {number|string=} seed
     */
    constructor(seed) {
        this.internalRng = makeNewRng(seed || Object(_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_random"])());
    }

    /**
     * Re-seeds the generator
     * @param {number|string} seed
     */
    reseed(seed) {
        this.internalRng = makeNewRng(seed || Object(_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_random"])());
    }

    /**
     * @returns {number} between 0 and 1
     */
    next() {
        return this.internalRng();
    }

    /**
     * Random choice of an array
     * @param {array} array
     */
    choice(array) {
        const index = this.nextIntRange(0, array.length);
        return array[index];
    }

    /**
     * @param {number} min
     * @param {number} max
     * @returns {number} Integer in range [min, max[
     */
    nextIntRange(min, max) {
        window.assert(Number.isFinite(min), "Minimum is no integer");
        window.assert(Number.isFinite(max), "Maximum is no integer");
        window.assert(max > min, "rng: max <= min");
        return Math.floor(this.next() * (max - min) + min);
    }
    /**
     * @param {number} min
     * @param {number} max
     * @returns {number} Integer in range [min, max]
     */
    nextIntRangeInclusive(min, max) {
        window.assert(Number.isFinite(min), "Minimum is no integer");
        window.assert(Number.isFinite(max), "Maximum is no integer");
        window.assert(max > min, "rng: max <= min");
        return Math.round(this.next() * (max - min) + min);
    }

    /**
     * @param {number} min
     * @param {number} max
     * @returns {number} Number in range [min, max[
     */
    nextRange(min, max) {
        window.assert(max > min, "rng: max <= min");
        return this.next() * (max - min) + min;
    }

    /**
     * Updates the seed
     * @param {number} seed
     */
    setSeed(seed) {
        this.internalRng = makeNewRng(seed);
    }
}


/***/ }),

/***/ "./src/js/core/sensitive_utils.encrypt.js":
/*!************************************************!*\
  !*** ./src/js/core/sensitive_utils.encrypt.js ***!
  \************************************************/
/*! exports provided: decodeHashedString, sha1, getNameOfProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeHashedString", function() { return decodeHashedString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sha1", function() { return sha1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNameOfProvider", function() { return getNameOfProvider; });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ "./src/js/core/config.js");
/* harmony import */ var _lzstring__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lzstring */ "./src/js/core/lzstring.js");



const Rusha = __webpack_require__(/*! rusha */ "./node_modules/rusha/dist/rusha.js");

const encryptKey = _config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].info.sgSalt;

function decodeHashedString(s) {
    return Object(_lzstring__WEBPACK_IMPORTED_MODULE_1__["decompressX64"])(s);
}

function sha1(str) {
    return Rusha.createHash().update(str).digest("hex");
}

// Window.location.host
function getNameOfProvider() {
    return window[decodeHashedString("DYewxghgLgliB2Q")][decodeHashedString("BYewzgLgdghgtgUyA")];
}


/***/ }),

/***/ "./src/js/core/signal.js":
/*!*******************************!*\
  !*** ./src/js/core/signal.js ***!
  \*******************************/
/*! exports provided: STOP_PROPAGATION, Signal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STOP_PROPAGATION", function() { return STOP_PROPAGATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Signal", function() { return Signal; });
const STOP_PROPAGATION = "stop_propagation";

class Signal {
    constructor() {
        this.receivers = [];
        this.modifyCount = 0;
    }

    /**
     * Adds a new signal listener
     * @param {function} receiver
     * @param {object} scope
     */
    add(receiver, scope = null) {
        window.assert(receiver, "receiver is null");
        this.receivers.push({ receiver, scope });
        ++this.modifyCount;
    }

    /**
     * Dispatches the signal
     * @param  {...any} payload
     */
    dispatch() {
        const modifyState = this.modifyCount;

        const n = this.receivers.length;
        for (let i = 0; i < n; ++i) {
            const { receiver, scope } = this.receivers[i];
            if (receiver.apply(scope, arguments) === STOP_PROPAGATION) {
                return STOP_PROPAGATION;
            }

            if (modifyState !== this.modifyCount) {
                // Signal got modified during iteration
                return STOP_PROPAGATION;
            }
        }
    }

    /**
     * Removes a receiver
     * @param {function} receiver
     */
    remove(receiver) {
        let index = null;
        const n = this.receivers.length;
        for (let i = 0; i < n; ++i) {
            if (this.receivers[i].receiver === receiver) {
                index = i;
                break;
            }
        }
        window.assert(index !== null, "Receiver not found in list");
        this.receivers.splice(index, 1);
        ++this.modifyCount;
    }

    /**
     * Removes all receivers
     */
    removeAll() {
        this.receivers = [];
        ++this.modifyCount;
    }
}


/***/ }),

/***/ "./src/js/core/singleton_factory.js":
/*!******************************************!*\
  !*** ./src/js/core/singleton_factory.js ***!
  \******************************************/
/*! exports provided: SingletonFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SingletonFactory", function() { return SingletonFactory; });
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logging */ "./src/js/core/logging.js");


const logger = Object(_logging__WEBPACK_IMPORTED_MODULE_0__["createLogger"])("singleton_factory");

// simple factory pattern
class SingletonFactory {
    constructor(id) {
        this.id = id;

        // Store array as well as dictionary, to speed up lookups
        this.entries = [];
        this.idToEntry = {};
    }

    getId() {
        return this.id;
    }

    register(classHandle) {
        // First, construct instance
        const instance = new classHandle();

        // Extract id
        const id = instance.getId();
        window.assert(id, "Factory: Invalid id for class " + classHandle.name + ": " + id);

        // Check duplicates
        window.assert(!this.idToEntry[id], "Duplicate factory entry for " + id);

        // Insert
        this.entries.push(instance);
        this.idToEntry[id] = instance;
    }

    /**
     * Checks if a given id is registered
     * @param {string} id
     * @returns {boolean}
     */
    hasId(id) {
        return !!this.idToEntry[id];
    }

    /**
     * Finds an instance by a given id
     * @param {string} id
     * @returns {object}
     */
    findById(id) {
        const entry = this.idToEntry[id];
        if (!entry) {
            logger.error("Object with id", id, "is not registered!");
            window.assert(false, "Factory: Object with id '" + id + "' is not registered!");
            return null;
        }
        return entry;
    }

    /**
     * Finds an instance by its constructor (The class handle)
     * @param {object} classHandle
     * @returns {object}
     */
    findByClass(classHandle) {
        for (let i = 0; i < this.entries.length; ++i) {
            if (this.entries[i] instanceof classHandle) {
                return this.entries[i];
            }
        }
        window.assert(false, "Factory: Object not found by classHandle (classid: " + classHandle.name + ")");
        return null;
    }

    /**
     * Returns all entries
     * @returns {Array<object>}
     */
    getEntries() {
        return this.entries;
    }

    /**
     * Returns all registered ids
     * @returns {Array<string>}
     */
    getAllIds() {
        return Object.keys(this.idToEntry);
    }

    /**
     * Returns amount of stored entries
     * @returns {number}
     */
    getNumEntries() {
        return this.entries.length;
    }
}


/***/ }),

/***/ "./src/js/core/sprites.js":
/*!********************************!*\
  !*** ./src/js/core/sprites.js ***!
  \********************************/
/*! exports provided: BaseSprite, SpriteAtlasLink, AtlasSprite, RegularSprite */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseSprite", function() { return BaseSprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteAtlasLink", function() { return SpriteAtlasLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AtlasSprite", function() { return AtlasSprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RegularSprite", function() { return RegularSprite; });
/* harmony import */ var _draw_parameters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _builtins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rectangle */ "./src/js/core/rectangle.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./src/js/core/utils.js");





const floorSpriteCoordinates = false;

const ORIGINAL_SCALE = "1";

class BaseSprite {
    /**
     * Returns the raw handle
     * @returns {HTMLImageElement|HTMLCanvasElement}
     */
    getRawTexture() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return null;
    }

    /**
     * Draws the sprite
     * @param {CanvasRenderingContext2D} context
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     */
    draw(context, x, y, w, h) {
        // eslint-disable-line no-unused-vars
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }
}

/**
 * Position of a sprite within an atlas
 */
class SpriteAtlasLink {
    /**
     *
     * @param {object} param0
     * @param {number} param0.packedX
     * @param {number} param0.packedY
     * @param {number} param0.packOffsetX
     * @param {number} param0.packOffsetY
     * @param {number} param0.packedW
     * @param {number} param0.packedH
     * @param {number} param0.w
     * @param {number} param0.h
     * @param {HTMLImageElement|HTMLCanvasElement} param0.atlas
     */
    constructor({ w, h, packedX, packedY, packOffsetX, packOffsetY, packedW, packedH, atlas }) {
        this.packedX = packedX;
        this.packedY = packedY;
        this.packedW = packedW;
        this.packedH = packedH;
        this.packOffsetX = packOffsetX;
        this.packOffsetY = packOffsetY;
        this.atlas = atlas;
        this.w = w;
        this.h = h;
    }
}

class AtlasSprite extends BaseSprite {
    /**
     *
     * @param {object} param0
     * @param {string} param0.spriteName
     */
    constructor({ spriteName = "sprite" }) {
        super();
        /** @type {Object.<string, SpriteAtlasLink>} */
        this.linksByResolution = {};
        this.spriteName = spriteName;
    }

    getRawTexture() {
        return this.linksByResolution[ORIGINAL_SCALE].atlas;
    }

    /**
     * Draws the sprite onto a regular context using no contexts
     * @see {BaseSprite.draw}
     */
    draw(context, x, y, w, h) {
        if (true) {
            window.assert(context instanceof CanvasRenderingContext2D, "Not a valid context");
        }

        const link = this.linksByResolution[ORIGINAL_SCALE];

        const width = w || link.w;
        const height = h || link.h;

        const scaleW = width / link.w;
        const scaleH = height / link.h;

        context.drawImage(
            link.atlas,

            link.packedX,
            link.packedY,
            link.packedW,
            link.packedH,

            x + link.packOffsetX * scaleW,
            y + link.packOffsetY * scaleH,
            link.packedW * scaleW,
            link.packedH * scaleH
        );
    }

    /**
     *
     * @param {DrawParameters} parameters
     * @param {number} x
     * @param {number} y
     * @param {number} size
     * @param {boolean=} clipping
     */
    drawCachedCentered(parameters, x, y, size, clipping = true) {
        this.drawCached(parameters, x - size / 2, y - size / 2, size, size, clipping);
    }

    /**
     *
     * @param {CanvasRenderingContext2D} context
     * @param {number} x
     * @param {number} y
     * @param {number} size
     */
    drawCentered(context, x, y, size) {
        this.draw(context, x - size / 2, y - size / 2, size, size);
    }

    /**
     * Draws the sprite
     * @param {DrawParameters} parameters
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @param {boolean=} clipping Whether to perform culling
     */
    drawCached(parameters, x, y, w = null, h = null, clipping = true) {
        if (true) {
            window.assert(parameters instanceof _draw_parameters__WEBPACK_IMPORTED_MODULE_0__["DrawParameters"], "Not a valid context");
            window.assert(!!w && w > 0, "Not a valid width:" + w);
            window.assert(!!h && h > 0, "Not a valid height:" + h);
        }

        const visibleRect = parameters.visibleRect;

        const scale = parameters.desiredAtlasScale;
        const link = this.linksByResolution[scale];
        const scaleW = w / link.w;
        const scaleH = h / link.h;

        let destX = x + link.packOffsetX * scaleW;
        let destY = y + link.packOffsetY * scaleH;
        let destW = link.packedW * scaleW;
        let destH = link.packedH * scaleH;

        let srcX = link.packedX;
        let srcY = link.packedY;
        let srcW = link.packedW;
        let srcH = link.packedH;

        let intersection = null;

        if (clipping) {
            const rect = new _rectangle__WEBPACK_IMPORTED_MODULE_2__["Rectangle"](destX, destY, destW, destH);
            intersection = rect.getUnion(visibleRect);
            if (!intersection) {
                return;
            }

            srcX += (intersection.x - destX) / scaleW;
            srcY += (intersection.y - destY) / scaleH;

            srcW *= intersection.w / destW;
            srcH *= intersection.h / destH;

            destX = intersection.x;
            destY = intersection.y;

            destW = intersection.w;
            destH = intersection.h;
        }

        // assert(epsilonCompare(scaleW, scaleH), "Sprite should be square for cached rendering");

        if (floorSpriteCoordinates) {
            parameters.context.drawImage(
                link.atlas,

                // atlas src pos
                Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(srcX),
                Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(srcY),

                // atlas src size
                Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(srcW),
                Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(srcH),

                // dest pos
                Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(destX),
                Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(destY),

                // dest size
                Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(destW),
                Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(destH)
            );
        } else {
            parameters.context.drawImage(
                link.atlas,

                // atlas src pos
                srcX,
                srcY,

                // atlas src siize
                srcW,
                srcH,

                // dest pos and size
                destX,
                destY,
                destW,
                destH
            );
        }
    }

    /**
     * Renders into an html element
     * @param {HTMLElement} element
     * @param {number} w
     * @param {number} h
     */
    renderToHTMLElement(element, w = 1, h = 1) {
        element.style.position = "relative";
        element.innerHTML = this.getAsHTML(w, h);
    }

    /**
     * Returns the html to render as icon
     * @param {number} w
     * @param {number} h
     */
    getAsHTML(w, h) {
        const link = this.linksByResolution["0.5"];

        // Find out how much we have to scale it so that it fits
        const scaleX = w / link.w;
        const scaleY = h / link.h;

        // Find out how big the scaled atlas is
        const atlasW = link.atlas.width * scaleX;
        const atlasH = link.atlas.height * scaleY;

        // @ts-ignore
        const srcSafe = link.atlas.src.replaceAll("\\", "/");

        // Find out how big we render the sprite
        const widthAbsolute = scaleX * link.packedW;
        const heightAbsolute = scaleY * link.packedH;

        // Compute the position in the relative container
        const leftRelative = (link.packOffsetX * scaleX) / w;
        const topRelative = (link.packOffsetY * scaleY) / h;
        const widthRelative = widthAbsolute / w;
        const heightRelative = heightAbsolute / h;

        // Scale the atlas relative to the width and height of the element
        const bgW = atlasW / widthAbsolute;
        const bgH = atlasH / heightAbsolute;

        // Figure out what the position of the atlas is
        const bgX = link.packedX * scaleX;
        const bgY = link.packedY * scaleY;

        // Fuck you, whoever thought its a good idea to make background-position work like it does now
        const bgXRelative = -bgX / (widthAbsolute - atlasW);
        const bgYRelative = -bgY / (heightAbsolute - atlasH);

        return `
            <span class="spritesheetImage" style="
                background-image: url('${srcSafe}');
                left: ${Object(_utils__WEBPACK_IMPORTED_MODULE_3__["round3Digits"])(leftRelative * 100.0)}%;
                top: ${Object(_utils__WEBPACK_IMPORTED_MODULE_3__["round3Digits"])(topRelative * 100.0)}%;
                width: ${Object(_utils__WEBPACK_IMPORTED_MODULE_3__["round3Digits"])(widthRelative * 100.0)}%;
                height: ${Object(_utils__WEBPACK_IMPORTED_MODULE_3__["round3Digits"])(heightRelative * 100.0)}%;
                background-repeat: repeat;
                background-position: ${Object(_utils__WEBPACK_IMPORTED_MODULE_3__["round3Digits"])(bgXRelative * 100.0)}% ${Object(_utils__WEBPACK_IMPORTED_MODULE_3__["round3Digits"])(
            bgYRelative * 100.0
        )}%;
                background-size: ${Object(_utils__WEBPACK_IMPORTED_MODULE_3__["round3Digits"])(bgW * 100.0)}% ${Object(_utils__WEBPACK_IMPORTED_MODULE_3__["round3Digits"])(bgH * 100.0)}%;
            "></span>
        `;
    }
}

class RegularSprite extends BaseSprite {
    constructor(sprite, w, h) {
        super();
        this.w = w;
        this.h = h;
        this.sprite = sprite;
    }

    getRawTexture() {
        return this.sprite;
    }

    /**
     * Draws the sprite, do *not* use this for sprites which are rendered! Only for drawing
     * images into buffers
     * @param {CanvasRenderingContext2D} context
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     */
    draw(context, x, y, w, h) {
        window.assert(context, "No context given");
        window.assert(x !== undefined, "No x given");
        window.assert(y !== undefined, "No y given");
        window.assert(w !== undefined, "No width given");
        window.assert(h !== undefined, "No height given");
        context.drawImage(this.sprite, x, y, w, h);
    }

    /**
     * Draws the sprite, do *not* use this for sprites which are rendered! Only for drawing
     * images into buffers
     * @param {CanvasRenderingContext2D} context
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     */
    drawCentered(context, x, y, w, h) {
        window.assert(context, "No context given");
        window.assert(x !== undefined, "No x given");
        window.assert(y !== undefined, "No y given");
        window.assert(w !== undefined, "No width given");
        window.assert(h !== undefined, "No height given");
        context.drawImage(this.sprite, x - w / 2, y - h / 2, w, h);
    }
}


/***/ }),

/***/ "./src/js/core/state_manager.js":
/*!**************************************!*\
  !*** ./src/js/core/state_manager.js ***!
  \**************************************/
/*! exports provided: StateManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StateManager", function() { return StateManager; });
/* harmony import */ var _game_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game_state */ "./src/js/core/game_state.js");
/* harmony import */ var _logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logging */ "./src/js/core/logging.js");
/* harmony import */ var _error_handler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./error_handler */ "./src/js/core/error_handler.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./src/js/core/utils.js");







const logger = Object(_logging__WEBPACK_IMPORTED_MODULE_1__["createLogger"])("state_manager");

/**
 * This is the main state machine which drives the game states.
 */
class StateManager {
    /**
     * @param {Application} app
     */
    constructor(app) {
        this.app = app;

        /** @type {GameState} */
        this.currentState = null;

        /** @type {Object.<string, new() => GameState>} */
        this.stateClasses = {};
    }

    /**
     * Registers a new state class, should be a GameState derived class
     * @param {object} stateClass
     */
    register(stateClass) {
        // Create a dummy to retrieve the key
        const dummy = new stateClass();
        window.assert(dummy instanceof _game_state__WEBPACK_IMPORTED_MODULE_0__["GameState"], "Not a state!");
        const key = dummy.getKey();
        window.assert(!this.stateClasses[key], `State '${key}' is already registered!`);
        this.stateClasses[key] = stateClass;
    }

    /**
     * Constructs a new state or returns the instance from the cache
     * @param {string} key
     */
    constructState(key) {
        if (this.stateClasses[key]) {
            return new this.stateClasses[key]();
        }
        window.assert(false, `State '${key}' is not known!`);
    }

    /**
     * Moves to a given state
     * @param {string} key State Key
     */
    moveToState(key, payload = {}) {
        if (_error_handler__WEBPACK_IMPORTED_MODULE_2__["APPLICATION_ERROR_OCCURED"]) {
            console.warn("Skipping state transition because of application crash");
            return;
        }

        if (this.currentState) {
            if (key === this.currentState.getKey()) {
                logger.error(`State '${key}' is already active!`);
                return false;
            }
            this.currentState.internalLeaveCallback();

            // Remove all references
            for (const stateKey in this.currentState) {
                if (this.currentState.hasOwnProperty(stateKey)) {
                    delete this.currentState[stateKey];
                }
            }
            this.currentState = null;
        }

        this.currentState = this.constructState(key);
        this.currentState.internalRegisterCallback(this, this.app);

        // Clean up old elements
        Object(_utils__WEBPACK_IMPORTED_MODULE_3__["removeAllChildren"])(document.body);

        document.body.className = "gameState " + (this.currentState.getHasFadeIn() ? "" : "arrived");
        document.body.id = "state_" + key;
        document.body.innerHTML = this.currentState.internalGetFullHtml();

        const dialogParent = document.createElement("div");
        dialogParent.classList.add("modalDialogParent");
        document.body.appendChild(dialogParent);

        this.app.sound.playThemeMusic(this.currentState.getThemeMusic());

        this.currentState.internalEnterCallback(payload);
        this.currentState.onResized(this.app.screenWidth, this.app.screenHeight);

        this.app.analytics.trackStateEnter(key);

        window.history.pushState(
            {
                key,
            },
            key
        );

        Object(_utils__WEBPACK_IMPORTED_MODULE_3__["waitNextFrame"])().then(() => {
            document.body.classList.add("arrived");
        });

        return true;
    }

    /**
     * Returns the current state
     * @returns {GameState}
     */
    getCurrentState() {
        return this.currentState;
    }
}


/***/ }),

/***/ "./src/js/core/textual_game_state.js":
/*!*******************************************!*\
  !*** ./src/js/core/textual_game_state.js ***!
  \*******************************************/
/*! exports provided: TextualGameState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextualGameState", function() { return TextualGameState; });
/* harmony import */ var _game_hud_parts_modal_dialogs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/hud/parts/modal_dialogs */ "./src/js/game/hud/parts/modal_dialogs.js");
/* harmony import */ var _game_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./game_state */ "./src/js/core/game_state.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../translations */ "./src/js/translations.js");




/**
 * Baseclass for all game states which are structured similary: A header with back button + some
 * scrollable content.
 */
class TextualGameState extends _game_state__WEBPACK_IMPORTED_MODULE_1__["GameState"] {
    ///// INTERFACE ////

    /**
     * Should return the states inner html. If not overriden, will create a scrollable container
     * with the content of getMainContentHTML()
     * @returns {string}
     */
    getInnerHTML() {
        return `
            <div class="content mainContent">
                ${this.getMainContentHTML()}
            </div>
        `;
    }

    /**
     * Should return the states HTML content.
     */
    getMainContentHTML() {
        return "";
    }

    /**
     * Should return the title of the game state. If null, no title and back button will
     * get created
     * @returns {string|null}
     */
    getStateHeaderTitle() {
        return null;
    }

    /////////////

    /**
     * Back button handler, can be overridden. Per default it goes back to the main menu,
     * or if coming from the game it moves back to the game again.
     */
    onBackButton() {
        if (this.backToStateId) {
            this.moveToState(this.backToStateId, this.backToStatePayload);
        } else {
            this.moveToState(this.getDefaultPreviousState());
        }
    }

    /**
     * Returns the default state to go back to
     */
    getDefaultPreviousState() {
        return "MainMenuState";
    }

    /**
     * Goes to a new state, telling him to go back to this state later
     * @param {string} stateId
     */
    moveToStateAddGoBack(stateId) {
        this.moveToState(stateId, {
            backToStateId: this.key,
            backToStatePayload: {
                backToStateId: this.backToStateId,
                backToStatePayload: this.backToStatePayload,
            },
        });
    }

    /**
     * Removes all click detectors, except the one on the back button. Useful when regenerating
     * content.
     */
    clearClickDetectorsExceptHeader() {
        for (let i = 0; i < this.clickDetectors.length; ++i) {
            const detector = this.clickDetectors[i];
            if (detector.element === this.headerElement) {
                continue;
            }
            detector.cleanup();
            this.clickDetectors.splice(i, 1);
            i -= 1;
        }
    }

    /**
     * Overrides the GameState implementation to provide our own html
     */
    internalGetFullHtml() {
        let headerHtml = "";
        if (this.getStateHeaderTitle()) {
            headerHtml = `
            <div class="headerBar">
            
                <h1><button class="backButton"></button> ${this.getStateHeaderTitle()}</h1>
            </div>`;
        }

        return `
            ${headerHtml}
            <div class="container">
                    ${this.getInnerHTML()}

            </div>
        `;
    }

    //// INTERNALS /////

    /**
     * Overrides the GameState leave callback to cleanup stuff
     */
    internalLeaveCallback() {
        super.internalLeaveCallback();
        this.dialogs.cleanup();
    }

    /**
     * Overrides the GameState enter callback to setup required stuff
     * @param {any} payload
     */
    internalEnterCallback(payload) {
        super.internalEnterCallback(payload, false);
        if (payload.backToStateId) {
            this.backToStateId = payload.backToStateId;
            this.backToStatePayload = payload.backToStatePayload;
        }

        this.htmlElement.classList.add("textualState");
        if (this.getStateHeaderTitle()) {
            this.htmlElement.classList.add("hasTitle");
        }

        this.containerElement = this.htmlElement.querySelector(".widthKeeper .container");
        this.headerElement = this.htmlElement.querySelector(".headerBar > h1");

        if (this.headerElement) {
            this.trackClicks(this.headerElement, this.onBackButton);
        }

        this.dialogs = new _game_hud_parts_modal_dialogs__WEBPACK_IMPORTED_MODULE_0__["HUDModalDialogs"](null, this.app);
        const dialogsElement = document.body.querySelector(".modalDialogParent");
        this.dialogs.initializeToElement(dialogsElement);

        this.onEnter(payload);
    }
}


/***/ }),

/***/ "./src/js/core/tracked_state.js":
/*!**************************************!*\
  !*** ./src/js/core/tracked_state.js ***!
  \**************************************/
/*! exports provided: TrackedState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrackedState", function() { return TrackedState; });
class TrackedState {
    constructor(callbackMethod = null, callbackScope = null) {
        this.lastSeenValue = null;

        if (callbackMethod) {
            this.callback = callbackMethod;
            if (callbackScope) {
                this.callback = this.callback.bind(callbackScope);
            }
        }
    }

    set(value, changeHandler = null, changeScope = null) {
        if (value !== this.lastSeenValue) {
            // Copy value since the changeHandler call could actually modify our lastSeenValue
            const valueCopy = value;
            this.lastSeenValue = value;
            if (changeHandler) {
                if (changeScope) {
                    changeHandler.call(changeScope, valueCopy);
                } else {
                    changeHandler(valueCopy);
                }
            } else if (this.callback) {
                this.callback(value);
            } else {
                window.assert(false, "No callback specified");
            }
        }
    }

    setSilent(value) {
        this.lastSeenValue = value;
    }

    get() {
        return this.lastSeenValue;
    }
}


/***/ }),

/***/ "./src/js/core/utils.js":
/*!******************************!*\
  !*** ./src/js/core/utils.js ***!
  \******************************/
/*! exports provided: TOP, RIGHT, BOTTOM, LEFT, ALL_DIRECTIONS, getBuildId, getEnvironmentId, isAndroid, isIos, getPlatformName, getIPCRenderer, formatSensitive, make2DArray, make2DUndefinedArray, clear2DArray, newEmptyMap, randomInt, accessNestedPropertyReverse, randomChoice, fastArrayDelete, fastArrayDeleteValue, fastArrayDeleteValueIfContained, arrayDelete, arrayDeleteValue, angleToSpriteIndex, epsilonCompare, epsilonIsZero, lerp, findNiceValue, findNiceIntegerValue, formatBigNumber, formatBigNumberFull, artificialDelayedPromise, pulseAnimation, smallestAngle, safeMod, wrapAngle, waitNextFrame, round1Digit, round2Digits, round3Digits, round4Digits, clamp, measure, makeDiv, makeButton, removeAllChildren, smartFadeNumber, quantizeFloat, checkTimerExpired, isSupportedBrowser, schemaObject, fastRotateMultipleOf90, formatSecondsToTimeAgo, formatSeconds, generateFileDownload, capitalizeFirstLetter, formatItemsPerSecond */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOP", function() { return TOP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RIGHT", function() { return RIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOTTOM", function() { return BOTTOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LEFT", function() { return LEFT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ALL_DIRECTIONS", function() { return ALL_DIRECTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBuildId", function() { return getBuildId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEnvironmentId", function() { return getEnvironmentId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAndroid", function() { return isAndroid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIos", function() { return isIos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPlatformName", function() { return getPlatformName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIPCRenderer", function() { return getIPCRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatSensitive", function() { return formatSensitive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "make2DArray", function() { return make2DArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "make2DUndefinedArray", function() { return make2DUndefinedArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear2DArray", function() { return clear2DArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newEmptyMap", function() { return newEmptyMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomInt", function() { return randomInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "accessNestedPropertyReverse", function() { return accessNestedPropertyReverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomChoice", function() { return randomChoice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fastArrayDelete", function() { return fastArrayDelete; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fastArrayDeleteValue", function() { return fastArrayDeleteValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fastArrayDeleteValueIfContained", function() { return fastArrayDeleteValueIfContained; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayDelete", function() { return arrayDelete; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayDeleteValue", function() { return arrayDeleteValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angleToSpriteIndex", function() { return angleToSpriteIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilonCompare", function() { return epsilonCompare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilonIsZero", function() { return epsilonIsZero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findNiceValue", function() { return findNiceValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findNiceIntegerValue", function() { return findNiceIntegerValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatBigNumber", function() { return formatBigNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatBigNumberFull", function() { return formatBigNumberFull; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "artificialDelayedPromise", function() { return artificialDelayedPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pulseAnimation", function() { return pulseAnimation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "smallestAngle", function() { return smallestAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "safeMod", function() { return safeMod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapAngle", function() { return wrapAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "waitNextFrame", function() { return waitNextFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round1Digit", function() { return round1Digit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round2Digits", function() { return round2Digits; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round3Digits", function() { return round3Digits; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round4Digits", function() { return round4Digits; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measure", function() { return measure; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeDiv", function() { return makeDiv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeButton", function() { return makeButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeAllChildren", function() { return removeAllChildren; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "smartFadeNumber", function() { return smartFadeNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quantizeFloat", function() { return quantizeFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkTimerExpired", function() { return checkTimerExpired; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSupportedBrowser", function() { return isSupportedBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "schemaObject", function() { return schemaObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fastRotateMultipleOf90", function() { return fastRotateMultipleOf90; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatSecondsToTimeAgo", function() { return formatSecondsToTimeAgo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatSeconds", function() { return formatSeconds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateFileDownload", function() { return generateFileDownload; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "capitalizeFirstLetter", function() { return capitalizeFirstLetter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatItemsPerSecond", function() { return formatItemsPerSecond; });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ "./src/js/core/config.js");
/* harmony import */ var _builtins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vector */ "./src/js/core/vector.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../translations */ "./src/js/translations.js");





// Constants
const TOP = new _vector__WEBPACK_IMPORTED_MODULE_2__["Vector"](0, -1);
const RIGHT = new _vector__WEBPACK_IMPORTED_MODULE_2__["Vector"](1, 0);
const BOTTOM = new _vector__WEBPACK_IMPORTED_MODULE_2__["Vector"](0, 1);
const LEFT = new _vector__WEBPACK_IMPORTED_MODULE_2__["Vector"](-1, 0);
const ALL_DIRECTIONS = [TOP, RIGHT, BOTTOM, LEFT];

const bigNumberSuffixTranslationKeys = ["thousands", "millions", "billions", "trillions"];
const bigNumberSuffixes = ["", "k", "M", "B", "T", "e15", "e18"];

/**
 * Returns the build id
 * @returns {string}
 */
function getBuildId() {
    if ( true && _config__WEBPACK_IMPORTED_MODULE_0__["IS_DEBUG"]) {
        return "local-dev";
    } else if (true) {
        return "dev-" + getPlatformName() + "-" + "4eaaf87";
    } else {}
}

/**
 * Returns the environment id (dev, prod, etc)
 * @returns {string}
 */
function getEnvironmentId() {
    if ( true && _config__WEBPACK_IMPORTED_MODULE_0__["IS_DEBUG"]) {
        return "local-dev";
    } else if (true) {
        return "dev-" + getPlatformName();
    } else {}
}

/**
 * Returns if this platform is android
 * @returns {boolean}
 */
function isAndroid() {
    if (true) {
        return false;
    }
    const platform = window.device.platform;
    return platform === "Android" || platform === "amazon-fireos";
}

/**
 * Returns if this platform is iOs
 * @returns {boolean}
 */
function isIos() {
    if (true) {
        return false;
    }
    return window.device.platform === "iOS";
}

/**
 * Returns a platform name
 * @returns {string}
 */
function getPlatformName() {
    if (false) {} else if (true) {
        return "browser";
    } else {}
    return "unknown";
}

/**
 * Returns the IPC renderer, or null if not within the standalone
 * @returns {object|null}
 */
let ipcRenderer = null;
function getIPCRenderer() {
    if (true) {
        return null;
    }
    if (!ipcRenderer) {
        ipcRenderer = eval("require")("electron").ipcRenderer;
    }
    return ipcRenderer;
}

/**
 * Formats a sensitive token by only displaying the first digits of it. Use for
 * stuff like savegame keys etc which should not appear in the log.
 * @param {string} key
 */
function formatSensitive(key) {
    if (!key) {
        return "<null>";
    }
    key = key || "";
    return "[" + key.substr(0, 8) + "...]";
}

/**
 * Creates a new 2D array with the given fill method
 * @param {number} w Width
 * @param {number} h Height
 * @param {(function(number, number) : any) | number | boolean | string | null | undefined} filler Either Fill method, which should return the content for each cell, or static content
 * @param {string=} context Optional context for memory tracking
 * @returns {Array<Array<any>>}
 */
function make2DArray(w, h, filler, context = null) {
    if (typeof filler === "function") {
        const tiles = new Array(w);
        for (let x = 0; x < w; ++x) {
            const row = new Array(h);
            for (let y = 0; y < h; ++y) {
                row[y] = filler(x, y);
            }
            tiles[x] = row;
        }
        return tiles;
    } else {
        const tiles = new Array(w);
        const row = new Array(h);
        for (let y = 0; y < h; ++y) {
            row[y] = filler;
        }

        for (let x = 0; x < w; ++x) {
            tiles[x] = row.slice();
        }
        return tiles;
    }
}

/**
 * Makes a new 2D array with undefined contents
 * @param {number} w
 * @param {number} h
 * @param {string=} context
 * @returns {Array<Array<any>>}
 */
function make2DUndefinedArray(w, h, context = null) {
    const result = new Array(w);
    for (let x = 0; x < w; ++x) {
        result[x] = new Array(h);
    }
    return result;
}

/**
 * Clears a given 2D array with the given fill method
 * @param {Array<Array<any>>} array
 * @param {number} w Width
 * @param {number} h Height
 * @param {(function(number, number) : any) | number | boolean | string | null | undefined} filler Either Fill method, which should return the content for each cell, or static content
 */
function clear2DArray(array, w, h, filler) {
    window.assert(array.length === w, "Array dims mismatch w");
    window.assert(array[0].length === h, "Array dims mismatch h");
    if (typeof filler === "function") {
        for (let x = 0; x < w; ++x) {
            const row = array[x];
            for (let y = 0; y < h; ++y) {
                row[y] = filler(x, y);
            }
        }
    } else {
        for (let x = 0; x < w; ++x) {
            const row = array[x];
            for (let y = 0; y < h; ++y) {
                row[y] = filler;
            }
        }
    }
}

/**
 * Creates a new map (an empty object without any props)
 */
function newEmptyMap() {
    return Object.create(null);
}

/**
 * Returns a random integer in the range [start,end]
 * @param {number} start
 * @param {number} end
 */
function randomInt(start, end) {
    return start + Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_round"])(Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_random"])() * (end - start));
}

/**
 * Access an object in a very annoying way, used for obsfuscation.
 * @param {any} obj
 * @param {Array<string>} keys
 */
function accessNestedPropertyReverse(obj, keys) {
    let result = obj;
    for (let i = keys.length - 1; i >= 0; --i) {
        result = result[keys[i]];
    }
    return result;
}

/**
 * Chooses a random entry of an array
 * @param {Array | string} arr
 */
function randomChoice(arr) {
    return arr[Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_random"])() * arr.length)];
}

/**
 * Deletes from an array by swapping with the last element
 * @param {Array<any>} array
 * @param {number} index
 */
function fastArrayDelete(array, index) {
    if (index < 0 || index >= array.length) {
        throw new Error("Out of bounds");
    }
    // When the element is not the last element
    if (index !== array.length - 1) {
        // Get the last element, and swap it with the one we want to delete
        const last = array[array.length - 1];
        array[index] = last;
    }

    // Finally remove the last element
    array.length -= 1;
}

/**
 * Deletes from an array by swapping with the last element. Searches
 * for the value in the array first
 * @param {Array<any>} array
 * @param {any} value
 */
function fastArrayDeleteValue(array, value) {
    if (array == null) {
        throw new Error("Tried to delete from non array!");
    }
    const index = array.indexOf(value);
    if (index < 0) {
        console.error("Value", value, "not contained in array:", array, "!");
        return value;
    }
    return fastArrayDelete(array, index);
}

/**
 * @see fastArrayDeleteValue
 * @param {Array<any>} array
 * @param {any} value
 */
function fastArrayDeleteValueIfContained(array, value) {
    if (array == null) {
        throw new Error("Tried to delete from non array!");
    }
    const index = array.indexOf(value);
    if (index < 0) {
        return value;
    }
    return fastArrayDelete(array, index);
}

/**
 * Deletes from an array at the given index
 * @param {Array<any>} array
 * @param {number} index
 */
function arrayDelete(array, index) {
    if (index < 0 || index >= array.length) {
        throw new Error("Out of bounds");
    }
    array.splice(index, 1);
}

/**
 * Deletes the given value from an array
 * @param {Array<any>} array
 * @param {any} value
 */
function arrayDeleteValue(array, value) {
    if (array == null) {
        throw new Error("Tried to delete from non array!");
    }
    const index = array.indexOf(value);
    if (index < 0) {
        console.error("Value", value, "not contained in array:", array, "!");
        return value;
    }
    return arrayDelete(array, index);
}

// Converts a direction into a 0 .. 7 index
/**
 * Converts a direction into a index from 0 .. 7, used for miners, zombies etc which have 8 sprites
 * @param {Vector} offset direction
 * @param {boolean} inverse if inverse, the direction is reversed
 * @returns {number} in range [0, 7]
 */
function angleToSpriteIndex(offset, inverse = false) {
    const twoPi = 2.0 * _builtins__WEBPACK_IMPORTED_MODULE_1__["Math_PI"];
    const factor = inverse ? -1 : 1;
    const offs = inverse ? 2.5 : 3.5;
    const angle = (factor * Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_atan2"])(offset.y, offset.x) + offs * _builtins__WEBPACK_IMPORTED_MODULE_1__["Math_PI"]) % twoPi;

    const index = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_round"])((angle / twoPi) * 8) % 8;
    return index;
}

/**
 * Compare two floats for epsilon equality
 * @param {number} a
 * @param {number} b
 * @returns {boolean}
 */
function epsilonCompare(a, b, epsilon = 1e-5) {
    return Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_abs"])(a - b) < epsilon;
}

/**
 * Compare a float for epsilon equal to 0
 * @param {number} a
 * @returns {boolean}
 */
function epsilonIsZero(a) {
    return epsilonCompare(a, 0);
}

/**
 * Interpolates two numbers
 * @param {number} a
 * @param {number} b
 * @param {number} x Mix factor, 0 means 100% a, 1 means 100%b, rest is interpolated
 */
function lerp(a, b, x) {
    return a * (1 - x) + b * x;
}

/**
 * Finds a value which is nice to display, e.g. 15669 -> 15000. Also handles fractional stuff
 * @param {number} num
 */
function findNiceValue(num) {
    if (num > 1e8) {
        return num;
    }
    if (num < 0.00001) {
        return 0;
    }

    const roundAmount = 0.5 * Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_pow"])(10, Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_log10"])(num) - 1));
    const niceValue = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(num / roundAmount) * roundAmount;
    if (num >= 10) {
        return Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_round"])(niceValue);
    }
    if (num >= 1) {
        return Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_round"])(niceValue * 10) / 10;
    }

    return Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_round"])(niceValue * 100) / 100;
}

/**
 * Finds a nice integer value
 * @see findNiceValue
 * @param {number} num
 */
function findNiceIntegerValue(num) {
    return Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_ceil"])(findNiceValue(num));
}

/**
 * Smart rounding + fractional handling
 * @param {number} n
 */
function roundSmart(n) {
    if (n < 100) {
        return n.toFixed(1);
    }
    return Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_round"])(n);
}

/**
 * Formats a big number
 * @param {number} num
 * @param {string=} divider THe divider for numbers like 50,000 (divider=',')
 * @returns {string}
 */
function formatBigNumber(num, divider = ".") {
    const sign = num < 0 ? "-" : "";
    num = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_abs"])(num);

    if (num > 1e54) {
        return sign + _translations__WEBPACK_IMPORTED_MODULE_3__["T"].global.infinite;
    }

    if (num < 10 && !Number.isInteger(num)) {
        return sign + num.toFixed(2);
    }
    if (num < 50 && !Number.isInteger(num)) {
        return sign + num.toFixed(1);
    }
    num = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(num);
    if (num < 10000) {
        return `${sign}${num}`;
    }

    let suffixIndex = 0;
    while (num > 1000) {
        num /= 1000;
        suffixIndex++;
    }

    let pow = 1000;

    while (num > 1000 / pow) {
        pow /= 10;
    }
    if (!_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug.disableShortNumbers) num = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(num * pow) / pow;
    let strNum = num.toString();
    if (divider != ".") {
        strNum = strNum.replace(".", divider);
    }

    return `${sign}${num}${bigNumberSuffixes[suffixIndex]}`;

    /*
    if (num < 1000) {
        return sign + "" + num;
    } else {
        let leadingDigits = num;
        let suffix = "";
        for (let suffixIndex = 0; suffixIndex < bigNumberSuffixTranslationKeys.length; ++suffixIndex) {
            leadingDigits = leadingDigits / 1000;
            suffix = T.global.suffix[bigNumberSuffixTranslationKeys[suffixIndex]];
            if (leadingDigits < 1000) {
                break;
            }
        }
        const leadingDigitsRounded = round1Digit(leadingDigits);
        const leadingDigitsNoTrailingDecimal = leadingDigitsRounded.toString().replace(".0", "");
        return sign + leadingDigitsNoTrailingDecimal + suffix;
    }
    */
}

/**
 * Formats a big number, but does not add any suffix and instead uses its full representation
 * @param {number} num
 * @param {string=} divider THe divider for numbers like 50,000 (divider=',')
 * @returns {string}
 */
function formatBigNumberFull(num, divider = _translations__WEBPACK_IMPORTED_MODULE_3__["T"].global.thousandsDivider) {
    if (num < 1000) {
        return num + "";
    }
    if (num > 1e54) {
        return _translations__WEBPACK_IMPORTED_MODULE_3__["T"].global.infinite;
    }
    let rest = num;
    let out = "";
    while (rest >= 1000) {
        out = (rest % 1000).toString().padStart(3, "0") + divider + out;
        rest = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(rest / 1000);
    }
    out = rest + divider + out;

    return out.substring(0, out.length - 1);
}

/**
 * Delayes a promise so that it will resolve after a *minimum* amount of time only
 * @param {Promise<any>} promise The promise to delay
 * @param {number} minTimeMs The time to make it run at least
 * @returns {Promise<any>} The delayed promise
 */
function artificialDelayedPromise(promise, minTimeMs = 500) {
    if ( true && _config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug.noArtificialDelays) {
        return promise;
    }

    const startTime = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["performanceNow"])();
    return promise.then(
        result => {
            const timeTaken = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["performanceNow"])() - startTime;
            const waitTime = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(minTimeMs - timeTaken);
            if (waitTime > 0) {
                return new Promise(resolve => {
                    setTimeout(() => {
                        resolve(result);
                    }, waitTime);
                });
            } else {
                return result;
            }
        },
        error => {
            const timeTaken = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["performanceNow"])() - startTime;
            const waitTime = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(minTimeMs - timeTaken);
            if (waitTime > 0) {
                // @ts-ignore
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        reject(error);
                    }, waitTime);
                });
            } else {
                throw error;
            }
        }
    );
}

/**
 * Computes a sine-based animation which pulsates from 0 .. 1 .. 0
 * @param {number} time Current time in seconds
 * @param {number} duration Duration of the full pulse in seconds
 * @param {number} seed Seed to offset the animation
 */
function pulseAnimation(time, duration = 1.0, seed = 0.0) {
    return Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_sin"])((time * _builtins__WEBPACK_IMPORTED_MODULE_1__["Math_PI"] * 2.0) / duration + seed * 5642.86729349) * 0.5 + 0.5;
}

/**
 * Returns the smallest angle between two angles
 * @param {number} a
 * @param {number} b
 * @returns {number} 0 .. 2 PI
 */
function smallestAngle(a, b) {
    return safeMod(a - b + _builtins__WEBPACK_IMPORTED_MODULE_1__["Math_PI"], 2.0 * _builtins__WEBPACK_IMPORTED_MODULE_1__["Math_PI"]) - _builtins__WEBPACK_IMPORTED_MODULE_1__["Math_PI"];
}

/**
 * Modulo which works for negative numbers
 * @param {number} n
 * @param {number} m
 */
function safeMod(n, m) {
    return ((n % m) + m) % m;
}

/**
 * Wraps an angle between 0 and 2 pi
 * @param {number} angle
 */
function wrapAngle(angle) {
    return safeMod(angle, 2.0 * _builtins__WEBPACK_IMPORTED_MODULE_1__["Math_PI"]);
}

/**
 * Waits two frames so the ui is updated
 * @returns {Promise<void>}
 */
function waitNextFrame() {
    return new Promise(function (resolve, reject) {
        window.requestAnimationFrame(function () {
            window.requestAnimationFrame(function () {
                resolve();
            });
        });
    });
}

/**
 * Rounds 1 digit
 * @param {number} n
 * @returns {number}
 */
function round1Digit(n) {
    return Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(n * 10.0) / 10.0;
}

/**
 * Rounds 2 digits
 * @param {number} n
 * @returns {number}
 */
function round2Digits(n) {
    return Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(n * 100.0) / 100.0;
}

/**
 * Rounds 3 digits
 * @param {number} n
 * @returns {number}
 */
function round3Digits(n) {
    return Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(n * 1000.0) / 1000.0;
}

/**
 * Rounds 4 digits
 * @param {number} n
 * @returns {number}
 */
function round4Digits(n) {
    return Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(n * 10000.0) / 10000.0;
}

/**
 * Clamps a value between [min, max]
 * @param {number} v
 * @param {number=} minimum Default 0
 * @param {number=} maximum Default 1
 */
function clamp(v, minimum = 0, maximum = 1) {
    return Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(minimum, Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_min"])(maximum, v));
}

/**
 * Measures how long a function took
 * @param {string} name
 * @param {function():void} target
 */
function measure(name, target) {
    const now = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["performanceNow"])();
    for (let i = 0; i < 25; ++i) {
        target();
    }
    const dur = (Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["performanceNow"])() - now) / 25.0;
    console.warn("->", name, "took", dur.toFixed(2), "ms");
}

/**
 * Helper method to create a new div
 * @param {Element} parent
 * @param {string=} id
 * @param {Array<string>=} classes
 * @param {string=} innerHTML
 */
function makeDiv(parent, id = null, classes = [], innerHTML = "") {
    const div = document.createElement("div");
    if (id) {
        div.id = id;
    }
    for (let i = 0; i < classes.length; ++i) {
        div.classList.add(classes[i]);
    }
    div.innerHTML = innerHTML;
    parent.appendChild(div);
    return div;
}

/**
 * Helper method to create a new button
 * @param {Element} parent
 * @param {Array<string>=} classes
 * @param {string=} innerHTML
 */
function makeButton(parent, classes = [], innerHTML = "") {
    const element = document.createElement("button");
    for (let i = 0; i < classes.length; ++i) {
        element.classList.add(classes[i]);
    }
    element.classList.add("styledButton");
    element.innerHTML = innerHTML;
    parent.appendChild(element);
    return element;
}

/**
 * Removes all children of the given element
 * @param {Element} elem
 */
function removeAllChildren(elem) {
    if (elem) {
        var range = document.createRange();
        range.selectNodeContents(elem);
        range.deleteContents();
    }
}

function smartFadeNumber(current, newOne, minFade = 0.01, maxFade = 0.9) {
    const tolerance = Math.min(current, newOne) * 0.5 + 10;
    let fade = minFade;
    if (Math.abs(current - newOne) < tolerance) {
        fade = maxFade;
    }

    return current * fade + newOne * (1 - fade);
}

/**
 * Fixes lockstep simulation by converting times like 34.0000000003 to 34.00.
 * We use 3 digits of precision, this allows to store sufficient precision of 1 ms without
 * the risk to simulation errors due to resync issues
 * @param {number} value
 */
function quantizeFloat(value) {
    return Math.round(value * 1000.0) / 1000.0;
}

/**
 * Safe check to check if a timer is expired. quantizes numbers
 * @param {number} now Current time
 * @param {number} lastTick Last tick of the timer
 * @param {number} tickRate Interval of the timer
 */
function checkTimerExpired(now, lastTick, tickRate) {
    if (true) {
        if (quantizeFloat(now) !== now) {
            console.error("Got non-quantizied time:" + now + " vs " + quantizeFloat(now));
            now = quantizeFloat(now);
        }
        if (quantizeFloat(lastTick) !== lastTick) {
            // FIXME: REENABLE
            // console.error("Got non-quantizied timer:" + lastTick + " vs " + quantizeFloat(lastTick));
            lastTick = quantizeFloat(lastTick);
        }
    } else {}
    /*
    Ok, so heres the issue (Died a bit while debugging it):

    In multiplayer lockstep simulation, client A will simulate everything at T, but client B
    will simulate it at T + 3. So we are running into the following precision issue:
    Lets say on client A the time is T = 30. Then on clientB the time is T = 33.
    Now, our timer takes 0.1 seconds and ticked at 29.90 - What does happen now?
    Client A computes the timer and checks T > lastTick + interval. He computes

    30 >= 29.90 + 0.1   <=> 30 >= 30.0000  <=> True  <=> Tick performed

    However, this is what it looks on client B:

    33 >= 32.90 + 0.1   <=> 33 >= 32.999999999999998 <=> False <=> No tick performed!

    This means that Client B will only tick at the *next* frame, which means it from now is out
    of sync by one tick, which means the game will resync further or later and be not able to recover,
    since it will run into the same issue over and over.
    */

    // The next tick, in our example it would be 30.0000 / 32.99999999998. In order to fix it, we quantize
    // it, so its now 30.0000 / 33.0000
    const nextTick = quantizeFloat(lastTick + tickRate);

    // This check is safe, but its the only check where you may compare times. You always need to use
    // this method!
    return now >= nextTick;
}

/**
 * Returns if the game supports this browser
 */
function isSupportedBrowser() {
    // please note,
    // that IE11 now returns undefined again for window.chrome
    // and new Opera 30 outputs true for window.chrome
    // but needs to check if window.opr is not undefined
    // and new IE Edge outputs to true now for window.chrome
    // and if not iOS Chrome check
    // so use the below updated condition

    if (false) {}

    // @ts-ignore
    var isChromium = window.chrome;
    var winNav = window.navigator;
    var vendorName = winNav.vendor;
    // @ts-ignore
    var isIEedge = winNav.userAgent.indexOf("Edge") > -1;
    var isIOSChrome = winNav.userAgent.match("CriOS");

    if (isIOSChrome) {
        // is Google Chrome on IOS
        return false;
    } else if (
        isChromium !== null &&
        typeof isChromium !== "undefined" &&
        vendorName === "Google Inc." &&
        isIEedge === false
    ) {
        // is Google Chrome
        return true;
    } else {
        // not Google Chrome
        return false;
    }
}

/**
 * Helper function to create a json schema object
 * @param {any} properties
 */
function schemaObject(properties) {
    return {
        type: "object",
        required: Object.keys(properties).slice(),
        additionalProperties: false,
        properties,
    };
}

/**
 * Quickly
 * @param {number} x
 * @param {number} y
 * @param {number} deg
 * @returns {Vector}
 */
function fastRotateMultipleOf90(x, y, deg) {
    switch (deg) {
        case 0: {
            return new _vector__WEBPACK_IMPORTED_MODULE_2__["Vector"](x, y);
        }
        case 90: {
            return new _vector__WEBPACK_IMPORTED_MODULE_2__["Vector"](x, y);
        }
    }
}

/**
 * Formats an amount of seconds into something like "5s ago"
 * @param {number} secs Seconds
 * @returns {string}
 */
function formatSecondsToTimeAgo(secs) {
    const seconds = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(secs);
    const minutes = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(seconds / 60);
    const hours = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(minutes / 60);
    const days = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(hours / 24);

    if (seconds <= 60) {
        if (seconds <= 1) {
            return _translations__WEBPACK_IMPORTED_MODULE_3__["T"].global.time.oneSecondAgo;
        }
        return _translations__WEBPACK_IMPORTED_MODULE_3__["T"].global.time.xSecondsAgo.replace("<x>", "" + seconds);
    } else if (minutes <= 60) {
        if (minutes <= 1) {
            return _translations__WEBPACK_IMPORTED_MODULE_3__["T"].global.time.oneMinuteAgo;
        }
        return _translations__WEBPACK_IMPORTED_MODULE_3__["T"].global.time.xMinutesAgo.replace("<x>", "" + minutes);
    } else if (hours <= 60) {
        if (hours <= 1) {
            return _translations__WEBPACK_IMPORTED_MODULE_3__["T"].global.time.oneHourAgo;
        }
        return _translations__WEBPACK_IMPORTED_MODULE_3__["T"].global.time.xHoursAgo.replace("<x>", "" + hours);
    } else {
        if (days <= 1) {
            return _translations__WEBPACK_IMPORTED_MODULE_3__["T"].global.time.oneDayAgo;
        }
        return _translations__WEBPACK_IMPORTED_MODULE_3__["T"].global.time.xDaysAgo.replace("<x>", "" + days);
    }
}

/**
 * Formats seconds into a readable string like "5h 23m"
 * @param {number} secs Seconds
 * @returns {string}
 */
function formatSeconds(secs) {
    const trans = _translations__WEBPACK_IMPORTED_MODULE_3__["T"].global.time;
    secs = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_ceil"])(secs);
    if (secs < 60) {
        return trans.secondsShort.replace("<seconds>", "" + secs);
    } else if (secs < 60 * 60) {
        const minutes = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(secs / 60);
        const seconds = secs % 60;
        return trans.minutesAndSecondsShort
            .replace("<seconds>", "" + seconds)
            .replace("<minutes>", "" + minutes);
    } else {
        const hours = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(secs / 3600);
        const minutes = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(secs / 60) % 60;
        return trans.hoursAndMinutesShort.replace("<minutes>", "" + minutes).replace("<hours>", "" + hours);
    }
}

/**
 * Generates a file download
 * @param {string} filename
 * @param {string} text
 */
function generateFileDownload(filename, text) {
    var element = document.createElement("a");
    element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(text));
    element.setAttribute("download", filename);

    element.style.display = "none";
    document.body.appendChild(element);

    element.click();
    document.body.removeChild(element);
}

/**
 * Capitalizes the first letter
 * @param {string} str
 */
function capitalizeFirstLetter(str) {
    return str.substr(0, 1).toUpperCase() + str.substr(1).toLowerCase();
}

/**
 * Formats a number like 2.5 to "2.5 items / s"
 * @param {number} speed
 * @param {boolean=} double
 */
function formatItemsPerSecond(speed, double = false) {
    return speed === 1.0
        ? _translations__WEBPACK_IMPORTED_MODULE_3__["T"].ingame.buildingPlacement.infoTexts.oneItemPerSecond
        : _translations__WEBPACK_IMPORTED_MODULE_3__["T"].ingame.buildingPlacement.infoTexts.itemsPerSecond.replace("<x>", "" + round2Digits(speed)) +
              (double ? "  " + _translations__WEBPACK_IMPORTED_MODULE_3__["T"].ingame.buildingPlacement.infoTexts.itemsPerSecondDouble : "");
}


/***/ }),

/***/ "./src/js/core/vector.js":
/*!*******************************!*\
  !*** ./src/js/core/vector.js ***!
  \*******************************/
/*! exports provided: enumDirection, enumInvertedDirections, enumDirectionToAngle, enumAngleToDirection, Vector, mixVector, enumDirectionToVector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumDirection", function() { return enumDirection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumInvertedDirections", function() { return enumInvertedDirections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumDirectionToAngle", function() { return enumDirectionToAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumAngleToDirection", function() { return enumAngleToDirection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector", function() { return Vector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mixVector", function() { return mixVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumDirectionToVector", function() { return enumDirectionToVector; });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ "./src/js/core/config.js");
/* harmony import */ var _builtins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./builtins */ "./src/js/core/builtins.js");



const tileSize = _config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize;
const halfTileSize = _config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].halfTileSize;

/**
 * @enum {string}
 */
const enumDirection = {
    top: "top",
    right: "right",
    bottom: "bottom",
    left: "left",
};

/**
 * @enum {string}
 */
const enumInvertedDirections = {
    [enumDirection.top]: enumDirection.bottom,
    [enumDirection.right]: enumDirection.left,
    [enumDirection.bottom]: enumDirection.top,
    [enumDirection.left]: enumDirection.right,
};

/**
 * @enum {number}
 */
const enumDirectionToAngle = {
    [enumDirection.top]: 0,
    [enumDirection.right]: 90,
    [enumDirection.bottom]: 180,
    [enumDirection.left]: 270,
};

/**
 * @enum {enumDirection}
 */
const enumAngleToDirection = {
    0: enumDirection.top,
    90: enumDirection.right,
    180: enumDirection.bottom,
    270: enumDirection.left,
};

class Vector {
    /**
     *
     * @param {number=} x
     * @param {number=} y
     */
    constructor(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }

    /**
     * return a copy of the vector
     * @returns {Vector}
     */
    copy() {
        return new Vector(this.x, this.y);
    }

    /**
     * Adds a vector and return a new vector
     * @param {Vector} other
     * @returns {Vector}
     */
    add(other) {
        return new Vector(this.x + other.x, this.y + other.y);
    }

    /**
     * Adds a vector
     * @param {Vector} other
     * @returns {Vector}
     */
    addInplace(other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    }

    /**
     * Substracts a vector and return a new vector
     * @param {Vector} other
     * @returns {Vector}
     */
    sub(other) {
        return new Vector(this.x - other.x, this.y - other.y);
    }

    /**
     * Subs a vector
     * @param {Vector} other
     * @returns {Vector}
     */
    subInplace(other) {
        this.x -= other.x;
        this.y -= other.y;
        return this;
    }

    /**
     * Multiplies with a vector and return a new vector
     * @param {Vector} other
     * @returns {Vector}
     */
    mul(other) {
        return new Vector(this.x * other.x, this.y * other.y);
    }

    /**
     * Adds two scalars and return a new vector
     * @param {number} x
     * @param {number} y
     * @returns {Vector}
     */
    addScalars(x, y) {
        return new Vector(this.x + x, this.y + y);
    }

    /**
     * Substracts a scalar and return a new vector
     * @param {number} f
     * @returns {Vector}
     */
    subScalar(f) {
        return new Vector(this.x - f, this.y - f);
    }

    /**
     * Substracts two scalars and return a new vector
     * @param {number} x
     * @param {number} y
     * @returns {Vector}
     */
    subScalars(x, y) {
        return new Vector(this.x - x, this.y - y);
    }

    /**
     * Returns the euclidian length
     * @returns {number}
     */
    length() {
        return Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_hypot"])(this.x, this.y);
    }

    /**
     * Returns the square length
     * @returns {number}
     */
    lengthSquare() {
        return this.x * this.x + this.y * this.y;
    }

    /**
     * Divides both components by a scalar and return a new vector
     * @param {number} f
     * @returns {Vector}
     */
    divideScalar(f) {
        return new Vector(this.x / f, this.y / f);
    }

    /**
     * Divides both components by the given scalars and return a new vector
     * @param {number} a
     * @param {number} b
     * @returns {Vector}
     */
    divideScalars(a, b) {
        return new Vector(this.x / a, this.y / b);
    }

    /**
     * Divides both components by a scalar
     * @param {number} f
     * @returns {Vector}
     */
    divideScalarInplace(f) {
        this.x /= f;
        this.y /= f;
        return this;
    }

    /**
     * Multiplies both components with a scalar and return a new vector
     * @param {number} f
     * @returns {Vector}
     */
    multiplyScalar(f) {
        return new Vector(this.x * f, this.y * f);
    }

    /**
     * Multiplies both components with two scalars and returns a new vector
     * @param {number} a
     * @param {number} b
     * @returns {Vector}
     */
    multiplyScalars(a, b) {
        return new Vector(this.x * a, this.y * b);
    }

    /**
     * For both components, compute the maximum of each component and the given scalar, and return a new vector.
     * For example:
     *   - new Vector(-1, 5).maxScalar(0) -> Vector(0, 5)
     * @param {number} f
     * @returns {Vector}
     */
    maxScalar(f) {
        return new Vector(Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(f, this.x), Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(f, this.y));
    }

    /**
     * Adds a scalar to both components and return a new vector
     * @param {number} f
     * @returns {Vector}
     */
    addScalar(f) {
        return new Vector(this.x + f, this.y + f);
    }

    /**
     * Computes the component wise minimum and return a new vector
     * @param {Vector} v
     * @returns {Vector}
     */
    min(v) {
        return new Vector(Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_min"])(v.x, this.x), Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_min"])(v.y, this.y));
    }

    /**
     * Computes the component wise maximum and return a new vector
     * @param {Vector} v
     * @returns {Vector}
     */
    max(v) {
        return new Vector(Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(v.x, this.x), Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(v.y, this.y));
    }
    /**
     * Computes the component wise absolute
     * @returns {Vector}
     */
    abs() {
        return new Vector(Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_abs"])(this.x), Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_abs"])(this.y));
    }

    /**
     * Computes the scalar product
     * @param {Vector} v
     * @returns {number}
     */
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }

    /**
     * Computes the distance to a given vector
     * @param {Vector} v
     * @returns {number}
     */
    distance(v) {
        return Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_hypot"])(this.x - v.x, this.y - v.y);
    }

    /**
     * Computes the square distance to a given vectort
     * @param {Vector} v
     * @returns {number}
     */
    distanceSquare(v) {
        const dx = this.x - v.x;
        const dy = this.y - v.y;
        return dx * dx + dy * dy;
    }

    /**
     * Computes and returns the center between both points
     * @param {Vector} v
     * @returns {Vector}
     */
    centerPoint(v) {
        const cx = this.x + v.x;
        const cy = this.y + v.y;
        return new Vector(cx / 2, cy / 2);
    }

    /**
     * Computes componentwise floor and return a new vector
     * @returns {Vector}
     */
    floor() {
        return new Vector(Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(this.x), Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(this.y));
    }

    /**
     * Computes componentwise round and return a new vector
     * @returns {Vector}
     */
    round() {
        return new Vector(Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_round"])(this.x), Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_round"])(this.y));
    }

    /**
     * Converts this vector from world to tile space and return a new vector
     * @returns {Vector}
     */
    toTileSpace() {
        return new Vector(Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(this.x / tileSize), Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(this.y / tileSize));
    }

    /**
     * Converts this vector from world to street space and return a new vector
     * @returns {Vector}
     */
    toStreetSpace() {
        return new Vector(Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(this.x / halfTileSize + 0.25), Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(this.y / halfTileSize + 0.25));
    }

    /**
     * Converts this vector to world space and return a new vector
     * @returns {Vector}
     */
    toWorldSpace() {
        return new Vector(this.x * tileSize, this.y * tileSize);
    }

    /**
     * Converts this vector to world space and return a new vector
     * @returns {Vector}
     */
    toWorldSpaceCenterOfTile() {
        return new Vector(this.x * tileSize + halfTileSize, this.y * tileSize + halfTileSize);
    }

    /**
     * Converts the top left tile position of this vector
     * @returns {Vector}
     */
    snapWorldToTile() {
        return new Vector(Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(this.x / tileSize) * tileSize, Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(this.y / tileSize) * tileSize);
    }

    /**
     * Normalizes the vector, dividing by the length(), and return a new vector
     * @returns {Vector}
     */
    normalize() {
        const len = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(1e-5, Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_hypot"])(this.x, this.y));
        return new Vector(this.x / len, this.y / len);
    }

    /**
     * Normalizes the vector, dividing by the length(), and return a new vector
     * @returns {Vector}
     */
    normalizeIfGreaterOne() {
        const len = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(1, Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_hypot"])(this.x, this.y));
        return new Vector(this.x / len, this.y / len);
    }

    /**
     * Returns the normalized vector to the other point
     * @param {Vector} v
     * @returns {Vector}
     */
    normalizedDirection(v) {
        const dx = v.x - this.x;
        const dy = v.y - this.y;
        const len = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(1e-5, Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_hypot"])(dx, dy));
        return new Vector(dx / len, dy / len);
    }

    /**
     * Returns a perpendicular vector
     * @returns {Vector}
     */
    findPerpendicular() {
        return new Vector(-this.y, this.x);
    }

    /**
     * Returns the unnormalized direction to the other point
     * @param {Vector} v
     * @returns {Vector}
     */
    direction(v) {
        return new Vector(v.x - this.x, v.y - this.y);
    }

    /**
     * Returns a string representation of the vector
     * @returns {string}
     */
    toString() {
        return this.x + "," + this.y;
    }

    /**
     * Compares both vectors for exact equality. Does not do an epsilon compare
     * @param {Vector} v
     * @returns {Boolean}
     */
    equals(v) {
        return this.x === v.x && this.y === v.y;
    }

    /**
     * Rotates this vector
     * @param {number} angle
     * @returns {Vector} new vector
     */
    rotated(angle) {
        const sin = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_sin"])(angle);
        const cos = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_cos"])(angle);
        return new Vector(this.x * cos - this.y * sin, this.x * sin + this.y * cos);
    }

    /**
     * Rotates this vector
     * @param {number} angle
     * @returns {Vector} this vector
     */
    rotateInplaceFastMultipleOf90(angle) {
        // const sin = Math_sin(angle);
        // const cos = Math_cos(angle);
        // let sin = 0, cos = 1;
        window.assert(angle >= 0 && angle <= 360, "Invalid angle, please clamp first: " + angle);

        switch (angle) {
            case 0:
            case 360: {
                return this;
            }
            case 90: {
                // sin = 1;
                // cos = 0;

                const x = this.x;
                this.x = -this.y;
                this.y = x;
                return this;
            }
            case 180: {
                // sin = 0
                // cos = -1
                this.x = -this.x;
                this.y = -this.y;
                return this;
            }
            case 270: {
                // sin = -1
                // cos = 0
                const x = this.x;
                this.x = this.y;
                this.y = -x;
                return this;
            }
            default: {
                window.assert(false, "Invalid fast inplace rotation: " + angle);
                return this;
            }
        }
        // return new Vector(this.x * cos - this.y * sin, this.x * sin + this.y * cos);
    }

    /**
     * Rotates this vector
     * @param {number} angle
     * @returns {Vector} new vector
     */
    rotateFastMultipleOf90(angle) {
        window.assert(angle >= 0 && angle <= 360, "Invalid angle, please clamp first: " + angle);

        switch (angle) {
            case 360:
            case 0: {
                return new Vector(this.x, this.y);
            }
            case 90: {
                return new Vector(-this.y, this.x);
            }
            case 180: {
                return new Vector(-this.x, -this.y);
            }
            case 270: {
                return new Vector(this.y, -this.x);
            }
            default: {
                window.assert(false, "Invalid fast inplace rotation: " + angle);
                return new Vector();
            }
        }
    }

    /**
     * Helper method to rotate a direction
     * @param {enumDirection} direction
     * @param {number} angle
     * @returns {enumDirection}
     */
    static transformDirectionFromMultipleOf90(direction, angle) {
        if (angle === 0 || angle === 360) {
            return direction;
        }
        window.assert(angle >= 0 && angle <= 360, "Invalid angle: " + angle);
        switch (direction) {
            case enumDirection.top: {
                switch (angle) {
                    case 90:
                        return enumDirection.right;
                    case 180:
                        return enumDirection.bottom;
                    case 270:
                        return enumDirection.left;
                    default:
                        window.assert(false, "Invalid angle: " + angle);
                        return;
                }
            }

            case enumDirection.right: {
                switch (angle) {
                    case 90:
                        return enumDirection.bottom;
                    case 180:
                        return enumDirection.left;
                    case 270:
                        return enumDirection.top;
                    default:
                        window.assert(false, "Invalid angle: " + angle);
                        return;
                }
            }

            case enumDirection.bottom: {
                switch (angle) {
                    case 90:
                        return enumDirection.left;
                    case 180:
                        return enumDirection.top;
                    case 270:
                        return enumDirection.right;
                    default:
                        window.assert(false, "Invalid angle: " + angle);
                        return;
                }
            }

            case enumDirection.left: {
                switch (angle) {
                    case 90:
                        return enumDirection.top;
                    case 180:
                        return enumDirection.right;
                    case 270:
                        return enumDirection.bottom;
                    default:
                        window.assert(false, "Invalid angle: " + angle);
                        return;
                }
            }
            default:
                window.assert(false, "Invalid angle: " + angle);
                return;
        }
    }

    /**
     * Compares both vectors for epsilon equality
     * @param {Vector} v
     * @returns {Boolean}
     */
    equalsEpsilon(v, epsilon = 1e-5) {
        return Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_abs"])(this.x - v.x) < 1e-5 && Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_abs"])(this.y - v.y) < epsilon;
    }

    /**
     * Returns the angle
     * @returns {number} 0 .. 2 PI
     */
    angle() {
        return Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_atan2"])(this.y, this.x) + _builtins__WEBPACK_IMPORTED_MODULE_1__["Math_PI"] / 2;
    }

    /**
     * Serializes the vector to a string
     * @returns {string}
     */
    serializeTile() {
        return String.fromCharCode(33 + this.x) + String.fromCharCode(33 + this.y);
    }

    /**
     * Creates a simple representation of the vector
     */
    serializeSimple() {
        return { x: this.x, y: this.y };
    }

    /**
     * @returns {number}
     */
    serializeTileToInt() {
        return this.x + this.y * 256;
    }

    /**
     *
     * @param {number} i
     * @returns {Vector}
     */
    static deserializeTileFromInt(i) {
        const x = i % 256;
        const y = Object(_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_floor"])(i / 256);
        return new Vector(x, y);
    }

    /**
     * Deserializes a vector from a string
     * @param {string} s
     * @returns {Vector}
     */
    static deserializeTile(s) {
        return new Vector(s.charCodeAt(0) - 33, s.charCodeAt(1) - 33);
    }

    /**
     * Deserializes a vector from a serialized json object
     * @param {object} obj
     * @returns {Vector}
     */
    static fromSerializedObject(obj) {
        if (obj) {
            return new Vector(obj.x || 0, obj.y || 0);
        }
    }
}

/**
 * Interpolates two vectors, for a = 0, returns v1 and for a = 1 return v2, otherwise interpolate
 * @param {Vector} v1
 * @param {Vector} v2
 * @param {number} a
 */
function mixVector(v1, v2, a) {
    return new Vector(v1.x * (1 - a) + v2.x * a, v1.y * (1 - a) + v2.y * a);
}

/**
 * Mapping from string direction to actual vector
 * @enum {Vector}
 */
const enumDirectionToVector = {
    top: new Vector(0, -1),
    right: new Vector(1, 0),
    bottom: new Vector(0, 1),
    left: new Vector(-1, 0),
};


/***/ }),

/***/ "./src/js/game/automatic_save.js":
/*!***************************************!*\
  !*** ./src/js/game/automatic_save.js ***!
  \***************************************/
/*! exports provided: enumSavePriority, AutomaticSave */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumSavePriority", function() { return enumSavePriority; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AutomaticSave", function() { return AutomaticSave; });
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./root */ "./src/js/game/root.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");





// How important it is that a savegame is created
/**
 * @enum {number}
 */
const enumSavePriority = {
    regular: 2,
    asap: 100,
};

const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_3__["createLogger"])("autosave");

// Internals
let MIN_INTERVAL_SECS = 60;

class AutomaticSave {
    constructor(root) {
        /** @type {GameRoot} */
        this.root = root;

        // Store the current maximum save importance
        this.saveImportance = enumSavePriority.regular;

        this.lastSaveAttempt = -1000;
    }

    setSaveImportance(importance) {
        this.saveImportance = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_2__["Math_max"])(this.saveImportance, importance);
    }

    doSave() {
        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].debug.disableSavegameWrite) {
            return;
        }

        this.root.gameState.doSave();
        this.saveImportance = enumSavePriority.regular;
    }

    update() {
        if (!this.root.gameInitialized) {
            // Bad idea
            return;
        }

        // Check when the last save was, but make sure that if it fails, we don't spam
        const lastSaveTime = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_2__["Math_max"])(this.lastSaveAttempt, this.root.savegame.getRealLastUpdate());

        let secondsSinceLastSave = (Date.now() - lastSaveTime) / 1000.0;
        let shouldSave = false;

        switch (this.saveImportance) {
            case enumSavePriority.asap:
                // High always should save
                shouldSave = true;
                break;

            case enumSavePriority.regular:
                // Could determine if there is a good / bad point here
                shouldSave = secondsSinceLastSave > MIN_INTERVAL_SECS;
                break;

            default:
                window.assert(false, "Unknown save prio: " + this.saveImportance);
                break;
        }
        if (shouldSave) {
            logger.log("Saving automatically");
            this.lastSaveAttempt = Date.now();
            this.doSave();
        }
    }
}


/***/ }),

/***/ "./src/js/game/base_item.js":
/*!**********************************!*\
  !*** ./src/js/game/base_item.js ***!
  \**********************************/
/*! exports provided: BaseItem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseItem", function() { return BaseItem; });
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../savegame/serialization */ "./src/js/savegame/serialization.js");
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./theme */ "./src/js/game/theme.js");




/**
 * Class for items on belts etc. Not an entity for performance reasons
 */
class BaseItem extends _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__["BasicSerializableObject"] {
    constructor() {
        super();
    }

    static getId() {
        return "base_item";
    }

    /** @returns {object} */
    static getSchema() {
        return {};
    }

    /**
     * Draws the item at the given position
     * @param {number} x
     * @param {number} y
     * @param {DrawParameters} parameters
     * @param {number=} size
     */
    draw(x, y, parameters, size) {}

    getBackgroundColorAsResource() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return "";
    }
}


/***/ }),

/***/ "./src/js/game/buildings/belt_base.js":
/*!********************************************!*\
  !*** ./src/js/game/buildings/belt_base.js ***!
  \********************************************/
/*! exports provided: arrayBeltVariantToRotation, MetaBeltBaseBuilding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayBeltVariantToRotation", function() { return arrayBeltVariantToRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MetaBeltBaseBuilding", function() { return MetaBeltBaseBuilding; });
/* harmony import */ var _core_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/loader */ "./src/js/core/loader.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _platform_sound__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../platform/sound */ "./src/js/platform/sound.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../translations */ "./src/js/translations.js");
/* harmony import */ var _components_belt__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/belt */ "./src/js/game/components/belt.js");
/* harmony import */ var _components_item_acceptor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../components/item_acceptor */ "./src/js/game/components/item_acceptor.js");
/* harmony import */ var _components_item_ejector__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/item_ejector */ "./src/js/game/components/item_ejector.js");
/* harmony import */ var _components_replaceable_map_entity__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../components/replaceable_map_entity */ "./src/js/game/components/replaceable_map_entity.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../root */ "./src/js/game/root.js");













const arrayBeltVariantToRotation = [_core_vector__WEBPACK_IMPORTED_MODULE_2__["enumDirection"].top, _core_vector__WEBPACK_IMPORTED_MODULE_2__["enumDirection"].left, _core_vector__WEBPACK_IMPORTED_MODULE_2__["enumDirection"].right];

class MetaBeltBaseBuilding extends _meta_building__WEBPACK_IMPORTED_MODULE_10__["MetaBuilding"] {
    constructor() {
        super("belt");
    }

    getSilhouetteColor() {
        return "#777";
    }

    /**
     * @param {GameRoot} root
     * @param {string} variant
     * @returns {Array<[string, string]>}
     */
    getAdditionalStatistics(root, variant) {
        const beltSpeed = root.hubGoals.getBeltBaseSpeed();

        return [[_translations__WEBPACK_IMPORTED_MODULE_4__["T"].ingame.buildingPlacement.infoTexts.speed, Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["formatItemsPerSecond"])(beltSpeed)]];
    }

    getPreviewSprite(rotationVariant) {
        switch (arrayBeltVariantToRotation[rotationVariant]) {
            case _core_vector__WEBPACK_IMPORTED_MODULE_2__["enumDirection"].top: {
                return _core_loader__WEBPACK_IMPORTED_MODULE_0__["Loader"].getSprite("sprites/buildings/belt_top.png");
            }
            case _core_vector__WEBPACK_IMPORTED_MODULE_2__["enumDirection"].left: {
                return _core_loader__WEBPACK_IMPORTED_MODULE_0__["Loader"].getSprite("sprites/buildings/belt_left.png");
            }
            case _core_vector__WEBPACK_IMPORTED_MODULE_2__["enumDirection"].right: {
                return _core_loader__WEBPACK_IMPORTED_MODULE_0__["Loader"].getSprite("sprites/buildings/belt_right.png");
            }
            default: {
                window.assert(false, "Invalid belt rotation variant");
            }
        }
    }

    getBlueprintSprite(rotationVariant) {
        switch (arrayBeltVariantToRotation[rotationVariant]) {
            case _core_vector__WEBPACK_IMPORTED_MODULE_2__["enumDirection"].top: {
                return _core_loader__WEBPACK_IMPORTED_MODULE_0__["Loader"].getSprite("sprites/blueprints/belt_top.png");
            }
            case _core_vector__WEBPACK_IMPORTED_MODULE_2__["enumDirection"].left: {
                return _core_loader__WEBPACK_IMPORTED_MODULE_0__["Loader"].getSprite("sprites/blueprints/belt_left.png");
            }
            case _core_vector__WEBPACK_IMPORTED_MODULE_2__["enumDirection"].right: {
                return _core_loader__WEBPACK_IMPORTED_MODULE_0__["Loader"].getSprite("sprites/blueprints/belt_right.png");
            }
            default: {
                window.assert(false, "Invalid belt rotation variant");
            }
        }
    }

    getStayInPlacementMode() {
        return true;
    }

    getRotateAutomaticallyWhilePlacing() {
        return true;
    }

    getPlacementSound() {
        return _platform_sound__WEBPACK_IMPORTED_MODULE_3__["SOUNDS"].placeBelt;
    }

    /**
     * Creates the entity at the given location
     * @param {Entity} entity
     */
    setupEntityComponents(entity) {
        entity.addComponent(
            new _components_belt__WEBPACK_IMPORTED_MODULE_5__["BeltComponent"]({
                direction: _core_vector__WEBPACK_IMPORTED_MODULE_2__["enumDirection"].top, // updated later
            })
        );

        entity.addComponent(
            new _components_item_acceptor__WEBPACK_IMPORTED_MODULE_6__["ItemAcceptorComponent"]({
                slots: [
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_2__["Vector"](0, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_2__["enumDirection"].bottom],
                    },
                ],
                animated: false,
            })
        );

        entity.addComponent(
            new _components_item_ejector__WEBPACK_IMPORTED_MODULE_7__["ItemEjectorComponent"]({
                slots: [
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_2__["Vector"](0, 0),
                        direction: _core_vector__WEBPACK_IMPORTED_MODULE_2__["enumDirection"].top, // updated later
                    },
                ],
                instantEject: true,
            })
        );
        // Make this entity replaceabel
        entity.addComponent(new _components_replaceable_map_entity__WEBPACK_IMPORTED_MODULE_8__["ReplaceableMapEntityComponent"]());
    }

    /**
     *
     * @param {Entity} entity
     * @param {number} rotationVariant
     */
    updateVariants(entity, rotationVariant) {
        entity.components.Belt.direction = arrayBeltVariantToRotation[rotationVariant];
        entity.components.ItemEjector.slots[0].direction = arrayBeltVariantToRotation[rotationVariant];

        entity.components.StaticMapEntity.spriteKey = null;
    }

    /**
     * Computes optimal belt rotation variant
     * @param {GameRoot} root
     * @param {Vector} tile
     * @param {number} rotation
     * @param {string} variant
     * @return {{ rotation: number, rotationVariant: number }}
     */
    computeOptimalDirectionAndRotationVariantAtTile(root, tile, rotation, variant) {
        const topDirection = _core_vector__WEBPACK_IMPORTED_MODULE_2__["enumAngleToDirection"][rotation];
        const rightDirection = _core_vector__WEBPACK_IMPORTED_MODULE_2__["enumAngleToDirection"][(rotation + 90) % 360];
        const bottomDirection = _core_vector__WEBPACK_IMPORTED_MODULE_2__["enumAngleToDirection"][(rotation + 180) % 360];
        const leftDirection = _core_vector__WEBPACK_IMPORTED_MODULE_2__["enumAngleToDirection"][(rotation + 270) % 360];

        const { ejectors, acceptors } = root.logic.getEjectorsAndAcceptorsAtTile(tile);

        let hasBottomEjector = false;
        let hasRightEjector = false;
        let hasLeftEjector = false;

        let hasTopAcceptor = false;
        let hasLeftAcceptor = false;
        let hasRightAcceptor = false;

        // Check all ejectors
        for (let i = 0; i < ejectors.length; ++i) {
            const ejector = ejectors[i];

            if (ejector.toDirection === topDirection) {
                hasBottomEjector = true;
            } else if (ejector.toDirection === leftDirection) {
                hasRightEjector = true;
            } else if (ejector.toDirection === rightDirection) {
                hasLeftEjector = true;
            }
        }

        // Check all acceptors
        for (let i = 0; i < acceptors.length; ++i) {
            const acceptor = acceptors[i];
            if (acceptor.fromDirection === bottomDirection) {
                hasTopAcceptor = true;
            } else if (acceptor.fromDirection === rightDirection) {
                hasLeftAcceptor = true;
            } else if (acceptor.fromDirection === leftDirection) {
                hasRightAcceptor = true;
            }
        }

        // Soo .. if there is any ejector below us we always prioritize
        // this ejector
        if (!hasBottomEjector) {
            // When something ejects to us from the left and nothing from the right,
            // do a curve from the left to the top

            if (hasRightEjector && !hasLeftEjector) {
                return {
                    rotation: (rotation + 270) % 360,
                    rotationVariant: 2,
                };
            }

            // When something ejects to us from the right and nothing from the left,
            // do a curve from the right to the top
            if (hasLeftEjector && !hasRightEjector) {
                return {
                    rotation: (rotation + 90) % 360,
                    rotationVariant: 1,
                };
            }
        }

        // When there is a top acceptor, ignore sides
        // NOTICE: This makes the belt prefer side turns *way* too much!
        if (!hasTopAcceptor) {
            // When there is an acceptor to the right but no acceptor to the left,
            // do a turn to the right
            if (hasRightAcceptor && !hasLeftAcceptor) {
                return {
                    rotation,
                    rotationVariant: 2,
                };
            }

            // When there is an acceptor to the left but no acceptor to the right,
            // do a turn to the left
            if (hasLeftAcceptor && !hasRightAcceptor) {
                return {
                    rotation,
                    rotationVariant: 1,
                };
            }
        }

        return {
            rotation,
            rotationVariant: 0,
        };
    }
}


/***/ }),

/***/ "./src/js/game/buildings/cutter.js":
/*!*****************************************!*\
  !*** ./src/js/game/buildings/cutter.js ***!
  \*****************************************/
/*! exports provided: enumCutterVariants, MetaCutterBuilding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumCutterVariants", function() { return enumCutterVariants; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MetaCutterBuilding", function() { return MetaCutterBuilding; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/item_acceptor */ "./src/js/game/components/item_acceptor.js");
/* harmony import */ var _components_item_ejector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/item_ejector */ "./src/js/game/components/item_ejector.js");
/* harmony import */ var _components_item_processor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/item_processor */ "./src/js/game/components/item_processor.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../root */ "./src/js/game/root.js");
/* harmony import */ var _tutorial_goals__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tutorial_goals */ "./src/js/game/tutorial_goals.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../translations */ "./src/js/translations.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/utils */ "./src/js/core/utils.js");












/** @enum {string} */
const enumCutterVariants = { quad: "quad" };

class MetaCutterBuilding extends _meta_building__WEBPACK_IMPORTED_MODULE_6__["MetaBuilding"] {
    constructor() {
        super("cutter");
    }

    getSilhouetteColor() {
        return "#7dcda2";
    }

    getDimensions(variant) {
        switch (variant) {
            case _meta_building__WEBPACK_IMPORTED_MODULE_6__["defaultBuildingVariant"]:
                return new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](2, 1);
            case enumCutterVariants.quad:
                return new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](4, 1);
            default:
                window.assert(false, "Unknown splitter variant: " + variant);
        }
    }

    /**
     * @param {GameRoot} root
     * @param {string} variant
     * @returns {Array<[string, string]>}
     */
    getAdditionalStatistics(root, variant) {
        const speed = root.hubGoals.getProcessorBaseSpeed(
            variant === enumCutterVariants.quad
                ? _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].cutterQuad
                : _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].cutter
        );
        return [[_translations__WEBPACK_IMPORTED_MODULE_9__["T"].ingame.buildingPlacement.infoTexts.speed, Object(_core_utils__WEBPACK_IMPORTED_MODULE_10__["formatItemsPerSecond"])(speed)]];
    }

    /**
     * @param {GameRoot} root
     */
    getAvailableVariants(root) {
        if (root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_8__["enumHubGoalRewards"].reward_cutter_quad)) {
            return [_meta_building__WEBPACK_IMPORTED_MODULE_6__["defaultBuildingVariant"], enumCutterVariants.quad];
        }
        return super.getAvailableVariants(root);
    }

    /**
     * @param {GameRoot} root
     */
    getIsUnlocked(root) {
        return root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_8__["enumHubGoalRewards"].reward_cutter_and_trash);
    }

    /**
     * Creates the entity at the given location
     * @param {Entity} entity
     */
    setupEntityComponents(entity) {
        entity.addComponent(
            new _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["ItemProcessorComponent"]({
                inputsPerCharge: 1,
                processorType: _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].cutter,
            })
        );
        entity.addComponent(new _components_item_ejector__WEBPACK_IMPORTED_MODULE_3__["ItemEjectorComponent"]({}));
        entity.addComponent(
            new _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["ItemAcceptorComponent"]({
                slots: [
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].bottom],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].shape,
                    },
                ],
            })
        );
    }

    /**
     *
     * @param {Entity} entity
     * @param {number} rotationVariant
     * @param {string} variant
     */
    updateVariants(entity, rotationVariant, variant) {
        switch (variant) {
            case _meta_building__WEBPACK_IMPORTED_MODULE_6__["defaultBuildingVariant"]: {
                entity.components.ItemEjector.setSlots([
                    { pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top },
                    { pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](1, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top },
                ]);
                entity.components.ItemProcessor.type = _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].cutter;
                break;
            }
            case enumCutterVariants.quad: {
                entity.components.ItemEjector.setSlots([
                    { pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top },
                    { pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](1, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top },
                    { pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](2, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top },
                    { pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](3, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top },
                ]);
                entity.components.ItemProcessor.type = _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].cutterQuad;
                break;
            }

            default:
                window.assert(false, "Unknown painter variant: " + variant);
        }
    }
}


/***/ }),

/***/ "./src/js/game/buildings/hub.js":
/*!**************************************!*\
  !*** ./src/js/game/buildings/hub.js ***!
  \**************************************/
/*! exports provided: MetaHubBuilding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MetaHubBuilding", function() { return MetaHubBuilding; });
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _components_item_acceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/item_acceptor */ "./src/js/game/components/item_acceptor.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _components_item_processor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/item_processor */ "./src/js/game/components/item_processor.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _components_unremovable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../components/unremovable */ "./src/js/game/components/unremovable.js");
/* harmony import */ var _components_hub__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/hub */ "./src/js/game/components/hub.js");









class MetaHubBuilding extends _meta_building__WEBPACK_IMPORTED_MODULE_3__["MetaBuilding"] {
    constructor() {
        super("hub");
    }

    getDimensions() {
        return new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](4, 4);
    }

    getSilhouetteColor() {
        return "#eb5555";
    }

    isRotateable() {
        return false;
    }

    getBlueprintSprite() {
        return null;
    }

    /**
     * Creates the entity at the given location
     * @param {Entity} entity
     */
    setupEntityComponents(entity) {
        entity.addComponent(new _components_hub__WEBPACK_IMPORTED_MODULE_7__["HubComponent"]());
        entity.addComponent(
            new _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["ItemProcessorComponent"]({
                inputsPerCharge: 1,
                processorType: _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].hub,
            })
        );

        // We render the sprite ourself
        entity.components.StaticMapEntity.spriteKey = null;

        entity.addComponent(new _components_unremovable__WEBPACK_IMPORTED_MODULE_6__["UnremovableComponent"]());
        entity.addComponent(
            new _components_item_acceptor__WEBPACK_IMPORTED_MODULE_1__["ItemAcceptorComponent"]({
                slots: [
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].top, _core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].left],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_1__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](1, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].top],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_1__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](2, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].top],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_1__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](3, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].top, _core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].right],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_1__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 3),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].bottom, _core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].left],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_1__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](1, 3),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].bottom],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_1__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](2, 3),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].bottom],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_1__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](3, 3),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].bottom, _core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].right],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_1__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 1),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].left],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_1__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 2),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].left],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_1__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 3),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].left],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_1__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](3, 1),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].right],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_1__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](3, 2),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].right],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_1__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](3, 3),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].right],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_1__["enumItemAcceptorItemFilter"].shape,
                    },
                ],
            })
        );
    }
}


/***/ }),

/***/ "./src/js/game/buildings/miner.js":
/*!****************************************!*\
  !*** ./src/js/game/buildings/miner.js ***!
  \****************************************/
/*! exports provided: enumMinerVariants, MetaMinerBuilding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumMinerVariants", function() { return enumMinerVariants; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MetaMinerBuilding", function() { return MetaMinerBuilding; });
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _components_item_ejector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/item_ejector */ "./src/js/game/components/item_ejector.js");
/* harmony import */ var _components_miner__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/miner */ "./src/js/game/components/miner.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../root */ "./src/js/game/root.js");
/* harmony import */ var _tutorial_goals__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tutorial_goals */ "./src/js/game/tutorial_goals.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../translations */ "./src/js/translations.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/utils */ "./src/js/core/utils.js");










/** @enum {string} */
const enumMinerVariants = { chainable: "chainable" };

class MetaMinerBuilding extends _meta_building__WEBPACK_IMPORTED_MODULE_4__["MetaBuilding"] {
    constructor() {
        super("miner");
    }

    getSilhouetteColor() {
        return "#b37dcd";
    }

    /**
     * @param {GameRoot} root
     * @param {string} variant
     * @returns {Array<[string, string]>}
     */
    getAdditionalStatistics(root, variant) {
        const speed = root.hubGoals.getMinerBaseSpeed();
        return [[_translations__WEBPACK_IMPORTED_MODULE_7__["T"].ingame.buildingPlacement.infoTexts.speed, Object(_core_utils__WEBPACK_IMPORTED_MODULE_8__["formatItemsPerSecond"])(speed)]];
    }

    /**
     *
     * @param {GameRoot} root
     */
    getAvailableVariants(root) {
        if (root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_6__["enumHubGoalRewards"].reward_miner_chainable)) {
            return [_meta_building__WEBPACK_IMPORTED_MODULE_4__["defaultBuildingVariant"], enumMinerVariants.chainable];
        }
        return super.getAvailableVariants(root);
    }

    /**
     * Creates the entity at the given location
     * @param {Entity} entity
     */
    setupEntityComponents(entity) {
        entity.addComponent(new _components_miner__WEBPACK_IMPORTED_MODULE_2__["MinerComponent"]({}));
        entity.addComponent(
            new _components_item_ejector__WEBPACK_IMPORTED_MODULE_1__["ItemEjectorComponent"]({
                slots: [{ pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].top }],
            })
        );
    }

    /**
     *
     * @param {Entity} entity
     * @param {number} rotationVariant
     * @param {string} variant
     */
    updateVariants(entity, rotationVariant, variant) {
        entity.components.Miner.chainable = variant === enumMinerVariants.chainable;
    }
}


/***/ }),

/***/ "./src/js/game/buildings/mixer.js":
/*!****************************************!*\
  !*** ./src/js/game/buildings/mixer.js ***!
  \****************************************/
/*! exports provided: MetaMixerBuilding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MetaMixerBuilding", function() { return MetaMixerBuilding; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/item_acceptor */ "./src/js/game/components/item_acceptor.js");
/* harmony import */ var _components_item_ejector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/item_ejector */ "./src/js/game/components/item_ejector.js");
/* harmony import */ var _components_item_processor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/item_processor */ "./src/js/game/components/item_processor.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../root */ "./src/js/game/root.js");
/* harmony import */ var _tutorial_goals__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tutorial_goals */ "./src/js/game/tutorial_goals.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../translations */ "./src/js/translations.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/utils */ "./src/js/core/utils.js");












class MetaMixerBuilding extends _meta_building__WEBPACK_IMPORTED_MODULE_6__["MetaBuilding"] {
    constructor() {
        super("mixer");
    }

    getDimensions() {
        return new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](2, 1);
    }

    getSilhouetteColor() {
        return "#cdbb7d";
    }

    /**
     * @param {GameRoot} root
     */
    getIsUnlocked(root) {
        return root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_8__["enumHubGoalRewards"].reward_mixer);
    }

    /**
     * @param {GameRoot} root
     * @param {string} variant
     * @returns {Array<[string, string]>}
     */
    getAdditionalStatistics(root, variant) {
        const speed = root.hubGoals.getProcessorBaseSpeed(_components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].mixer);
        return [[_translations__WEBPACK_IMPORTED_MODULE_9__["T"].ingame.buildingPlacement.infoTexts.speed, Object(_core_utils__WEBPACK_IMPORTED_MODULE_10__["formatItemsPerSecond"])(speed)]];
    }

    /**
     * Creates the entity at the given location
     * @param {Entity} entity
     */
    setupEntityComponents(entity) {
        entity.addComponent(
            new _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["ItemProcessorComponent"]({
                inputsPerCharge: 2,
                processorType: _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].mixer,
            })
        );

        entity.addComponent(
            new _components_item_ejector__WEBPACK_IMPORTED_MODULE_3__["ItemEjectorComponent"]({
                slots: [{ pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top }],
            })
        );
        entity.addComponent(
            new _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["ItemAcceptorComponent"]({
                slots: [
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].bottom],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].color,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](1, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].bottom],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].color,
                    },
                ],
            })
        );
    }
}


/***/ }),

/***/ "./src/js/game/buildings/painter.js":
/*!******************************************!*\
  !*** ./src/js/game/buildings/painter.js ***!
  \******************************************/
/*! exports provided: enumPainterVariants, MetaPainterBuilding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumPainterVariants", function() { return enumPainterVariants; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MetaPainterBuilding", function() { return MetaPainterBuilding; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/item_acceptor */ "./src/js/game/components/item_acceptor.js");
/* harmony import */ var _components_item_ejector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/item_ejector */ "./src/js/game/components/item_ejector.js");
/* harmony import */ var _components_item_processor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/item_processor */ "./src/js/game/components/item_processor.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _tutorial_goals__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tutorial_goals */ "./src/js/game/tutorial_goals.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../root */ "./src/js/game/root.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../translations */ "./src/js/translations.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/utils */ "./src/js/core/utils.js");












/** @enum {string} */
const enumPainterVariants = { double: "double", quad: "quad" };

class MetaPainterBuilding extends _meta_building__WEBPACK_IMPORTED_MODULE_6__["MetaBuilding"] {
    constructor() {
        super("painter");
    }

    getDimensions(variant) {
        switch (variant) {
            case _meta_building__WEBPACK_IMPORTED_MODULE_6__["defaultBuildingVariant"]:
                return new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](2, 1);
            case enumPainterVariants.double:
                return new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](2, 2);
            case enumPainterVariants.quad:
                return new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](4, 1);
            default:
                window.assert(false, "Unknown painter variant: " + variant);
        }
    }

    getSilhouetteColor() {
        return "#cd9b7d";
    }

    /**
     * @param {GameRoot} root
     * @param {string} variant
     * @returns {Array<[string, string]>}
     */
    getAdditionalStatistics(root, variant) {
        switch (variant) {
            case _meta_building__WEBPACK_IMPORTED_MODULE_6__["defaultBuildingVariant"]: {
                const speed = root.hubGoals.getProcessorBaseSpeed(_components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].painter);
                return [[_translations__WEBPACK_IMPORTED_MODULE_9__["T"].ingame.buildingPlacement.infoTexts.speed, Object(_core_utils__WEBPACK_IMPORTED_MODULE_10__["formatItemsPerSecond"])(speed)]];
            }
            case enumPainterVariants.double: {
                const speed = root.hubGoals.getProcessorBaseSpeed(_components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].painterDouble);
                return [[_translations__WEBPACK_IMPORTED_MODULE_9__["T"].ingame.buildingPlacement.infoTexts.speed, Object(_core_utils__WEBPACK_IMPORTED_MODULE_10__["formatItemsPerSecond"])(speed, true)]];
            }
            case enumPainterVariants.quad: {
                const speed = root.hubGoals.getProcessorBaseSpeed(_components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].painterQuad);
                return [[_translations__WEBPACK_IMPORTED_MODULE_9__["T"].ingame.buildingPlacement.infoTexts.speed, Object(_core_utils__WEBPACK_IMPORTED_MODULE_10__["formatItemsPerSecond"])(speed)]];
            }
        }
    }

    /**
     * @param {GameRoot} root
     */
    getAvailableVariants(root) {
        let variants = [_meta_building__WEBPACK_IMPORTED_MODULE_6__["defaultBuildingVariant"]];
        if (root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_7__["enumHubGoalRewards"].reward_painter_double)) {
            variants.push(enumPainterVariants.double);
        }
        if (root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_7__["enumHubGoalRewards"].reward_painter_quad)) {
            variants.push(enumPainterVariants.quad);
        }
        return variants;
    }

    /**
     * @param {GameRoot} root
     */
    getIsUnlocked(root) {
        return root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_7__["enumHubGoalRewards"].reward_painter);
    }

    /**
     * Creates the entity at the given location
     * @param {Entity} entity
     */
    setupEntityComponents(entity) {
        entity.addComponent(new _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["ItemProcessorComponent"]({}));

        entity.addComponent(
            new _components_item_ejector__WEBPACK_IMPORTED_MODULE_3__["ItemEjectorComponent"]({
                slots: [{ pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](1, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].right }],
            })
        );
        entity.addComponent(
            new _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["ItemAcceptorComponent"]({
                slots: [
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].left],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](1, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].color,
                    },
                ],
            })
        );
    }

    /**
     *
     * @param {Entity} entity
     * @param {number} rotationVariant
     * @param {string} variant
     */
    updateVariants(entity, rotationVariant, variant) {
        switch (variant) {
            case _meta_building__WEBPACK_IMPORTED_MODULE_6__["defaultBuildingVariant"]: {
                entity.components.ItemAcceptor.setSlots([
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].left],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](1, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].color,
                    },
                ]);

                entity.components.ItemProcessor.type = _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].painter;
                entity.components.ItemProcessor.inputsPerCharge = 2;
                entity.components.ItemEjector.setSlots([
                    { pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](1, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].right },
                ]);
                break;
            }
            case enumPainterVariants.double: {
                entity.components.ItemAcceptor.setSlots([
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].left],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 1),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].left],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](1, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].color,
                    },
                ]);

                entity.components.ItemProcessor.type = _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].painterDouble;
                entity.components.ItemProcessor.inputsPerCharge = 3;

                entity.components.ItemEjector.setSlots([
                    { pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](1, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].right },
                ]);
                break;
            }
            case enumPainterVariants.quad: {
                entity.components.ItemAcceptor.setSlots([
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].left],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].bottom],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].color,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](1, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].bottom],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].color,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](2, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].bottom],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].color,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](3, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].bottom],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].color,
                    },
                ]);

                entity.components.ItemProcessor.type = _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].painterQuad;
                entity.components.ItemProcessor.inputsPerCharge = 5;

                entity.components.ItemEjector.setSlots([
                    { pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top },
                ]);
                break;
            }
            default:
                window.assert(false, "Unknown painter variant: " + variant);
        }
    }
}


/***/ }),

/***/ "./src/js/game/buildings/rotater.js":
/*!******************************************!*\
  !*** ./src/js/game/buildings/rotater.js ***!
  \******************************************/
/*! exports provided: enumRotaterVariants, MetaRotaterBuilding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumRotaterVariants", function() { return enumRotaterVariants; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MetaRotaterBuilding", function() { return MetaRotaterBuilding; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/item_acceptor */ "./src/js/game/components/item_acceptor.js");
/* harmony import */ var _components_item_ejector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/item_ejector */ "./src/js/game/components/item_ejector.js");
/* harmony import */ var _components_item_processor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/item_processor */ "./src/js/game/components/item_processor.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _tutorial_goals__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tutorial_goals */ "./src/js/game/tutorial_goals.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../root */ "./src/js/game/root.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../translations */ "./src/js/translations.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/utils */ "./src/js/core/utils.js");












/** @enum {string} */
const enumRotaterVariants = { ccw: "ccw" };

class MetaRotaterBuilding extends _meta_building__WEBPACK_IMPORTED_MODULE_6__["MetaBuilding"] {
    constructor() {
        super("rotater");
    }

    getSilhouetteColor() {
        return "#7dc6cd";
    }

    /**
     * @param {GameRoot} root
     * @param {string} variant
     * @returns {Array<[string, string]>}
     */
    getAdditionalStatistics(root, variant) {
        const speed = root.hubGoals.getProcessorBaseSpeed(
            variant === enumRotaterVariants.ccw
                ? _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].rotaterCCW
                : _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].rotater
        );
        return [[_translations__WEBPACK_IMPORTED_MODULE_9__["T"].ingame.buildingPlacement.infoTexts.speed, Object(_core_utils__WEBPACK_IMPORTED_MODULE_10__["formatItemsPerSecond"])(speed)]];
    }

    /**
     *
     * @param {GameRoot} root
     */
    getAvailableVariants(root) {
        if (root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_7__["enumHubGoalRewards"].reward_rotater_ccw)) {
            return [_meta_building__WEBPACK_IMPORTED_MODULE_6__["defaultBuildingVariant"], enumRotaterVariants.ccw];
        }
        return super.getAvailableVariants(root);
    }

    /**
     * @param {GameRoot} root
     */
    getIsUnlocked(root) {
        return root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_7__["enumHubGoalRewards"].reward_rotater);
    }

    /**
     * Creates the entity at the given location
     * @param {Entity} entity
     */
    setupEntityComponents(entity) {
        entity.addComponent(
            new _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["ItemProcessorComponent"]({
                inputsPerCharge: 1,
                processorType: _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].rotater,
            })
        );

        entity.addComponent(
            new _components_item_ejector__WEBPACK_IMPORTED_MODULE_3__["ItemEjectorComponent"]({
                slots: [{ pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top }],
            })
        );
        entity.addComponent(
            new _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["ItemAcceptorComponent"]({
                slots: [
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].bottom],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].shape,
                    },
                ],
            })
        );
    }

    /**
     *
     * @param {Entity} entity
     * @param {number} rotationVariant
     * @param {string} variant
     */
    updateVariants(entity, rotationVariant, variant) {
        switch (variant) {
            case _meta_building__WEBPACK_IMPORTED_MODULE_6__["defaultBuildingVariant"]: {
                entity.components.ItemProcessor.type = _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].rotater;
                break;
            }
            case enumRotaterVariants.ccw: {
                entity.components.ItemProcessor.type = _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].rotaterCCW;
                break;
            }
            default:
                window.assert(false, "Unknown rotater variant: " + variant);
        }
    }
}


/***/ }),

/***/ "./src/js/game/buildings/sorter.js":
/*!*****************************************!*\
  !*** ./src/js/game/buildings/sorter.js ***!
  \*****************************************/
/*! exports provided: MetaSorterBuilding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MetaSorterBuilding", function() { return MetaSorterBuilding; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/item_acceptor */ "./src/js/game/components/item_acceptor.js");
/* harmony import */ var _components_item_ejector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/item_ejector */ "./src/js/game/components/item_ejector.js");
/* harmony import */ var _components_item_processor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/item_processor */ "./src/js/game/components/item_processor.js");
/* harmony import */ var _components_sorter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/sorter */ "./src/js/game/components/sorter.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../root */ "./src/js/game/root.js");
/* harmony import */ var _tutorial_goals__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../tutorial_goals */ "./src/js/game/tutorial_goals.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../translations */ "./src/js/translations.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/utils */ "./src/js/core/utils.js");













class MetaSorterBuilding extends _meta_building__WEBPACK_IMPORTED_MODULE_7__["MetaBuilding"] {
    constructor() {
        super("sorter");
    }

    getDimensions() {
        return new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](1, 1);
    }

    getSilhouetteColor() {
        return "#ff6000";
    }

    /**
     * @param {GameRoot} root
     */
    getIsUnlocked(root) {
        return root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_9__["enumHubGoalRewards"].reward_sorter);
    }

    /**
     * @param {GameRoot} root
     * @param {string} variant
     * @returns {Array<[string, string]>}
     */
    getAdditionalStatistics(root, variant) {
        const speed = root.hubGoals.getProcessorBaseSpeed(_components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].sorter);
        return [[_translations__WEBPACK_IMPORTED_MODULE_10__["T"].ingame.buildingPlacement.infoTexts.speed, Object(_core_utils__WEBPACK_IMPORTED_MODULE_11__["formatItemsPerSecond"])(speed)]];
    }

    /**
     * Creates the entity at the given location
     * @param {Entity} entity
     */
    setupEntityComponents(entity) {
        entity.addComponent(
            new _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["ItemProcessorComponent"]({
                inputsPerCharge: 1,
                processorType: _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].sorter,
            })
        );
        entity.addComponent(new _components_sorter__WEBPACK_IMPORTED_MODULE_5__["SorterComponent"]({}));
        entity.addComponent(
            new _components_item_ejector__WEBPACK_IMPORTED_MODULE_3__["ItemEjectorComponent"]({
                slots: [
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0),
                        direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].left,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0),
                        direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top,
                    },
                    //{
                    //    pos: new Vector(0, 0),
                    //    direction: enumDirection.right,
                    //},
                ],
            })
        );
        entity.addComponent(
            new _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["ItemAcceptorComponent"]({
                slots: [
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].bottom],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].shape,
                    },
                ],
            })
        );
    }
}


/***/ }),

/***/ "./src/js/game/buildings/splitter.js":
/*!*******************************************!*\
  !*** ./src/js/game/buildings/splitter.js ***!
  \*******************************************/
/*! exports provided: enumSplitterVariants, MetaSplitterBuilding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumSplitterVariants", function() { return enumSplitterVariants; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MetaSplitterBuilding", function() { return MetaSplitterBuilding; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/item_acceptor */ "./src/js/game/components/item_acceptor.js");
/* harmony import */ var _components_item_ejector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/item_ejector */ "./src/js/game/components/item_ejector.js");
/* harmony import */ var _components_item_processor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/item_processor */ "./src/js/game/components/item_processor.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../root */ "./src/js/game/root.js");
/* harmony import */ var _tutorial_goals__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tutorial_goals */ "./src/js/game/tutorial_goals.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../translations */ "./src/js/translations.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/utils */ "./src/js/core/utils.js");












/** @enum {string} */
const enumSplitterVariants = { compact: "compact", compactInverse: "compact-inverse" };

class MetaSplitterBuilding extends _meta_building__WEBPACK_IMPORTED_MODULE_6__["MetaBuilding"] {
    constructor() {
        super("splitter");
    }

    getDimensions(variant) {
        switch (variant) {
            case _meta_building__WEBPACK_IMPORTED_MODULE_6__["defaultBuildingVariant"]:
                return new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](2, 1);
            case enumSplitterVariants.compact:
            case enumSplitterVariants.compactInverse:
                return new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](1, 1);
            default:
                window.assert(false, "Unknown splitter variant: " + variant);
        }
    }

    /**
     * @param {GameRoot} root
     * @param {string} variant
     * @returns {Array<[string, string]>}
     */
    getAdditionalStatistics(root, variant) {
        const speed = root.hubGoals.getProcessorBaseSpeed(_components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].splitter);
        return [[_translations__WEBPACK_IMPORTED_MODULE_9__["T"].ingame.buildingPlacement.infoTexts.speed, Object(_core_utils__WEBPACK_IMPORTED_MODULE_10__["formatItemsPerSecond"])(speed)]];
    }

    getSilhouetteColor() {
        return "#444";
    }

    /**
     * @param {GameRoot} root
     */
    getAvailableVariants(root) {
        if (root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_8__["enumHubGoalRewards"].reward_splitter_compact)) {
            return [
                _meta_building__WEBPACK_IMPORTED_MODULE_6__["defaultBuildingVariant"],
                enumSplitterVariants.compact,
                enumSplitterVariants.compactInverse,
            ];
        }
        return super.getAvailableVariants(root);
    }

    /**
     * @param {GameRoot} root
     */
    getIsUnlocked(root) {
        return root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_8__["enumHubGoalRewards"].reward_splitter);
    }

    /**
     * Creates the entity at the given location
     * @param {Entity} entity
     */
    setupEntityComponents(entity) {
        entity.addComponent(
            new _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["ItemAcceptorComponent"]({
                slots: [
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].bottom],
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](1, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].bottom],
                    },
                ],
            })
        );

        entity.addComponent(
            new _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["ItemProcessorComponent"]({
                inputsPerCharge: 1,
                processorType: _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].splitter,
            })
        );

        entity.addComponent(
            new _components_item_ejector__WEBPACK_IMPORTED_MODULE_3__["ItemEjectorComponent"]({
                slots: [
                    { pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top },
                    { pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](1, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top },
                ],
            })
        );
    }

    /**
     *
     * @param {Entity} entity
     * @param {number} rotationVariant
     * @param {string} variant
     */
    updateVariants(entity, rotationVariant, variant) {
        switch (variant) {
            case _meta_building__WEBPACK_IMPORTED_MODULE_6__["defaultBuildingVariant"]: {
                entity.components.ItemAcceptor.setSlots([
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].bottom],
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](1, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].bottom],
                    },
                ]);

                entity.components.ItemEjector.setSlots([
                    { pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top },
                    { pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](1, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top },
                ]);

                entity.components.ItemAcceptor.beltUnderlays = [
                    { pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top },
                    { pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](1, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top },
                ];

                break;
            }
            case enumSplitterVariants.compact:
            case enumSplitterVariants.compactInverse: {
                entity.components.ItemAcceptor.setSlots([
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].bottom],
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0),
                        directions: [
                            variant === enumSplitterVariants.compactInverse
                                ? _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].left
                                : _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].right,
                        ],
                    },
                ]);

                entity.components.ItemEjector.setSlots([
                    { pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top },
                ]);

                entity.components.ItemAcceptor.beltUnderlays = [
                    { pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top },
                ];

                break;
            }
            default:
                window.assert(false, "Unknown painter variant: " + variant);
        }
    }
}


/***/ }),

/***/ "./src/js/game/buildings/stacker.js":
/*!******************************************!*\
  !*** ./src/js/game/buildings/stacker.js ***!
  \******************************************/
/*! exports provided: MetaStackerBuilding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MetaStackerBuilding", function() { return MetaStackerBuilding; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/item_acceptor */ "./src/js/game/components/item_acceptor.js");
/* harmony import */ var _components_item_ejector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/item_ejector */ "./src/js/game/components/item_ejector.js");
/* harmony import */ var _components_item_processor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/item_processor */ "./src/js/game/components/item_processor.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../root */ "./src/js/game/root.js");
/* harmony import */ var _tutorial_goals__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tutorial_goals */ "./src/js/game/tutorial_goals.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../translations */ "./src/js/translations.js");












class MetaStackerBuilding extends _meta_building__WEBPACK_IMPORTED_MODULE_6__["MetaBuilding"] {
    constructor() {
        super("stacker");
    }

    getSilhouetteColor() {
        return "#9fcd7d";
    }

    getDimensions() {
        return new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](2, 1);
    }

    /**
     * @param {GameRoot} root
     * @param {string} variant
     * @returns {Array<[string, string]>}
     */
    getAdditionalStatistics(root, variant) {
        const speed = root.hubGoals.getProcessorBaseSpeed(_components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].stacker);
        return [[_translations__WEBPACK_IMPORTED_MODULE_10__["T"].ingame.buildingPlacement.infoTexts.speed, Object(_core_utils__WEBPACK_IMPORTED_MODULE_9__["formatItemsPerSecond"])(speed)]];
    }

    /**
     * @param {GameRoot} root
     */
    getIsUnlocked(root) {
        return root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_8__["enumHubGoalRewards"].reward_stacker);
    }

    /**
     * Creates the entity at the given location
     * @param {Entity} entity
     */
    setupEntityComponents(entity) {
        entity.addComponent(
            new _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["ItemProcessorComponent"]({
                inputsPerCharge: 2,
                processorType: _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].stacker,
            })
        );

        entity.addComponent(
            new _components_item_ejector__WEBPACK_IMPORTED_MODULE_3__["ItemEjectorComponent"]({
                slots: [{ pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0), direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top }],
            })
        );
        entity.addComponent(
            new _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["ItemAcceptorComponent"]({
                slots: [
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].bottom],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].shape,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](1, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].bottom],
                        filter: _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["enumItemAcceptorItemFilter"].shape,
                    },
                ],
            })
        );
    }
}


/***/ }),

/***/ "./src/js/game/buildings/trash.js":
/*!****************************************!*\
  !*** ./src/js/game/buildings/trash.js ***!
  \****************************************/
/*! exports provided: enumTrashVariants, MetaTrashBuilding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumTrashVariants", function() { return enumTrashVariants; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MetaTrashBuilding", function() { return MetaTrashBuilding; });
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _components_item_acceptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/item_acceptor */ "./src/js/game/components/item_acceptor.js");
/* harmony import */ var _components_item_ejector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/item_ejector */ "./src/js/game/components/item_ejector.js");
/* harmony import */ var _components_item_processor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/item_processor */ "./src/js/game/components/item_processor.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _tutorial_goals__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tutorial_goals */ "./src/js/game/tutorial_goals.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../root */ "./src/js/game/root.js");
/* harmony import */ var _components_storage__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../components/storage */ "./src/js/game/components/storage.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../translations */ "./src/js/translations.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/utils */ "./src/js/core/utils.js");












/** @enum {string} */
const enumTrashVariants = { storage: "storage" };

const trashSize = 5000;

class MetaTrashBuilding extends _meta_building__WEBPACK_IMPORTED_MODULE_5__["MetaBuilding"] {
    constructor() {
        super("trash");
    }

    isRotateable(variant) {
        return variant !== _meta_building__WEBPACK_IMPORTED_MODULE_5__["defaultBuildingVariant"];
    }

    getSilhouetteColor() {
        return "#cd7d86";
    }

    /**
     * @param {GameRoot} root
     * @param {string} variant
     * @returns {Array<[string, string]>}
     */
    getAdditionalStatistics(root, variant) {
        if (variant === enumTrashVariants.storage) {
            return [[_translations__WEBPACK_IMPORTED_MODULE_9__["T"].ingame.buildingPlacement.infoTexts.storage, Object(_core_utils__WEBPACK_IMPORTED_MODULE_10__["formatBigNumber"])(trashSize)]];
        }
        return [];
    }

    getDimensions(variant) {
        switch (variant) {
            case _meta_building__WEBPACK_IMPORTED_MODULE_5__["defaultBuildingVariant"]:
                return new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](1, 1);
            case enumTrashVariants.storage:
                return new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](2, 2);
            default:
                window.assert(false, "Unknown trash variant: " + variant);
        }
    }

    /**
     * @param {GameRoot} root
     */
    getAvailableVariants(root) {
        if (root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_6__["enumHubGoalRewards"].reward_storage)) {
            return [_meta_building__WEBPACK_IMPORTED_MODULE_5__["defaultBuildingVariant"], enumTrashVariants.storage];
        }
        return super.getAvailableVariants(root);
    }

    /**
     * @param {GameRoot} root
     */
    getIsUnlocked(root) {
        return root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_6__["enumHubGoalRewards"].reward_cutter_and_trash);
    }

    /**
     * Creates the entity at the given location
     * @param {Entity} entity
     */
    setupEntityComponents(entity) {
        // Required, since the item processor needs this.
        entity.addComponent(
            new _components_item_ejector__WEBPACK_IMPORTED_MODULE_2__["ItemEjectorComponent"]({
                slots: [],
            })
        );

        entity.addComponent(
            new _components_item_acceptor__WEBPACK_IMPORTED_MODULE_1__["ItemAcceptorComponent"]({
                slots: [
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 0),
                        directions: [
                            _core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].top,
                            _core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].right,
                            _core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].bottom,
                            _core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].left,
                        ],
                    },
                ],
            })
        );
    }

    /**
     *
     * @param {Entity} entity
     * @param {number} rotationVariant
     * @param {string} variant
     */
    updateVariants(entity, rotationVariant, variant) {
        switch (variant) {
            case _meta_building__WEBPACK_IMPORTED_MODULE_5__["defaultBuildingVariant"]: {
                if (!entity.components.ItemProcessor) {
                    entity.addComponent(
                        new _components_item_processor__WEBPACK_IMPORTED_MODULE_3__["ItemProcessorComponent"]({
                            inputsPerCharge: 1,
                            processorType: _components_item_processor__WEBPACK_IMPORTED_MODULE_3__["enumItemProcessorTypes"].trash,
                        })
                    );
                }
                if (entity.components.Storage) {
                    entity.removeComponent(_components_storage__WEBPACK_IMPORTED_MODULE_8__["StorageComponent"]);
                }

                entity.components.ItemAcceptor.setSlots([
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 0),
                        directions: [
                            _core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].top,
                            _core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].right,
                            _core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].bottom,
                            _core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].left,
                        ],
                    },
                ]);
                entity.components.ItemEjector.setSlots([]);
                entity.components.ItemProcessor.type = _components_item_processor__WEBPACK_IMPORTED_MODULE_3__["enumItemProcessorTypes"].trash;
                break;
            }
            case enumTrashVariants.storage: {
                if (entity.components.ItemProcessor) {
                    entity.removeComponent(_components_item_processor__WEBPACK_IMPORTED_MODULE_3__["ItemProcessorComponent"]);
                }
                if (!entity.components.Storage) {
                    entity.addComponent(new _components_storage__WEBPACK_IMPORTED_MODULE_8__["StorageComponent"]({}));
                }

                entity.components.Storage.maximumStorage = trashSize;
                entity.components.ItemAcceptor.setSlots([
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 1),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].bottom],
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](1, 1),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].bottom],
                    },
                ]);

                entity.components.ItemEjector.setSlots([
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](0, 0),
                        direction: _core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].top,
                    },
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](1, 0),
                        direction: _core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"].top,
                    },
                ]);
                break;
            }
            default:
                window.assert(false, "Unknown trash variant: " + variant);
        }
    }
}


/***/ }),

/***/ "./src/js/game/buildings/underground_belt.js":
/*!***************************************************!*\
  !*** ./src/js/game/buildings/underground_belt.js ***!
  \***************************************************/
/*! exports provided: arrayUndergroundRotationVariantToMode, enumUndergroundBeltVariants, enumUndergroundBeltVariantToTier, MetaUndergroundBeltBuilding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayUndergroundRotationVariantToMode", function() { return arrayUndergroundRotationVariantToMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumUndergroundBeltVariants", function() { return enumUndergroundBeltVariants; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumUndergroundBeltVariantToTier", function() { return enumUndergroundBeltVariantToTier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MetaUndergroundBeltBuilding", function() { return MetaUndergroundBeltBuilding; });
/* harmony import */ var _core_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/loader */ "./src/js/core/loader.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/item_acceptor */ "./src/js/game/components/item_acceptor.js");
/* harmony import */ var _components_item_ejector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/item_ejector */ "./src/js/game/components/item_ejector.js");
/* harmony import */ var _components_underground_belt__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/underground_belt */ "./src/js/game/components/underground_belt.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../root */ "./src/js/game/root.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _tutorial_goals__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../tutorial_goals */ "./src/js/game/tutorial_goals.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../translations */ "./src/js/translations.js");













/** @enum {string} */
const arrayUndergroundRotationVariantToMode = [
    _components_underground_belt__WEBPACK_IMPORTED_MODULE_4__["enumUndergroundBeltMode"].sender,
    _components_underground_belt__WEBPACK_IMPORTED_MODULE_4__["enumUndergroundBeltMode"].receiver,
];

/** @enum {string} */
const enumUndergroundBeltVariants = { tier2: "tier2" };

const enumUndergroundBeltVariantToTier = {
    [_meta_building__WEBPACK_IMPORTED_MODULE_6__["defaultBuildingVariant"]]: 0,
    [enumUndergroundBeltVariants.tier2]: 1,
};

class MetaUndergroundBeltBuilding extends _meta_building__WEBPACK_IMPORTED_MODULE_6__["MetaBuilding"] {
    constructor() {
        super("underground_belt");
    }

    getSilhouetteColor() {
        return "#555";
    }

    getFlipOrientationAfterPlacement() {
        return true;
    }

    getStayInPlacementMode() {
        return true;
    }

    /**
     * @param {GameRoot} root
     * @param {string} variant
     * @returns {Array<[string, string]>}
     */
    getAdditionalStatistics(root, variant) {
        const rangeTiles =
            _core_config__WEBPACK_IMPORTED_MODULE_8__["globalConfig"].undergroundBeltMaxTilesByTier[enumUndergroundBeltVariantToTier[variant]];

        const beltSpeed = root.hubGoals.getUndergroundBeltBaseSpeed();
        return [
            [
                _translations__WEBPACK_IMPORTED_MODULE_11__["T"].ingame.buildingPlacement.infoTexts.range,
                _translations__WEBPACK_IMPORTED_MODULE_11__["T"].ingame.buildingPlacement.infoTexts.tiles.replace("<x>", "" + rangeTiles),
            ],
            [_translations__WEBPACK_IMPORTED_MODULE_11__["T"].ingame.buildingPlacement.infoTexts.speed, Object(_core_utils__WEBPACK_IMPORTED_MODULE_10__["formatItemsPerSecond"])(beltSpeed)],
        ];
    }

    /**
     * @param {GameRoot} root
     */
    getAvailableVariants(root) {
        if (root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_9__["enumHubGoalRewards"].reward_underground_belt_tier_2)) {
            return [_meta_building__WEBPACK_IMPORTED_MODULE_6__["defaultBuildingVariant"], enumUndergroundBeltVariants.tier2];
        }
        return super.getAvailableVariants(root);
    }

    getPreviewSprite(rotationVariant, variant) {
        let suffix = "";
        if (variant !== _meta_building__WEBPACK_IMPORTED_MODULE_6__["defaultBuildingVariant"]) {
            suffix = "-" + variant;
        }

        switch (arrayUndergroundRotationVariantToMode[rotationVariant]) {
            case _components_underground_belt__WEBPACK_IMPORTED_MODULE_4__["enumUndergroundBeltMode"].sender:
                return _core_loader__WEBPACK_IMPORTED_MODULE_0__["Loader"].getSprite("sprites/buildings/underground_belt_entry" + suffix + ".png");
            case _components_underground_belt__WEBPACK_IMPORTED_MODULE_4__["enumUndergroundBeltMode"].receiver:
                return _core_loader__WEBPACK_IMPORTED_MODULE_0__["Loader"].getSprite("sprites/buildings/underground_belt_exit" + suffix + ".png");
            default:
                window.assert(false, "Invalid rotation variant");
        }
    }

    getBlueprintSprite(rotationVariant, variant) {
        let suffix = "";
        if (variant !== _meta_building__WEBPACK_IMPORTED_MODULE_6__["defaultBuildingVariant"]) {
            suffix = "-" + variant;
        }

        switch (arrayUndergroundRotationVariantToMode[rotationVariant]) {
            case _components_underground_belt__WEBPACK_IMPORTED_MODULE_4__["enumUndergroundBeltMode"].sender:
                return _core_loader__WEBPACK_IMPORTED_MODULE_0__["Loader"].getSprite("sprites/blueprints/underground_belt_entry" + suffix + ".png");
            case _components_underground_belt__WEBPACK_IMPORTED_MODULE_4__["enumUndergroundBeltMode"].receiver:
                return _core_loader__WEBPACK_IMPORTED_MODULE_0__["Loader"].getSprite("sprites/blueprints/underground_belt_exit" + suffix + ".png");
            default:
                window.assert(false, "Invalid rotation variant");
        }
    }

    /**
     * @param {GameRoot} root
     */
    getIsUnlocked(root) {
        return root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_9__["enumHubGoalRewards"].reward_tunnel);
    }

    /**
     * Creates the entity at the given location
     * @param {Entity} entity
     */
    setupEntityComponents(entity) {
        // Required, since the item processor needs this.
        entity.addComponent(
            new _components_item_ejector__WEBPACK_IMPORTED_MODULE_3__["ItemEjectorComponent"]({
                slots: [],
            })
        );

        entity.addComponent(new _components_underground_belt__WEBPACK_IMPORTED_MODULE_4__["UndergroundBeltComponent"]({}));
        entity.addComponent(
            new _components_item_acceptor__WEBPACK_IMPORTED_MODULE_2__["ItemAcceptorComponent"]({
                slots: [],
            })
        );
    }

    /**
     * @param {GameRoot} root
     * @param {Vector} tile
     * @param {number} rotation
     * @param {string} variant
     * @return {{ rotation: number, rotationVariant: number, connectedEntities?: Array<Entity> }}
     */
    computeOptimalDirectionAndRotationVariantAtTile(root, tile, rotation, variant) {
        const searchDirection = _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumAngleToDirection"][rotation];
        const searchVector = _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirectionToVector"][searchDirection];
        const tier = enumUndergroundBeltVariantToTier[variant];

        const targetRotation = (rotation + 180) % 360;
        const targetSenderRotation = rotation;

        for (
            let searchOffset = 1;
            searchOffset <= _core_config__WEBPACK_IMPORTED_MODULE_8__["globalConfig"].undergroundBeltMaxTilesByTier[tier];
            ++searchOffset
        ) {
            tile = tile.addScalars(searchVector.x, searchVector.y);

            const contents = root.map.getTileContent(tile);
            if (contents) {
                const undergroundComp = contents.components.UndergroundBelt;
                if (undergroundComp && undergroundComp.tier === tier) {
                    const staticComp = contents.components.StaticMapEntity;
                    if (staticComp.rotation === targetRotation) {
                        if (undergroundComp.mode !== _components_underground_belt__WEBPACK_IMPORTED_MODULE_4__["enumUndergroundBeltMode"].sender) {
                            // If we encounter an underground receiver on our way which is also faced in our direction, we don't accept that
                            break;
                        }
                        return {
                            rotation: targetRotation,
                            rotationVariant: 1,
                            connectedEntities: [contents],
                        };
                    } else if (staticComp.rotation === targetSenderRotation) {
                        // Draw connections to receivers
                        if (undergroundComp.mode === _components_underground_belt__WEBPACK_IMPORTED_MODULE_4__["enumUndergroundBeltMode"].receiver) {
                            return {
                                rotation: rotation,
                                rotationVariant: 0,
                                connectedEntities: [contents],
                            };
                        }
                    }
                }
            }
        }

        return {
            rotation,
            rotationVariant: 0,
        };
    }

    /**
     *
     * @param {Entity} entity
     * @param {number} rotationVariant
     * @param {string} variant
     */
    updateVariants(entity, rotationVariant, variant) {
        entity.components.UndergroundBelt.tier = enumUndergroundBeltVariantToTier[variant];
        entity.components.StaticMapEntity.spriteKey = this.getPreviewSprite(
            rotationVariant,
            variant
        ).spriteName;

        switch (arrayUndergroundRotationVariantToMode[rotationVariant]) {
            case _components_underground_belt__WEBPACK_IMPORTED_MODULE_4__["enumUndergroundBeltMode"].sender: {
                entity.components.UndergroundBelt.mode = _components_underground_belt__WEBPACK_IMPORTED_MODULE_4__["enumUndergroundBeltMode"].sender;
                entity.components.ItemEjector.setSlots([]);
                entity.components.ItemAcceptor.setSlots([
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0),
                        directions: [_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].bottom],
                    },
                ]);
                return;
            }
            case _components_underground_belt__WEBPACK_IMPORTED_MODULE_4__["enumUndergroundBeltMode"].receiver: {
                entity.components.UndergroundBelt.mode = _components_underground_belt__WEBPACK_IMPORTED_MODULE_4__["enumUndergroundBeltMode"].receiver;
                entity.components.ItemAcceptor.setSlots([]);
                entity.components.ItemEjector.setSlots([
                    {
                        pos: new _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"](0, 0),
                        direction: _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"].top,
                    },
                ]);
                return;
            }
            default:
                window.assert(false, "Invalid rotation variant");
        }
    }
}


/***/ }),

/***/ "./src/js/game/camera.js":
/*!*******************************!*\
  !*** ./src/js/game/camera.js ***!
  \*******************************/
/*! exports provided: USER_INTERACT_MOVE, USER_INTERACT_ZOOM, USER_INTERACT_TOUCHEND, enumMouseButton, Camera */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "USER_INTERACT_MOVE", function() { return USER_INTERACT_MOVE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "USER_INTERACT_ZOOM", function() { return USER_INTERACT_ZOOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "USER_INTERACT_TOUCHEND", function() { return USER_INTERACT_TOUCHEND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumMouseButton", function() { return enumMouseButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Camera", function() { return Camera; });
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_click_detector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/click_detector */ "./src/js/core/click_detector.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_query_parameters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/query_parameters */ "./src/js/core/query_parameters.js");
/* harmony import */ var _core_rectangle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/rectangle */ "./src/js/core/rectangle.js");
/* harmony import */ var _core_signal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/signal */ "./src/js/core/signal.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../savegame/serialization */ "./src/js/savegame/serialization.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./root */ "./src/js/game/root.js");
/* harmony import */ var _key_action_mapper__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./key_action_mapper */ "./src/js/game/key_action_mapper.js");













const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_3__["createLogger"])("camera");

const USER_INTERACT_MOVE = "move";
const USER_INTERACT_ZOOM = "zoom";
const USER_INTERACT_TOUCHEND = "touchend";

const velocitySmoothing = 0.5;
const velocityFade = 0.98;
const velocityStrength = 0.4;
const velocityMax = 20;

/**
 * @enum {string}
 */
const enumMouseButton = {
    left: "left",
    middle: "middle",
    right: "right",
};

class Camera extends _savegame_serialization__WEBPACK_IMPORTED_MODULE_9__["BasicSerializableObject"] {
    constructor(root) {
        super();

        /** @type {GameRoot} */
        this.root = root;

        // Zoom level, 2 means double size

        // Find optimal initial zoom

        this.zoomLevel = this.findInitialZoom();
        this.doubleZoomCount = 4;
        this.kbDoubleZoomCount = 4;
        this.clampZoomLevel();

        /** @type {Vector} */
        this.center = new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](0, 0);

        // Input handling
        this.currentlyMoving = false;
        this.lastMovingPosition = null;
        this.cameraUpdateTimeBucket = 0.0;
        this.didMoveSinceTouchStart = false;
        this.currentlyPinching = false;
        this.lastPinchPositions = null;

        this.keyboardForce = new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"]();

        // Signal which gets emitted once the user changed something
        this.userInteraction = new _core_signal__WEBPACK_IMPORTED_MODULE_6__["Signal"]();

        /** @type {Vector} */
        this.currentShake = new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](0, 0);

        /** @type {Vector} */
        this.currentPan = new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](0, 0);

        // Set desired pan (camera movement)
        /** @type {Vector} */
        this.desiredPan = new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](0, 0);

        // Set desired camera center
        /** @type {Vector} */
        this.desiredCenter = null;

        // Set desired camera zoom
        /** @type {number} */
        this.desiredZoom = null;

        /** @type {Vector} */
        this.touchPostMoveVelocity = new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](0, 0);

        // Handlers
        this.downPreHandler = /** @type {TypedSignal<[Vector, enumMouseButton]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_6__["Signal"]());
        this.movePreHandler = /** @type {TypedSignal<[Vector]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_6__["Signal"]());
        // this.pinchPreHandler = /** @type {TypedSignal<[Vector]>} */ (new Signal());
        this.upPostHandler = /** @type {TypedSignal<[Vector]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_6__["Signal"]());

        this.internalInitEvents();
        this.clampZoomLevel();
        this.bindKeys();
        if (true) {
            window.addEventListener("keydown", ev => {
                if (ev.key === "l") {
                    this.zoomLevel = 3;
                }
            });
        }
    }

    // Serialization
    static getId() {
        return "Camera";
    }

    static getSchema() {
        return {
            zoomLevel: _savegame_serialization__WEBPACK_IMPORTED_MODULE_9__["types"].float,
            center: _savegame_serialization__WEBPACK_IMPORTED_MODULE_9__["types"].vector,
        };
    }

    deserialize(data) {
        const errorCode = super.deserialize(data);
        if (errorCode) {
            return errorCode;
        }

        // Safety
        this.clampZoomLevel();
    }

    // Simple geters & setters

    addScreenShake(amount) {
        const currentShakeAmount = this.currentShake.length();
        const scale = 1 / (1 + 3 * currentShakeAmount);
        this.currentShake.x = this.currentShake.x + 2 * (Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_random"])() - 0.5) * scale * amount;
        this.currentShake.y = this.currentShake.y + 2 * (Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_random"])() - 0.5) * scale * amount;
    }

    /**
     * Sets a point in world space to focus on
     * @param {Vector} center
     */
    setDesiredCenter(center) {
        this.desiredCenter = center.copy();
        this.currentlyMoving = false;
    }

    /**
     * Sets a desired zoom level
     * @param {number} zoom
     */
    setDesiredZoom(zoom) {
        this.desiredZoom = zoom;
    }

    /**
     * Returns if this camera is currently moving by a non-user interaction
     */
    isCurrentlyMovingToDesiredCenter() {
        return this.desiredCenter !== null;
    }

    /**
     * Sets the camera pan, every frame the camera will move by this amount
     * @param {Vector} pan
     */
    setPan(pan) {
        this.desiredPan = pan.copy();
    }

    /**
     * Finds a good initial zoom level
     */
    findInitialZoom() {
        const desiredWorldSpaceWidth = 15 * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize;
        const zoomLevelX = this.root.gameWidth / desiredWorldSpaceWidth;
        const zoomLevelY = this.root.gameHeight / desiredWorldSpaceWidth;

        const finalLevel = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_min"])(zoomLevelX, zoomLevelY);
        window.assert(
            Number.isFinite(finalLevel) && finalLevel > 0,
            "Invalid zoom level computed for initial zoom: " + finalLevel
        );
        return finalLevel;
    }

    /**
     * Clears all animations
     */
    clearAnimations() {
        this.touchPostMoveVelocity.x = 0;
        this.touchPostMoveVelocity.y = 0;
        this.desiredCenter = null;
        this.desiredPan.x = 0;
        this.desiredPan.y = 0;
        this.currentPan.x = 0;
        this.currentPan.y = 0;
        this.currentlyPinching = false;
        this.currentlyMoving = false;
        this.lastMovingPosition = null;
        this.didMoveSinceTouchStart = false;
        this.desiredZoom = null;
    }

    /**
     * Returns if the user is currently interacting with the camera
     * @returns {boolean} true if the user interacts
     */
    isCurrentlyInteracting() {
        if (this.currentlyPinching) {
            return true;
        }
        if (this.currentlyMoving) {
            // Only interacting if moved at least once
            return this.didMoveSinceTouchStart;
        }
        if (this.touchPostMoveVelocity.lengthSquare() > 1) {
            return true;
        }
        return false;
    }

    /**
     * Returns if in the next frame the viewport will change
     * @returns {boolean} true if it willchange
     */
    viewportWillChange() {
        return this.desiredCenter !== null || this.desiredZoom !== null || this.isCurrentlyInteracting();
    }

    /**
     * Cancels all interactions, that is user interaction and non user interaction
     */
    cancelAllInteractions() {
        this.touchPostMoveVelocity = new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](0, 0);
        this.desiredCenter = null;
        this.currentlyMoving = false;
        this.currentlyPinching = false;
        this.desiredZoom = null;
    }

    /**
     * Returns effective viewport width
     */
    getViewportWidth() {
        return this.root.gameWidth / this.zoomLevel;
    }

    /**
     * Returns effective viewport height
     */
    getViewportHeight() {
        return this.root.gameHeight / this.zoomLevel;
    }

    /**
     * Returns effective world space viewport left
     */
    getViewportLeft() {
        return this.center.x - this.getViewportWidth() / 2 + (this.currentShake.x * 10) / this.zoomLevel;
    }

    /**
     * Returns effective world space viewport right
     */
    getViewportRight() {
        return this.center.x + this.getViewportWidth() / 2 + (this.currentShake.x * 10) / this.zoomLevel;
    }

    /**
     * Returns effective world space viewport top
     */
    getViewportTop() {
        return this.center.y - this.getViewportHeight() / 2 + (this.currentShake.x * 10) / this.zoomLevel;
    }

    /**
     * Returns effective world space viewport bottom
     */
    getViewportBottom() {
        return this.center.y + this.getViewportHeight() / 2 + (this.currentShake.x * 10) / this.zoomLevel;
    }

    /**
     * Returns the visible world space rect
     * @returns {Rectangle}
     */
    getVisibleRect() {
        return _core_rectangle__WEBPACK_IMPORTED_MODULE_5__["Rectangle"].fromTRBL(
            Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_floor"])(this.getViewportTop()),
            Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_ceil"])(this.getViewportRight()),
            Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_ceil"])(this.getViewportBottom()),
            Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_floor"])(this.getViewportLeft())
        );
    }

    getIsMapOverlayActive() {
        return this.zoomLevel < _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].mapChunkOverviewMinZoom;
    }

    /**
     * Attaches all event listeners
     */
    internalInitEvents() {
        this.eventListenerTouchStart = this.onTouchStart.bind(this);
        this.eventListenerTouchEnd = this.onTouchEnd.bind(this);
        this.eventListenerTouchMove = this.onTouchMove.bind(this);
        this.eventListenerMousewheel = this.onMouseWheel.bind(this);
        this.eventListenerMouseDown = this.onMouseDown.bind(this);
        this.eventListenerMouseMove = this.onMouseMove.bind(this);
        this.eventListenerMouseUp = this.onMouseUp.bind(this);

        this.root.canvas.addEventListener("touchstart", this.eventListenerTouchStart);
        this.root.canvas.addEventListener("touchend", this.eventListenerTouchEnd);
        this.root.canvas.addEventListener("touchcancel", this.eventListenerTouchEnd);
        this.root.canvas.addEventListener("touchmove", this.eventListenerTouchMove);

        this.root.canvas.addEventListener("wheel", this.eventListenerMousewheel);
        this.root.canvas.addEventListener("mousedown", this.eventListenerMouseDown);
        this.root.canvas.addEventListener("mousemove", this.eventListenerMouseMove);
        this.root.canvas.addEventListener("mouseup", this.eventListenerMouseUp);
        this.root.canvas.addEventListener("mouseout", this.eventListenerMouseUp);
    }

    /**
     * Cleans up all event listeners
     */
    cleanup() {
        this.root.canvas.removeEventListener("touchstart", this.eventListenerTouchStart);
        this.root.canvas.removeEventListener("touchend", this.eventListenerTouchEnd);
        this.root.canvas.removeEventListener("touchcancel", this.eventListenerTouchEnd);
        this.root.canvas.removeEventListener("touchmove", this.eventListenerTouchMove);

        this.root.canvas.removeEventListener("wheel", this.eventListenerMousewheel);
        this.root.canvas.removeEventListener("mousedown", this.eventListenerMouseDown);
        this.root.canvas.removeEventListener("mousemove", this.eventListenerMouseMove);
        this.root.canvas.removeEventListener("mouseup", this.eventListenerMouseUp);
        this.root.canvas.removeEventListener("mouseout", this.eventListenerMouseUp);
    }

    /**
     * Binds the arrow keys
     */
    bindKeys() {
        const mapper = this.root.keyMapper;
        mapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_11__["KEYMAPPINGS"].navigation.mapMoveUp).add(() => (this.keyboardForce.y = -1));
        mapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_11__["KEYMAPPINGS"].navigation.mapMoveDown).add(() => (this.keyboardForce.y = 1));
        mapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_11__["KEYMAPPINGS"].navigation.mapMoveRight).add(() => (this.keyboardForce.x = 1));
        mapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_11__["KEYMAPPINGS"].navigation.mapMoveLeft).add(() => (this.keyboardForce.x = -1));

        mapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_11__["KEYMAPPINGS"].navigation.centerMap).add(() => this.centerOnMap());
        mapper
            .getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_11__["KEYMAPPINGS"].navigation.mapZoomIn)
            .add(() => this.changePowZoomLevel(+1, true, this.kbDoubleZoomCount));
        mapper
            .getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_11__["KEYMAPPINGS"].navigation.mapZoomOut)
            .add(() => this.changePowZoomLevel(-1, true, this.kbDoubleZoomCount));

        document.ondblclick = () => this.setPowZoomLevel(0);
    }

    centerOnMap() {
        this.desiredCenter = new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](0, 0);
    }

    /**
     * Converts from screen to world space
     * @param {Vector} screen
     * @returns {Vector} world space
     */
    screenToWorld(screen) {
        const centerSpace = screen.subScalars(this.root.gameWidth / 2, this.root.gameHeight / 2);
        return centerSpace.divideScalar(this.zoomLevel).add(this.center);
    }

    /**
     * Converts from world to screen space
     * @param {Vector} world
     * @returns {Vector} screen space
     */
    worldToScreen(world) {
        const screenSpace = world.sub(this.center).multiplyScalar(this.zoomLevel);
        return screenSpace.addScalars(this.root.gameWidth / 2, this.root.gameHeight / 2);
    }

    /**
     * Returns if a point is on screen
     * @param {Vector} point
     * @returns {boolean} true if its on screen
     */
    isWorldPointOnScreen(point) {
        const rect = this.getVisibleRect();
        return rect.containsPoint(point.x, point.y);
    }

    /**
     * Returns if we can further zoom in
     * @returns {boolean}
     */
    canZoomIn() {
        const maxLevel = this.root.app.platformWrapper.getMaximumZoom();
        return this.zoomLevel <= maxLevel - 0.01;
    }

    /**
     * Returns if we can further zoom out
     * @returns {boolean}
     */
    canZoomOut() {
        const minLevel = this.root.app.platformWrapper.getMinimumZoom();
        return this.zoomLevel >= minLevel + 0.01;
    }

    /**
     * Changes zoom level as a power of 2
     * @param {number} level
     * @param {boolean} asDesired
     * @param {number} divider
     */
    setPowZoomLevel(level, asDesired = false, divider = this.doubleZoomCount) {
        const value = Math.pow(2, Math.round(level * divider) / divider);
        console.log({ newZoomLevel: value, level, asDesired, divider });
        if (asDesired) {
            this.desiredZoom = value;
        } else {
            this.zoomLevel = value;
        }
    }

    /**
     * Changes zoom level as a power of 2 relatively
     * @param {number} delta
     * @param {boolean} asDesired
     * @param {number} divider
     */
    changePowZoomLevel(delta, asDesired = false, divider = this.doubleZoomCount) {
        const prevPow = Math.log2(asDesired && this.desiredZoom != null ? this.desiredZoom : this.zoomLevel);
        const nextPow = prevPow + delta / divider;
        this.setPowZoomLevel(nextPow, asDesired, divider);
    }

    // EVENTS

    /**
     * Checks if the mouse event is too close after a touch event and thus
     * should get ignored
     */
    checkPreventDoubleMouse() {
        if (Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["performanceNow"])() - _core_click_detector__WEBPACK_IMPORTED_MODULE_1__["clickDetectorGlobals"].lastTouchTime < 1000.0) {
            return false;
        }
        return true;
    }

    /**
     * Mousedown handler
     * @param {MouseEvent} event
     */
    onMouseDown(event) {
        if (event.cancelable) {
            event.preventDefault();
            // event.stopPropagation();
        }

        if (!this.checkPreventDoubleMouse()) {
            return;
        }

        this.touchPostMoveVelocity = new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](0, 0);
        if (event.button === 0) {
            this.combinedSingleTouchStartHandler(event.clientX, event.clientY);
        } else if (event.button === 1) {
            this.downPreHandler.dispatch(new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](event.clientX, event.clientY), enumMouseButton.middle);
        } else if (event.button === 2) {
            this.downPreHandler.dispatch(new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](event.clientX, event.clientY), enumMouseButton.right);
        }
        return false;
    }

    /**
     * Mousemove handler
     * @param {MouseEvent} event
     */
    onMouseMove(event) {
        if (event.cancelable) {
            event.preventDefault();
            // event.stopPropagation();
        }

        if (!this.checkPreventDoubleMouse()) {
            return;
        }

        if (event.button === 0) {
            this.combinedSingleTouchMoveHandler(event.clientX, event.clientY);
        }

        // Clamp everything afterwards
        this.clampZoomLevel();
        return false;
    }

    /**
     * Mouseup handler
     * @param {MouseEvent=} event
     */
    onMouseUp(event) {
        if (event) {
            if (event.cancelable) {
                event.preventDefault();
                // event.stopPropagation();
            }
        }

        if (!this.checkPreventDoubleMouse()) {
            return;
        }

        this.combinedSingleTouchStopHandler(event.clientX, event.clientY);
        return false;
    }

    /**
     * Mousewheel event
     * @param {WheelEvent} event
     */
    onMouseWheel(event) {
        if (event.cancelable) {
            event.preventDefault();
            // event.stopPropagation();
        }

        const delta = -Math.sign(event.deltaY);
        const zoomSteps = Math.ceil(
            this.doubleZoomCount / this.root.app.settings.getScrollWheelSensitivity()
        );
        window.assert(Number.isFinite(delta), "Got invalid delta in mouse wheel event: " + event.deltaY);
        window.assert(Number.isFinite(this.zoomLevel), "Got invalid zoom level *before* wheel: " + this.zoomLevel);
        this.changePowZoomLevel(delta, false, zoomSteps);
        window.assert(Number.isFinite(this.zoomLevel), "Got invalid zoom level *after* wheel: " + this.zoomLevel);

        this.clampZoomLevel();
        this.desiredZoom = null;
        return false;
    }

    /**
     * Touch start handler
     * @param {TouchEvent} event
     */
    onTouchStart(event) {
        if (event.cancelable) {
            event.preventDefault();
            // event.stopPropagation();
        }

        _core_click_detector__WEBPACK_IMPORTED_MODULE_1__["clickDetectorGlobals"].lastTouchTime = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["performanceNow"])();
        this.touchPostMoveVelocity = new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](0, 0);

        if (event.touches.length === 1) {
            const touch = event.touches[0];
            this.combinedSingleTouchStartHandler(touch.clientX, touch.clientY);
        } else if (event.touches.length === 2) {
            // if (this.pinchPreHandler.dispatch() === STOP_PROPAGATION) {
            //     // Something prevented pinching
            //     return false;
            // }

            const touch1 = event.touches[0];
            const touch2 = event.touches[1];
            this.currentlyMoving = false;
            this.currentlyPinching = true;
            this.lastPinchPositions = [
                new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](touch1.clientX, touch1.clientY),
                new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](touch2.clientX, touch2.clientY),
            ];
        }
        return false;
    }

    /**
     * Touch move handler
     * @param {TouchEvent} event
     */
    onTouchMove(event) {
        if (event.cancelable) {
            event.preventDefault();
            // event.stopPropagation();
        }

        _core_click_detector__WEBPACK_IMPORTED_MODULE_1__["clickDetectorGlobals"].lastTouchTime = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["performanceNow"])();

        if (event.touches.length === 1) {
            const touch = event.touches[0];
            this.combinedSingleTouchMoveHandler(touch.clientX, touch.clientY);
        } else if (event.touches.length === 2) {
            if (this.currentlyPinching) {
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];

                const newPinchPositions = [
                    new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](touch1.clientX, touch1.clientY),
                    new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](touch2.clientX, touch2.clientY),
                ];

                // Get distance of taps last time and now
                const lastDistance = this.lastPinchPositions[0].distance(this.lastPinchPositions[1]);
                const thisDistance = newPinchPositions[0].distance(newPinchPositions[1]);

                // IMPORTANT to do math max here to avoid NaN and causing an invalid zoom level
                const difference = thisDistance / Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_max"])(0.001, lastDistance);

                // Find old center of zoom
                let oldCenter = this.lastPinchPositions[0].centerPoint(this.lastPinchPositions[1]);

                // Find new center of zoom
                let center = newPinchPositions[0].centerPoint(newPinchPositions[1]);

                // Compute movement
                let movement = oldCenter.sub(center);
                this.center.x += movement.x / this.zoomLevel;
                this.center.y += movement.y / this.zoomLevel;

                // Compute zoom
                center = center.sub(new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](this.root.gameWidth / 2, this.root.gameHeight / 2));

                // Apply zoom
                window.assert(
                    Number.isFinite(difference),
                    "Invalid pinch difference: " +
                        difference +
                        "(last=" +
                        lastDistance +
                        ", new = " +
                        thisDistance +
                        ")"
                );
                this.zoomLevel *= difference;

                // Stick to pivot point
                const correcture = center.multiplyScalar(difference - 1).divideScalar(this.zoomLevel);

                this.center = this.center.add(correcture);
                this.lastPinchPositions = newPinchPositions;
                this.userInteraction.dispatch(USER_INTERACT_MOVE);

                // Since we zoomed, abort any programmed zooming
                if (this.desiredZoom) {
                    this.desiredZoom = null;
                }
            }
        }

        // Clamp everything afterwards
        this.clampZoomLevel();
        return false;
    }

    /**
     * Touch end and cancel handler
     * @param {TouchEvent=} event
     */
    onTouchEnd(event) {
        if (event) {
            if (event.cancelable) {
                event.preventDefault();
                // event.stopPropagation();
            }
        }

        _core_click_detector__WEBPACK_IMPORTED_MODULE_1__["clickDetectorGlobals"].lastTouchTime = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["performanceNow"])();
        if (event.changedTouches.length === 0) {
            logger.warn("Touch end without changed touches");
        }

        const touch = event.changedTouches[0];
        this.combinedSingleTouchStopHandler(touch.clientX, touch.clientY);
        return false;
    }

    /**
     * Internal touch start handler
     * @param {number} x
     * @param {number} y
     */
    combinedSingleTouchStartHandler(x, y) {
        const pos = new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](x, y);
        if (this.downPreHandler.dispatch(pos, enumMouseButton.left) === _core_signal__WEBPACK_IMPORTED_MODULE_6__["STOP_PROPAGATION"]) {
            // Somebody else captured it
            return;
        }

        this.touchPostMoveVelocity = new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](0, 0);
        this.currentlyMoving = true;
        this.lastMovingPosition = pos;
        this.didMoveSinceTouchStart = false;
    }

    /**
     * Internal touch move handler
     * @param {number} x
     * @param {number} y
     */
    combinedSingleTouchMoveHandler(x, y) {
        const pos = new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](x, y);
        if (this.movePreHandler.dispatch(pos) === _core_signal__WEBPACK_IMPORTED_MODULE_6__["STOP_PROPAGATION"]) {
            // Somebody else captured it
            return;
        }

        if (!this.currentlyMoving) {
            return false;
        }

        let delta = this.lastMovingPosition.sub(pos).divideScalar(this.zoomLevel);
        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].debug.testCulling) {
            // When testing culling, we see everything from the same distance
            delta = delta.multiplyScalar(this.zoomLevel * -2);
        }

        this.didMoveSinceTouchStart = this.didMoveSinceTouchStart || delta.length() > 0;
        this.center = this.center.add(delta);

        this.touchPostMoveVelocity = this.touchPostMoveVelocity
            .multiplyScalar(velocitySmoothing)
            .add(delta.multiplyScalar(1 - velocitySmoothing));

        this.lastMovingPosition = pos;
        this.userInteraction.dispatch(USER_INTERACT_MOVE);

        // Since we moved, abort any programmed moving
        if (this.desiredCenter) {
            this.desiredCenter = null;
        }
    }

    /**
     * Internal touch stop handler
     */
    combinedSingleTouchStopHandler(x, y) {
        if (this.currentlyMoving || this.currentlyPinching) {
            this.currentlyMoving = false;
            this.currentlyPinching = false;
            this.lastMovingPosition = null;
            this.lastPinchPositions = null;
            this.userInteraction.dispatch(USER_INTERACT_TOUCHEND);
            this.didMoveSinceTouchStart = false;
        }
        this.upPostHandler.dispatch(new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](x, y));
    }

    /**
     * Clamps the camera zoom level within the allowed range
     */
    clampZoomLevel() {
        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].debug.disableZoomLimits) {
            return;
        }
        const wrapper = this.root.app.platformWrapper;

        window.assert(Number.isFinite(this.zoomLevel), "Invalid zoom level *before* clamp: " + this.zoomLevel);
        this.zoomLevel = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["clamp"])(this.zoomLevel, wrapper.getMinimumZoom(), wrapper.getMaximumZoom());
        window.assert(Number.isFinite(this.zoomLevel), "Invalid zoom level *after* clamp: " + this.zoomLevel);

        if (this.desiredZoom) {
            this.desiredZoom = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["clamp"])(this.desiredZoom, wrapper.getMinimumZoom(), wrapper.getMaximumZoom());
        }
    }

    /**
     * Updates the camera
     * @param {number} dt Delta time in milliseconds
     */
    update(dt) {
        dt = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_min"])(dt, 33);
        this.cameraUpdateTimeBucket += dt;

        // Simulate movement of N FPS
        const updatesPerFrame = 4;
        const physicsStepSizeMs = 1000.0 / (60.0 * updatesPerFrame);

        let now = this.root.time.systemNow() - 3 * physicsStepSizeMs;

        while (this.cameraUpdateTimeBucket > physicsStepSizeMs) {
            now += physicsStepSizeMs;
            this.cameraUpdateTimeBucket -= physicsStepSizeMs;

            this.internalUpdatePanning(now, physicsStepSizeMs);
            this.internalUpdateZooming(now, physicsStepSizeMs);
            this.internalUpdateCentering(now, physicsStepSizeMs);
            this.internalUpdateShake(now, physicsStepSizeMs);
            this.internalUpdateKeyboardForce(now, physicsStepSizeMs);
        }
        this.clampZoomLevel();
    }

    /**
     * Prepares a context to transform it
     * @param {CanvasRenderingContext2D} context
     */
    transform(context) {
        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].debug.testCulling) {
            context.transform(1, 0, 0, 1, 100, 100);
            return;
        }

        this.clampZoomLevel();
        const zoom = this.zoomLevel;

        context.transform(
            // Scale, skew, rotate
            zoom,
            0,
            0,
            zoom,

            // Translate
            -zoom * this.getViewportLeft(),
            -zoom * this.getViewportTop()
        );
    }

    /**
     * Internal shake handler
     * @param {number} now Time now in seconds
     * @param {number} dt Delta time
     */
    internalUpdateShake(now, dt) {
        this.currentShake = this.currentShake.multiplyScalar(0.92);
    }

    /**
     * Internal pan handler
     * @param {number} now Time now in seconds
     * @param {number} dt Delta time
     */
    internalUpdatePanning(now, dt) {
        const baseStrength = velocityStrength * this.root.app.platformWrapper.getTouchPanStrength();

        this.touchPostMoveVelocity = this.touchPostMoveVelocity.multiplyScalar(velocityFade);

        // Check influence of past points
        if (!this.currentlyMoving && !this.currentlyPinching) {
            const len = this.touchPostMoveVelocity.length();
            if (len >= velocityMax) {
                this.touchPostMoveVelocity.x = (this.touchPostMoveVelocity.x * velocityMax) / len;
                this.touchPostMoveVelocity.y = (this.touchPostMoveVelocity.y * velocityMax) / len;
            }

            this.center = this.center.add(this.touchPostMoveVelocity.multiplyScalar(baseStrength));

            // Panning
            this.currentPan = Object(_core_vector__WEBPACK_IMPORTED_MODULE_8__["mixVector"])(this.currentPan, this.desiredPan, 0.06);
            this.center = this.center.add(this.currentPan.multiplyScalar((0.5 * dt) / this.zoomLevel));
        }
    }

    /**
     * Updates the non user interaction zooming
     * @param {number} now Time now in seconds
     * @param {number} dt Delta time
     */
    internalUpdateZooming(now, dt) {
        if (!this.currentlyPinching && this.desiredZoom !== null) {
            const diff = this.zoomLevel - this.desiredZoom;
            if (Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_abs"])(diff) > 0.0001) {
                let fade = 0.94;
                if (diff > 0) {
                    // Zoom out faster than in
                    fade = 0.9;
                }

                window.assert(Number.isFinite(this.desiredZoom), "Desired zoom is NaN: " + this.desiredZoom);
                window.assert(Number.isFinite(fade), "Zoom fade is NaN: " + fade);
                this.zoomLevel = this.zoomLevel * fade + this.desiredZoom * (1 - fade);
                window.assert(Number.isFinite(this.zoomLevel), "Zoom level is NaN after fade: " + this.zoomLevel);
            } else {
                this.desiredZoom = null;
            }
        }
    }

    /**
     * Updates the non user interaction centering
     * @param {number} now Time now in seconds
     * @param {number} dt Delta time
     */
    internalUpdateCentering(now, dt) {
        if (!this.currentlyMoving && this.desiredCenter !== null) {
            const diff = this.center.direction(this.desiredCenter);
            const length = diff.length();
            const tolerance = 1 / this.zoomLevel;
            if (length > tolerance) {
                const movement = diff.multiplyScalar(Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_min"])(1, dt * 0.008));
                this.center.x += movement.x;
                this.center.y += movement.y;
            } else {
                this.desiredCenter = null;
            }
        }
    }

    /**
     * Updates the keyboard forces
     * @param {number} now
     * @param {number} dt Delta time
     */
    internalUpdateKeyboardForce(now, dt) {
        if (!this.currentlyMoving && this.desiredCenter == null) {
            const limitingDimension = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_min"])(this.root.gameWidth, this.root.gameHeight);

            const moveAmount = ((limitingDimension / 2048) * dt) / this.zoomLevel;

            let forceX = 0;
            let forceY = 0;

            const actionMapper = this.root.keyMapper;
            if (actionMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_11__["KEYMAPPINGS"].navigation.mapMoveUp).isCurrentlyPressed()) {
                forceY -= 1;
            }

            if (actionMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_11__["KEYMAPPINGS"].navigation.mapMoveDown).isCurrentlyPressed()) {
                forceY += 1;
            }

            if (actionMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_11__["KEYMAPPINGS"].navigation.mapMoveLeft).isCurrentlyPressed()) {
                forceX -= 1;
            }

            if (actionMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_11__["KEYMAPPINGS"].navigation.mapMoveRight).isCurrentlyPressed()) {
                forceX += 1;
            }

            this.center.x += moveAmount * forceX;
            this.center.y += moveAmount * forceY;
        }
    }
}


/***/ }),

/***/ "./src/js/game/canvas_click_interceptor.js":
/*!*************************************************!*\
  !*** ./src/js/game/canvas_click_interceptor.js ***!
  \*************************************************/
/*! exports provided: CanvasClickInterceptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasClickInterceptor", function() { return CanvasClickInterceptor; });
/* harmony import */ var _core_signal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/signal */ "./src/js/core/signal.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./root */ "./src/js/game/root.js");
/* harmony import */ var _core_click_detector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/click_detector */ "./src/js/core/click_detector.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");





const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_3__["createLogger"])("canvas_click_interceptor");

class CanvasClickInterceptor {
    /**
     * @param {GameRoot} root
     */
    constructor(root) {
        this.root = root;

        this.root.signals.postLoadHook.add(this.initialize, this);
        this.root.signals.aboutToDestruct.add(this.cleanup, this);

        /** @type {Array<object>} */
        this.interceptors = [];
    }

    initialize() {
        this.clickDetector = new _core_click_detector__WEBPACK_IMPORTED_MODULE_2__["ClickDetector"](this.root.canvas, {
            applyCssClass: null,
            captureTouchmove: false,
            targetOnly: true,
            preventDefault: true,
            maxDistance: 13,
            clickSound: null,
        });
        this.clickDetector.click.add(this.onCanvasClick, this);
        this.clickDetector.rightClick.add(this.onCanvasRightClick, this);

        if (this.root.hud.parts.buildingPlacer) {
            this.interceptors.push(this.root.hud.parts.buildingPlacer);
        }

        logger.log("Registered", this.interceptors.length, "interceptors");
    }

    cleanup() {
        if (this.clickDetector) {
            this.clickDetector.cleanup();
        }
        this.interceptors = [];
    }

    onCanvasClick(position, event, cancelAction = false) {
        if (!this.root.gameInitialized) {
            logger.warn("Skipping click outside of game initiaization!");
            return;
        }

        if (this.root.hud.hasBlockingOverlayOpen()) {
            return;
        }

        for (let i = 0; i < this.interceptors.length; ++i) {
            const interceptor = this.interceptors[i];
            if (interceptor.onCanvasClick(position, cancelAction) === _core_signal__WEBPACK_IMPORTED_MODULE_0__["STOP_PROPAGATION"]) {
                // log(this, "Interceptor", interceptor.constructor.name, "catched click");
                break;
            }
        }
    }

    onCanvasRightClick(position, event) {
        this.onCanvasClick(position, event, true);
    }
}


/***/ }),

/***/ "./src/js/game/colors.js":
/*!*******************************!*\
  !*** ./src/js/game/colors.js ***!
  \*******************************/
/*! exports provided: enumColors, enumColorToShortcode, enumShortcodeToColor, enumColorsToHexCode, enumColorMixingResults */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumColors", function() { return enumColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumColorToShortcode", function() { return enumColorToShortcode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumShortcodeToColor", function() { return enumShortcodeToColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumColorsToHexCode", function() { return enumColorsToHexCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumColorMixingResults", function() { return enumColorMixingResults; });
/** @enum {string} */
const enumColors = {
    red: "red",
    green: "green",
    blue: "blue",

    yellow: "yellow",
    purple: "purple",
    cyan: "cyan",

    white: "white",
    uncolored: "uncolored",

    black: "black",
};

/** @enum {string} */
const enumColorToShortcode = {
    [enumColors.red]: "r",
    [enumColors.green]: "g",
    [enumColors.blue]: "b",

    [enumColors.yellow]: "y",
    [enumColors.purple]: "p",
    [enumColors.cyan]: "c",

    [enumColors.white]: "w",
    [enumColors.uncolored]: "u",

    [enumColors.black]: "k",
};

/** @enum {enumColors} */
const enumShortcodeToColor = {};
for (const key in enumColorToShortcode) {
    enumShortcodeToColor[enumColorToShortcode[key]] = key;
}

/** @enum {string} */
const enumColorsToHexCode = {
    [enumColors.red]: "#ff666a",
    [enumColors.green]: "#78ff66",
    [enumColors.blue]: "#66a7ff",

    // red + green
    [enumColors.yellow]: "#fcf52a",

    // red + blue
    [enumColors.purple]: "#dd66ff",

    // blue + green
    [enumColors.cyan]: "#00fcff",

    // blue + green + red
    [enumColors.white]: "#ffffff",

    [enumColors.uncolored]: "#aaaaaa",

    [enumColors.black]: "#333333",
};

const c = enumColors;
/** @enum {Object.<string, string>} */
const enumColorMixingResults = {
    // 255, 0, 0
    [c.red]: {
        [c.green]: c.yellow,
        [c.blue]: c.purple,

        [c.yellow]: c.yellow,
        [c.purple]: c.purple,
        [c.cyan]: c.white,

        [c.white]: c.white,
    },

    // 0, 255, 0
    [c.green]: {
        [c.blue]: c.cyan,

        [c.yellow]: c.yellow,
        [c.purple]: c.white,
        [c.cyan]: c.cyan,

        [c.white]: c.white,
    },

    // 0, 255, 0
    [c.blue]: {
        [c.yellow]: c.white,
        [c.purple]: c.purple,
        [c.cyan]: c.cyan,

        [c.white]: c.white,
    },

    // 255, 255, 0
    [c.yellow]: {
        [c.purple]: c.white,
        [c.cyan]: c.white,
    },

    // 255, 0, 255
    [c.purple]: {
        [c.cyan]: c.white,
    },

    // 0, 255, 255
    [c.cyan]: {},

    //// SPECIAL COLORS

    // 255, 255, 255
    [c.white]: {
        [c.black]: c.uncolored,
    },

    // X, X, X
    [c.uncolored]: {
        [c.black]: c.black,
    },

    [c.black]: {
        [c.white]: c.uncolored,
    },
};

// Create same color lookups
for (const color in enumColors) {
    if (!enumColorMixingResults[color][color]) enumColorMixingResults[color][color] = color;

    // Anything with white is white again
    if (!enumColorMixingResults[color][c.white]) enumColorMixingResults[color][c.white] = c.white;

    // Anything with black is black
    if (!enumColorMixingResults[color][c.black]) enumColorMixingResults[color][c.black] = color;

    // Anything with uncolored is the same color
    if (!enumColorMixingResults[color][c.uncolored]) enumColorMixingResults[color][c.uncolored] = color;
}

// Create reverse lookup and check color mixing lookups
for (const colorA in enumColorMixingResults) {
    for (const colorB in enumColorMixingResults[colorA]) {
        const resultColor = enumColorMixingResults[colorA][colorB];
        if (!enumColorMixingResults[colorB]) {
            enumColorMixingResults[colorB] = {
                [colorA]: resultColor,
            };
        } else {
            const existingResult = enumColorMixingResults[colorB][colorA];
            if (existingResult && existingResult !== resultColor) {
                window.assert(
                    false,
                    "invalid color mixing configuration, " +
                        colorA +
                        " + " +
                        colorB +
                        " is " +
                        resultColor +
                        " but " +
                        colorB +
                        " + " +
                        colorA +
                        " is " +
                        existingResult
                );
            }
            enumColorMixingResults[colorB][colorA] = resultColor;
        }
    }
}

for (const colorA in enumColorMixingResults) {
    for (const colorB in enumColorMixingResults) {
        if (!enumColorMixingResults[colorA][colorB]) {
            window.assert(false, "Color mixing of", colorA, "with", colorB, "is not defined");
        }
    }
}


/***/ }),

/***/ "./src/js/game/component.js":
/*!**********************************!*\
  !*** ./src/js/game/component.js ***!
  \**********************************/
/*! exports provided: Component */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return Component; });
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../savegame/serialization */ "./src/js/savegame/serialization.js");


class Component extends _savegame_serialization__WEBPACK_IMPORTED_MODULE_0__["BasicSerializableObject"] {
    /**
     * Returns the components unique id
     * @returns {string}
     */
    static getId() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return "unknown-component";
    }

    /**
     * Should return the schema used for serialization
     */
    static getSchema() {
        return {};
    }

    /**
     * Should duplicate the component but without its contents
     * @returns {object}
     */
    duplicateWithoutContents() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }

    /* dev:start */

    /**
     * Fixes typeof DerivedComponent is not assignable to typeof Component, compiled out
     * in non-dev builds
     */
    constructor(...args) {
        super();
    }

    /**
     * Returns a string representing the components data, only in dev builds
     * @returns {string}
     */
    getDebugString() {
        return null;
    }
    /* dev:end */
}


/***/ }),

/***/ "./src/js/game/component_registry.js":
/*!*******************************************!*\
  !*** ./src/js/game/component_registry.js ***!
  \*******************************************/
/*! exports provided: initComponentRegistry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initComponentRegistry", function() { return initComponentRegistry; });
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/global_registries */ "./src/js/core/global_registries.js");
/* harmony import */ var _components_static_map_entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/static_map_entity */ "./src/js/game/components/static_map_entity.js");
/* harmony import */ var _components_belt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/belt */ "./src/js/game/components/belt.js");
/* harmony import */ var _components_sorter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/sorter */ "./src/js/game/components/sorter.js");
/* harmony import */ var _components_item_ejector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/item_ejector */ "./src/js/game/components/item_ejector.js");
/* harmony import */ var _components_item_acceptor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/item_acceptor */ "./src/js/game/components/item_acceptor.js");
/* harmony import */ var _components_miner__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/miner */ "./src/js/game/components/miner.js");
/* harmony import */ var _components_item_processor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/item_processor */ "./src/js/game/components/item_processor.js");
/* harmony import */ var _components_replaceable_map_entity__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/replaceable_map_entity */ "./src/js/game/components/replaceable_map_entity.js");
/* harmony import */ var _components_underground_belt__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/underground_belt */ "./src/js/game/components/underground_belt.js");
/* harmony import */ var _components_unremovable__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/unremovable */ "./src/js/game/components/unremovable.js");
/* harmony import */ var _components_hub__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/hub */ "./src/js/game/components/hub.js");
/* harmony import */ var _components_storage__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/storage */ "./src/js/game/components/storage.js");














function initComponentRegistry() {
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gComponentRegistry"].register(_components_static_map_entity__WEBPACK_IMPORTED_MODULE_1__["StaticMapEntityComponent"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gComponentRegistry"].register(_components_belt__WEBPACK_IMPORTED_MODULE_2__["BeltComponent"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gComponentRegistry"].register(_components_sorter__WEBPACK_IMPORTED_MODULE_3__["SorterComponent"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gComponentRegistry"].register(_components_item_ejector__WEBPACK_IMPORTED_MODULE_4__["ItemEjectorComponent"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gComponentRegistry"].register(_components_item_acceptor__WEBPACK_IMPORTED_MODULE_5__["ItemAcceptorComponent"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gComponentRegistry"].register(_components_miner__WEBPACK_IMPORTED_MODULE_6__["MinerComponent"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gComponentRegistry"].register(_components_item_processor__WEBPACK_IMPORTED_MODULE_7__["ItemProcessorComponent"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gComponentRegistry"].register(_components_replaceable_map_entity__WEBPACK_IMPORTED_MODULE_8__["ReplaceableMapEntityComponent"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gComponentRegistry"].register(_components_underground_belt__WEBPACK_IMPORTED_MODULE_9__["UndergroundBeltComponent"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gComponentRegistry"].register(_components_unremovable__WEBPACK_IMPORTED_MODULE_10__["UnremovableComponent"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gComponentRegistry"].register(_components_hub__WEBPACK_IMPORTED_MODULE_11__["HubComponent"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gComponentRegistry"].register(_components_storage__WEBPACK_IMPORTED_MODULE_12__["StorageComponent"]);

    // IMPORTANT ^^^^^ UPDATE ENTITY COMPONENT STORAGE AFTERWARDS

    // Sanity check - If this is thrown, you (=me, lol) forgot to add a new component here

    window.assert(
        // @ts-ignore
        __webpack_require__("./src/js/game/components sync .*\\.js/").keys().length ===
            _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gComponentRegistry"].getNumEntries(),
        "Not all components are registered"
    );

    console.log("📦 There are", _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gComponentRegistry"].getNumEntries(), "components");
}


/***/ }),

/***/ "./src/js/game/components sync .*\\.js/":
/*!**********************************************************!*\
  !*** ./src/js/game/components sync nonrecursive .*\.js/ ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./belt.js": "./src/js/game/components/belt.js",
	"./hub.js": "./src/js/game/components/hub.js",
	"./item_acceptor.js": "./src/js/game/components/item_acceptor.js",
	"./item_ejector.js": "./src/js/game/components/item_ejector.js",
	"./item_processor.js": "./src/js/game/components/item_processor.js",
	"./miner.js": "./src/js/game/components/miner.js",
	"./replaceable_map_entity.js": "./src/js/game/components/replaceable_map_entity.js",
	"./sorter.js": "./src/js/game/components/sorter.js",
	"./static_map_entity.js": "./src/js/game/components/static_map_entity.js",
	"./storage.js": "./src/js/game/components/storage.js",
	"./underground_belt.js": "./src/js/game/components/underground_belt.js",
	"./unremovable.js": "./src/js/game/components/unremovable.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./src/js/game/components sync .*\\.js/";

/***/ }),

/***/ "./src/js/game/components/belt.js":
/*!****************************************!*\
  !*** ./src/js/game/components/belt.js ***!
  \****************************************/
/*! exports provided: BeltComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BeltComponent", function() { return BeltComponent; });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component */ "./src/js/game/component.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../savegame/serialization */ "./src/js/savegame/serialization.js");
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/global_registries */ "./src/js/core/global_registries.js");
/* harmony import */ var _base_item__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base_item */ "./src/js/game/base_item.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");








class BeltComponent extends _component__WEBPACK_IMPORTED_MODULE_0__["Component"] {
    static getId() {
        return "Belt";
    }

    static getSchema() {
        return {
            direction: _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__["types"].string,
            sortedItems: _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__["types"].array(_savegame_serialization__WEBPACK_IMPORTED_MODULE_1__["types"].pair(_savegame_serialization__WEBPACK_IMPORTED_MODULE_1__["types"].float, _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__["types"].obj(_core_global_registries__WEBPACK_IMPORTED_MODULE_2__["gItemRegistry"]))),
        };
    }

    duplicateWithoutContents() {
        return new BeltComponent({ direction: this.direction });
    }

    /**
     *
     * @param {object} param0
     * @param {enumDirection=} param0.direction The direction of the belt
     */
    constructor({ direction = _core_vector__WEBPACK_IMPORTED_MODULE_4__["enumDirection"].top }) {
        super();

        this.direction = direction;

        /** @type {Array<[number, BaseItem]>} */
        this.sortedItems = [];
    }

    /**
     * Converts from belt space (0 = start of belt ... 1 = end of belt) to the local
     * belt coordinates (-0.5|-0.5 to 0.5|0.5)
     * @param {number} progress
     * @returns {Vector}
     */
    transformBeltToLocalSpace(progress) {
        switch (this.direction) {
            case _core_vector__WEBPACK_IMPORTED_MODULE_4__["enumDirection"].top:
                return new _core_vector__WEBPACK_IMPORTED_MODULE_4__["Vector"](0, 0.5 - progress);

            case _core_vector__WEBPACK_IMPORTED_MODULE_4__["enumDirection"].right: {
                const arcProgress = progress * 0.5 * _core_builtins__WEBPACK_IMPORTED_MODULE_5__["Math_PI"];
                return new _core_vector__WEBPACK_IMPORTED_MODULE_4__["Vector"](0.5 - 0.5 * Object(_core_builtins__WEBPACK_IMPORTED_MODULE_5__["Math_cos"])(arcProgress), 0.5 - 0.5 * Object(_core_builtins__WEBPACK_IMPORTED_MODULE_5__["Math_sin"])(arcProgress));
            }
            case _core_vector__WEBPACK_IMPORTED_MODULE_4__["enumDirection"].left: {
                const arcProgress = progress * 0.5 * _core_builtins__WEBPACK_IMPORTED_MODULE_5__["Math_PI"];
                return new _core_vector__WEBPACK_IMPORTED_MODULE_4__["Vector"](-0.5 + 0.5 * Object(_core_builtins__WEBPACK_IMPORTED_MODULE_5__["Math_cos"])(arcProgress), 0.5 - 0.5 * Object(_core_builtins__WEBPACK_IMPORTED_MODULE_5__["Math_sin"])(arcProgress));
            }
            default:
                window.assert(false, "Invalid belt direction: " + this.direction);
                return new _core_vector__WEBPACK_IMPORTED_MODULE_4__["Vector"](0, 0);
        }
    }

    /**
     *  Returns if the belt can currently accept an item from the given direction
     */
    canAcceptItem(leftoverProgress = 0.0) {
        const firstItem = this.sortedItems[0];
        if (!firstItem) {
            return true;
        }

        return firstItem[0] > _core_config__WEBPACK_IMPORTED_MODULE_6__["globalConfig"].itemSpacingOnBelts;
    }

    /**
     * Pushes a new item to the belt
     * @param {BaseItem} item
     */
    takeItem(item, leftoverProgress = 0.0) {
        if ( true && !_core_config__WEBPACK_IMPORTED_MODULE_6__["globalConfig"].debug.disableBeltAsserts) {
            window.assert(
                this.sortedItems.length === 0 ||
                    leftoverProgress <= this.sortedItems[0][0] - _core_config__WEBPACK_IMPORTED_MODULE_6__["globalConfig"].itemSpacingOnBelts + 0.001,
                "Invalid leftover: " +
                    leftoverProgress +
                    " items are " +
                    this.sortedItems.map(item => item[0])
            );
            window.assert(leftoverProgress < 1.0, "Invalid leftover: " + leftoverProgress);
        }
        this.sortedItems.unshift([leftoverProgress, item]);
    }

    /**
     * Returns how much space there is to the first item
     */
    getDistanceToFirstItemCenter() {
        const firstItem = this.sortedItems[0];
        if (!firstItem) {
            return 1;
        }
        return firstItem[0];
    }
}


/***/ }),

/***/ "./src/js/game/components/hub.js":
/*!***************************************!*\
  !*** ./src/js/game/components/hub.js ***!
  \***************************************/
/*! exports provided: HubComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HubComponent", function() { return HubComponent; });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component */ "./src/js/game/component.js");
/* harmony import */ var _shape_definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shape_definition */ "./src/js/game/shape_definition.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../savegame/serialization */ "./src/js/savegame/serialization.js");




class HubComponent extends _component__WEBPACK_IMPORTED_MODULE_0__["Component"] {
    static getId() {
        return "Hub";
    }

    static getSchema() {
        return {
            definitionsToAnalyze: _savegame_serialization__WEBPACK_IMPORTED_MODULE_2__["types"].array(_savegame_serialization__WEBPACK_IMPORTED_MODULE_2__["types"].knownType(_shape_definition__WEBPACK_IMPORTED_MODULE_1__["ShapeDefinition"])),
        };
    }

    constructor() {
        super();

        /**
         * Shape definitions in queue to be analyzed and counted towards the goal
         * @type {Array<ShapeDefinition>}
         */
        this.definitionsToAnalyze = [];
    }

    /**
     * @param {ShapeDefinition} definition
     */
    queueShapeDefinition(definition) {
        this.definitionsToAnalyze.push(definition);
    }
}


/***/ }),

/***/ "./src/js/game/components/item_acceptor.js":
/*!*************************************************!*\
  !*** ./src/js/game/components/item_acceptor.js ***!
  \*************************************************/
/*! exports provided: enumItemAcceptorItemFilter, ItemAcceptorComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumItemAcceptorItemFilter", function() { return enumItemAcceptorItemFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ItemAcceptorComponent", function() { return ItemAcceptorComponent; });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component */ "./src/js/game/component.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _base_item__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base_item */ "./src/js/game/base_item.js");
/* harmony import */ var _items_shape_item__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../items/shape_item */ "./src/js/game/items/shape_item.js");
/* harmony import */ var _items_color_item__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../items/color_item */ "./src/js/game/items/color_item.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../savegame/serialization */ "./src/js/savegame/serialization.js");







/**
 * @enum {string?}
 */
const enumItemAcceptorItemFilter = {
    shape: "shape",
    color: "color",
    none: null,
};

/** @typedef {{
 * pos: Vector,
 * directions: enumDirection[],
 * filter?: enumItemAcceptorItemFilter
 * }} ItemAcceptorSlot */

class ItemAcceptorComponent extends _component__WEBPACK_IMPORTED_MODULE_0__["Component"] {
    static getId() {
        return "ItemAcceptor";
    }

    static getSchema() {
        return {
            slots: _savegame_serialization__WEBPACK_IMPORTED_MODULE_5__["types"].array(
                _savegame_serialization__WEBPACK_IMPORTED_MODULE_5__["types"].structured({
                    pos: _savegame_serialization__WEBPACK_IMPORTED_MODULE_5__["types"].vector,
                    directions: _savegame_serialization__WEBPACK_IMPORTED_MODULE_5__["types"].array(_savegame_serialization__WEBPACK_IMPORTED_MODULE_5__["types"].enum(_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"])),
                    filter: _savegame_serialization__WEBPACK_IMPORTED_MODULE_5__["types"].nullable(_savegame_serialization__WEBPACK_IMPORTED_MODULE_5__["types"].enum(enumItemAcceptorItemFilter)),
                })
            ),
            animated: _savegame_serialization__WEBPACK_IMPORTED_MODULE_5__["types"].bool,
            beltUnderlays: _savegame_serialization__WEBPACK_IMPORTED_MODULE_5__["types"].array(
                _savegame_serialization__WEBPACK_IMPORTED_MODULE_5__["types"].structured({
                    pos: _savegame_serialization__WEBPACK_IMPORTED_MODULE_5__["types"].vector,
                    direction: _savegame_serialization__WEBPACK_IMPORTED_MODULE_5__["types"].enum(_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirection"]),
                })
            ),

            // We don't actually need to store the animations
            // itemConsumptionAnimations: types.array(
            //     types.structured({
            //         item: types.obj(gItemRegistry),
            //         slotIndex: types.uint,
            //         animProgress: types.float,
            //         direction: types.enum(enumDirection),
            //     })
            // ),
        };
    }

    duplicateWithoutContents() {
        const slotsCopy = [];
        for (let i = 0; i < this.slots.length; ++i) {
            const slot = this.slots[i];
            slotsCopy.push({
                pos: slot.pos.copy(),
                directions: slot.directions.slice(),
                filter: slot.filter,
            });
        }

        const beltUnderlaysCopy = [];
        for (let i = 0; i < this.beltUnderlays.length; ++i) {
            const underlay = this.beltUnderlays[i];
            beltUnderlaysCopy.push({
                pos: underlay.pos.copy(),
                direction: underlay.direction,
            });
        }

        return new ItemAcceptorComponent({
            slots: slotsCopy,
            beltUnderlays: beltUnderlaysCopy,
            animated: this.animated,
        });
    }

    /**
     *
     * @param {object} param0
     * @param {Array<{pos: Vector, directions: enumDirection[], filter?: enumItemAcceptorItemFilter}>} param0.slots The slots from which we accept items
     * @param {boolean=} param0.animated Whether to animate item consumption
     * @param {Array<{pos: Vector, direction: enumDirection}>=} param0.beltUnderlays Where to render belt underlays
     */
    constructor({ slots = [], beltUnderlays = [], animated = true }) {
        super();

        this.animated = animated;

        /**
         * Fixes belt animations
         * @type {Array<{ item: BaseItem, slotIndex: number, animProgress: number, direction: enumDirection}>}
         */
        this.itemConsumptionAnimations = [];

        /* Which belt underlays to render */
        this.beltUnderlays = beltUnderlays;

        this.setSlots(slots);
    }

    /**
     *
     * @param {Array<{pos: Vector, directions: enumDirection[], filter?: enumItemAcceptorItemFilter}>} slots
     */
    setSlots(slots) {
        /** @type {Array<{pos: Vector, directions: enumDirection[], filter?: enumItemAcceptorItemFilter}>} */
        this.slots = [];
        for (let i = 0; i < slots.length; ++i) {
            const slot = slots[i];
            this.slots.push({
                pos: slot.pos,
                directions: slot.directions,

                // Which type of item to accept (shape | color | all) @see enumItemAcceptorItemFilter
                filter: slot.filter,
            });
        }
    }

    /**
     * Returns if this acceptor can accept a new item at slot N
     * @param {number} slotIndex
     * @param {BaseItem=} item
     */
    canAcceptItem(slotIndex, item) {
        const slot = this.slots[slotIndex];
        switch (slot.filter) {
            case enumItemAcceptorItemFilter.shape: {
                return item instanceof _items_shape_item__WEBPACK_IMPORTED_MODULE_3__["ShapeItem"];
            }
            case enumItemAcceptorItemFilter.color: {
                return item instanceof _items_color_item__WEBPACK_IMPORTED_MODULE_4__["ColorItem"];
            }
            default:
                return true;
        }
    }

    /**
     * Called when an item has been accepted so that
     * @param {number} slotIndex
     * @param {enumDirection} direction
     * @param {BaseItem} item
     */
    onItemAccepted(slotIndex, direction, item) {
        if (this.animated) {
            this.itemConsumptionAnimations.push({
                item,
                slotIndex,
                direction,
                animProgress: 0.0,
            });
        }
    }

    /**
     * Tries to find a slot which accepts the current item
     * @param {Vector} targetLocalTile
     * @param {enumDirection} fromLocalDirection
     * @returns {{
     *  slot: ItemAcceptorSlot,
     *  index: number,
     *  acceptedDirection: enumDirection
     * }|null}
     */
    findMatchingSlot(targetLocalTile, fromLocalDirection) {
        // We need to invert our direction since the acceptor specifies *from* which direction
        // it accepts items, but the ejector specifies *into* which direction it ejects items.
        // E.g.: Ejector ejects into "right" direction but acceptor accepts from "left" direction.
        const desiredDirection = _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumInvertedDirections"][fromLocalDirection];

        // Go over all slots and try to find a target slot
        for (let slotIndex = 0; slotIndex < this.slots.length; ++slotIndex) {
            const slot = this.slots[slotIndex];

            // Make sure the acceptor slot is on the right position
            if (!slot.pos.equals(targetLocalTile)) {
                continue;
            }

            // Check if the acceptor slot accepts items from our direction
            for (let i = 0; i < slot.directions.length; ++i) {
                // const localDirection = targetStaticComp.localDirectionToWorld(slot.directions[l]);
                if (desiredDirection === slot.directions[i]) {
                    return {
                        slot,
                        index: slotIndex,
                        acceptedDirection: desiredDirection,
                    };
                }
            }
        }

        return null;
    }
}


/***/ }),

/***/ "./src/js/game/components/item_ejector.js":
/*!************************************************!*\
  !*** ./src/js/game/components/item_ejector.js ***!
  \************************************************/
/*! exports provided: ItemEjectorComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ItemEjectorComponent", function() { return ItemEjectorComponent; });
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _base_item__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base_item */ "./src/js/game/base_item.js");
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../component */ "./src/js/game/component.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../savegame/serialization */ "./src/js/savegame/serialization.js");
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/global_registries */ "./src/js/core/global_registries.js");






/**
 * @typedef {{
 *    pos: Vector,
 *    direction: enumDirection,
 *    item: BaseItem,
 *    progress: number?
 * }} ItemEjectorSlot
 */

class ItemEjectorComponent extends _component__WEBPACK_IMPORTED_MODULE_2__["Component"] {
    static getId() {
        return "ItemEjector";
    }

    static getSchema() {
        return {
            instantEject: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].bool,
            slots: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].array(
                _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].structured({
                    pos: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].vector,
                    direction: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].enum(_core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirection"]),
                    item: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].nullable(_savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].obj(_core_global_registries__WEBPACK_IMPORTED_MODULE_4__["gItemRegistry"])),
                    progress: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].float,
                })
            ),
        };
    }

    duplicateWithoutContents() {
        const slotsCopy = [];
        for (let i = 0; i < this.slots.length; ++i) {
            const slot = this.slots[i];
            slotsCopy.push({
                pos: slot.pos.copy(),
                direction: slot.direction,
            });
        }

        return new ItemEjectorComponent({
            slots: slotsCopy,
            instantEject: this.instantEject,
        });
    }

    /**
     *
     * @param {object} param0
     * @param {Array<{pos: Vector, direction: enumDirection}>=} param0.slots The slots to eject on
     * @param {boolean=} param0.instantEject If the ejection is instant
     */
    constructor({ slots = [], instantEject = false }) {
        super();

        // How long items take to eject
        this.instantEject = instantEject;

        this.setSlots(slots);
    }

    /**
     * @param {Array<{pos: Vector, direction: enumDirection}>} slots The slots to eject on
     */
    setSlots(slots) {
        /** @type {Array<ItemEjectorSlot>} */
        this.slots = [];
        for (let i = 0; i < slots.length; ++i) {
            const slot = slots[i];
            this.slots.push({
                pos: slot.pos,
                direction: slot.direction,
                item: null,
                progress: 0,
            });
        }
    }

    /**
     * Returns the amount of slots
     */
    getNumSlots() {
        return this.slots.length;
    }

    /**
     * Returns where this slot ejects to
     * @param {number} index
     * @returns {Vector}
     */
    getSlotTargetLocalTile(index) {
        const slot = this.slots[index];
        const directionVector = _core_vector__WEBPACK_IMPORTED_MODULE_0__["enumDirectionToVector"][slot.direction];
        return slot.pos.add(directionVector);
    }

    /**
     * Returns whether any slot ejects to the given local tile
     * @param {Vector} tile
     */
    anySlotEjectsToLocalTile(tile) {
        for (let i = 0; i < this.slots.length; ++i) {
            if (this.getSlotTargetLocalTile(i).equals(tile)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns if slot # is currently ejecting
     * @param {number} slotIndex
     * @returns {boolean}
     */
    isSlotEjecting(slotIndex) {
        window.assert(slotIndex >= 0 && slotIndex < this.slots.length, "Invalid ejector slot: " + slotIndex);
        return !!this.slots[slotIndex].item;
    }

    /**
     * Returns if we can eject on a given slot
     * @param {number} slotIndex
     * @returns {boolean}
     */
    canEjectOnSlot(slotIndex) {
        window.assert(slotIndex >= 0 && slotIndex < this.slots.length, "Invalid ejector slot: " + slotIndex);
        return !this.slots[slotIndex].item;
    }

    /**
     * Returns the first free slot on this ejector or null if there is none
     * @returns {number?}
     */
    getFirstFreeSlot() {
        for (let i = 0; i < this.slots.length; ++i) {
            if (this.canEjectOnSlot(i)) {
                return i;
            }
        }
        return null;
    }

    /**
     * Returns if any slot is ejecting
     * @returns {boolean}
     */
    isAnySlotEjecting() {
        for (let i = 0; i < this.slots.length; ++i) {
            if (this.slots[i].item) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns if any slot is free
     * @returns {boolean}
     */
    hasAnySlotFree() {
        for (let i = 0; i < this.slots.length; ++i) {
            if (this.canEjectOnSlot(i)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Tries to eject a given item
     * @param {number} slotIndex
     * @param {BaseItem} item
     * @returns {boolean}
     */
    tryEject(slotIndex, item) {
        if (!this.canEjectOnSlot(slotIndex)) {
            return false;
        }
        this.slots[slotIndex].item = item;
        this.slots[slotIndex].progress = this.instantEject ? 1 : 0;
        return true;
    }
}


/***/ }),

/***/ "./src/js/game/components/item_processor.js":
/*!**************************************************!*\
  !*** ./src/js/game/components/item_processor.js ***!
  \**************************************************/
/*! exports provided: enumItemProcessorTypes, ItemProcessorComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumItemProcessorTypes", function() { return enumItemProcessorTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ItemProcessorComponent", function() { return ItemProcessorComponent; });
/* harmony import */ var _base_item__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base_item */ "./src/js/game/base_item.js");
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component */ "./src/js/game/component.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../savegame/serialization */ "./src/js/savegame/serialization.js");
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/global_registries */ "./src/js/core/global_registries.js");






/** @enum {string} */
const enumItemProcessorTypes = {
    splitter: "splitter",
    sorter: "sorter",
    cutter: "cutter",
    cutterQuad: "cutterQuad",
    rotater: "rotater",
    rotaterCCW: "rotaterCCW",
    stacker: "stacker",
    trash: "trash",
    mixer: "mixer",
    painter: "painter",
    painterDouble: "painterDouble",
    painterQuad: "painterQuad",
    hub: "hub",
};

class ItemProcessorComponent extends _component__WEBPACK_IMPORTED_MODULE_1__["Component"] {
    static getId() {
        return "ItemProcessor";
    }

    static getSchema() {
        return {
            nextOutputSlot: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].uint,
            type: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].enum(enumItemProcessorTypes),
            inputsPerCharge: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].uint,

            inputSlots: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].array(
                _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].structured({
                    item: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].obj(_core_global_registries__WEBPACK_IMPORTED_MODULE_4__["gItemRegistry"]),
                    sourceSlot: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].uint,
                })
            ),
            itemsToEject: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].array(
                _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].structured({
                    item: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].obj(_core_global_registries__WEBPACK_IMPORTED_MODULE_4__["gItemRegistry"]),
                    requiredSlot: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].nullable(_savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].uint),
                    preferredSlot: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].nullable(_savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].uint),
                })
            ),
            secondsUntilEject: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].float,
        };
    }

    duplicateWithoutContents() {
        return new ItemProcessorComponent({
            processorType: this.type,
            inputsPerCharge: this.inputsPerCharge,
        });
    }

    /**
     *
     * @param {object} param0
     * @param {enumItemProcessorTypes=} param0.processorType Which type of processor this is
     * @param {number=} param0.inputsPerCharge How many items this machine needs until it can start working
     *
     */
    constructor({ processorType = enumItemProcessorTypes.splitter, inputsPerCharge = 1 }) {
        super();

        // Which slot to emit next, this is only a preference and if it can't emit
        // it will take the other one. Some machines ignore this (e.g. the splitter) to make
        // sure the outputs always match
        this.nextOutputSlot = 0;

        // Type of the processor
        this.type = processorType;

        // How many inputs we need for one charge
        this.inputsPerCharge = inputsPerCharge;

        /**
         * Our current inputs
         * @type {Array<{ item: BaseItem, sourceSlot: number }>}
         */
        this.inputSlots = [];

        /**
         * What we are currently processing, empty if we don't produce anything rn
         * requiredSlot: Item *must* be ejected on this slot
         * preferredSlot: Item *can* be ejected on this slot, but others are fine too if the one is not usable
         * @type {Array<{item: BaseItem, requiredSlot?: number, preferredSlot?: number}>}
         */
        this.itemsToEject = [];

        /**
         * How long it takes until we are done with the current items
         */
        this.secondsUntilEject = 0;
    }

    /**
     * Tries to take the item
     * @param {BaseItem} item
     * @param {number} sourceSlot
     */
    tryTakeItem(item, sourceSlot) {
        // Check that we only take one item per slot
        for (let i = 0; i < this.inputSlots.length; ++i) {
            const slot = this.inputSlots[i];
            if (slot.sourceSlot === sourceSlot) {
                return false;
            }
        }

        this.inputSlots.push({ item, sourceSlot });
        return true;
    }
}


/***/ }),

/***/ "./src/js/game/components/miner.js":
/*!*****************************************!*\
  !*** ./src/js/game/components/miner.js ***!
  \*****************************************/
/*! exports provided: MinerComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MinerComponent", function() { return MinerComponent; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../savegame/serialization */ "./src/js/savegame/serialization.js");
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../component */ "./src/js/game/component.js");
/* harmony import */ var _base_item__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base_item */ "./src/js/game/base_item.js");
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/global_registries */ "./src/js/core/global_registries.js");






const chainBufferSize = 3;

class MinerComponent extends _component__WEBPACK_IMPORTED_MODULE_2__["Component"] {
    static getId() {
        return "Miner";
    }

    static getSchema() {
        return {
            lastMiningTime: _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__["types"].ufloat,
            chainable: _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__["types"].bool,
            itemChainBuffer: _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__["types"].array(_savegame_serialization__WEBPACK_IMPORTED_MODULE_1__["types"].obj(_core_global_registries__WEBPACK_IMPORTED_MODULE_4__["gItemRegistry"])),
        };
    }

    duplicateWithoutContents() {
        return new MinerComponent({
            chainable: this.chainable,
        });
    }

    /**
     */
    constructor({ chainable = false }) {
        super();
        this.lastMiningTime = 0;
        this.chainable = chainable;

        /**
         * Stores items from other miners which were chained to this
         * miner.
         * @type {Array<BaseItem>}
         */
        this.itemChainBuffer = [];
    }

    /**
     *
     * @param {BaseItem} item
     */
    tryAcceptChainedItem(item) {
        if (this.itemChainBuffer.length > chainBufferSize) {
            // Well, this one is full
            return false;
        }

        this.itemChainBuffer.push(item);
        return true;
    }
}


/***/ }),

/***/ "./src/js/game/components/replaceable_map_entity.js":
/*!**********************************************************!*\
  !*** ./src/js/game/components/replaceable_map_entity.js ***!
  \**********************************************************/
/*! exports provided: ReplaceableMapEntityComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReplaceableMapEntityComponent", function() { return ReplaceableMapEntityComponent; });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component */ "./src/js/game/component.js");


/**
 * Marks an entity as replaceable, so that when other buildings are placed above him it
 * simply gets deleted
 */
class ReplaceableMapEntityComponent extends _component__WEBPACK_IMPORTED_MODULE_0__["Component"] {
    static getId() {
        return "ReplaceableMapEntity";
    }

    duplicateWithoutContents() {
        return new ReplaceableMapEntityComponent();
    }
}


/***/ }),

/***/ "./src/js/game/components/sorter.js":
/*!******************************************!*\
  !*** ./src/js/game/components/sorter.js ***!
  \******************************************/
/*! exports provided: SorterComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SorterComponent", function() { return SorterComponent; });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component */ "./src/js/game/component.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../savegame/serialization */ "./src/js/savegame/serialization.js");
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/global_registries */ "./src/js/core/global_registries.js");
/* harmony import */ var _base_item__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base_item */ "./src/js/game/base_item.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");








class SorterComponent extends _component__WEBPACK_IMPORTED_MODULE_0__["Component"] {
    static getId() {
        return "Sorter";
    }

    static getSchema() {
        return {
            filter: _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__["types"].string,
            isfil: _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__["types"].bool,
        };
    }
    constructor({ filter = "CuCuCuCu", isfil = false }) {
        super();

        this.filter = filter;
        this.isfil = isfil;
    }
}


/***/ }),

/***/ "./src/js/game/components/static_map_entity.js":
/*!*****************************************************!*\
  !*** ./src/js/game/components/static_map_entity.js ***!
  \*****************************************************/
/*! exports provided: StaticMapEntityComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticMapEntityComponent", function() { return StaticMapEntityComponent; });
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _core_rectangle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/rectangle */ "./src/js/core/rectangle.js");
/* harmony import */ var _core_sprites__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/sprites */ "./src/js/core/sprites.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../savegame/serialization */ "./src/js/savegame/serialization.js");
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component */ "./src/js/game/component.js");









class StaticMapEntityComponent extends _component__WEBPACK_IMPORTED_MODULE_7__["Component"] {
    static getId() {
        return "StaticMapEntity";
    }

    static getSchema() {
        return {
            origin: _savegame_serialization__WEBPACK_IMPORTED_MODULE_6__["types"].tileVector,
            tileSize: _savegame_serialization__WEBPACK_IMPORTED_MODULE_6__["types"].tileVector,
            rotation: _savegame_serialization__WEBPACK_IMPORTED_MODULE_6__["types"].float,
            originalRotation: _savegame_serialization__WEBPACK_IMPORTED_MODULE_6__["types"].float,
            spriteKey: _savegame_serialization__WEBPACK_IMPORTED_MODULE_6__["types"].nullable(_savegame_serialization__WEBPACK_IMPORTED_MODULE_6__["types"].string),
            blueprintSpriteKey: _savegame_serialization__WEBPACK_IMPORTED_MODULE_6__["types"].string,
            silhouetteColor: _savegame_serialization__WEBPACK_IMPORTED_MODULE_6__["types"].nullable(_savegame_serialization__WEBPACK_IMPORTED_MODULE_6__["types"].string),
        };
    }

    duplicateWithoutContents() {
        return new StaticMapEntityComponent({
            origin: this.origin.copy(),
            tileSize: this.tileSize.copy(),
            rotation: this.rotation,
            originalRotation: this.originalRotation,
            spriteKey: this.spriteKey,
            silhouetteColor: this.silhouetteColor,
            blueprintSpriteKey: this.blueprintSpriteKey,
        });
    }

    /**
     *
     * @param {object} param0
     * @param {Vector=} param0.origin Origin (Top Left corner) of the entity
     * @param {Vector=} param0.tileSize Size of the entity in tiles
     * @param {number=} param0.rotation Rotation in degrees. Must be multiple of 90
     * @param {number=} param0.originalRotation Original Rotation in degrees. Must be multiple of 90
     * @param {string=} param0.spriteKey Optional sprite
     * @param {string} param0.blueprintSpriteKey Blueprint sprite, required
     * @param {string=} param0.silhouetteColor Optional silhouette color override
     */
    constructor({
        origin = new _core_vector__WEBPACK_IMPORTED_MODULE_5__["Vector"](),
        tileSize = new _core_vector__WEBPACK_IMPORTED_MODULE_5__["Vector"](1, 1),
        rotation = 0,
        originalRotation = 0,
        spriteKey = null,
        silhouetteColor = null,
        blueprintSpriteKey = null,
    }) {
        super();
        window.assert(
            rotation % 90 === 0,
            "Rotation of static map entity must be multiple of 90 (was " + rotation + ")"
        );

        this.origin = origin;
        this.tileSize = tileSize;
        this.spriteKey = spriteKey;
        this.rotation = rotation;
        this.originalRotation = originalRotation;
        this.silhouetteColor = silhouetteColor;
        this.blueprintSpriteKey = blueprintSpriteKey;
    }

    /**
     * Returns the effective rectangle of this entity in tile space
     * @returns {Rectangle}
     */
    getTileSpaceBounds() {
        switch (this.rotation) {
            case 0:
                return new _core_rectangle__WEBPACK_IMPORTED_MODULE_3__["Rectangle"](this.origin.x, this.origin.y, this.tileSize.x, this.tileSize.y);
            case 90:
                return new _core_rectangle__WEBPACK_IMPORTED_MODULE_3__["Rectangle"](
                    this.origin.x - this.tileSize.y + 1,
                    this.origin.y,
                    this.tileSize.y,
                    this.tileSize.x
                );
            case 180:
                return new _core_rectangle__WEBPACK_IMPORTED_MODULE_3__["Rectangle"](
                    this.origin.x - this.tileSize.x + 1,
                    this.origin.y - this.tileSize.y + 1,
                    this.tileSize.x,
                    this.tileSize.y
                );
            case 270:
                return new _core_rectangle__WEBPACK_IMPORTED_MODULE_3__["Rectangle"](
                    this.origin.x,
                    this.origin.y - this.tileSize.x + 1,
                    this.tileSize.y,
                    this.tileSize.x
                );
            default:
                window.assert(false, "Invalid rotation");
        }
    }

    /**
     * Transforms the given vector/rotation from local space to world space
     * @param {Vector} vector
     * @returns {Vector}
     */
    applyRotationToVector(vector) {
        return vector.rotateFastMultipleOf90(this.rotation);
    }

    /**
     * Transforms the given vector/rotation from world space to local space
     * @param {Vector} vector
     * @returns {Vector}
     */
    unapplyRotationToVector(vector) {
        return vector.rotateFastMultipleOf90(360 - this.rotation);
    }

    /**
     * Transforms the given direction from local space
     * @param {enumDirection} direction
     * @returns {enumDirection}
     */
    localDirectionToWorld(direction) {
        return _core_vector__WEBPACK_IMPORTED_MODULE_5__["Vector"].transformDirectionFromMultipleOf90(direction, this.rotation);
    }

    /**
     * Transforms the given direction from world to local space
     * @param {enumDirection} direction
     * @returns {enumDirection}
     */
    worldDirectionToLocal(direction) {
        return _core_vector__WEBPACK_IMPORTED_MODULE_5__["Vector"].transformDirectionFromMultipleOf90(direction, 360 - this.rotation);
    }

    /**
     * Transforms from local tile space to global tile space
     * @param {Vector} localTile
     * @returns {Vector}
     */
    localTileToWorld(localTile) {
        const result = this.applyRotationToVector(localTile);
        result.addInplace(this.origin);
        return result;
    }

    /**
     * Transforms from world space to local space
     * @param {Vector} worldTile
     */
    worldToLocalTile(worldTile) {
        const localUnrotated = worldTile.sub(this.origin);
        return this.unapplyRotationToVector(localUnrotated);
    }

    /**
     * Returns whether the entity should be drawn for the given parameters
     * @param {DrawParameters} parameters
     */
    shouldBeDrawn(parameters) {
        let x = 0;
        let y = 0;
        let w = 0;
        let h = 0;

        switch (this.rotation) {
            case 0: {
                x = this.origin.x;
                y = this.origin.y;
                w = this.tileSize.x;
                h = this.tileSize.y;
                break;
            }
            case 90: {
                x = this.origin.x - this.tileSize.y + 1;
                y = this.origin.y;
                w = this.tileSize.y;
                h = this.tileSize.x;
                break;
            }
            case 180: {
                x = this.origin.x - this.tileSize.x + 1;
                y = this.origin.y - this.tileSize.y + 1;
                w = this.tileSize.x;
                h = this.tileSize.y;
                break;
            }
            case 270: {
                x = this.origin.x;
                y = this.origin.y - this.tileSize.x + 1;
                w = this.tileSize.y;
                h = this.tileSize.x;
                break;
            }
            default:
                window.assert(false, "Invalid rotation");
        }

        return parameters.visibleRect.containsRect4Params(
            x * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize,
            y * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize,
            w * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize,
            h * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize
        );
    }

    /**
     * Draws a sprite over the whole space of the entity
     * @param {DrawParameters} parameters
     * @param {AtlasSprite} sprite
     * @param {number=} extrudePixels How many pixels to extrude the sprite
     * @param {boolean=} clipping Whether to clip
     * @param {Vector=} overridePosition Whether to drwa the entity at a different location
     */
    drawSpriteOnFullEntityBounds(
        parameters,
        sprite,
        extrudePixels = 0,
        clipping = true,
        overridePosition = null
    ) {
        if (!this.shouldBeDrawn(parameters) && !overridePosition) {
            return;
        }
        let worldX = this.origin.x * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize;
        let worldY = this.origin.y * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize;

        if (overridePosition) {
            worldX = overridePosition.x * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize;
            worldY = overridePosition.y * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize;
        }

        if (this.rotation === 0) {
            // Early out, is faster
            sprite.drawCached(
                parameters,
                worldX - extrudePixels * this.tileSize.x,
                worldY - extrudePixels * this.tileSize.y,
                _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize * this.tileSize.x + 2 * extrudePixels * this.tileSize.x,
                _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize * this.tileSize.y + 2 * extrudePixels * this.tileSize.y,
                false
            );
        } else {
            const rotationCenterX = worldX + _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].halfTileSize;
            const rotationCenterY = worldY + _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].halfTileSize;

            parameters.context.translate(rotationCenterX, rotationCenterY);
            parameters.context.rotate(Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_radians"])(this.rotation));

            sprite.drawCached(
                parameters,
                -_core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].halfTileSize - extrudePixels * this.tileSize.x,
                -_core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].halfTileSize - extrudePixels * this.tileSize.y,
                _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize * this.tileSize.x + 2 * extrudePixels * this.tileSize.x,
                _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize * this.tileSize.y + 2 * extrudePixels * this.tileSize.y,
                false
            );

            parameters.context.rotate(-Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_radians"])(this.rotation));
            parameters.context.translate(-rotationCenterX, -rotationCenterY);
        }
    }
}


/***/ }),

/***/ "./src/js/game/components/storage.js":
/*!*******************************************!*\
  !*** ./src/js/game/components/storage.js ***!
  \*******************************************/
/*! exports provided: StorageComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StorageComponent", function() { return StorageComponent; });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component */ "./src/js/game/component.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../savegame/serialization */ "./src/js/savegame/serialization.js");
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/global_registries */ "./src/js/core/global_registries.js");
/* harmony import */ var _base_item__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base_item */ "./src/js/game/base_item.js");
/* harmony import */ var _items_color_item__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../items/color_item */ "./src/js/game/items/color_item.js");
/* harmony import */ var _items_shape_item__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../items/shape_item */ "./src/js/game/items/shape_item.js");







class StorageComponent extends _component__WEBPACK_IMPORTED_MODULE_0__["Component"] {
    static getId() {
        return "Storage";
    }

    static getSchema() {
        return {
            maximumStorage: _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__["types"].uint,
            storedCount: _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__["types"].uint,
            storedItem: _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__["types"].nullable(_savegame_serialization__WEBPACK_IMPORTED_MODULE_1__["types"].obj(_core_global_registries__WEBPACK_IMPORTED_MODULE_2__["gItemRegistry"])),
            overlayOpacity: _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__["types"].ufloat,
        };
    }

    duplicateWithoutContents() {
        return new StorageComponent({ maximumStorage: this.maximumStorage });
    }

    /**
     * @param {object} param0
     * @param {number=} param0.maximumStorage How much this storage can hold
     */
    constructor({ maximumStorage = 1e20 }) {
        super();
        this.maximumStorage = maximumStorage;

        /**
         * Currently stored item
         * @type {BaseItem}
         */
        this.storedItem = null;

        /**
         * How many of this item we have stored
         */
        this.storedCount = 0;

        /**
         * We compute an opacity to make sure it doesn't flicker
         */
        this.overlayOpacity = 0;
    }

    /**
     * Returns whether this storage can accept the item
     * @param {BaseItem} item
     */
    canAcceptItem(item) {
        if (this.storedCount >= this.maximumStorage) {
            return false;
        }
        if (!this.storedItem || this.storedCount === 0) {
            return true;
        }

        if (item instanceof _items_color_item__WEBPACK_IMPORTED_MODULE_4__["ColorItem"]) {
            return this.storedItem instanceof _items_color_item__WEBPACK_IMPORTED_MODULE_4__["ColorItem"] && this.storedItem.color === item.color;
        }

        if (item instanceof _items_shape_item__WEBPACK_IMPORTED_MODULE_5__["ShapeItem"]) {
            return (
                this.storedItem instanceof _items_shape_item__WEBPACK_IMPORTED_MODULE_5__["ShapeItem"] &&
                this.storedItem.definition.getHash() === item.definition.getHash()
            );
        }

        return false;
    }

    /**
     * @param {BaseItem} item
     */
    takeItem(item) {
        this.storedItem = item;
        this.storedCount++;
    }
}


/***/ }),

/***/ "./src/js/game/components/underground_belt.js":
/*!****************************************************!*\
  !*** ./src/js/game/components/underground_belt.js ***!
  \****************************************************/
/*! exports provided: enumUndergroundBeltMode, UndergroundBeltComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumUndergroundBeltMode", function() { return enumUndergroundBeltMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UndergroundBeltComponent", function() { return UndergroundBeltComponent; });
/* harmony import */ var _base_item__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base_item */ "./src/js/game/base_item.js");
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component */ "./src/js/game/component.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../savegame/serialization */ "./src/js/savegame/serialization.js");
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/global_registries */ "./src/js/core/global_registries.js");






/** @enum {string} */
const enumUndergroundBeltMode = {
    sender: "sender",
    receiver: "receiver",
};

class UndergroundBeltComponent extends _component__WEBPACK_IMPORTED_MODULE_1__["Component"] {
    static getId() {
        return "UndergroundBelt";
    }

    static getSchema() {
        return {
            mode: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].enum(enumUndergroundBeltMode),
            pendingItems: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].array(_savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].pair(_savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].obj(_core_global_registries__WEBPACK_IMPORTED_MODULE_4__["gItemRegistry"]), _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].float)),
            tier: _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].uint,
        };
    }

    duplicateWithoutContents() {
        return new UndergroundBeltComponent({
            mode: this.mode,
            tier: this.tier,
        });
    }

    /**
     *
     * @param {object} param0
     * @param {enumUndergroundBeltMode=} param0.mode As which type of belt the entity acts
     * @param {number=} param0.tier
     */
    constructor({ mode = enumUndergroundBeltMode.sender, tier = 0 }) {
        super();

        this.mode = mode;
        this.tier = tier;

        /** @type {Array<{ item: BaseItem, progress: number }>} */
        this.consumptionAnimations = [];

        /**
         * Used on both receiver and sender.
         * Reciever: Used to store the next item to transfer, and to block input while doing this
         * Sender: Used to store which items are currently "travelling"
         * @type {Array<[BaseItem, number]>} Format is [Item, remaining seconds until transfer/ejection]
         */
        this.pendingItems = [];
    }

    /**
     * Tries to accept an item from an external source like a regular belt or building
     * @param {BaseItem} item
     * @param {number} beltSpeed How fast this item travels
     */
    tryAcceptExternalItem(item, beltSpeed) {
        if (this.mode !== enumUndergroundBeltMode.sender) {
            // Only senders accept external items
            return false;
        }

        if (this.pendingItems.length > 0) {
            // We currently have a pending item
            return false;
        }

        this.pendingItems.push([item, 0]);
        return true;
    }

    /**
     * Tries to accept a tunneled item
     * @param {BaseItem} item
     * @param {number} travelDistance How many tiles this item has to travel
     * @param {number} beltSpeed How fast this item travels
     */
    tryAcceptTunneledItem(item, travelDistance, beltSpeed) {
        if (this.mode !== enumUndergroundBeltMode.receiver) {
            // Only receivers can accept tunneled items
            return false;
        }

        // Notice: We assume that for all items the travel distance is the same
        const maxItemsInTunnel = (2 + travelDistance) / _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].itemSpacingOnBelts;
        if (this.pendingItems.length >= maxItemsInTunnel) {
            // Simulate a real belt which gets full at some point
            return false;
        }

        // NOTICE:
        // This corresponds to the item ejector - it needs 0.5 additional tiles to eject the item.
        // So instead of adding 1 we add 0.5 only.
        // Additionally it takes 1 tile for the acceptor which we just add on top.
        const travelDuration = (travelDistance + 1.5) / beltSpeed / _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].itemSpacingOnBelts;

        this.pendingItems.push([item, travelDuration]);

        // Sort so we can only look at the first ones
        this.pendingItems.sort((a, b) => a[1] - b[1]);

        return true;
    }
}


/***/ }),

/***/ "./src/js/game/components/unremovable.js":
/*!***********************************************!*\
  !*** ./src/js/game/components/unremovable.js ***!
  \***********************************************/
/*! exports provided: UnremovableComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnremovableComponent", function() { return UnremovableComponent; });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component */ "./src/js/game/component.js");


class UnremovableComponent extends _component__WEBPACK_IMPORTED_MODULE_0__["Component"] {
    static getId() {
        return "Unremovable";
    }

    static getSchema() {
        return {};
    }

    duplicateWithoutContents() {
        return new UnremovableComponent();
    }
}


/***/ }),

/***/ "./src/js/game/core.js":
/*!*****************************!*\
  !*** ./src/js/game/core.js ***!
  \*****************************/
/*! exports provided: GameCore */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameCore", function() { return GameCore; });
/* harmony import */ var _core_buffer_maintainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/buffer_maintainer */ "./src/js/core/buffer_maintainer.js");
/* harmony import */ var _core_buffer_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/buffer_utils */ "./src/js/core/buffer_utils.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_dpi_manager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/dpi_manager */ "./src/js/core/dpi_manager.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/global_registries */ "./src/js/core/global_registries.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _savegame_savegame__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../savegame/savegame */ "./src/js/savegame/savegame.js");
/* harmony import */ var _savegame_savegame_serializer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../savegame/savegame_serializer */ "./src/js/savegame/savegame_serializer.js");
/* harmony import */ var _automatic_save__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./automatic_save */ "./src/js/game/automatic_save.js");
/* harmony import */ var _buildings_hub__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./buildings/hub */ "./src/js/game/buildings/hub.js");
/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./camera */ "./src/js/game/camera.js");
/* harmony import */ var _canvas_click_interceptor__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./canvas_click_interceptor */ "./src/js/game/canvas_click_interceptor.js");
/* harmony import */ var _entity_manager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./entity_manager */ "./src/js/game/entity_manager.js");
/* harmony import */ var _game_system_manager__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./game_system_manager */ "./src/js/game/game_system_manager.js");
/* harmony import */ var _hub_goals__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./hub_goals */ "./src/js/game/hub_goals.js");
/* harmony import */ var _hud_hud__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./hud/hud */ "./src/js/game/hud/hud.js");
/* harmony import */ var _key_action_mapper__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./key_action_mapper */ "./src/js/game/key_action_mapper.js");
/* harmony import */ var _logic__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./logic */ "./src/js/game/logic.js");
/* harmony import */ var _map_view__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./map_view */ "./src/js/game/map_view.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./root */ "./src/js/game/root.js");
/* harmony import */ var _shape_definition_manager__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./shape_definition_manager */ "./src/js/game/shape_definition_manager.js");
/* harmony import */ var _sound_proxy__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./sound_proxy */ "./src/js/game/sound_proxy.js");
/* harmony import */ var _time_game_time__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./time/game_time */ "./src/js/game/time/game_time.js");
/* harmony import */ var _production_analytics__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./production_analytics */ "./src/js/game/production_analytics.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _dynamic_tickrate__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./dynamic_tickrate */ "./src/js/game/dynamic_tickrate.js");

































const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_7__["createLogger"])("ingame/core");

// Store the canvas so we can reuse it later
/** @type {HTMLCanvasElement} */
let lastCanvas = null;
/** @type {CanvasRenderingContext2D} */
let lastContext = null;

/**
 * The core manages the root and represents the whole game. It wraps the root, since
 * the root class is just a data holder.
 */
class GameCore {
    /** @param {Application} app */
    constructor(app) {
        this.app = app;

        /** @type {GameRoot} */
        this.root = null;

        /**
         * Set to true at the beginning of a logic update and cleared when its finished.
         * This is to prevent doing a recursive logic update which can lead to unexpected
         * behaviour.
         */
        this.duringLogicUpdate = false;

        // Cached
        this.boundInternalTick = this.updateLogic.bind(this);
    }

    /**
     * Initializes the root object which stores all game related data. The state
     * is required as a back reference (used sometimes)
     * @param {InGameState} parentState
     * @param {Savegame} savegame
     */
    initializeRoot(parentState, savegame) {
        // Construct the root element, this is the data representation of the game
        this.root = new _root__WEBPACK_IMPORTED_MODULE_22__["GameRoot"](this.app);
        this.root.gameState = parentState;
        this.root.keyMapper = parentState.keyActionMapper;
        this.root.savegame = savegame;
        this.root.gameWidth = this.app.screenWidth;
        this.root.gameHeight = this.app.screenHeight;

        // Initialize canvas element & context
        this.internalInitCanvas();

        // Members
        const root = this.root;

        // This isn't nice, but we need it right here
        root.keyMapper = new _key_action_mapper__WEBPACK_IMPORTED_MODULE_19__["KeyActionMapper"](root, this.root.gameState.inputReciever);

        // Needs to come first
        root.dynamicTickrate = new _dynamic_tickrate__WEBPACK_IMPORTED_MODULE_29__["DynamicTickrate"](root);

        // Init classes
        root.camera = new _camera__WEBPACK_IMPORTED_MODULE_13__["Camera"](root);
        root.map = new _map_view__WEBPACK_IMPORTED_MODULE_21__["MapView"](root);
        root.logic = new _logic__WEBPACK_IMPORTED_MODULE_20__["GameLogic"](root);
        root.hud = new _hud_hud__WEBPACK_IMPORTED_MODULE_18__["GameHUD"](root);
        root.time = new _time_game_time__WEBPACK_IMPORTED_MODULE_25__["GameTime"](root);
        root.canvasClickInterceptor = new _canvas_click_interceptor__WEBPACK_IMPORTED_MODULE_14__["CanvasClickInterceptor"](root);
        root.automaticSave = new _automatic_save__WEBPACK_IMPORTED_MODULE_11__["AutomaticSave"](root);
        root.soundProxy = new _sound_proxy__WEBPACK_IMPORTED_MODULE_24__["SoundProxy"](root);

        // Init managers
        root.entityMgr = new _entity_manager__WEBPACK_IMPORTED_MODULE_15__["EntityManager"](root);
        root.systemMgr = new _game_system_manager__WEBPACK_IMPORTED_MODULE_16__["GameSystemManager"](root);
        root.shapeDefinitionMgr = new _shape_definition_manager__WEBPACK_IMPORTED_MODULE_23__["ShapeDefinitionManager"](root);
        root.hubGoals = new _hub_goals__WEBPACK_IMPORTED_MODULE_17__["HubGoals"](root);
        root.productionAnalytics = new _production_analytics__WEBPACK_IMPORTED_MODULE_26__["ProductionAnalytics"](root);
        root.buffers = new _core_buffer_maintainer__WEBPACK_IMPORTED_MODULE_0__["BufferMaintainer"](root);

        // Initialize the hud once everything is loaded
        this.root.hud.initialize();

        // Initial resize event, it might be possible that the screen
        // resized later during init tho, which is why will emit it later
        // again anyways
        this.resize(this.app.screenWidth, this.app.screenHeight);

        if (true) {
            // @ts-ignore
            window.globalRoot = root;
        }
    }

    /**
     * Initializes a new game, this means creating a new map and centering on the
     * playerbase
     * */
    initNewGame() {
        logger.log("Initializing new game");
        this.root.gameIsFresh = true;
        this.root.map.seed = Object(_core_utils__WEBPACK_IMPORTED_MODULE_27__["randomInt"])(0, 100000);

        _core_global_registries__WEBPACK_IMPORTED_MODULE_6__["gMetaBuildingRegistry"].findByClass(_buildings_hub__WEBPACK_IMPORTED_MODULE_12__["MetaHubBuilding"]).createAndPlaceEntity({
            root: this.root,
            origin: new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](-2, -2),
            rotation: 0,
            originalRotation: 0,
            rotationVariant: 0,
            variant: _meta_building__WEBPACK_IMPORTED_MODULE_28__["defaultBuildingVariant"],
        });
    }

    /**
     * Inits an existing game by loading the raw savegame data and deserializing it.
     * Also runs basic validity checks.
     */
    initExistingGame() {
        logger.log("Initializing existing game");
        const serializer = new _savegame_savegame_serializer__WEBPACK_IMPORTED_MODULE_10__["SavegameSerializer"]();

        try {
            const status = serializer.deserialize(this.root.savegame.getCurrentDump(), this.root);
            if (!status.isGood()) {
                logger.error("savegame-deserialize-failed:" + status.reason);
                return false;
            }
        } catch (ex) {
            logger.error("Exception during deserialization:", ex);
            return false;
        }
        this.root.gameIsFresh = false;
        return true;
    }

    /**
     * Initializes the render canvas
     */
    internalInitCanvas() {
        let canvas, context;
        if (!lastCanvas) {
            logger.log("Creating new canvas");
            canvas = document.createElement("canvas");
            canvas.id = "ingame_Canvas";
            canvas.setAttribute("opaque", "true");
            canvas.setAttribute("webkitOpaque", "true");
            canvas.setAttribute("mozOpaque", "true");
            this.root.gameState.getDivElement().appendChild(canvas);
            context = canvas.getContext("2d", { alpha: false });

            lastCanvas = canvas;
            lastContext = context;
        } else {
            logger.log("Reusing canvas");
            if (lastCanvas.parentElement) {
                lastCanvas.parentElement.removeChild(lastCanvas);
            }
            this.root.gameState.getDivElement().appendChild(lastCanvas);

            canvas = lastCanvas;
            context = lastContext;

            lastContext.clearRect(0, 0, lastCanvas.width, lastCanvas.height);
        }

        // globalConfig.smoothing.smoothMainCanvas = getDeviceDPI() < 1.5;
        // globalConfig.smoothing.smoothMainCanvas = true;

        canvas.classList.toggle("smoothed", _core_config__WEBPACK_IMPORTED_MODULE_3__["globalConfig"].smoothing.smoothMainCanvas);

        // Oof, use :not() instead
        canvas.classList.toggle("unsmoothed", !_core_config__WEBPACK_IMPORTED_MODULE_3__["globalConfig"].smoothing.smoothMainCanvas);

        if (_core_config__WEBPACK_IMPORTED_MODULE_3__["globalConfig"].smoothing.smoothMainCanvas) {
            Object(_core_buffer_utils__WEBPACK_IMPORTED_MODULE_1__["enableImageSmoothing"])(context);
        } else {
            Object(_core_buffer_utils__WEBPACK_IMPORTED_MODULE_1__["disableImageSmoothing"])(context);
        }

        this.root.canvas = canvas;
        this.root.context = context;

        Object(_core_buffer_utils__WEBPACK_IMPORTED_MODULE_1__["registerCanvas"])(canvas, context);
    }

    /**
     * Destructs the root, freeing all resources
     */
    destruct() {
        if (lastCanvas && lastCanvas.parentElement) {
            lastCanvas.parentElement.removeChild(lastCanvas);
        }

        this.root.destruct();
        delete this.root;
        this.root = null;
        this.app = null;
    }

    tick(deltaMs) {
        const root = this.root;

        if (root.hud.parts.processingOverlay.hasTasks() || root.hud.parts.processingOverlay.isRunning()) {
            return true;
        }

        // Extract current real time
        root.time.updateRealtimeNow();

        // Camera is always updated, no matter what
        root.camera.update(deltaMs);

        // Perform logic ticks
        this.root.time.performTicks(deltaMs, this.boundInternalTick);

        // Update analytics
        root.productionAnalytics.update();

        // Update automatic save after everything finished
        root.automaticSave.update();

        return true;
    }

    shouldRender() {
        if (this.root.queue.requireRedraw) {
            return true;
        }
        if (this.root.hud.shouldPauseRendering()) {
            return false;
        }

        // Do not render
        if (!this.app.isRenderable()) {
            return false;
        }

        return true;
    }

    updateLogic() {
        const root = this.root;

        root.dynamicTickrate.beginTick();

        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_3__["globalConfig"].debug.disableLogicTicks) {
            root.dynamicTickrate.endTick();
            return true;
        }

        this.duringLogicUpdate = true;

        // Update entities, this removes destroyed entities
        root.entityMgr.update();

        // IMPORTANT: At this point, the game might be game over. Stop if this is the case
        if (!this.root) {
            logger.log("Root destructed, returning false");
            root.dynamicTickrate.endTick();

            return false;
        }

        root.systemMgr.update();
        // root.particleMgr.update();

        this.duringLogicUpdate = false;
        root.dynamicTickrate.endTick();
        return true;
    }

    resize(w, h) {
        this.root.gameWidth = w;
        this.root.gameHeight = h;
        Object(_core_dpi_manager__WEBPACK_IMPORTED_MODULE_4__["resizeHighDPICanvas"])(this.root.canvas, w, h, _core_config__WEBPACK_IMPORTED_MODULE_3__["globalConfig"].smoothing.smoothMainCanvas);
        this.root.signals.resized.dispatch(w, h);
        this.root.queue.requireRedraw = true;
    }

    postLoadHook() {
        logger.log("Dispatching post load hook");
        this.root.signals.postLoadHook.dispatch();

        if (!this.root.gameIsFresh) {
            // Also dispatch game restored hook on restored savegames
            this.root.signals.gameRestored.dispatch();
        }

        this.root.gameInitialized = true;
    }

    draw() {
        const root = this.root;
        const systems = root.systemMgr.systems;

        const taskRunner = root.hud.parts.processingOverlay;
        if (taskRunner.hasTasks()) {
            if (!taskRunner.isRunning()) {
                taskRunner.process();
            }
            return;
        }

        this.root.dynamicTickrate.onFrameRendered();

        if (!this.shouldRender()) {
            // Always update hud tho
            root.hud.update();
            return;
        }

        // Update buffers as the very first
        root.buffers.update();

        root.queue.requireRedraw = false;

        // Gather context and save all state
        const context = root.context;
        context.save();
        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_3__["globalConfig"].debug.testClipping) {
            context.clearRect(0, 0, window.innerWidth * 3, window.innerHeight * 3);
        }

        // Compute optimal zoom level and atlas scale
        const zoomLevel = root.camera.zoomLevel;
        const effectiveZoomLevel =
            (zoomLevel / _core_config__WEBPACK_IMPORTED_MODULE_3__["globalConfig"].assetsDpi) * Object(_core_dpi_manager__WEBPACK_IMPORTED_MODULE_4__["getDeviceDPI"])() * _core_config__WEBPACK_IMPORTED_MODULE_3__["globalConfig"].assetsSharpness;

        let desiredAtlasScale = "0.1";
        if (effectiveZoomLevel > 0.75) {
            desiredAtlasScale = "1";
        } else if (effectiveZoomLevel > 0.5) {
            desiredAtlasScale = "0.75";
        } else if (effectiveZoomLevel > 0.25) {
            desiredAtlasScale = "0.5";
        } else if (effectiveZoomLevel > 0.1) {
            desiredAtlasScale = "0.25";
        }

        // Construct parameters required for drawing
        const params = new _core_draw_parameters__WEBPACK_IMPORTED_MODULE_5__["DrawParameters"]({
            context: context,
            visibleRect: root.camera.getVisibleRect(),
            desiredAtlasScale,
            zoomLevel,
            root: root,
        });

        if ( true && (_core_config__WEBPACK_IMPORTED_MODULE_3__["globalConfig"].debug.testCulling || _core_config__WEBPACK_IMPORTED_MODULE_3__["globalConfig"].debug.hideFog)) {
            context.clearRect(0, 0, root.gameWidth, root.gameHeight);
        }

        // Transform to world space
        root.camera.transform(context);

        window.assert(context.globalAlpha === 1.0, "Global alpha not 1 on frame start");

        // Update hud
        root.hud.update();

        // Main rendering order
        // -----

        root.map.drawBackground(params);

        if (!this.root.camera.getIsMapOverlayActive()) {
            systems.itemAcceptor.drawUnderlays(params);
            systems.belt.draw(params);
            systems.itemEjector.draw(params);
            systems.itemAcceptor.draw(params);
        }

        root.map.drawForeground(params);
        if (!this.root.camera.getIsMapOverlayActive()) {
            systems.hub.draw(params);
            systems.storage.draw(params);
        }

        if (true) {
            root.map.drawStaticEntities(params);
        }

        // END OF GAME CONTENT
        // -----

        // Finally, draw the hud. Nothing should come after that
        root.hud.draw(params);

        window.assert(context.globalAlpha === 1.0, "Global alpha not 1 on frame end before restore");

        // Restore to screen space
        context.restore();

        // Draw overlays, those are screen space
        root.hud.drawOverlays(params);

        window.assert(context.globalAlpha === 1.0, "context.globalAlpha not 1 on frame end");

        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_3__["globalConfig"].debug.simulateSlowRendering) {
            let sum = 0;
            for (let i = 0; i < 1e8; ++i) {
                sum += i;
            }
            if (Object(_core_builtins__WEBPACK_IMPORTED_MODULE_2__["Math_random"])() > 0.95) {
                console.log(sum);
            }
        }
    }
}


/***/ }),

/***/ "./src/js/game/dynamic_tickrate.js":
/*!*****************************************!*\
  !*** ./src/js/game/dynamic_tickrate.js ***!
  \*****************************************/
/*! exports provided: DynamicTickrate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicTickrate", function() { return DynamicTickrate; });
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./root */ "./src/js/game/root.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/utils */ "./src/js/core/utils.js");






const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_1__["createLogger"])("dynamic_tickrate");

const fpsAccumulationTime = 1000;

class DynamicTickrate {
    /**
     *
     * @param {GameRoot} root
     */
    constructor(root) {
        this.root = root;

        this.currentTickStart = null;
        this.capturedTicks = [];
        this.averageTickDuration = 0;

        this.accumulatedFps = 0;
        this.accumulatedFpsLastUpdate = 0;

        this.averageFps = 60;

        this.setTickRate(60);

        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].debug.renderForTrailer) {
            this.setTickRate(300);
        }
    }

    onFrameRendered() {
        ++this.accumulatedFps;

        const now = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_3__["performanceNow"])();
        const timeDuration = now - this.accumulatedFpsLastUpdate;
        if (timeDuration > fpsAccumulationTime) {
            const avgFps = (this.accumulatedFps / fpsAccumulationTime) * 1000;
            this.averageFps = avgFps;
            this.accumulatedFps = 0;
            this.accumulatedFpsLastUpdate = now;
        }
    }

    /**
     * Sets the tick rate to N updates per second
     * @param {number} rate
     */
    setTickRate(rate) {
        logger.log("Applying tick-rate of", rate);
        this.currentTickRate = rate;
        this.deltaMs = 1000.0 / this.currentTickRate;
        this.deltaSeconds = 1.0 / this.currentTickRate;
    }

    /**
     * Increases the tick rate marginally
     */
    increaseTickRate() {
        if (( true && _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].debug.renderForTrailer) || _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].debug.disableDynamicTickrate) {
            return;
        }

        const desiredFps = this.root.app.settings.getDesiredFps();
        this.setTickRate(Object(_core_builtins__WEBPACK_IMPORTED_MODULE_3__["Math_round"])(Object(_core_builtins__WEBPACK_IMPORTED_MODULE_3__["Math_min"])(desiredFps, this.currentTickRate * 1.2)));
    }

    /**
     * Decreases the tick rate marginally
     */
    decreaseTickRate() {
        if (( true && _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].debug.renderForTrailer) || _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].debug.disableDynamicTickrate) {
            return;
        }

        const desiredFps = this.root.app.settings.getDesiredFps();
        this.setTickRate(Object(_core_builtins__WEBPACK_IMPORTED_MODULE_3__["Math_round"])(Object(_core_builtins__WEBPACK_IMPORTED_MODULE_3__["Math_max"])(desiredFps / 2, this.currentTickRate * 0.8)));
    }

    /**
     * Call whenever a tick began
     */
    beginTick() {
        window.assert(this.currentTickStart === null, "BeginTick called twice");
        this.currentTickStart = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_3__["performanceNow"])();

        if (this.capturedTicks.length > this.currentTickRate * 2) {
            // Take only a portion of the ticks
            this.capturedTicks.sort();
            this.capturedTicks.splice(0, 10);
            this.capturedTicks.splice(this.capturedTicks.length - 11, 10);

            let average = 0;
            for (let i = 0; i < this.capturedTicks.length; ++i) {
                average += this.capturedTicks[i];
            }
            average /= this.capturedTicks.length;

            this.averageTickDuration = average;

            const desiredFps = this.root.app.settings.getDesiredFps();

            if (this.averageFps > desiredFps * 0.9) {
                // if (average < maxTickDuration) {
                this.increaseTickRate();
            } else if (this.averageFps < desiredFps * 0.7) {
                this.decreaseTickRate();
            }

            this.capturedTicks = [];
        }
    }

    /**
     * Call whenever a tick ended
     */
    endTick() {
        window.assert(this.currentTickStart !== null, "EndTick called without BeginTick");
        const duration = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_3__["performanceNow"])() - this.currentTickStart;
        this.capturedTicks.push(duration);
        this.currentTickStart = null;
    }
}


/***/ }),

/***/ "./src/js/game/entity.js":
/*!*******************************!*\
  !*** ./src/js/game/entity.js ***!
  \*******************************/
/*! exports provided: Entity */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Entity", function() { return Entity; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../savegame/serialization */ "./src/js/savegame/serialization.js");
/* harmony import */ var _entity_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./entity_components */ "./src/js/game/entity_components.js");
/* harmony import */ var _core_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/loader */ "./src/js/core/loader.js");
/* harmony import */ var _core_draw_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/draw_utils */ "./src/js/core/draw_utils.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/global_registries */ "./src/js/core/global_registries.js");











class Entity extends _savegame_serialization__WEBPACK_IMPORTED_MODULE_2__["BasicSerializableObject"] {
    /**
     * @param {GameRoot} root
     */
    constructor(root) {
        super();

        /**
         * Handle to the global game root
         */
        this.root = root;

        /**
         * The components of the entity
         */
        this.components = new _entity_components__WEBPACK_IMPORTED_MODULE_3__["EntityComponentStorage"]();

        /**
         * Whether this entity was registered on the @see EntityManager so far
         */
        this.registered = false;

        /**
         * Internal entity unique id, set by the @see EntityManager
         */
        this.uid = 0;


    }

    static getId() {
        return "Entity";
    }

    /**
     * @see BasicSerializableObject.getSchema
     * @returns {import("../savegame/serialization").Schema}
     */
    static getSchema() {
        return {
            uid: _savegame_serialization__WEBPACK_IMPORTED_MODULE_2__["types"].uint,
            components: _savegame_serialization__WEBPACK_IMPORTED_MODULE_2__["types"].keyValueMap(_savegame_serialization__WEBPACK_IMPORTED_MODULE_2__["types"].objData(_core_global_registries__WEBPACK_IMPORTED_MODULE_7__["gComponentRegistry"])),
        };
    }

    /**
     * Returns a clone of this entity without contents
     */
    duplicateWithoutContents() {
        const clone = new Entity(this.root);
        for (const key in this.components) {
            clone.components[key] = this.components[key].duplicateWithoutContents();
        }
        return clone;
    }

    /**
     * Internal destroy callback
     */
    internalDestroyCallback() {
        window.assert(!this.destroyed, "Can not destroy entity twice");
        this.destroyed = true;
    }

    /**
     * Adds a new component, only possible until the entity is registered on the entity manager,
     * after that use @see EntityManager.addDynamicComponent
     * @param {Component} componentInstance
     * @param {boolean} force Used by the entity manager. Internal parameter, do not change
     */
    addComponent(componentInstance, force = false) {
        if (!force && this.registered) {
            this.root.entityMgr.attachDynamicComponent(this, componentInstance);
            return;
        }
        window.assert(force || !this.registered, "Entity already registered, use EntityManager.addDynamicComponent");
        const id = /** @type {typeof Component} */ (componentInstance.constructor).getId();
        window.assert(!this.components[id], "Component already present");
        this.components[id] = componentInstance;
    }

    /**
     * Removes a given component, only possible until the entity is registered on the entity manager,
     * after that use @see EntityManager.removeDynamicComponent
     * @param {typeof Component} componentClass
     * @param {boolean} force
     */
    removeComponent(componentClass, force = false) {
        if (!force && this.registered) {
            this.root.entityMgr.removeDynamicComponent(this, componentClass);
            return;
        }
        window.assert(
            force || !this.registered,
            "Entity already registered, use EntityManager.removeDynamicComponent"
        );
        const id = componentClass.getId();
        window.assert(this.components[id], "Component does not exist on entity");
        delete this.components[id];
    }

    /**
     * Draws the entity, to override use @see Entity.drawImpl
     * @param {DrawParameters} parameters
     */
    draw(parameters) {
        const context = parameters.context;
        const staticComp = this.components.StaticMapEntity;

        if ( true && staticComp && _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug.showEntityBounds) {
            if (staticComp) {
                const transformed = staticComp.getTileSpaceBounds();
                context.strokeStyle = "rgba(255, 0, 0, 0.5)";
                context.lineWidth = 2;
                // const boundsSize = 20;
                context.beginPath();
                context.rect(
                    transformed.x * _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize,
                    transformed.y * _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize,
                    transformed.w * _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize,
                    transformed.h * _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize
                );
                context.stroke();
            }
        }
        if ( true && staticComp && _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug.showAcceptorEjectors) {
            const ejectorComp = this.components.ItemEjector;

            if (ejectorComp) {
                const ejectorSprite = _core_loader__WEBPACK_IMPORTED_MODULE_4__["Loader"].getSprite("sprites/debug/ejector_slot.png");
                for (let i = 0; i < ejectorComp.slots.length; ++i) {
                    const slot = ejectorComp.slots[i];
                    const slotTile = staticComp.localTileToWorld(slot.pos);
                    const direction = staticComp.localDirectionToWorld(slot.direction);
                    const directionVector = _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirectionToVector"][direction];
                    const angle = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_6__["Math_radians"])(_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirectionToAngle"][direction]);

                    context.globalAlpha = slot.item ? 1 : 0.2;
                    Object(_core_draw_utils__WEBPACK_IMPORTED_MODULE_5__["drawRotatedSprite"])({
                        parameters,
                        sprite: ejectorSprite,
                        x: (slotTile.x + 0.5 + directionVector.x * 0.37) * _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize,
                        y: (slotTile.y + 0.5 + directionVector.y * 0.37) * _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize,
                        angle,
                        size: _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize * 0.25,
                    });
                }
            }
            const acceptorComp = this.components.ItemAcceptor;

            if (acceptorComp) {
                const acceptorSprite = _core_loader__WEBPACK_IMPORTED_MODULE_4__["Loader"].getSprite("sprites/debug/acceptor_slot.png");
                for (let i = 0; i < acceptorComp.slots.length; ++i) {
                    const slot = acceptorComp.slots[i];
                    const slotTile = staticComp.localTileToWorld(slot.pos);
                    for (let k = 0; k < slot.directions.length; ++k) {
                        const direction = staticComp.localDirectionToWorld(slot.directions[k]);
                        const directionVector = _core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirectionToVector"][direction];
                        const angle = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_6__["Math_radians"])(_core_vector__WEBPACK_IMPORTED_MODULE_1__["enumDirectionToAngle"][direction] + 180);
                        context.globalAlpha = 0.4;
                        Object(_core_draw_utils__WEBPACK_IMPORTED_MODULE_5__["drawRotatedSprite"])({
                            parameters,
                            sprite: acceptorSprite,
                            x: (slotTile.x + 0.5 + directionVector.x * 0.37) * _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize,
                            y: (slotTile.y + 0.5 + directionVector.y * 0.37) * _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize,
                            angle,
                            size: _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize * 0.25,
                        });
                    }
                }
            }

            context.globalAlpha = 1;
        }
        // this.drawImpl(parameters);
    }

    ///// Helper interfaces

    ///// Interface to override by subclasses

    /**
     * override, should draw the entity
     * @param {DrawParameters} parameters
     */
    drawImpl(parameters) {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }
}


/***/ }),

/***/ "./src/js/game/entity_components.js":
/*!******************************************!*\
  !*** ./src/js/game/entity_components.js ***!
  \******************************************/
/*! exports provided: EntityComponentStorage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EntityComponentStorage", function() { return EntityComponentStorage; });


/**
 * Typedefs for all entity components. These are not actually present on the entity,
 * thus they are undefined by default
 */
class EntityComponentStorage {
    constructor() {
        // TODO: Figure out if its faster to declare all components here and not
        // compile them out (In theory, should make it a fast object in V8 engine)


    }
}


/***/ }),

/***/ "./src/js/game/entity_manager.js":
/*!***************************************!*\
  !*** ./src/js/game/entity_manager.js ***!
  \***************************************/
/*! exports provided: EntityManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EntityManager", function() { return EntityManager; });
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component */ "./src/js/game/component.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./root */ "./src/js/game/root.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./entity */ "./src/js/game/entity.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../savegame/serialization */ "./src/js/savegame/serialization.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");







const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_5__["createLogger"])("entity_manager");

// Manages all entities

// TODO & NOTICE: We use arrayDeleteValue instead of fastArrayDeleteValue since that does not preserve the order
// This is slower but we need it for the street path generation

class EntityManager extends _savegame_serialization__WEBPACK_IMPORTED_MODULE_4__["BasicSerializableObject"] {
    constructor(root) {
        super();

        /** @type {GameRoot} */
        this.root = root;

        /** @type {Array<Entity>} */
        this.entities = [];

        // We store a seperate list with entities to destroy, since we don't destroy
        // them instantly
        /** @type {Array<Entity>} */
        this.destroyList = [];

        // Store a map from componentid to entities - This is used by the game system
        // for faster processing
        /** @type {Object.<string, Array<Entity>>} */
        this.componentToEntity = Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__["newEmptyMap"])();

        // Store the next uid to use
        this.nextUid = 10000;
    }

    static getId() {
        return "EntityManager";
    }

    static getSchema() {
        return {
            nextUid: _savegame_serialization__WEBPACK_IMPORTED_MODULE_4__["types"].uint,
        };
    }

    getStatsText() {
        return this.entities.length + " entities [" + this.destroyList.length + " to kill]";
    }

    // Main update
    update() {
        this.processDestroyList();
    }

    /**
     * Registers a new entity
     * @param {Entity} entity
     * @param {number=} uid Optional predefined uid
     */
    registerEntity(entity, uid = null) {
        window.assert(this.entities.indexOf(entity) < 0, `RegisterEntity() called twice for entity ${entity}`);
        window.assert(!entity.destroyed, `Attempting to register destroyed entity ${entity}`);

        if ( true && uid !== null) {
            window.assert(!this.findByUid(uid, false), "Entity uid already taken: " + uid);
        }

        if (uid !== null) {
            window.assert(uid >= 0 && uid < Number.MAX_SAFE_INTEGER, "Invalid uid passed: " + uid);
        }

        this.entities.push(entity);

        // Register into the componentToEntity map
        for (const componentId in entity.components) {
            if (entity.components[componentId]) {
                if (this.componentToEntity[componentId]) {
                    this.componentToEntity[componentId].push(entity);
                } else {
                    this.componentToEntity[componentId] = [entity];
                }
            }
        }

        // Give each entity a unique id
        entity.uid = uid ? uid : this.generateUid();
        entity.registered = true;

        this.root.signals.entityAdded.dispatch(entity);
    }

    /**
     * Sorts all entitiy lists after a resync
     */
    sortEntityLists() {
        this.entities.sort((a, b) => a.uid - b.uid);
        this.destroyList.sort((a, b) => a.uid - b.uid);

        for (const key in this.componentToEntity) {
            this.componentToEntity[key].sort((a, b) => a.uid - b.uid);
        }
    }

    /**
     * Generates a new uid
     * @returns {number}
     */
    generateUid() {
        return this.nextUid++;
    }

    /**
     * Call to attach a new component after the creation of the entity
     * @param {Entity} entity
     * @param {Component} component
     */
    attachDynamicComponent(entity, component) {
        entity.addComponent(component, true);
        const componentId = /** @type {typeof Component} */ (component.constructor).getId();
        if (this.componentToEntity[componentId]) {
            this.componentToEntity[componentId].push(entity);
        } else {
            this.componentToEntity[componentId] = [entity];
        }
        this.root.signals.entityGotNewComponent.dispatch(entity);
    }

    /**
     * Call to remove a component after the creation of the entity
     * @param {Entity} entity
     * @param {typeof Component} component
     */
    removeDynamicComponent(entity, component) {
        entity.removeComponent(component, true);
        const componentId = /** @type {typeof Component} */ (component.constructor).getId();

        Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__["fastArrayDeleteValue"])(this.componentToEntity[componentId], entity);
        this.root.signals.entityComponentRemoved.dispatch(entity);
    }

    /**
     * Finds an entity buy its uid, kinda slow since it loops over all entities
     * @param {number} uid
     * @param {boolean=} errorWhenNotFound
     * @returns {Entity}
     */
    findByUid(uid, errorWhenNotFound = true) {
        const arr = this.entities;
        for (let i = 0, len = arr.length; i < len; ++i) {
            const entity = arr[i];
            if (entity.uid === uid) {
                if (entity.queuedForDestroy || entity.destroyed) {
                    if (errorWhenNotFound) {
                        logger.warn("Entity with UID", uid, "not found (destroyed)");
                    }
                    return null;
                }
                return entity;
            }
        }
        if (errorWhenNotFound) {
            logger.warn("Entity with UID", uid, "not found");
        }
        return null;
    }

    /**
     * Returns all entities having the given component
     * @param {typeof Component} componentHandle
     * @returns {Array<Entity>} entities
     */
    getAllWithComponent(componentHandle) {
        return this.componentToEntity[componentHandle.getId()] || [];
    }

    /**
     * Return all of a given class. This is SLOW!
     * @param {object} entityClass
     * @returns {Array<Entity>} entities
     */
    getAllOfClass(entityClass) {
        // FIXME: Slow
        const result = [];
        for (let i = 0; i < this.entities.length; ++i) {
            const entity = this.entities[i];
            if (entity instanceof entityClass) {
                result.push(entity);
            }
        }
        return result;
    }

    /**
     * Unregisters all components of an entity from the component to entity mapping
     * @param {Entity} entity
     */
    unregisterEntityComponents(entity) {
        for (const componentId in entity.components) {
            if (entity.components[componentId]) {
                Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__["arrayDeleteValue"])(this.componentToEntity[componentId], entity);
            }
        }
    }

    // Processes the entities to destroy and actually destroys them
    /* eslint-disable max-statements */
    processDestroyList() {
        for (let i = 0; i < this.destroyList.length; ++i) {
            const entity = this.destroyList[i];

            // Remove from entities list
            Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__["arrayDeleteValue"])(this.entities, entity);

            // Remove from componentToEntity list
            this.unregisterEntityComponents(entity);

            entity.registered = false;
            entity.internalDestroyCallback();

            this.root.signals.entityDestroyed.dispatch(entity);
        }

        this.destroyList = [];
    }

    /**
     * Queues an entity for destruction
     * @param {Entity} entity
     */
    destroyEntity(entity) {
        if (entity.destroyed) {
            logger.error("Tried to destroy already destroyed entity:", entity.uid);
            return;
        }

        if (entity.queuedForDestroy) {
            logger.error("Trying to destroy entity which is already queued for destroy!", entity.uid);
            return;
        }

        if (this.destroyList.indexOf(entity) < 0) {
            this.destroyList.push(entity);
            entity.queuedForDestroy = true;
            this.root.signals.entityQueuedForDestroy.dispatch(entity);
        } else {
            window.assert(false, "Trying to destroy entity twice");
        }
    }
}


/***/ }),

/***/ "./src/js/game/game_loading_overlay.js":
/*!*********************************************!*\
  !*** ./src/js/game/game_loading_overlay.js ***!
  \*********************************************/
/*! exports provided: GameLoadingOverlay */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameLoadingOverlay", function() { return GameLoadingOverlay; });
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../translations */ "./src/js/translations.js");



class GameLoadingOverlay {
    /**
     *
     * @param {Application} app
     * @param {HTMLElement} parent
     */
    constructor(app, parent) {
        this.app = app;
        this.parent = parent;

        /** @type {HTMLElement} */
        this.element = null;
    }

    /**
     * Removes the overlay if its currently visible
     */
    removeIfAttached() {
        if (this.element) {
            this.element.remove();
            this.element = null;
        }
    }

    /**
     * Returns if the loading overlay is attached
     */
    isAttached() {
        return this.element;
    }

    /**
     * Shows a super basic overlay
     */
    showBasic() {
        window.assert(!this.element, "Loading overlay already visible, cant show again");
        this.element = document.createElement("div");
        this.element.classList.add("gameLoadingOverlay");
        this.parent.appendChild(this.element);
        this.internalAddSpinnerAndText(this.element);
    }

    /**
     * Adds a text with 'loading' and a spinner
     * @param {HTMLElement} element
     */
    internalAddSpinnerAndText(element) {
        const inner = document.createElement("span");
        inner.classList.add("prefab_LoadingTextWithAnim");
        inner.innerText = _translations__WEBPACK_IMPORTED_MODULE_0__["T"].global.loading;
        element.appendChild(inner);
    }
}


/***/ }),

/***/ "./src/js/game/game_speed_registry.js":
/*!********************************************!*\
  !*** ./src/js/game/game_speed_registry.js ***!
  \********************************************/
/*! exports provided: initGameSpeedRegistry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initGameSpeedRegistry", function() { return initGameSpeedRegistry; });
/* harmony import */ var _time_regular_game_speed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time/regular_game_speed */ "./src/js/game/time/regular_game_speed.js");
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/global_registries */ "./src/js/core/global_registries.js");



function initGameSpeedRegistry() {
    _core_global_registries__WEBPACK_IMPORTED_MODULE_1__["gGameSpeedRegistry"].register(_time_regular_game_speed__WEBPACK_IMPORTED_MODULE_0__["RegularGameSpeed"]);

    // Others are disabled for now
}


/***/ }),

/***/ "./src/js/game/game_system.js":
/*!************************************!*\
  !*** ./src/js/game/game_system.js ***!
  \************************************/
/*! exports provided: GameSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameSystem", function() { return GameSystem; });


/**
 * A game system processes all entities which match a given schema, usually a list of
 * required components. This is the core of the game logic.
 */
class GameSystem {
    /**
     * @param {GameRoot} root
     */
    constructor(root) {
        this.root = root;
    }

    ///// PUBLIC API /////

    /**
     * Updates the game system, override to perform logic
     */
    update() {}

    /**
     * Override, do not call this directly, use startDraw()
     * @param {DrawParameters} parameters
     */
    draw(parameters) {}

    /**
     * Should refresh all caches
     */
    refreshCaches() {}

    /**
     * @see GameSystem.draw Wrapper arround the draw method
     * @param {DrawParameters} parameters
     */
    startDraw(parameters) {
        this.draw(parameters);
    }
}


/***/ }),

/***/ "./src/js/game/game_system_manager.js":
/*!********************************************!*\
  !*** ./src/js/game/game_system_manager.js ***!
  \********************************************/
/*! exports provided: GameSystemManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameSystemManager", function() { return GameSystemManager; });
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _systems_belt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./systems/belt */ "./src/js/game/systems/belt.js");
/* harmony import */ var _systems_item_ejector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./systems/item_ejector */ "./src/js/game/systems/item_ejector.js");
/* harmony import */ var _systems_map_resources__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./systems/map_resources */ "./src/js/game/systems/map_resources.js");
/* harmony import */ var _systems_miner__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./systems/miner */ "./src/js/game/systems/miner.js");
/* harmony import */ var _systems_item_processor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./systems/item_processor */ "./src/js/game/systems/item_processor.js");
/* harmony import */ var _systems_underground_belt__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./systems/underground_belt */ "./src/js/game/systems/underground_belt.js");
/* harmony import */ var _systems_hub__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./systems/hub */ "./src/js/game/systems/hub.js");
/* harmony import */ var _systems_static_map_entity__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./systems/static_map_entity */ "./src/js/game/systems/static_map_entity.js");
/* harmony import */ var _systems_item_acceptor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./systems/item_acceptor */ "./src/js/game/systems/item_acceptor.js");
/* harmony import */ var _systems_storage__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./systems/storage */ "./src/js/game/systems/storage.js");














const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_0__["createLogger"])("game_system_manager");

class GameSystemManager {
    /**
     *
     * @param {GameRoot} root
     */
    constructor(root) {
        this.root = root;

        this.systems = {

        };
        this.systemUpdateOrder = [];

        this.internalInitSystems();
    }

    /**
     * Initializes all systems
     */
    internalInitSystems() {
        const add = (id, systemClass) => {
            this.systems[id] = new systemClass(this.root);
            this.systemUpdateOrder.push(id);
        };

        // Order is important!

        add("belt", _systems_belt__WEBPACK_IMPORTED_MODULE_1__["BeltSystem"]);

        add("undergroundBelt", _systems_underground_belt__WEBPACK_IMPORTED_MODULE_6__["UndergroundBeltSystem"]);

        add("miner", _systems_miner__WEBPACK_IMPORTED_MODULE_4__["MinerSystem"]);

        add("storage", _systems_storage__WEBPACK_IMPORTED_MODULE_10__["StorageSystem"]);

        add("itemProcessor", _systems_item_processor__WEBPACK_IMPORTED_MODULE_5__["ItemProcessorSystem"]);

        add("itemEjector", _systems_item_ejector__WEBPACK_IMPORTED_MODULE_2__["ItemEjectorSystem"]);

        add("mapResources", _systems_map_resources__WEBPACK_IMPORTED_MODULE_3__["MapResourcesSystem"]);

        add("hub", _systems_hub__WEBPACK_IMPORTED_MODULE_7__["HubSystem"]);

        add("staticMapEntities", _systems_static_map_entity__WEBPACK_IMPORTED_MODULE_8__["StaticMapEntitySystem"]);

        add("itemAcceptor", _systems_item_acceptor__WEBPACK_IMPORTED_MODULE_9__["ItemAcceptorSystem"]);

        logger.log("📦 There are", this.systemUpdateOrder.length, "game systems");
    }

    /**
     * Updates all systems
     */
    update() {
        for (let i = 0; i < this.systemUpdateOrder.length; ++i) {
            const system = this.systems[this.systemUpdateOrder[i]];
            system.update();
        }
    }

    refreshCaches() {
        for (let i = 0; i < this.systemUpdateOrder.length; ++i) {
            const system = this.systems[this.systemUpdateOrder[i]];
            system.refreshCaches();
        }
    }
}


/***/ }),

/***/ "./src/js/game/game_system_with_filter.js":
/*!************************************************!*\
  !*** ./src/js/game/game_system_with_filter.js ***!
  \************************************************/
/*! exports provided: GameSystemWithFilter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameSystemWithFilter", function() { return GameSystemWithFilter; });
/* harmony import */ var _game_system__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game_system */ "./src/js/game/game_system.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");








class GameSystemWithFilter extends _game_system__WEBPACK_IMPORTED_MODULE_0__["GameSystem"] {
    /**
     * Constructs a new game system with the given component filter. It will process
     * all entities which have *all* of the passed components
     * @param {GameRoot} root
     * @param {Array<typeof Component>} requiredComponents
     */
    constructor(root, requiredComponents) {
        super(root);
        this.requiredComponents = requiredComponents;
        this.requiredComponentIds = requiredComponents.map(component => component.getId());

        /**
         * All entities which match the current components
         * @type {Array<Entity>}
         */
        this.allEntities = [];

        this.root.signals.entityAdded.add(this.internalPushEntityIfMatching, this);
        this.root.signals.entityGotNewComponent.add(this.internalReconsiderEntityToAdd, this);
        this.root.signals.entityComponentRemoved.add(this.internalCheckEntityAfterComponentRemoval, this);
        this.root.signals.entityQueuedForDestroy.add(this.internalPopEntityIfMatching, this);

        this.root.signals.postLoadHook.add(this.internalPostLoadHook, this);
        this.root.signals.bulkOperationFinished.add(this.refreshCaches, this);
    }

    /**
     * Calls a function for each matching entity on the screen, useful for drawing them
     * @param {DrawParameters} parameters
     * @param {function} callback
     */
    forEachMatchingEntityOnScreen(parameters, callback) {
        const cullRange = parameters.visibleRect.toTileCullRectangle();
        if (this.allEntities.length < 100) {
            // So, its much quicker to simply perform per-entity checking

            for (let i = 0; i < this.allEntities.length; ++i) {
                const entity = this.allEntities[i];
                if (cullRange.containsRect(entity.components.StaticMapEntity.getTileSpaceBounds())) {
                    callback(parameters, entity);
                }
            }
            return;
        }

        const top = cullRange.top();
        const right = cullRange.right();
        const bottom = cullRange.bottom();
        const left = cullRange.left();

        const border = 1;
        const minY = top - border;
        const maxY = bottom + border;
        const minX = left - border;
        const maxX = right + border - 1;

        const map = this.root.map;

        let seenUids = new Set();

        const chunkStartX = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_4__["Math_floor"])(minX / _core_config__WEBPACK_IMPORTED_MODULE_3__["globalConfig"].mapChunkSize);
        const chunkStartY = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_4__["Math_floor"])(minY / _core_config__WEBPACK_IMPORTED_MODULE_3__["globalConfig"].mapChunkSize);

        const chunkEndX = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_4__["Math_ceil"])(maxX / _core_config__WEBPACK_IMPORTED_MODULE_3__["globalConfig"].mapChunkSize);
        const chunkEndY = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_4__["Math_ceil"])(maxY / _core_config__WEBPACK_IMPORTED_MODULE_3__["globalConfig"].mapChunkSize);

        const requiredComponents = this.requiredComponentIds;

        // Render y from top down for proper blending
        for (let chunkX = chunkStartX; chunkX <= chunkEndX; ++chunkX) {
            for (let chunkY = chunkStartY; chunkY <= chunkEndY; ++chunkY) {
                const chunk = map.getChunk(chunkX, chunkY, false);
                if (!chunk) {
                    continue;
                }

                // BIG TODO: CULLING ON AN ENTITY BASIS

                const entities = chunk.containedEntities;
                entityLoop: for (let i = 0; i < entities.length; ++i) {
                    const entity = entities[i];

                    // Avoid drawing twice
                    if (seenUids.has(entity.uid)) {
                        continue;
                    }
                    seenUids.add(entity.uid);

                    for (let i = 0; i < requiredComponents.length; ++i) {
                        if (!entity.components[requiredComponents[i]]) {
                            continue entityLoop;
                        }
                    }
                    callback(parameters, entity);
                }
            }
        }
    }

    /**
     * @param {Entity} entity
     */
    internalPushEntityIfMatching(entity) {
        for (let i = 0; i < this.requiredComponentIds.length; ++i) {
            if (!entity.components[this.requiredComponentIds[i]]) {
                return;
            }
        }

        window.assert(this.allEntities.indexOf(entity) < 0, "entity already in list: " + entity);
        this.internalRegisterEntity(entity);
    }

    /**
     *
     * @param {Entity} entity
     */
    internalCheckEntityAfterComponentRemoval(entity) {
        if (this.allEntities.indexOf(entity) < 0) {
            // Entity wasn't interesting anyways
            return;
        }

        for (let i = 0; i < this.requiredComponentIds.length; ++i) {
            if (!entity.components[this.requiredComponentIds[i]]) {
                // Entity is not interesting anymore
                Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["arrayDeleteValue"])(this.allEntities, entity);
            }
        }
    }

    /**
     *
     * @param {Entity} entity
     */
    internalReconsiderEntityToAdd(entity) {
        for (let i = 0; i < this.requiredComponentIds.length; ++i) {
            if (!entity.components[this.requiredComponentIds[i]]) {
                return;
            }
        }
        if (this.allEntities.indexOf(entity) >= 0) {
            return;
        }
        this.internalRegisterEntity(entity);
    }

    refreshCaches() {
        this.allEntities.sort((a, b) => a.uid - b.uid);

        // Remove all entities which are queued for destroy
        for (let i = 0; i < this.allEntities.length; ++i) {
            const entity = this.allEntities[i];
            if (entity.queuedForDestroy || entity.destroyed) {
                this.allEntities.splice(i, 1);
            }
        }
    }

    /**
     * Recomputes all target entities after the game has loaded
     */
    internalPostLoadHook() {
        this.refreshCaches();
    }

    /**
     *
     * @param {Entity} entity
     */
    internalRegisterEntity(entity) {
        this.allEntities.push(entity);

        if (this.root.gameInitialized && !this.root.bulkOperationRunning) {
            // Sort entities by uid so behaviour is predictable
            this.allEntities.sort((a, b) => a.uid - b.uid);
        }
    }

    /**
     *
     * @param {Entity} entity
     */
    internalPopEntityIfMatching(entity) {
        if (this.root.bulkOperationRunning) {
            // We do this in refreshCaches afterwards
            return;
        }
        const index = this.allEntities.indexOf(entity);
        if (index >= 0) {
            Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["arrayDelete"])(this.allEntities, index);
        }
    }
}


/***/ }),

/***/ "./src/js/game/hub_goals.js":
/*!**********************************!*\
  !*** ./src/js/game/hub_goals.js ***!
  \**********************************/
/*! exports provided: HubGoals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HubGoals", function() { return HubGoals; });
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_query_parameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/query_parameters */ "./src/js/core/query_parameters.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../savegame/serialization */ "./src/js/savegame/serialization.js");
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./colors */ "./src/js/game/colors.js");
/* harmony import */ var _components_item_processor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/item_processor */ "./src/js/game/components/item_processor.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./root */ "./src/js/game/root.js");
/* harmony import */ var _shape_definition__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./shape_definition */ "./src/js/game/shape_definition.js");
/* harmony import */ var _tutorial_goals__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tutorial_goals */ "./src/js/game/tutorial_goals.js");
/* harmony import */ var _upgrades__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./upgrades */ "./src/js/game/upgrades.js");












class HubGoals extends _savegame_serialization__WEBPACK_IMPORTED_MODULE_4__["BasicSerializableObject"] {
    static getId() {
        return "HubGoals";
    }

    static getSchema() {
        return {
            level: _savegame_serialization__WEBPACK_IMPORTED_MODULE_4__["types"].uint,
            storedShapes: _savegame_serialization__WEBPACK_IMPORTED_MODULE_4__["types"].keyValueMap(_savegame_serialization__WEBPACK_IMPORTED_MODULE_4__["types"].uint),
            upgradeLevels: _savegame_serialization__WEBPACK_IMPORTED_MODULE_4__["types"].keyValueMap(_savegame_serialization__WEBPACK_IMPORTED_MODULE_4__["types"].uint),

            currentGoal: _savegame_serialization__WEBPACK_IMPORTED_MODULE_4__["types"].structured({
                definition: _savegame_serialization__WEBPACK_IMPORTED_MODULE_4__["types"].knownType(_shape_definition__WEBPACK_IMPORTED_MODULE_8__["ShapeDefinition"]),
                required: _savegame_serialization__WEBPACK_IMPORTED_MODULE_4__["types"].uint,
                reward: _savegame_serialization__WEBPACK_IMPORTED_MODULE_4__["types"].nullable(_savegame_serialization__WEBPACK_IMPORTED_MODULE_4__["types"].enum(_tutorial_goals__WEBPACK_IMPORTED_MODULE_9__["enumHubGoalRewards"])),
            }),
        };
    }

    deserialize(data) {
        const errorCode = super.deserialize(data);
        if (errorCode) {
            return errorCode;
        }

        // Compute gained rewards
        for (let i = 0; i < this.level - 1; ++i) {
            if (i < _tutorial_goals__WEBPACK_IMPORTED_MODULE_9__["tutorialGoals"].length) {
                const reward = _tutorial_goals__WEBPACK_IMPORTED_MODULE_9__["tutorialGoals"][i].reward;
                this.gainedRewards[reward] = (this.gainedRewards[reward] || 0) + 1;
            }
        }

        // Compute upgrade improvements
        for (const upgradeId in _upgrades__WEBPACK_IMPORTED_MODULE_10__["UPGRADES"]) {
            const upgradeHandle = _upgrades__WEBPACK_IMPORTED_MODULE_10__["UPGRADES"][upgradeId];
            const level = this.upgradeLevels[upgradeId] || 0;
            let totalImprovement = upgradeHandle.baseValue || 1;
            for (let i = 0; i < level; ++i) {
                totalImprovement += upgradeHandle.tiers[i].improvement;
            }
            this.upgradeImprovements[upgradeId] = totalImprovement;
        }
    }

    /**
     * @param {GameRoot} root
     */
    constructor(root) {
        super();

        this.root = root;

        this.level = 1;

        /**
         * Which story rewards we already gained
         * @type {Object.<string, number>}
         */
        this.gainedRewards = {};

        /**
         * Mapping from shape hash -> amount
         * @type {Object<string, number>}
         */
        this.storedShapes = {};

        /**
         * Stores the levels for all upgrades
         * @type {Object<string, number>}
         */
        this.upgradeLevels = {};

        /**
         * Stores the improvements for all upgrades
         * @type {Object<string, number>}
         */
        this.upgradeImprovements = {};
        for (const key in _upgrades__WEBPACK_IMPORTED_MODULE_10__["UPGRADES"]) {
            this.upgradeImprovements[key] = _upgrades__WEBPACK_IMPORTED_MODULE_10__["UPGRADES"][key].baseValue || 1;
        }

        this.createNextGoal();

        // Allow quickly switching goals in dev mode with key "C"
        if (true) {
            this.root.gameState.inputReciever.keydown.add(key => {
                if (key.keyCode === 66) {
                    // Key: b
                    this.onGoalCompleted();
                }
            });
        }
    }

    /**
     * Returns how much of the current shape is stored
     * @param {ShapeDefinition} definition
     * @returns {number}
     */
    getShapesStored(definition) {
        return this.storedShapes[definition.getHash()] || 0;
    }

    /**
     * @param {string} key
     * @param {number} amount
     */
    takeShapeByKey(key, amount) {
        window.assert(this.getShapesStoredByKey(key) >= amount, "Can not afford: " + key + " x " + amount);
        window.assert(amount >= 0, "Amount < 0 for " + key);
        window.assert(Number.isInteger(amount), "Invalid amount: " + amount);
        this.storedShapes[key] = (this.storedShapes[key] || 0) - amount;
        return;
    }

    /**
     * Returns how much of the current shape is stored
     * @param {string} key
     * @returns {number}
     */
    getShapesStoredByKey(key) {
        return this.storedShapes[key] || 0;
    }

    /**
     * Returns how much of the current goal was already delivered
     */
    getCurrentGoalDelivered() {
        return this.getShapesStored(this.currentGoal.definition);
    }

    /**
     * Returns the current level of a given upgrade
     * @param {string} upgradeId
     */
    getUpgradeLevel(upgradeId) {
        return this.upgradeLevels[upgradeId] || 0;
    }

    /**
     * Returns whether the given reward is already unlocked
     * @param {enumHubGoalRewards} reward
     */
    isRewardUnlocked(reward) {
        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].debug.allBuildingsUnlocked) {
            return true;
        }
        return !!this.gainedRewards[reward];
    }

    /**
     * Handles the given definition, by either accounting it towards the
     * goal or otherwise granting some points
     * @param {ShapeDefinition} definition
     */
    handleDefinitionDelivered(definition) {
        const hash = definition.getHash();
        this.storedShapes[hash] = (this.storedShapes[hash] || 0) + 1;

        this.root.signals.shapeDelivered.dispatch(definition);

        // Check if we have enough for the next level
        const targetHash = this.currentGoal.definition.getHash();
        if (
            this.storedShapes[targetHash] >= this.currentGoal.required ||
            ( true && _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].debug.rewardsInstant)
        ) {
            this.onGoalCompleted();
        }
    }

    /**
     * Creates the next goal
     */
    createNextGoal() {
        const storyIndex = this.level - 1;
        if (storyIndex < _tutorial_goals__WEBPACK_IMPORTED_MODULE_9__["tutorialGoals"].length) {
            const { shape, required, reward } = _tutorial_goals__WEBPACK_IMPORTED_MODULE_9__["tutorialGoals"][storyIndex];
            this.currentGoal = {
                /** @type {ShapeDefinition} */
                definition: this.root.shapeDefinitionMgr.getShapeFromShortKey(shape),
                required,
                reward,
            };
            return;
        }

        this.currentGoal = {
            /** @type {ShapeDefinition} */
            definition: this.createRandomShape(),
            required: 1000 + Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["findNiceIntegerValue"])(this.level * 47.5),
            reward: _tutorial_goals__WEBPACK_IMPORTED_MODULE_9__["enumHubGoalRewards"].no_reward_freeplay,
        };
    }

    /**
     * Called when the level was completed
     */
    onGoalCompleted() {
        const reward = this.currentGoal.reward;
        this.gainedRewards[reward] = (this.gainedRewards[reward] || 0) + 1;

        this.root.app.gameAnalytics.handleLevelCompleted(this.level);
        ++this.level;
        this.createNextGoal();

        this.root.signals.storyGoalCompleted.dispatch(this.level - 1, reward);
    }

    /**
     * Returns whether we are playing in free-play
     */
    isFreePlay() {
        return this.level >= _tutorial_goals__WEBPACK_IMPORTED_MODULE_9__["tutorialGoals"].length;
    }

    /**
     * Returns whether a given upgrade can be unlocked
     * @param {string} upgradeId
     */
    canUnlockUpgrade(upgradeId) {
        const handle = _upgrades__WEBPACK_IMPORTED_MODULE_10__["UPGRADES"][upgradeId];
        const currentLevel = this.getUpgradeLevel(upgradeId);

        if (currentLevel >= handle.tiers.length) {
            // Max level
            return false;
        }

        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].debug.upgradesNoCost) {
            return true;
        }

        const tierData = handle.tiers[currentLevel];

        for (let i = 0; i < tierData.required.length; ++i) {
            const requirement = tierData.required[i];
            if ((this.storedShapes[requirement.shape] || 0) < requirement.amount) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns the number of available upgrades
     * @returns {number}
     */
    getAvailableUpgradeCount() {
        let count = 0;
        for (const upgradeId in _upgrades__WEBPACK_IMPORTED_MODULE_10__["UPGRADES"]) {
            if (this.canUnlockUpgrade(upgradeId)) {
                ++count;
            }
        }
        return count;
    }

    /**
     * Tries to unlock the given upgrade
     * @param {string} upgradeId
     * @returns {boolean}
     */
    tryUnlockUgprade(upgradeId) {
        if (!this.canUnlockUpgrade(upgradeId)) {
            return false;
        }

        const handle = _upgrades__WEBPACK_IMPORTED_MODULE_10__["UPGRADES"][upgradeId];
        const currentLevel = this.getUpgradeLevel(upgradeId);

        const tierData = handle.tiers[currentLevel];
        if (!tierData) {
            return false;
        }

        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].debug.upgradesNoCost) {
            // Dont take resources
        } else {
            for (let i = 0; i < tierData.required.length; ++i) {
                const requirement = tierData.required[i];

                // Notice: Don't have to check for hash here
                this.storedShapes[requirement.shape] -= requirement.amount;
            }
        }

        this.upgradeLevels[upgradeId] = (this.upgradeLevels[upgradeId] || 0) + 1;
        this.upgradeImprovements[upgradeId] += tierData.improvement;

        this.root.signals.upgradePurchased.dispatch(upgradeId);

        this.root.app.gameAnalytics.handleUpgradeUnlocked(upgradeId, currentLevel);

        return true;
    }

    /**
     * @returns {ShapeDefinition}
     */
    createRandomShape() {
        const layerCount = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["clamp"])(this.level / 50, 2, 4);
        /** @type {Array<import("./shape_definition").ShapeLayer>} */
        let layers = [];

        // @ts-ignore
        const randomColor = () => Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["randomChoice"])(Object.values(_colors__WEBPACK_IMPORTED_MODULE_5__["enumColors"]));
        // @ts-ignore
        const randomShape = () => Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["randomChoice"])(Object.values(_shape_definition__WEBPACK_IMPORTED_MODULE_8__["enumSubShape"]));

        let anyIsMissingTwo = false;

        for (let i = 0; i < layerCount; ++i) {
            /** @type {import("./shape_definition").ShapeLayer} */
            const layer = [null, null, null, null];

            for (let quad = 0; quad < 4; ++quad) {
                layer[quad] = {
                    subShape: randomShape(),
                    color: randomColor(),
                };
            }

            // Sometimes shapes are missing
            if (Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_random"])() > 0.85) {
                layer[Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["randomInt"])(0, 3)] = null;
            }

            // Sometimes they actually are missing *two* ones!
            // Make sure at max only one layer is missing it though, otherwise we could
            // create an uncreateable shape
            if (Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_random"])() > 0.95 && !anyIsMissingTwo) {
                layer[Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["randomInt"])(0, 3)] = null;
                anyIsMissingTwo = true;
            }

            layers.push(layer);
        }

        const definition = new _shape_definition__WEBPACK_IMPORTED_MODULE_8__["ShapeDefinition"]({ layers });
        return this.root.shapeDefinitionMgr.registerOrReturnHandle(definition);
    }

    ////////////// HELPERS

    /**
     * Belt speed
     * @returns {number} items / sec
     */
    getBeltBaseSpeed() {
        return _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].beltSpeedItemsPerSecond * this.upgradeImprovements.belt;
    }

    /**
     * Underground belt speed
     * @returns {number} items / sec
     */
    getUndergroundBeltBaseSpeed() {
        return _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].beltSpeedItemsPerSecond * this.upgradeImprovements.belt;
    }

    /**
     * Miner speed
     * @returns {number} items / sec
     */
    getMinerBaseSpeed() {
        return _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].minerSpeedItemsPerSecond * this.upgradeImprovements.miner;
    }

    /**
     * Processor speed
     * @param {enumItemProcessorTypes} processorType
     * @returns {number} items / sec
     */
    getProcessorBaseSpeed(processorType) {
        switch (processorType) {
            case _components_item_processor__WEBPACK_IMPORTED_MODULE_6__["enumItemProcessorTypes"].trash:
            case _components_item_processor__WEBPACK_IMPORTED_MODULE_6__["enumItemProcessorTypes"].hub:
                return 1e30;
            case _components_item_processor__WEBPACK_IMPORTED_MODULE_6__["enumItemProcessorTypes"].splitter:
                return _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].beltSpeedItemsPerSecond * this.upgradeImprovements.belt * 2;

            case _components_item_processor__WEBPACK_IMPORTED_MODULE_6__["enumItemProcessorTypes"].mixer:
            case _components_item_processor__WEBPACK_IMPORTED_MODULE_6__["enumItemProcessorTypes"].painter:
            case _components_item_processor__WEBPACK_IMPORTED_MODULE_6__["enumItemProcessorTypes"].painterDouble:
            case _components_item_processor__WEBPACK_IMPORTED_MODULE_6__["enumItemProcessorTypes"].painterQuad: {
                window.assert(
                    _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].buildingSpeeds[processorType],
                    "Processor type has no speed set in globalConfig.buildingSpeeds: " + processorType
                );
                return (
                    _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].beltSpeedItemsPerSecond *
                    this.upgradeImprovements.painting *
                    _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].buildingSpeeds[processorType]
                );
            }

            case _components_item_processor__WEBPACK_IMPORTED_MODULE_6__["enumItemProcessorTypes"].cutter:
            case _components_item_processor__WEBPACK_IMPORTED_MODULE_6__["enumItemProcessorTypes"].cutterQuad:
            case _components_item_processor__WEBPACK_IMPORTED_MODULE_6__["enumItemProcessorTypes"].rotater:
            case _components_item_processor__WEBPACK_IMPORTED_MODULE_6__["enumItemProcessorTypes"].rotaterCCW:
            case _components_item_processor__WEBPACK_IMPORTED_MODULE_6__["enumItemProcessorTypes"].sorter:
            case _components_item_processor__WEBPACK_IMPORTED_MODULE_6__["enumItemProcessorTypes"].stacker: {
                window.assert(
                    _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].buildingSpeeds[processorType],
                    "Processor type has no speed set in globalConfig.buildingSpeeds: " + processorType
                );
                return (
                    _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].beltSpeedItemsPerSecond *
                    this.upgradeImprovements.processors *
                    _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].buildingSpeeds[processorType]
                );
            }
            default:
                window.assert(false, "invalid processor type: " + processorType);
        }

        return 1 / _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].beltSpeedItemsPerSecond;
    }
}


/***/ }),

/***/ "./src/js/game/hud/base_hud_part.js":
/*!******************************************!*\
  !*** ./src/js/game/hud/base_hud_part.js ***!
  \******************************************/
/*! exports provided: BaseHUDPart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseHUDPart", function() { return BaseHUDPart; });
/* harmony import */ var _core_click_detector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/click_detector */ "./src/js/core/click_detector.js");
/* harmony import */ var _key_action_mapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../key_action_mapper */ "./src/js/game/key_action_mapper.js");





class BaseHUDPart {
    /**
     * @param {GameRoot} root
     */
    constructor(root) {
        this.root = root;

        /** @type {Array<ClickDetector>} */
        this.clickDetectors = [];
    }

    /**
     * Should create all require elements
     * @param {HTMLElement} parent
     */
    createElements(parent) {}

    /**
     * Should initialize the element, called *after* the elements have been created
     */
    initialize() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }

    /**
     * Should update any required logic
     */
    update() {}

    /**
     * Should draw the hud
     * @param {DrawParameters} parameters
     */
    draw(parameters) {}

    /**
     * Should draw any overlays (screen space)
     * @param {DrawParameters} parameters
     */
    drawOverlays(parameters) {}

    /**
     * Should return true if the widget has a modal dialog opened and thus
     * the game does not need to update / redraw
     * @returns {boolean}
     */
    shouldPauseRendering() {
        return false;
    }

    /**
     * Should return false if the game should be paused
     * @returns {boolean}
     */
    shouldPauseGame() {
        return false;
    }

    /**
     * Should return true if this overlay is open and currently blocking any user interaction
     */
    isBlockingOverlay() {
        return false;
    }

    /**
     * Cleans up the hud element, if overridden make sure to call super.cleanup
     */
    cleanup() {
        this.cleanupClickDetectors();
    }

    /**
     * Cleans up all click detectors
     */
    cleanupClickDetectors() {
        if (this.clickDetectors) {
            for (let i = 0; i < this.clickDetectors.length; ++i) {
                this.clickDetectors[i].cleanup();
            }
            this.clickDetectors = [];
        }
    }

    /**
     * Should close the element, in case its supported
     */
    close() {}

    // Helpers

    /**
     * Helper method to construct a new click detector
     * @param {Element} element The element to listen on
     * @param {function} handler The handler to call on this object
     * @param {import("../../core/click_detector").ClickDetectorConstructorArgs=} args Click detector arguments
     *
     */
    trackClicks(element, handler, args = {}) {
        const detector = new _core_click_detector__WEBPACK_IMPORTED_MODULE_0__["ClickDetector"](element, args);
        detector.click.add(handler, this);
        this.registerClickDetector(detector);
    }

    /**
     * Registers a new click detector
     * @param {ClickDetector} detector
     */
    registerClickDetector(detector) {
        this.clickDetectors.push(detector);
        if (true) {
            // @ts-ignore
            detector._src = "hud-" + this.constructor.name;
        }
    }

    /**
     * Closes this element when its background is clicked
     * @param {HTMLElement} element
     * @param {function} closeMethod
     */
    closeOnBackgroundClick(element, closeMethod = null) {
        const bgClickDetector = new _core_click_detector__WEBPACK_IMPORTED_MODULE_0__["ClickDetector"](element, {
            preventDefault: true,
            targetOnly: true,
            applyCssClass: null,
            consumeEvents: true,
            clickSound: null,
        });

        // If the state defines a close method, use that as fallback
        // @ts-ignore
        bgClickDetector.touchend.add(closeMethod || this.close, this);
        this.registerClickDetector(bgClickDetector);
    }

    /**
     * Forwards the game speed keybindings so you can toggle pause / Fastforward
     * in the building tooltip and such
     * @param {KeyActionMapper} sourceMapper
     */
    forwardGameSpeedKeybindings(sourceMapper) {
        sourceMapper.forward(this.root.keyMapper, ["gamespeed_pause", "gamespeed_fastforward"]);
    }

    /**
     * Forwards the map movement keybindings so you can move the map with the
     * arrow keys
     * @param {KeyActionMapper} sourceMapper
     */
    forwardMapMovementKeybindings(sourceMapper) {
        sourceMapper.forward(this.root.keyMapper, [
            "mapMoveUp",
            "mapMoveRight",
            "mapMoveDown",
            "mapMoveLeft",
        ]);
    }
}


/***/ }),

/***/ "./src/js/game/hud/dynamic_dom_attach.js":
/*!***********************************************!*\
  !*** ./src/js/game/hud/dynamic_dom_attach.js ***!
  \***********************************************/
/*! exports provided: DynamicDomAttach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicDomAttach", function() { return DynamicDomAttach; });
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../root */ "./src/js/game/root.js");


// Automatically attaches and detaches elements from the dom
// Also supports detaching elements after a given time, useful if there is a
// hide animation like for the tooltips

// Also attaches a class name if desired

class DynamicDomAttach {
    constructor(root, element, { timeToKeepSeconds = 0, attachClass = null } = {}) {
        /** @type {GameRoot} */
        this.root = root;

        /** @type {HTMLElement} */
        this.element = element;
        this.parent = this.element.parentElement;

        this.attachClass = attachClass;

        this.timeToKeepSeconds = timeToKeepSeconds;
        this.lastVisibleTime = 0;

        // We start attached, so detach the node first
        this.attached = true;
        this.internalDetach();

        this.internalIsClassAttached = false;
        this.classAttachTimeout = null;
    }

    internalAttach() {
        if (!this.attached) {
            this.parent.appendChild(this.element);
            window.assert(this.element.parentElement === this.parent, "Invalid parent #1");
            this.attached = true;
        }
    }

    internalDetach() {
        if (this.attached) {
            window.assert(this.element.parentElement === this.parent, "Invalid parent #2");
            this.element.parentElement.removeChild(this.element);
            this.attached = false;
        }
    }

    isAttached() {
        return this.attached;
    }

    update(isVisible) {
        if (isVisible) {
            this.lastVisibleTime = this.root ? this.root.time.realtimeNow() : 0;
            this.internalAttach();
        } else {
            if (!this.root || this.root.time.realtimeNow() - this.lastVisibleTime >= this.timeToKeepSeconds) {
                this.internalDetach();
            }
        }

        if (this.attachClass && isVisible !== this.internalIsClassAttached) {
            // State changed
            this.internalIsClassAttached = isVisible;

            if (this.classAttachTimeout) {
                clearTimeout(this.classAttachTimeout);
                this.classAttachTimeout = null;
            }

            if (isVisible) {
                this.classAttachTimeout = setTimeout(() => {
                    this.element.classList.add(this.attachClass);
                }, 15);
            } else {
                this.element.classList.remove(this.attachClass);
            }
        }
    }
}


/***/ }),

/***/ "./src/js/game/hud/hud.js":
/*!********************************!*\
  !*** ./src/js/game/hud/hud.js ***!
  \********************************/
/*! exports provided: GameHUD */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameHUD", function() { return GameHUD; });
/* harmony import */ var _core_signal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/signal */ "./src/js/core/signal.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _parts_processing_overlay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parts/processing_overlay */ "./src/js/game/hud/parts/processing_overlay.js");
/* harmony import */ var _parts_buildings_toolbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parts/buildings_toolbar */ "./src/js/game/hud/parts/buildings_toolbar.js");
/* harmony import */ var _parts_building_placer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parts/building_placer */ "./src/js/game/hud/parts/building_placer.js");
/* harmony import */ var _parts_blueprint_placer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parts/blueprint_placer */ "./src/js/game/hud/parts/blueprint_placer.js");
/* harmony import */ var _parts_keybinding_overlay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parts/keybinding_overlay */ "./src/js/game/hud/parts/keybinding_overlay.js");
/* harmony import */ var _parts_unlock_notification__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./parts/unlock_notification */ "./src/js/game/hud/parts/unlock_notification.js");
/* harmony import */ var _parts_game_menu__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parts/game_menu */ "./src/js/game/hud/parts/game_menu.js");
/* harmony import */ var _parts_shop__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./parts/shop */ "./src/js/game/hud/parts/shop.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _parts_mass_selector__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./parts/mass_selector */ "./src/js/game/hud/parts/mass_selector.js");
/* harmony import */ var _parts_vignette_overlay__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./parts/vignette_overlay */ "./src/js/game/hud/parts/vignette_overlay.js");
/* harmony import */ var _parts_statistics__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./parts/statistics */ "./src/js/game/hud/parts/statistics.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _parts_pinned_shapes__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./parts/pinned_shapes */ "./src/js/game/hud/parts/pinned_shapes.js");
/* harmony import */ var _shape_definition__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../shape_definition */ "./src/js/game/shape_definition.js");
/* harmony import */ var _parts_notifications__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./parts/notifications */ "./src/js/game/hud/parts/notifications.js");
/* harmony import */ var _parts_settings_menu__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./parts/settings_menu */ "./src/js/game/hud/parts/settings_menu.js");
/* harmony import */ var _parts_debug_info__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./parts/debug_info */ "./src/js/game/hud/parts/debug_info.js");
/* harmony import */ var _parts_entity_debugger__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./parts/entity_debugger */ "./src/js/game/hud/parts/entity_debugger.js");
/* harmony import */ var _key_action_mapper__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../key_action_mapper */ "./src/js/game/key_action_mapper.js");
/* harmony import */ var _parts_watermark__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./parts/watermark */ "./src/js/game/hud/parts/watermark.js");
/* harmony import */ var _parts_modal_dialogs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./parts/modal_dialogs */ "./src/js/game/hud/parts/modal_dialogs.js");
/* harmony import */ var _parts_tutorial_hints__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./parts/tutorial_hints */ "./src/js/game/hud/parts/tutorial_hints.js");
/* harmony import */ var _parts_waypoints__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./parts/waypoints */ "./src/js/game/hud/parts/waypoints.js");
/* harmony import */ var _trailer_maker__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./trailer_maker */ "./src/js/game/hud/trailer_maker.js");





























/* dev:start */

/* dev:end */

class GameHUD {
    /**
     * @param {GameRoot} root
     */
    constructor(root) {
        this.root = root;
    }

    /**
     * Initializes the hud parts
     */
    initialize() {
        this.parts = {
            processingOverlay: new _parts_processing_overlay__WEBPACK_IMPORTED_MODULE_2__["HUDProcessingOverlay"](this.root),
            buildingsToolbar: new _parts_buildings_toolbar__WEBPACK_IMPORTED_MODULE_3__["HUDBuildingsToolbar"](this.root),
            blueprintPlacer: new _parts_blueprint_placer__WEBPACK_IMPORTED_MODULE_5__["HUDBlueprintPlacer"](this.root),
            buildingPlacer: new _parts_building_placer__WEBPACK_IMPORTED_MODULE_4__["HUDBuildingPlacer"](this.root),
            unlockNotification: new _parts_unlock_notification__WEBPACK_IMPORTED_MODULE_7__["HUDUnlockNotification"](this.root),
            gameMenu: new _parts_game_menu__WEBPACK_IMPORTED_MODULE_8__["HUDGameMenu"](this.root),
            massSelector: new _parts_mass_selector__WEBPACK_IMPORTED_MODULE_11__["HUDMassSelector"](this.root),
            shop: new _parts_shop__WEBPACK_IMPORTED_MODULE_9__["HUDShop"](this.root),
            statistics: new _parts_statistics__WEBPACK_IMPORTED_MODULE_13__["HUDStatistics"](this.root),
            waypoints: new _parts_waypoints__WEBPACK_IMPORTED_MODULE_25__["HUDWaypoints"](this.root),
            vignetteOverlay: new _parts_vignette_overlay__WEBPACK_IMPORTED_MODULE_12__["HUDVignetteOverlay"](this.root),

            // Must always exist
            pinnedShapes: new _parts_pinned_shapes__WEBPACK_IMPORTED_MODULE_15__["HUDPinnedShapes"](this.root),
            notifications: new _parts_notifications__WEBPACK_IMPORTED_MODULE_17__["HUDNotifications"](this.root),
            settingsMenu: new _parts_settings_menu__WEBPACK_IMPORTED_MODULE_18__["HUDSettingsMenu"](this.root),
            // betaOverlay: new HUDBetaOverlay(this.root),
            debugInfo: new _parts_debug_info__WEBPACK_IMPORTED_MODULE_19__["HUDDebugInfo"](this.root),
            dialogs: new _parts_modal_dialogs__WEBPACK_IMPORTED_MODULE_23__["HUDModalDialogs"](this.root),
        };

        this.signals = {
            selectedPlacementBuildingChanged: /** @type {TypedSignal<[MetaBuilding|null]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()),
            shapePinRequested: /** @type {TypedSignal<[ShapeDefinition, number]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()),
            notification: /** @type {TypedSignal<[string, enumNotificationType]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()),
            buildingsSelectedForCopy: /** @type {TypedSignal<[Array<number>]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()),
        };

        if (!_core_config__WEBPACK_IMPORTED_MODULE_10__["IS_MOBILE"]) {
            this.parts.keybindingOverlay = new _parts_keybinding_overlay__WEBPACK_IMPORTED_MODULE_6__["HUDKeybindingOverlay"](this.root);
        }

        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_10__["globalConfig"].debug.enableEntityInspector) {
            this.parts.entityDebugger = new _parts_entity_debugger__WEBPACK_IMPORTED_MODULE_20__["HUDEntityDebugger"](this.root);
        }

        if (_core_config__WEBPACK_IMPORTED_MODULE_10__["IS_DEMO"]) {
            this.parts.watermark = new _parts_watermark__WEBPACK_IMPORTED_MODULE_22__["HUDWatermark"](this.root);
        }
        if (this.root.app.settings.getAllSettings().offerHints) {
            this.parts.tutorialHints = new _parts_tutorial_hints__WEBPACK_IMPORTED_MODULE_24__["HUDPartTutorialHints"](this.root);
        }

        const frag = document.createDocumentFragment();
        for (const key in this.parts) {
            this.parts[key].createElements(frag);
        }

        document.body.appendChild(frag);

        for (const key in this.parts) {
            this.parts[key].initialize();
        }
        this.internalInitSignalConnections();

        this.root.keyMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_21__["KEYMAPPINGS"].ingame.toggleHud).add(this.toggleUi, this);

        /* dev:start */
        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_10__["globalConfig"].debug.renderForTrailer) {
            this.trailerMaker = new _trailer_maker__WEBPACK_IMPORTED_MODULE_26__["TrailerMaker"](this.root);
        }
        /* dev:end*/
    }

    /**
     * Attempts to close all overlays
     */
    closeAllOverlays() {
        for (const key in this.parts) {
            this.parts[key].close();
        }
    }

    /**
     * Returns true if the game logic should be paused
     */
    shouldPauseGame() {
        for (const key in this.parts) {
            if (this.parts[key].shouldPauseGame()) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns true if the rendering can be paused
     */
    shouldPauseRendering() {
        for (const key in this.parts) {
            if (this.parts[key].shouldPauseRendering()) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns true if the rendering can be paused
     */
    hasBlockingOverlayOpen() {
        if (this.root.camera.getIsMapOverlayActive()) {
            return true;
        }
        for (const key in this.parts) {
            if (this.parts[key].isBlockingOverlay()) {
                return true;
            }
        }
        return false;
    }

    /**
     * Toggles the ui
     */
    toggleUi() {
        document.body.classList.toggle("uiHidden");
    }

    /**
     * Initializes connections between parts
     */
    internalInitSignalConnections() {
        const p = this.parts;
        p.buildingsToolbar.sigBuildingSelected.add(p.buildingPlacer.startSelection, p.buildingPlacer);
    }

    /**
     * Updates all parts
     */
    update() {
        if (!this.root.gameInitialized) {
            return;
        }

        for (const key in this.parts) {
            this.parts[key].update();
        }

        /* dev:start */
        if (this.trailerMaker) {
            this.trailerMaker.update();
        }
        /* dev:end*/
    }

    /**
     * Draws all parts
     * @param {DrawParameters} parameters
     */
    draw(parameters) {
        const partsOrder = ["waypoints", "massSelector", "buildingPlacer", "blueprintPlacer"];

        for (let i = 0; i < partsOrder.length; ++i) {
            if (this.parts[partsOrder[i]]) {
                this.parts[partsOrder[i]].draw(parameters);
            }
        }
    }

    /**
     * Draws all part overlays
     * @param {DrawParameters} parameters
     */
    drawOverlays(parameters) {
        const partsOrder = ["watermark"];

        for (let i = 0; i < partsOrder.length; ++i) {
            if (this.parts[partsOrder[i]]) {
                this.parts[partsOrder[i]].drawOverlays(parameters);
            }
        }
    }

    /**
     * Cleans up everything
     */
    cleanup() {
        for (const key in this.parts) {
            this.parts[key].cleanup();
        }

        for (const key in this.signals) {
            this.signals[key].removeAll();
        }
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/blueprint.js":
/*!********************************************!*\
  !*** ./src/js/game/hud/parts/blueprint.js ***!
  \********************************************/
/*! exports provided: Blueprint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Blueprint", function() { return Blueprint; });
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _core_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/loader */ "./src/js/core/loader.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../entity */ "./src/js/game/entity.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../root */ "./src/js/game/root.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _upgrades__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../upgrades */ "./src/js/game/upgrades.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../core/config */ "./src/js/core/config.js");











const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_2__["createLogger"])("blueprint");

class Blueprint {
    /**
     * @param {Array<Entity>} entities
     */
    constructor(entities) {
        this.entities = entities;
    }

    /**
     * Creates a new blueprint from the given entity uids
     * @param {GameRoot} root
     * @param {Array<number>} uids
     */
    static fromUids(root, uids) {
        const newEntities = [];

        let averagePosition = new _core_vector__WEBPACK_IMPORTED_MODULE_3__["Vector"]();

        // First, create a copy
        for (let i = 0; i < uids.length; ++i) {
            const entity = root.entityMgr.findByUid(uids[i]);
            window.assert(entity, "Entity for blueprint not found:" + uids[i]);

            const clone = entity.duplicateWithoutContents();
            newEntities.push(clone);

            const pos = entity.components.StaticMapEntity.getTileSpaceBounds().getCenter();
            averagePosition.addInplace(pos);
        }

        averagePosition.divideScalarInplace(uids.length);
        const blueprintOrigin = averagePosition.floor();
        for (let i = 0; i < uids.length; ++i) {
            newEntities[i].components.StaticMapEntity.origin.subInplace(blueprintOrigin);
        }

        // Now, make sure the origin is 0,0
        return new Blueprint(newEntities);
    }

    /**
     * Returns the cost of this blueprint in shapes
     */
    getCost() {
        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_9__["globalConfig"].debug.blueprintsNoCost) {
            return 0;
        }
        return Object(_core_utils__WEBPACK_IMPORTED_MODULE_6__["findNiceIntegerValue"])(4 * Object(_core_builtins__WEBPACK_IMPORTED_MODULE_7__["Math_pow"])(this.entities.length, 1.1));
    }

    /**
     * Draws the blueprint at the given origin
     * @param {DrawParameters} parameters
     */
    draw(parameters, tile) {
        parameters.context.globalAlpha = 0.8;
        for (let i = 0; i < this.entities.length; ++i) {
            const entity = this.entities[i];
            const staticComp = entity.components.StaticMapEntity;
            if (!staticComp.blueprintSpriteKey) {
                logger.warn("Blueprint entity without sprite!");
                return;
            }
            const newPos = staticComp.origin.add(tile);

            const rect = staticComp.getTileSpaceBounds();
            rect.moveBy(tile.x, tile.y);

            let placeable = true;
            placementCheck: for (let x = rect.x; x < rect.right(); ++x) {
                for (let y = rect.y; y < rect.bottom(); ++y) {
                    if (parameters.root.map.isTileUsedXY(x, y)) {
                        placeable = false;
                        break placementCheck;
                    }
                }
            }

            if (!placeable) {
                parameters.context.globalAlpha = 0.3;
            } else {
                parameters.context.globalAlpha = 1;
            }

            staticComp.drawSpriteOnFullEntityBounds(
                parameters,
                _core_loader__WEBPACK_IMPORTED_MODULE_1__["Loader"].getSprite(staticComp.blueprintSpriteKey),
                0,
                true,
                newPos
            );
        }
        parameters.context.globalAlpha = 1;
    }

    /**
     * Rotates the blueprint clockwise
     */
    rotateCw() {
        for (let i = 0; i < this.entities.length; ++i) {
            const entity = this.entities[i];
            const staticComp = entity.components.StaticMapEntity;

            staticComp.rotation = (staticComp.rotation + 90) % 360;
            staticComp.originalRotation = (staticComp.originalRotation + 90) % 360;
            staticComp.origin = staticComp.origin.rotateFastMultipleOf90(90);
        }
    }

    /**
     * Rotates the blueprint counter clock wise
     */
    rotateCcw() {
        // Well ...
        for (let i = 0; i < 3; ++i) {
            this.rotateCw();
        }
    }

    /**
     * Checks if the blueprint can be placed at the given tile
     * @param {GameRoot} root
     * @param {Vector} tile
     */
    canPlace(root, tile) {
        let anyPlaceable = false;

        for (let i = 0; i < this.entities.length; ++i) {
            let placeable = true;
            const entity = this.entities[i];
            const staticComp = entity.components.StaticMapEntity;
            const rect = staticComp.getTileSpaceBounds();
            rect.moveBy(tile.x, tile.y);
            placementCheck: for (let x = rect.x; x < rect.right(); ++x) {
                for (let y = rect.y; y < rect.bottom(); ++y) {
                    if (root.map.isTileUsedXY(x, y)) {
                        placeable = false;
                        break placementCheck;
                    }
                }
            }

            if (placeable) {
                anyPlaceable = true;
            }
        }

        return anyPlaceable;
    }

    /**
     * @param {GameRoot} root
     */
    canAfford(root) {
        return root.hubGoals.getShapesStoredByKey(_upgrades__WEBPACK_IMPORTED_MODULE_8__["blueprintShape"]) >= this.getCost();
    }

    /**
     * Attempts to place the blueprint at the given tile
     * @param {GameRoot} root
     * @param {Vector} tile
     */
    tryPlace(root, tile) {
        return root.logic.performBulkOperation(() => {
            let anyPlaced = false;
            for (let i = 0; i < this.entities.length; ++i) {
                let placeable = true;
                const entity = this.entities[i];
                const staticComp = entity.components.StaticMapEntity;
                const rect = staticComp.getTileSpaceBounds();
                rect.moveBy(tile.x, tile.y);
                placementCheck: for (let x = rect.x; x < rect.right(); ++x) {
                    for (let y = rect.y; y < rect.bottom(); ++y) {
                        const contents = root.map.getTileContentXY(x, y);
                        if (contents && !contents.components.ReplaceableMapEntity) {
                            placeable = false;
                            break placementCheck;
                        }
                    }
                }

                if (placeable) {
                    for (let x = rect.x; x < rect.right(); ++x) {
                        for (let y = rect.y; y < rect.bottom(); ++y) {
                            const contents = root.map.getTileContentXY(x, y);
                            if (contents) {
                                window.assert(
                                    contents.components.ReplaceableMapEntity,
                                    "Can not delete entity for blueprint"
                                );
                                if (!root.logic.tryDeleteBuilding(contents)) {
                                    logger.error(
                                        "Building has replaceable component but is also unremovable in blueprint"
                                    );
                                    return false;
                                }
                            }
                        }
                    }

                    const clone = entity.duplicateWithoutContents();
                    clone.components.StaticMapEntity.origin.addInplace(tile);

                    root.map.placeStaticEntity(clone);
                    root.entityMgr.registerEntity(clone);
                    anyPlaced = true;
                }
            }
            return anyPlaced;
        });
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/blueprint_placer.js":
/*!***************************************************!*\
  !*** ./src/js/game/hud/parts/blueprint_placer.js ***!
  \***************************************************/
/*! exports provided: HUDBlueprintPlacer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDBlueprintPlacer", function() { return HUDBlueprintPlacer; });
/* harmony import */ var _core_signal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/signal */ "./src/js/core/signal.js");
/* harmony import */ var _core_tracked_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/tracked_state */ "./src/js/core/tracked_state.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../camera */ "./src/js/game/camera.js");
/* harmony import */ var _key_action_mapper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../key_action_mapper */ "./src/js/game/key_action_mapper.js");
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _blueprint__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./blueprint */ "./src/js/game/hud/parts/blueprint.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dynamic_dom_attach */ "./src/js/game/hud/dynamic_dom_attach.js");
/* harmony import */ var _upgrades__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../upgrades */ "./src/js/game/upgrades.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../translations */ "./src/js/translations.js");
//www.youtube.com/watch?v=KyorY1uIqiQimport { DrawParameters } from "../../../core/draw_parameters";












class HUDBlueprintPlacer extends _base_hud_part__WEBPACK_IMPORTED_MODULE_5__["BaseHUDPart"] {
    createElements(parent) {
        const blueprintCostShape = this.root.shapeDefinitionMgr.getShapeFromShortKey(_upgrades__WEBPACK_IMPORTED_MODULE_9__["blueprintShape"]);
        const blueprintCostShapeCanvas = blueprintCostShape.generateAsCanvas(80);

        this.costDisplayParent = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["makeDiv"])(parent, "ingame_HUD_BlueprintPlacer", [], ``);

        Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["makeDiv"])(this.costDisplayParent, null, ["label"], _translations__WEBPACK_IMPORTED_MODULE_10__["T"].ingame.blueprintPlacer.cost);
        const costContainer = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["makeDiv"])(this.costDisplayParent, null, ["costContainer"], "");
        this.costDisplayText = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["makeDiv"])(costContainer, null, ["costText"], "");
        costContainer.appendChild(blueprintCostShapeCanvas);
    }

    initialize() {
        this.root.hud.signals.buildingsSelectedForCopy.add(this.onBuildingsSelected, this);

        /** @type {TypedTrackedState<Blueprint?>} */
        this.currentBlueprint = new _core_tracked_state__WEBPACK_IMPORTED_MODULE_1__["TrackedState"](this.onBlueprintChanged, this);

        const keyActionMapper = this.root.keyMapper;
        keyActionMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_4__["KEYMAPPINGS"].general.back).add(this.abortPlacement, this);
        keyActionMapper
            .getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_4__["KEYMAPPINGS"].placement.abortBuildingPlacement)
            .add(this.abortPlacement, this);
        keyActionMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_4__["KEYMAPPINGS"].placement.rotateWhilePlacing).add(this.rotateBlueprint, this);
        keyActionMapper
            .getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_4__["KEYMAPPINGS"].placement.abortBuildingPlacement)
            .add(this.abortPlacement, this);

        this.root.camera.downPreHandler.add(this.onMouseDown, this);
        this.root.camera.movePreHandler.add(this.onMouseMove, this);

        this.root.hud.signals.selectedPlacementBuildingChanged.add(this.abortPlacement, this);

        this.domAttach = new _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_8__["DynamicDomAttach"](this.root, this.costDisplayParent);
        this.trackedCanAfford = new _core_tracked_state__WEBPACK_IMPORTED_MODULE_1__["TrackedState"](this.onCanAffordChanged, this);
    }

    abortPlacement() {
        if (this.currentBlueprint.get()) {
            this.currentBlueprint.set(null);

            return _core_signal__WEBPACK_IMPORTED_MODULE_0__["STOP_PROPAGATION"];
        }
    }

    onCanAffordChanged(canAfford) {
        this.costDisplayParent.classList.toggle("canAfford", canAfford);
    }

    update() {
        this.domAttach.update(this.currentBlueprint.get());
        this.trackedCanAfford.set(
            this.currentBlueprint.get() && this.currentBlueprint.get().canAfford(this.root)
        );
    }

    /**
     * @param {Blueprint} blueprint
     */
    onBlueprintChanged(blueprint) {
        if (blueprint) {
            this.costDisplayText.innerText = "" + blueprint.getCost();
        }
    }

    /**
     * mouse down pre handler
     * @param {Vector} pos
     * @param {enumMouseButton} button
     */
    onMouseDown(pos, button) {
        if (button === _camera__WEBPACK_IMPORTED_MODULE_3__["enumMouseButton"].right) {
            if (this.currentBlueprint.get()) {
                this.abortPlacement();
                return _core_signal__WEBPACK_IMPORTED_MODULE_0__["STOP_PROPAGATION"];
            }
        }

        const blueprint = this.currentBlueprint.get();
        if (!blueprint) {
            return;
        }

        if (!blueprint.canAfford(this.root)) {
            this.root.soundProxy.playUiError();
            return;
        }

        const worldPos = this.root.camera.screenToWorld(pos);
        const tile = worldPos.toTileSpace();
        if (blueprint.tryPlace(this.root, tile)) {
            const cost = blueprint.getCost();
            this.root.hubGoals.takeShapeByKey(_upgrades__WEBPACK_IMPORTED_MODULE_9__["blueprintShape"], cost);

            // This actually feels weird
            // if (!this.root.keyMapper.getBinding(KEYMAPPINGS.placementModifiers.placeMultiple).isCurrentlyPressed()) {
            //     this.currentBlueprint.set(null);
            // }
        }
    }

    onMouseMove() {
        // Prevent movement while blueprint is selected
        if (this.currentBlueprint.get()) {
            return _core_signal__WEBPACK_IMPORTED_MODULE_0__["STOP_PROPAGATION"];
        }
    }

    /**
     * @param {Array<number>} uids
     */
    onBuildingsSelected(uids) {
        if (uids.length === 0) {
            return;
        }
        this.currentBlueprint.set(_blueprint__WEBPACK_IMPORTED_MODULE_6__["Blueprint"].fromUids(this.root, uids));
    }

    rotateBlueprint() {
        if (this.currentBlueprint.get()) {
            if (
                this.root.keyMapper
                    .getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_4__["KEYMAPPINGS"].placement.rotateInverseModifier)
                    .isCurrentlyPressed()
            ) {
                this.currentBlueprint.get().rotateCcw();
            } else {
                this.currentBlueprint.get().rotateCw();
            }
        }
    }

    /**
     *
     * @param {DrawParameters} parameters
     */
    draw(parameters) {
        const blueprint = this.currentBlueprint.get();
        if (!blueprint) {
            return;
        }
        const mousePosition = this.root.app.mousePosition;
        if (!mousePosition) {
            // Not on screen
            return;
        }

        const worldPos = this.root.camera.screenToWorld(mousePosition);
        const tile = worldPos.toTileSpace();
        blueprint.draw(parameters, tile);
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/building_placer.js":
/*!**************************************************!*\
  !*** ./src/js/game/hud/parts/building_placer.js ***!
  \**************************************************/
/*! exports provided: HUDBuildingPlacer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDBuildingPlacer", function() { return HUDBuildingPlacer; });
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _core_draw_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/draw_utils */ "./src/js/core/draw_utils.js");
/* harmony import */ var _core_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/loader */ "./src/js/core/loader.js");
/* harmony import */ var _core_signal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/signal */ "./src/js/core/signal.js");
/* harmony import */ var _core_tracked_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/tracked_state */ "./src/js/core/tracked_state.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../core/global_registries */ "./src/js/core/global_registries.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../camera */ "./src/js/game/camera.js");
/* harmony import */ var _components_static_map_entity__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../components/static_map_entity */ "./src/js/game/components/static_map_entity.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../entity */ "./src/js/game/entity.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../dynamic_dom_attach */ "./src/js/game/hud/dynamic_dom_attach.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../../translations */ "./src/js/translations.js");
/* harmony import */ var _key_action_mapper__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../key_action_mapper */ "./src/js/game/key_action_mapper.js");



















class HUDBuildingPlacer extends _base_hud_part__WEBPACK_IMPORTED_MODULE_14__["BaseHUDPart"] {
    initialize() {
        /** @type {TypedTrackedState<MetaBuilding?>} */
        this.currentMetaBuilding = new _core_tracked_state__WEBPACK_IMPORTED_MODULE_6__["TrackedState"](this.onSelectedMetaBuildingChanged, this);
        this.currentBaseRotation = 0;

        /** @type {Entity} */
        this.fakeEntity = null;

        const keyActionMapper = this.root.keyMapper;
        keyActionMapper
            .getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_17__["KEYMAPPINGS"].placement.abortBuildingPlacement)
            .add(this.abortPlacement, this);
        keyActionMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_17__["KEYMAPPINGS"].general.back).add(this.abortPlacement, this);

        keyActionMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_17__["KEYMAPPINGS"].placement.rotateWhilePlacing).add(this.tryRotate, this);
        keyActionMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_17__["KEYMAPPINGS"].placement.cycleBuildingVariants).add(this.cycleVariants, this);
        keyActionMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_17__["KEYMAPPINGS"].placement.pipette).add(this.usePipette, this);

        this.root.hud.signals.buildingsSelectedForCopy.add(this.abortPlacement, this);

        this.domAttach = new _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_15__["DynamicDomAttach"](this.root, this.element, {});

        this.root.camera.downPreHandler.add(this.onMouseDown, this);
        this.root.camera.movePreHandler.add(this.onMouseMove, this);
        this.root.camera.upPostHandler.add(this.abortDragging, this);

        this.currentlyDragging = false;
        this.currentVariant = new _core_tracked_state__WEBPACK_IMPORTED_MODULE_6__["TrackedState"](this.rerenderVariants, this);

        this.variantsAttach = new _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_15__["DynamicDomAttach"](this.root, this.variantsElement, {});

        /**
         * Whether we are currently drag-deleting
         */
        this.currentlyDeleting = false;

        /**
         * Stores which variants for each building we prefer, this is based on what
         * the user last selected
         */
        this.preferredVariants = {};

        /**
         * The tile we last dragged onto
         * @type {Vector}
         *  */
        this.lastDragTile = null;

        /**
         * The tile we initially dragged from
         * @type {Vector}
         */
        this.initialDragTile = null;

        this.root.signals.storyGoalCompleted.add(this.rerenderVariants, this);
        this.root.signals.upgradePurchased.add(this.rerenderVariants, this);
    }

    createElements(parent) {
        this.element = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["makeDiv"])(parent, "ingame_HUD_PlacementHints", [], ``);

        this.buildingInfoElements = {};
        this.buildingInfoElements.label = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["makeDiv"])(this.element, null, ["buildingLabel"], "Extract");
        this.buildingInfoElements.desc = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["makeDiv"])(this.element, null, ["description"], "");
        this.buildingInfoElements.descText = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["makeDiv"])(this.buildingInfoElements.desc, null, ["text"], "");
        this.buildingInfoElements.additionalInfo = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["makeDiv"])(
            this.buildingInfoElements.desc,
            null,
            ["additionalInfo"],
            ""
        );
        this.buildingInfoElements.hotkey = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["makeDiv"])(this.buildingInfoElements.desc, null, ["hotkey"], "");
        this.buildingInfoElements.tutorialImage = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["makeDiv"])(this.element, null, ["buildingImage"]);

        this.variantsElement = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["makeDiv"])(parent, "ingame_HUD_PlacerVariants");
    }

    abortPlacement() {
        if (this.currentMetaBuilding.get()) {
            this.currentMetaBuilding.set(null);
            return _core_signal__WEBPACK_IMPORTED_MODULE_5__["STOP_PROPAGATION"];
        }
    }

    usePipette() {
        if (this.currentMetaBuilding.get()) {
            return;
        }
        if (this.root.camera.getIsMapOverlayActive()) {
            return;
        }

        const mousePos = this.root.app.mousePosition;
        if (!mousePos) {
            return;
        }
        const worldPos = this.root.camera.screenToWorld(mousePos);
        const worldTile = worldPos.toTileSpace();

        const entity = this.root.map.getTileContent(worldTile);
        if (!entity) {
            return;
        }
        const staticEntity = entity.components.StaticMapEntity;

        this.currentBaseRotation = (Math.round(staticEntity.originalRotation / 90) * 90 + 360) % 360;
        // maybe not originalRotation, but rotation

        if (!staticEntity.spriteKey) {
            if (entity.components.Belt) {
                this.currentMetaBuilding.set(_core_global_registries__WEBPACK_IMPORTED_MODULE_8__["gMetaBuildingRegistry"].findById("belt"));
            }
            return;
        }

        let match = staticEntity.spriteKey.match(
            /sprites\/buildings\/(.*?)(_entry|_exit|_[a-z]+|)(|-(.*))\.png/
        );
        const id = match[1];
        const variant = match[4] || _meta_building__WEBPACK_IMPORTED_MODULE_13__["defaultBuildingVariant"];

        const metaBuilding = _core_global_registries__WEBPACK_IMPORTED_MODULE_8__["gMetaBuildingRegistry"].findById(id);

        this.currentMetaBuilding.set(metaBuilding);
        this.currentVariant.set(variant);
    }

    /**
     * mouse down pre handler
     * @param {Vector} pos
     * @param {enumMouseButton} button
     */
    onMouseDown(pos, button) {
        if (this.root.camera.getIsMapOverlayActive()) {
            return;
        }

        // Placement
        if (button === _camera__WEBPACK_IMPORTED_MODULE_10__["enumMouseButton"].left && this.currentMetaBuilding.get()) {
            this.currentlyDragging = true;
            this.currentlyDeleting = false;
            this.lastDragTile = this.root.camera.screenToWorld(pos).toTileSpace();

            // Place initial building
            this.tryPlaceCurrentBuildingAt(this.lastDragTile);

            return _core_signal__WEBPACK_IMPORTED_MODULE_5__["STOP_PROPAGATION"];
        }

        // Deletion
        if (button === _camera__WEBPACK_IMPORTED_MODULE_10__["enumMouseButton"].right && !this.currentMetaBuilding.get()) {
            this.currentlyDragging = true;
            this.currentlyDeleting = true;
            this.lastDragTile = this.root.camera.screenToWorld(pos).toTileSpace();
            this.currentMetaBuilding.set(null);
            return _core_signal__WEBPACK_IMPORTED_MODULE_5__["STOP_PROPAGATION"];
        }
    }

    /**
     * mouse move pre handler
     * @param {Vector} pos
     */
    onMouseMove(pos) {
        if (this.root.camera.getIsMapOverlayActive()) {
            return;
        }

        const metaBuilding = this.currentMetaBuilding.get();
        if ((metaBuilding || this.currentlyDeleting) && this.lastDragTile) {
            const oldPos = this.lastDragTile;
            const newPos = this.root.camera.screenToWorld(pos).toTileSpace();

            if (this.root.camera.desiredCenter) {
                // Camera is moving
                this.lastDragTile = newPos;
                return;
            }

            if (!oldPos.equals(newPos)) {
                if (
                    metaBuilding &&
                    metaBuilding.getRotateAutomaticallyWhilePlacing(this.currentVariant.get()) &&
                    !this.root.keyMapper
                        .getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_17__["KEYMAPPINGS"].placementModifiers.placementDisableAutoOrientation)
                        .isCurrentlyPressed()
                ) {
                    const delta = newPos.sub(oldPos);
                    const angleDeg = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_degrees"])(delta.angle());
                    this.currentBaseRotation = (Math.round(angleDeg / 90) * 90 + 360) % 360;

                    // Holding alt inverts the placement
                    if (
                        this.root.keyMapper
                            .getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_17__["KEYMAPPINGS"].placementModifiers.placeInverse)
                            .isCurrentlyPressed()
                    ) {
                        this.currentBaseRotation = (180 + this.currentBaseRotation) % 360;
                    }
                }

                // - Using bresenhams algorithmus

                let x0 = oldPos.x;
                let y0 = oldPos.y;
                let x1 = newPos.x;
                let y1 = newPos.y;

                var dx = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_abs"])(x1 - x0);
                var dy = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_abs"])(y1 - y0);
                var sx = x0 < x1 ? 1 : -1;
                var sy = y0 < y1 ? 1 : -1;
                var err = dx - dy;

                while (this.currentlyDeleting || this.currentMetaBuilding.get()) {
                    if (this.currentlyDeleting) {
                        const contents = this.root.map.getTileContentXY(x0, y0);
                        if (contents && !contents.queuedForDestroy && !contents.destroyed) {
                            this.root.logic.tryDeleteBuilding(contents);
                        }
                    } else {
                        this.tryPlaceCurrentBuildingAt(new _core_vector__WEBPACK_IMPORTED_MODULE_9__["Vector"](x0, y0));
                    }
                    if (x0 === x1 && y0 === y1) break;
                    var e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x0 += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        y0 += sy;
                    }
                }
            }

            this.lastDragTile = newPos;

            return _core_signal__WEBPACK_IMPORTED_MODULE_5__["STOP_PROPAGATION"];
        }
    }

    update() {
        // ALways update since the camera might have moved
        const mousePos = this.root.app.mousePosition;
        if (mousePos) {
            this.onMouseMove(mousePos);
        }
    }

    /**
     * aborts any dragging op
     */
    abortDragging() {
        this.currentlyDragging = true;
        this.currentlyDeleting = false;
        this.lastDragTile = null;
    }

    /**
     *
     * @param {MetaBuilding} metaBuilding
     */
    startSelection(metaBuilding) {
        this.currentMetaBuilding.set(metaBuilding);
    }

    /**
     * @param {MetaBuilding} metaBuilding
     */
    onSelectedMetaBuildingChanged(metaBuilding) {
        this.abortDragging();
        this.root.hud.signals.selectedPlacementBuildingChanged.dispatch(metaBuilding);
        if (metaBuilding) {
            const variant = this.preferredVariants[metaBuilding.getId()] || _meta_building__WEBPACK_IMPORTED_MODULE_13__["defaultBuildingVariant"];
            this.currentVariant.set(variant);

            this.fakeEntity = new _entity__WEBPACK_IMPORTED_MODULE_12__["Entity"](null);
            metaBuilding.setupEntityComponents(this.fakeEntity, null);

            this.fakeEntity.addComponent(
                new _components_static_map_entity__WEBPACK_IMPORTED_MODULE_11__["StaticMapEntityComponent"]({
                    origin: new _core_vector__WEBPACK_IMPORTED_MODULE_9__["Vector"](0, 0),
                    rotation: 0,
                    tileSize: metaBuilding.getDimensions(this.currentVariant.get()).copy(),
                    blueprintSpriteKey: "",
                })
            );
            metaBuilding.updateVariants(this.fakeEntity, 0, this.currentVariant.get());
        } else {
            this.fakeEntity = null;
        }

        // Since it depends on both, rerender twice
        this.rerenderVariants();
    }

    /**
     * Rerenders the building info dialog
     */
    rerenderInfoDialog() {
        const metaBuilding = this.currentMetaBuilding.get();

        if (!metaBuilding) {
            return;
        }

        const variant = this.currentVariant.get();

        this.buildingInfoElements.label.innerHTML = _translations__WEBPACK_IMPORTED_MODULE_16__["T"].buildings[metaBuilding.id][variant].name;
        this.buildingInfoElements.descText.innerHTML = _translations__WEBPACK_IMPORTED_MODULE_16__["T"].buildings[metaBuilding.id][variant].description;

        const binding = this.root.keyMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_17__["KEYMAPPINGS"].buildings[metaBuilding.getId()]);
        this.buildingInfoElements.hotkey.innerHTML = _translations__WEBPACK_IMPORTED_MODULE_16__["T"].ingame.buildingPlacement.hotkeyLabel.replace(
            "<key>",
            "<code class='keybinding'>" + binding.getKeyCodeString() + "</code>"
        );

        this.buildingInfoElements.tutorialImage.setAttribute(
            "data-icon",
            "building_tutorials/" +
                metaBuilding.getId() +
                (variant === _meta_building__WEBPACK_IMPORTED_MODULE_13__["defaultBuildingVariant"] ? "" : "-" + variant) +
                ".png"
        );

        Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["removeAllChildren"])(this.buildingInfoElements.additionalInfo);
        const additionalInfo = metaBuilding.getAdditionalStatistics(this.root, this.currentVariant.get());
        for (let i = 0; i < additionalInfo.length; ++i) {
            const [label, contents] = additionalInfo[i];
            this.buildingInfoElements.additionalInfo.innerHTML += `
                <label>${label}:</label>
                <span>${contents}</contents>
            `;
        }
    }

    /**
     * Rerenders the variants displayed
     */
    rerenderVariants() {
        Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["removeAllChildren"])(this.variantsElement);
        this.rerenderInfoDialog();

        const metaBuilding = this.currentMetaBuilding.get();

        if (!metaBuilding) {
            return;
        }
        const availableVariants = metaBuilding.getAvailableVariants(this.root);
        if (availableVariants.length === 1) {
            return;
        }

        Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["makeDiv"])(
            this.variantsElement,
            null,
            ["explanation"],
            _translations__WEBPACK_IMPORTED_MODULE_16__["T"].ingame.buildingPlacement.cycleBuildingVariants.replace(
                "<key>",
                "<code class='keybinding'>" +
                    this.root.keyMapper
                        .getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_17__["KEYMAPPINGS"].placement.cycleBuildingVariants)
                        .getKeyCodeString() +
                    "</code>"
            )
        );

        const container = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["makeDiv"])(this.variantsElement, null, ["variants"]);

        for (let i = 0; i < availableVariants.length; ++i) {
            const variant = availableVariants[i];

            const element = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["makeDiv"])(container, null, ["variant"]);
            element.classList.toggle("active", variant === this.currentVariant.get());
            Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["makeDiv"])(element, null, ["label"], variant);

            const iconSize = 64;

            const dimensions = metaBuilding.getDimensions(variant);
            const sprite = metaBuilding.getPreviewSprite(0, variant);
            const spriteWrapper = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["makeDiv"])(element, null, ["iconWrap"]);
            spriteWrapper.setAttribute("data-tile-w", dimensions.x);
            spriteWrapper.setAttribute("data-tile-h", dimensions.y);

            spriteWrapper.innerHTML = sprite.getAsHTML(iconSize * dimensions.x, iconSize * dimensions.y);
        }
    }

    /**
     * Cycles through the variants
     */
    cycleVariants() {
        const metaBuilding = this.currentMetaBuilding.get();
        if (!metaBuilding) {
            this.currentVariant.set(_meta_building__WEBPACK_IMPORTED_MODULE_13__["defaultBuildingVariant"]);
        } else {
            const availableVariants = metaBuilding.getAvailableVariants(this.root);
            const index = availableVariants.indexOf(this.currentVariant.get());
            window.assert(
                index >= 0,
                "Current variant was invalid: " + this.currentVariant.get() + " out of " + availableVariants
            );
            const newIndex = (index + 1) % availableVariants.length;
            const newVariant = availableVariants[newIndex];
            this.currentVariant.set(newVariant);

            this.preferredVariants[metaBuilding.getId()] = newVariant;
        }
    }

    /**
     * Tries to rotate
     */
    tryRotate() {
        const selectedBuilding = this.currentMetaBuilding.get();
        if (selectedBuilding) {
            if (
                this.root.keyMapper
                    .getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_17__["KEYMAPPINGS"].placement.rotateInverseModifier)
                    .isCurrentlyPressed()
            ) {
                this.currentBaseRotation = (this.currentBaseRotation + 270) % 360;
            } else {
                this.currentBaseRotation = (this.currentBaseRotation + 90) % 360;
            }

            const staticComp = this.fakeEntity.components.StaticMapEntity;
            staticComp.rotation = this.currentBaseRotation;
        }
    }

    /**
     * Tries to delete the building under the mouse
     */
    deleteBelowCursor() {
        const mousePosition = this.root.app.mousePosition;
        if (!mousePosition) {
            // Not on screen
            return;
        }

        const worldPos = this.root.camera.screenToWorld(mousePosition);
        const tile = worldPos.toTileSpace();
        const contents = this.root.map.getTileContent(tile);
        if (contents) {
            this.root.logic.tryDeleteBuilding(contents);
        }
    }

    /**
     * Canvas click handler
     * @param {Vector} mousePos
     * @param {boolean} cancelAction
     */
    onCanvasClick(mousePos, cancelAction = false) {
        if (cancelAction) {
            if (this.currentMetaBuilding.get()) {
                this.currentMetaBuilding.set(null);
            } else {
                this.deleteBelowCursor();
            }
            return _core_signal__WEBPACK_IMPORTED_MODULE_5__["STOP_PROPAGATION"];
        }

        if (!this.currentMetaBuilding.get()) {
            return;
        }

        return _core_signal__WEBPACK_IMPORTED_MODULE_5__["STOP_PROPAGATION"];
    }

    /**
     * Tries to place the current building at the given tile
     * @param {Vector} tile
     */
    tryPlaceCurrentBuildingAt(tile) {
        if (this.root.camera.zoomLevel < _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkOverviewMinZoom) {
            // Dont allow placing in overview mode
            return;
        }
        // Transform to world space

        const metaBuilding = this.currentMetaBuilding.get();

        const { rotation, rotationVariant } = metaBuilding.computeOptimalDirectionAndRotationVariantAtTile(
            this.root,
            tile,
            this.currentBaseRotation,
            this.currentVariant.get()
        );

        if (
            this.root.logic.tryPlaceBuilding({
                origin: tile,
                rotation,
                rotationVariant,
                originalRotation: this.currentBaseRotation,
                building: this.currentMetaBuilding.get(),
                variant: this.currentVariant.get(),
            })
        ) {
            // Succesfully placed

            if (
                metaBuilding.getFlipOrientationAfterPlacement() &&
                !this.root.keyMapper
                    .getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_17__["KEYMAPPINGS"].placementModifiers.placementDisableAutoOrientation)
                    .isCurrentlyPressed()
            ) {
                this.currentBaseRotation = (180 + this.currentBaseRotation) % 360;
            }

            if (
                !metaBuilding.getStayInPlacementMode() &&
                !this.root.keyMapper
                    .getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_17__["KEYMAPPINGS"].placementModifiers.placeMultiple)
                    .isCurrentlyPressed() &&
                !this.root.app.settings.getAllSettings().alwaysMultiplace
            ) {
                // Stop placement
                this.currentMetaBuilding.set(null);
            }

            return true;
        } else {
            return false;
        }
    }

    /**
     *
     * @param {DrawParameters} parameters
     */
    draw(parameters) {
        if (this.root.camera.zoomLevel < _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkOverviewMinZoom) {
            // Dont allow placing in overview mode
            this.domAttach.update(false);
            this.variantsAttach.update(false);
            return;
        }

        this.domAttach.update(this.currentMetaBuilding.get());
        this.variantsAttach.update(this.currentMetaBuilding.get());
        const metaBuilding = this.currentMetaBuilding.get();

        if (!metaBuilding) {
            return;
        }

        const mousePosition = this.root.app.mousePosition;
        if (!mousePosition) {
            // Not on screen
            return;
        }

        const worldPos = this.root.camera.screenToWorld(mousePosition);
        const tile = worldPos.toTileSpace();

        // Compute best rotation variant
        const {
            rotation,
            rotationVariant,
            connectedEntities,
        } = metaBuilding.computeOptimalDirectionAndRotationVariantAtTile(
            this.root,
            tile,
            this.currentBaseRotation,
            this.currentVariant.get()
        );

        // Check if there are connected entities
        if (connectedEntities) {
            for (let i = 0; i < connectedEntities.length; ++i) {
                const connectedEntity = connectedEntities[i];
                const connectedWsPoint = connectedEntity.components.StaticMapEntity.getTileSpaceBounds()
                    .getCenter()
                    .toWorldSpace();

                const startWsPoint = tile.toWorldSpaceCenterOfTile();

                const startOffset = connectedWsPoint
                    .sub(startWsPoint)
                    .normalize()
                    .multiplyScalar(_core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize * 0.3);
                const effectiveStartPoint = startWsPoint.add(startOffset);
                const effectiveEndPoint = connectedWsPoint.sub(startOffset);

                parameters.context.globalAlpha = 0.6;

                // parameters.context.lineCap = "round";
                parameters.context.strokeStyle = "#7f7";
                parameters.context.lineWidth = 10;
                parameters.context.beginPath();
                parameters.context.moveTo(effectiveStartPoint.x, effectiveStartPoint.y);
                parameters.context.lineTo(effectiveEndPoint.x, effectiveEndPoint.y);
                parameters.context.stroke();
                parameters.context.globalAlpha = 1;
                // parameters.context.lineCap = "square";
            }
        }

        // Synchronize rotation and origin
        const staticComp = this.fakeEntity.components.StaticMapEntity;
        staticComp.origin = tile;
        staticComp.rotation = rotation;
        staticComp.tileSize = metaBuilding.getDimensions(this.currentVariant.get());
        metaBuilding.updateVariants(this.fakeEntity, rotationVariant, this.currentVariant.get());

        // Check if we could place the buildnig
        const canBuild = this.root.logic.checkCanPlaceBuilding({
            origin: tile,
            rotation,
            rotationVariant,
            building: metaBuilding,
            variant: this.currentVariant.get(),
        });

        // Fade in / out
        parameters.context.lineWidth = 1;
        // parameters.context.globalAlpha = 0.3 + pulseAnimation(this.root.time.realtimeNow(), 0.9) * 0.7;

        // Determine the bounds and visualize them
        const entityBounds = staticComp.getTileSpaceBounds();
        const drawBorder = -3;
        if (canBuild) {
            parameters.context.strokeStyle = "rgba(56, 235, 111, 0.5)";
            parameters.context.fillStyle = "rgba(56, 235, 111, 0.2)";
        } else {
            parameters.context.strokeStyle = "rgba(255, 0, 0, 0.2)";
            parameters.context.fillStyle = "rgba(255, 0, 0, 0.2)";
        }

        parameters.context.beginRoundedRect(
            entityBounds.x * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize - drawBorder,
            entityBounds.y * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize - drawBorder,
            entityBounds.w * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize + 2 * drawBorder,
            entityBounds.h * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize + 2 * drawBorder,
            4
        );
        parameters.context.stroke();
        // parameters.context.fill();
        parameters.context.globalAlpha = 1;

        // HACK to draw the entity sprite
        const previewSprite = metaBuilding.getBlueprintSprite(rotationVariant, this.currentVariant.get());
        staticComp.origin = worldPos.divideScalar(_core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize).subScalars(0.5, 0.5);
        staticComp.drawSpriteOnFullEntityBounds(parameters, previewSprite);
        staticComp.origin = tile;

        // Draw ejectors
        if (canBuild) {
            this.drawMatchingAcceptorsAndEjectors(parameters);
        }
    }

    /**
     *
     * @param {DrawParameters} parameters
     */
    drawMatchingAcceptorsAndEjectors(parameters) {
        const acceptorComp = this.fakeEntity.components.ItemAcceptor;
        const ejectorComp = this.fakeEntity.components.ItemEjector;
        const staticComp = this.fakeEntity.components.StaticMapEntity;

        const goodArrowSprite = _core_loader__WEBPACK_IMPORTED_MODULE_4__["Loader"].getSprite("sprites/misc/slot_good_arrow.png");
        const badArrowSprite = _core_loader__WEBPACK_IMPORTED_MODULE_4__["Loader"].getSprite("sprites/misc/slot_bad_arrow.png");

        // Just ignore this code ...

        const offsetShift = 10;

        if (acceptorComp) {
            const slots = acceptorComp.slots;
            for (let acceptorSlotIndex = 0; acceptorSlotIndex < slots.length; ++acceptorSlotIndex) {
                const slot = slots[acceptorSlotIndex];
                const acceptorSlotWsTile = staticComp.localTileToWorld(slot.pos);
                const acceptorSlotWsPos = acceptorSlotWsTile.toWorldSpaceCenterOfTile();

                for (
                    let acceptorDirectionIndex = 0;
                    acceptorDirectionIndex < slot.directions.length;
                    ++acceptorDirectionIndex
                ) {
                    const direction = slot.directions[acceptorDirectionIndex];
                    const worldDirection = staticComp.localDirectionToWorld(direction);

                    const sourceTile = acceptorSlotWsTile.add(_core_vector__WEBPACK_IMPORTED_MODULE_9__["enumDirectionToVector"][worldDirection]);
                    const sourceEntity = this.root.map.getTileContent(sourceTile);

                    let sprite = goodArrowSprite;
                    let alpha = 0.5;

                    if (sourceEntity) {
                        sprite = badArrowSprite;
                        const sourceEjector = sourceEntity.components.ItemEjector;
                        const sourceStaticComp = sourceEntity.components.StaticMapEntity;
                        const ejectorAcceptLocalTile = sourceStaticComp.worldToLocalTile(acceptorSlotWsTile);
                        if (sourceEjector && sourceEjector.anySlotEjectsToLocalTile(ejectorAcceptLocalTile)) {
                            sprite = goodArrowSprite;
                        }
                        alpha = 1.0;
                    }

                    parameters.context.globalAlpha = alpha;
                    Object(_core_draw_utils__WEBPACK_IMPORTED_MODULE_3__["drawRotatedSprite"])({
                        parameters,
                        sprite,
                        x: acceptorSlotWsPos.x,
                        y: acceptorSlotWsPos.y,
                        angle: Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_radians"])(_core_vector__WEBPACK_IMPORTED_MODULE_9__["enumDirectionToAngle"][_core_vector__WEBPACK_IMPORTED_MODULE_9__["enumInvertedDirections"][worldDirection]]),
                        size: 13,
                        offsetY: offsetShift + 13,
                    });
                    parameters.context.globalAlpha = 1;
                }
            }
        }

        if (ejectorComp) {
            const slots = ejectorComp.slots;
            for (let ejectorSlotIndex = 0; ejectorSlotIndex < slots.length; ++ejectorSlotIndex) {
                const slot = ejectorComp.slots[ejectorSlotIndex];

                const ejectorSlotWsTile = staticComp.localTileToWorld(
                    ejectorComp.getSlotTargetLocalTile(ejectorSlotIndex)
                );
                const ejectorSLotWsPos = ejectorSlotWsTile.toWorldSpaceCenterOfTile();
                const ejectorSlotWsDirection = staticComp.localDirectionToWorld(slot.direction);

                const destEntity = this.root.map.getTileContent(ejectorSlotWsTile);

                let sprite = goodArrowSprite;
                let alpha = 0.5;
                if (destEntity) {
                    alpha = 1;
                    const destAcceptor = destEntity.components.ItemAcceptor;
                    const destStaticComp = destEntity.components.StaticMapEntity;

                    if (destAcceptor) {
                        const destLocalTile = destStaticComp.worldToLocalTile(ejectorSlotWsTile);
                        const destLocalDir = destStaticComp.worldDirectionToLocal(ejectorSlotWsDirection);
                        if (destAcceptor.findMatchingSlot(destLocalTile, destLocalDir)) {
                            sprite = goodArrowSprite;
                        } else {
                            sprite = badArrowSprite;
                        }
                    }
                }

                parameters.context.globalAlpha = alpha;
                Object(_core_draw_utils__WEBPACK_IMPORTED_MODULE_3__["drawRotatedSprite"])({
                    parameters,
                    sprite,
                    x: ejectorSLotWsPos.x,
                    y: ejectorSLotWsPos.y,
                    angle: Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_radians"])(_core_vector__WEBPACK_IMPORTED_MODULE_9__["enumDirectionToAngle"][ejectorSlotWsDirection]),
                    size: 13,
                    offsetY: offsetShift,
                });
                parameters.context.globalAlpha = 1;
            }
        }
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/buildings_toolbar.js":
/*!****************************************************!*\
  !*** ./src/js/game/hud/parts/buildings_toolbar.js ***!
  \****************************************************/
/*! exports provided: HUDBuildingsToolbar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDBuildingsToolbar", function() { return HUDBuildingsToolbar; });
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/global_registries */ "./src/js/core/global_registries.js");
/* harmony import */ var _core_signal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/signal */ "./src/js/core/signal.js");
/* harmony import */ var _core_tracked_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/tracked_state */ "./src/js/core/tracked_state.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _buildings_belt_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../buildings/belt_base */ "./src/js/game/buildings/belt_base.js");
/* harmony import */ var _buildings_cutter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../buildings/cutter */ "./src/js/game/buildings/cutter.js");
/* harmony import */ var _buildings_miner__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../buildings/miner */ "./src/js/game/buildings/miner.js");
/* harmony import */ var _buildings_mixer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../buildings/mixer */ "./src/js/game/buildings/mixer.js");
/* harmony import */ var _buildings_painter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../buildings/painter */ "./src/js/game/buildings/painter.js");
/* harmony import */ var _buildings_rotater__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../buildings/rotater */ "./src/js/game/buildings/rotater.js");
/* harmony import */ var _buildings_splitter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../buildings/splitter */ "./src/js/game/buildings/splitter.js");
/* harmony import */ var _buildings_stacker__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../buildings/stacker */ "./src/js/game/buildings/stacker.js");
/* harmony import */ var _buildings_trash__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../buildings/trash */ "./src/js/game/buildings/trash.js");
/* harmony import */ var _buildings_sorter__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../buildings/sorter */ "./src/js/game/buildings/sorter.js");
/* harmony import */ var _buildings_underground_belt__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../buildings/underground_belt */ "./src/js/game/buildings/underground_belt.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _key_action_mapper__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../key_action_mapper */ "./src/js/game/key_action_mapper.js");



















const toolbarBuildings = [
    _buildings_belt_base__WEBPACK_IMPORTED_MODULE_4__["MetaBeltBaseBuilding"],
    _buildings_splitter__WEBPACK_IMPORTED_MODULE_10__["MetaSplitterBuilding"],
    _buildings_underground_belt__WEBPACK_IMPORTED_MODULE_14__["MetaUndergroundBeltBuilding"],
    _buildings_miner__WEBPACK_IMPORTED_MODULE_6__["MetaMinerBuilding"],
    _buildings_cutter__WEBPACK_IMPORTED_MODULE_5__["MetaCutterBuilding"],
    _buildings_rotater__WEBPACK_IMPORTED_MODULE_9__["MetaRotaterBuilding"],
    _buildings_stacker__WEBPACK_IMPORTED_MODULE_11__["MetaStackerBuilding"],
    _buildings_mixer__WEBPACK_IMPORTED_MODULE_7__["MetaMixerBuilding"],
    _buildings_painter__WEBPACK_IMPORTED_MODULE_8__["MetaPainterBuilding"],
    _buildings_trash__WEBPACK_IMPORTED_MODULE_12__["MetaTrashBuilding"],
    _buildings_sorter__WEBPACK_IMPORTED_MODULE_13__["MetaSorterBuilding"],
];

class HUDBuildingsToolbar extends _base_hud_part__WEBPACK_IMPORTED_MODULE_16__["BaseHUDPart"] {
    constructor(root) {
        super(root);

        /** @type {Object.<string, {
         * metaBuilding: MetaBuilding,
         * unlocked: boolean,
         * selected: boolean,
         * element: HTMLElement,
         * index: number
         * }>} */
        this.buildingHandles = {};

        this.sigBuildingSelected = new _core_signal__WEBPACK_IMPORTED_MODULE_1__["Signal"]();

        this.trackedIsVisisible = new _core_tracked_state__WEBPACK_IMPORTED_MODULE_2__["TrackedState"](this.onVisibilityChanged, this);
    }

    onVisibilityChanged(visible) {
        this.element.classList.toggle("visible", visible);
    }

    /**
     * Should create all require elements
     * @param {HTMLElement} parent
     */
    createElements(parent) {
        this.element = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(parent, "ingame_HUD_buildings_toolbar", [], "");
    }

    initialize() {
        const actionMapper = this.root.keyMapper;

        const items = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(this.element, null, ["buildings"]);

        for (let i = 0; i < toolbarBuildings.length; ++i) {
            const metaBuilding = _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gMetaBuildingRegistry"].findByClass(toolbarBuildings[i]);
            const binding = actionMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_17__["KEYMAPPINGS"].buildings[metaBuilding.getId()]);

            const itemContainer = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(items, null, ["building"]);
            itemContainer.setAttribute("data-icon", "building_icons/" + metaBuilding.getId() + ".png");

            binding.add(() => this.selectBuildingForPlacement(metaBuilding));

            this.trackClicks(itemContainer, () => this.selectBuildingForPlacement(metaBuilding), {
                clickSound: null,
            });

            this.buildingHandles[metaBuilding.id] = {
                metaBuilding,
                element: itemContainer,
                unlocked: false,
                selected: false,
                index: i,
            };
        }

        this.root.hud.signals.selectedPlacementBuildingChanged.add(
            this.onSelectedPlacementBuildingChanged,
            this
        );

        this.lastSelectedIndex = 0;
        actionMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_17__["KEYMAPPINGS"].placement.cycleBuildings).add(this.cycleBuildings, this);
    }

    update() {
        this.trackedIsVisisible.set(!this.root.camera.getIsMapOverlayActive());

        for (const buildingId in this.buildingHandles) {
            const handle = this.buildingHandles[buildingId];
            const newStatus = handle.metaBuilding.getIsUnlocked(this.root);
            if (handle.unlocked !== newStatus) {
                handle.unlocked = newStatus;
                handle.element.classList.toggle("unlocked", newStatus);
            }
        }
    }

    cycleBuildings() {
        let newIndex = this.lastSelectedIndex;
        for (let i = 0; i < toolbarBuildings.length; ++i, ++newIndex) {
            newIndex %= toolbarBuildings.length;
            const metaBuilding = _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gMetaBuildingRegistry"].findByClass(toolbarBuildings[newIndex]);
            const handle = this.buildingHandles[metaBuilding.id];
            if (!handle.selected && handle.unlocked) {
                break;
            }
        }
        const metaBuildingClass = toolbarBuildings[newIndex];
        const metaBuilding = _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gMetaBuildingRegistry"].findByClass(metaBuildingClass);
        this.selectBuildingForPlacement(metaBuilding);
    }

    /**
     * @param {MetaBuilding} metaBuilding
     */
    onSelectedPlacementBuildingChanged(metaBuilding) {
        for (const buildingId in this.buildingHandles) {
            const handle = this.buildingHandles[buildingId];
            const newStatus = handle.metaBuilding === metaBuilding;
            if (handle.selected !== newStatus) {
                handle.selected = newStatus;
                handle.element.classList.toggle("selected", newStatus);
            }
            if (handle.selected) {
                this.lastSelectedIndex = handle.index;
            }
        }

        this.element.classList.toggle("buildingSelected", !!metaBuilding);
    }

    /**
     * @param {MetaBuilding} metaBuilding
     */
    selectBuildingForPlacement(metaBuilding) {
        if (!metaBuilding.getIsUnlocked(this.root)) {
            this.root.soundProxy.playUiError();
            return;
        }

        // Allow clicking an item again to deselect it
        for (const buildingId in this.buildingHandles) {
            const handle = this.buildingHandles[buildingId];
            if (handle.selected && handle.metaBuilding === metaBuilding) {
                metaBuilding = null;
                break;
            }
        }

        this.root.soundProxy.playUiClick();
        this.sigBuildingSelected.dispatch(metaBuilding);
        this.onSelectedPlacementBuildingChanged(metaBuilding);
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/debug_info.js":
/*!*********************************************!*\
  !*** ./src/js/game/hud/parts/debug_info.js ***!
  \*********************************************/
/*! exports provided: HUDDebugInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDDebugInfo", function() { return HUDDebugInfo; });
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dynamic_dom_attach */ "./src/js/game/hud/dynamic_dom_attach.js");
/* harmony import */ var _key_action_mapper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../key_action_mapper */ "./src/js/game/key_action_mapper.js");






class HUDDebugInfo extends _base_hud_part__WEBPACK_IMPORTED_MODULE_0__["BaseHUDPart"] {
    createElements(parent) {
        this.element = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(parent, "ingame_HUD_DebugInfo", []);

        this.tickRateElement = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(this.element, null, ["tickRate"], "Ticks /s: 120");
        this.fpsElement = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(this.element, null, ["fps"], "FPS: 60");
        this.tickDurationElement = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(this.element, null, ["tickDuration"], "Update time: 0.5ms");
    }

    initialize() {
        this.lastTick = 0;

        this.visible = false;
        this.domAttach = new _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_3__["DynamicDomAttach"](this.root, this.element);

        this.root.keyMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_4__["KEYMAPPINGS"].ingame.toggleFPSInfo).add(() => this.toggle());
    }

    toggle() {
        this.visible = !this.visible;
        this.domAttach.update(this.visible);
    }

    update() {
        const now = this.root.time.realtimeNow();
        if (now - this.lastTick > 0.25 && this.visible) {
            this.lastTick = now;
            this.tickRateElement.innerText = "Tickrate: " + this.root.dynamicTickrate.currentTickRate;
            this.fpsElement.innerText =
                "FPS: " +
                Object(_core_builtins__WEBPACK_IMPORTED_MODULE_2__["Math_round"])(this.root.dynamicTickrate.averageFps) +
                " (" +
                Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["round2Digits"])(1000 / this.root.dynamicTickrate.averageFps) +
                " ms)";
            this.tickDurationElement.innerText =
                "Tick Dur: " + Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["round3Digits"])(this.root.dynamicTickrate.averageTickDuration) + "ms";
        }
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/entity_debugger.js":
/*!**************************************************!*\
  !*** ./src/js/game/hud/parts/entity_debugger.js ***!
  \**************************************************/
/*! exports provided: HUDEntityDebugger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDEntityDebugger", function() { return HUDEntityDebugger; });
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/config */ "./src/js/core/config.js");




class HUDEntityDebugger extends _base_hud_part__WEBPACK_IMPORTED_MODULE_0__["BaseHUDPart"] {
    createElements(parent) {
        this.element = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(
            parent,
            "ingame_HUD_EntityDebugger",
            [],
            `
            Tile below cursor: <span class="mousePos"></span><br>
            Chunk below cursor: <span class="chunkPos"></span><br>
            <div class="entityInfo"></div>
        `
        );

        this.mousePosElem = this.element.querySelector(".mousePos");
        this.chunkPosElem = this.element.querySelector(".chunkPos");
        this.entityInfoElem = this.element.querySelector(".entityInfo");
    }

    initialize() {
        this.root.camera.downPreHandler.add(this.onMouseDown, this);
    }

    update() {
        const mousePos = this.root.app.mousePosition;
        if (!mousePos) {
            return;
        }
        const worldPos = this.root.camera.screenToWorld(mousePos);
        const worldTile = worldPos.toTileSpace();

        const chunk = worldTile.divideScalar(_core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].mapChunkSize).floor();
        this.mousePosElem.innerText = worldTile.x + " / " + worldTile.y;
        this.chunkPosElem.innerText = chunk.x + " / " + chunk.y;

        const entity = this.root.map.getTileContent(worldTile);
        if (entity) {
            Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["removeAllChildren"])(this.entityInfoElem);
            let html = "Entity";

            const flag = (name, val) =>
                `<span class='flag' data-value='${val ? "1" : "0"}'><u>${name}</u> ${val}</span>`;

            html += "<div class='entityFlags'>";
            html += flag("registered", entity.registered);
            html += flag("uid", entity.uid);
            html += flag("destroyed", entity.destroyed);
            html += "</div>";

            html += "<div class='components'>";

            for (const componentId in entity.components) {
                const data = entity.components[componentId];
                html += "<div class='component'>";
                html += "<strong class='name'>" + componentId + "</strong>";
                html += "<textarea class='data'>" + JSON.stringify(data.serialize(), null, 2) + "</textarea>";

                html += "</div>";
            }

            html += "</div>";

            this.entityInfoElem.innerHTML = html;
        }
    }

    onMouseDown() {}
}


/***/ }),

/***/ "./src/js/game/hud/parts/game_menu.js":
/*!********************************************!*\
  !*** ./src/js/game/hud/parts/game_menu.js ***!
  \********************************************/
/*! exports provided: HUDGameMenu */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDGameMenu", function() { return HUDGameMenu; });
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _platform_sound__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../platform/sound */ "./src/js/platform/sound.js");
/* harmony import */ var _notifications__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./notifications */ "./src/js/game/hud/parts/notifications.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../translations */ "./src/js/translations.js");
/* harmony import */ var _key_action_mapper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../key_action_mapper */ "./src/js/game/key_action_mapper.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/config */ "./src/js/core/config.js");








class HUDGameMenu extends _base_hud_part__WEBPACK_IMPORTED_MODULE_0__["BaseHUDPart"] {
    initialize() {}
    createElements(parent) {
        this.element = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(parent, "ingame_HUD_GameMenu");

        const buttons = [
            {
                id: "shop",
                label: "Upgrades",
                handler: () => this.root.hud.parts.shop.show(),
                keybinding: _key_action_mapper__WEBPACK_IMPORTED_MODULE_5__["KEYMAPPINGS"].ingame.menuOpenShop,
                badge: () => this.root.hubGoals.getAvailableUpgradeCount(),
                notification: /** @type {[string, enumNotificationType]} */ ([
                    _translations__WEBPACK_IMPORTED_MODULE_4__["T"].ingame.notifications.newUpgrade,
                    _notifications__WEBPACK_IMPORTED_MODULE_3__["enumNotificationType"].upgrade,
                ]),
            },
            {
                id: "stats",
                label: "Stats",
                handler: () => this.root.hud.parts.statistics.show(),
                keybinding: _key_action_mapper__WEBPACK_IMPORTED_MODULE_5__["KEYMAPPINGS"].ingame.menuOpenStats,
            },
        ];

        /** @type {Array<{
         * badge: function,
         * button: HTMLElement,
         * badgeElement: HTMLElement,
         * lastRenderAmount: number,
         * notification: [string, enumNotificationType]
         * }>} */
        this.badgesToUpdate = [];

        buttons.forEach(({ id, label, handler, keybinding, badge, notification }) => {
            const button = document.createElement("button");
            button.setAttribute("data-button-id", id);
            this.element.appendChild(button);
            this.trackClicks(button, handler);

            if (keybinding) {
                const binding = this.root.keyMapper.getBinding(keybinding);
                binding.add(handler);
                binding.appendLabelToElement(button);
            }

            if (badge) {
                const badgeElement = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(button, null, ["badge"]);
                this.badgesToUpdate.push({
                    badge,
                    lastRenderAmount: 0,
                    button,
                    badgeElement,
                    notification,
                });
            }
        });

        const menuButtons = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(this.element, null, ["menuButtons"]);

        this.musicButton = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(menuButtons, null, ["button", "music"]);
        this.sfxButton = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(menuButtons, null, ["button", "sfx"]);
        this.saveButton = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(menuButtons, null, ["button", "save", "animEven"]);
        this.settingsButton = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(menuButtons, null, ["button", "settings"]);

        this.trackClicks(this.musicButton, this.toggleMusic);
        this.trackClicks(this.sfxButton, this.toggleSfx);
        this.trackClicks(this.saveButton, this.startSave);
        this.trackClicks(this.settingsButton, this.openSettings);

        this.musicButton.classList.toggle("muted", this.root.app.settings.getAllSettings().musicMuted);
        this.sfxButton.classList.toggle("muted", this.root.app.settings.getAllSettings().soundsMuted);

        this.root.signals.gameSaved.add(this.onGameSaved, this);
    }

    update() {
        let playSound = false;
        let notifications = new Set();
        for (let i = 0; i < this.badgesToUpdate.length; ++i) {
            const { badge, button, badgeElement, lastRenderAmount, notification } = this.badgesToUpdate[i];
            const amount = badge();
            if (lastRenderAmount !== amount) {
                if (amount > 0) {
                    badgeElement.innerText = amount;
                }
                // Check if the badge increased
                if (amount > lastRenderAmount) {
                    playSound = true;
                    if (notification) {
                        notifications.add(notification);
                    }
                }
                this.badgesToUpdate[i].lastRenderAmount = amount;
                button.classList.toggle("hasBadge", amount > 0);
            }
        }

        if (playSound) {
            this.root.soundProxy.playUi(_platform_sound__WEBPACK_IMPORTED_MODULE_2__["SOUNDS"].badgeNotification);
        }
        notifications.forEach(([notification, type]) => {
            this.root.hud.signals.notification.dispatch(notification, type);
        });
    }

    onGameSaved() {
        this.saveButton.classList.toggle("animEven");
        this.saveButton.classList.toggle("animOdd");
    }

    startSave() {
        // if (IS_DEMO) {
        //     this.root.hud.parts.dialogs.showFeatureRestrictionInfo(
        //         null,
        //         T.dialogs.saveNotPossibleInDemo.desc
        //     );
        // }

        this.root.gameState.doSave();
    }

    openSettings() {
        this.root.hud.parts.settingsMenu.show();
    }

    toggleMusic() {
        const newValue = !this.root.app.settings.getAllSettings().musicMuted;
        this.root.app.settings.updateSetting("musicMuted", newValue);

        this.musicButton.classList.toggle("muted", newValue);
    }

    toggleSfx() {
        const newValue = !this.root.app.settings.getAllSettings().soundsMuted;
        this.root.app.settings.updateSetting("soundsMuted", newValue);
        this.sfxButton.classList.toggle("muted", newValue);
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/keybinding_overlay.js":
/*!*****************************************************!*\
  !*** ./src/js/game/hud/parts/keybinding_overlay.js ***!
  \*****************************************************/
/*! exports provided: HUDKeybindingOverlay */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDKeybindingOverlay", function() { return HUDKeybindingOverlay; });
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../translations */ "./src/js/translations.js");
/* harmony import */ var _key_action_mapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../key_action_mapper */ "./src/js/game/key_action_mapper.js");
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");





class HUDKeybindingOverlay extends _base_hud_part__WEBPACK_IMPORTED_MODULE_3__["BaseHUDPart"] {
    initialize() {
        this.root.hud.signals.selectedPlacementBuildingChanged.add(
            this.onSelectedBuildingForPlacementChanged,
            this
        );
    }

    createElements(parent) {
        const mapper = this.root.keyMapper;

        const getKeycode = id => {
            return Object(_key_action_mapper__WEBPACK_IMPORTED_MODULE_2__["getStringForKeyCode"])(mapper.getBinding(id).keyCode);
        };

        this.element = Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__["makeDiv"])(
            parent,
            "ingame_HUD_KeybindingOverlay",
            [],
            `
            <div class="binding">
                <code class="keybinding">${getKeycode(_key_action_mapper__WEBPACK_IMPORTED_MODULE_2__["KEYMAPPINGS"].navigation.createMarker)}</code>
                <label>${_translations__WEBPACK_IMPORTED_MODULE_1__["T"].ingame.keybindingsOverlay.createMarker}</label>
            </div>

            <div class="binding">
                <code class="keybinding leftMouse noPlacementOnly"></code><i class="noPlacementOnly"></i>
                <code class="keybinding">${getKeycode(_key_action_mapper__WEBPACK_IMPORTED_MODULE_2__["KEYMAPPINGS"].navigation.mapMoveUp)}</code>
                <code class="keybinding">${getKeycode(_key_action_mapper__WEBPACK_IMPORTED_MODULE_2__["KEYMAPPINGS"].navigation.mapMoveLeft)}</code>
                <code class="keybinding">${getKeycode(_key_action_mapper__WEBPACK_IMPORTED_MODULE_2__["KEYMAPPINGS"].navigation.mapMoveDown)}</code>
                <code class="keybinding">${getKeycode(_key_action_mapper__WEBPACK_IMPORTED_MODULE_2__["KEYMAPPINGS"].navigation.mapMoveRight)}</code>
                <label>${_translations__WEBPACK_IMPORTED_MODULE_1__["T"].ingame.keybindingsOverlay.moveMap}</label>
            </div>               
            
            <div class="binding noPlacementOnly">
                <code class="keybinding builtinKey">${getKeycode(
                    _key_action_mapper__WEBPACK_IMPORTED_MODULE_2__["KEYMAPPINGS"].massSelect.massSelectStart
                )}</code>+
                <code class="keybinding leftMouse"></code>
                <label>${_translations__WEBPACK_IMPORTED_MODULE_1__["T"].ingame.keybindingsOverlay.selectBuildings}</label>
            </div>
            
            
            <div class="binding placementOnly">
                <code class="keybinding leftMouse"></code>
                <label>${_translations__WEBPACK_IMPORTED_MODULE_1__["T"].ingame.keybindingsOverlay.placeBuilding}</label>
            </div>
            
            <div class="binding placementOnly">
                <code class="keybinding rightMouse"></code><i></i>
                <code class="keybinding">${getKeycode(_key_action_mapper__WEBPACK_IMPORTED_MODULE_2__["KEYMAPPINGS"].placement.abortBuildingPlacement)}</code>
                <label>${_translations__WEBPACK_IMPORTED_MODULE_1__["T"].ingame.keybindingsOverlay.stopPlacement}</label>
            </div>

            <div class="binding placementOnly">
                <code class="keybinding">${getKeycode(_key_action_mapper__WEBPACK_IMPORTED_MODULE_2__["KEYMAPPINGS"].placement.rotateWhilePlacing)}</code>
                <label>${_translations__WEBPACK_IMPORTED_MODULE_1__["T"].ingame.keybindingsOverlay.rotateBuilding}</label>
            </div>

            <div class="binding placementOnly">
                <code class="keybinding builtinKey shift">${getKeycode(
                    _key_action_mapper__WEBPACK_IMPORTED_MODULE_2__["KEYMAPPINGS"].placementModifiers.placeMultiple
                )}</code>
                <label>${_translations__WEBPACK_IMPORTED_MODULE_1__["T"].ingame.keybindingsOverlay.placeMultiple}</label>
            </div>
        `
        );
    }

    onSelectedBuildingForPlacementChanged(selectedMetaBuilding) {
        this.element.classList.toggle("placementActive", !!selectedMetaBuilding);
    }

    update() {}
}


/***/ }),

/***/ "./src/js/game/hud/parts/mass_selector.js":
/*!************************************************!*\
  !*** ./src/js/game/hud/parts/mass_selector.js ***!
  \************************************************/
/*! exports provided: HUDMassSelector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDMassSelector", function() { return HUDMassSelector; });
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _core_signal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/signal */ "./src/js/core/signal.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../entity */ "./src/js/game/entity.js");
/* harmony import */ var _core_loader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/loader */ "./src/js/core/loader.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dynamic_dom_attach */ "./src/js/game/hud/dynamic_dom_attach.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../camera */ "./src/js/game/camera.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../translations */ "./src/js/translations.js");
/* harmony import */ var _key_action_mapper__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../key_action_mapper */ "./src/js/game/key_action_mapper.js");
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../theme */ "./src/js/game/theme.js");
/* harmony import */ var _tutorial_goals__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../tutorial_goals */ "./src/js/game/tutorial_goals.js");
















const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_9__["createLogger"])("hud/mass_selector");

class HUDMassSelector extends _base_hud_part__WEBPACK_IMPORTED_MODULE_0__["BaseHUDPart"] {
    createElements(parent) {
        const removalKeybinding = this.root.keyMapper
            .getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_12__["KEYMAPPINGS"].massSelect.confirmMassDelete)
            .getKeyCodeString();
        const abortKeybinding = this.root.keyMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_12__["KEYMAPPINGS"].general.back).getKeyCodeString();
        const copyKeybinding = this.root.keyMapper
            .getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_12__["KEYMAPPINGS"].massSelect.massSelectCopy)
            .getKeyCodeString();

        this.element = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["makeDiv"])(
            parent,
            "ingame_HUD_MassSelector",
            [],
            _translations__WEBPACK_IMPORTED_MODULE_11__["T"].ingame.massSelect.infoText
                .replace("<keyDelete>", `<code class='keybinding'>${removalKeybinding}</code>`)
                .replace("<keyCopy>", `<code class='keybinding'>${copyKeybinding}</code>`)
                .replace("<keyCancel>", `<code class='keybinding'>${abortKeybinding}</code>`)
        );
    }

    initialize() {
        this.deletionMarker = _core_loader__WEBPACK_IMPORTED_MODULE_5__["Loader"].getSprite("sprites/misc/deletion_marker.png");

        this.currentSelectionStart = null;
        this.currentSelectionStartWorld = null;
        this.currentSelectionEnd = null;
        this.selectedUids = new Set();

        this.root.signals.entityQueuedForDestroy.add(this.onEntityDestroyed, this);

        this.root.camera.downPreHandler.add(this.onMouseDown, this);
        this.root.camera.movePreHandler.add(this.onMouseMove, this);
        this.root.camera.upPostHandler.add(this.onMouseUp, this);

        this.root.keyMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_12__["KEYMAPPINGS"].general.back).add(this.onBack, this);
        this.root.keyMapper
            .getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_12__["KEYMAPPINGS"].massSelect.confirmMassDelete)
            .add(this.confirmDelete, this);
        this.root.keyMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_12__["KEYMAPPINGS"].massSelect.massSelectCopy).add(this.startCopy, this);

        this.domAttach = new _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_8__["DynamicDomAttach"](this.root, this.element);
    }

    /**
     * Handles the destroy callback and makes sure we clean our list
     * @param {Entity} entity
     */
    onEntityDestroyed(entity) {
        this.selectedUids.delete(entity.uid);
    }

    /**
     *
     */
    onBack() {
        // Clear entities on escape
        if (this.selectedUids.size > 0) {
            this.selectedUids = new Set();
            return _core_signal__WEBPACK_IMPORTED_MODULE_2__["STOP_PROPAGATION"];
        }
    }

    confirmDelete() {
        if (this.selectedUids.size > 100) {
            const { ok } = this.root.hud.parts.dialogs.showWarning(
                _translations__WEBPACK_IMPORTED_MODULE_11__["T"].dialogs.massDeleteConfirm.title,
                _translations__WEBPACK_IMPORTED_MODULE_11__["T"].dialogs.massDeleteConfirm.desc.replace(
                    "<count>",
                    "" + Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__["formatBigNumberFull"])(this.selectedUids.size)
                ),
                ["cancel:good", "ok:bad"]
            );
            ok.add(() => this.doDelete());
        } else {
            this.doDelete();
        }
    }

    doDelete() {
        const entityUids = Array.from(this.selectedUids);
        for (let i = 0; i < entityUids.length; ++i) {
            const uid = entityUids[i];
            const entity = this.root.entityMgr.findByUid(uid);
            if (!this.root.logic.tryDeleteBuilding(entity)) {
                logger.error("Error in mass delete, could not remove building");
                this.selectedUids.delete(uid);
            }
        }
    }

    startCopy() {
        if (this.selectedUids.size > 0) {
            if (!this.root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_14__["enumHubGoalRewards"].reward_blueprints)) {
                this.root.hud.parts.dialogs.showInfo(
                    _translations__WEBPACK_IMPORTED_MODULE_11__["T"].dialogs.blueprintsNotUnlocked.title,
                    _translations__WEBPACK_IMPORTED_MODULE_11__["T"].dialogs.blueprintsNotUnlocked.desc
                );
                return;
            }
            this.root.hud.signals.buildingsSelectedForCopy.dispatch(Array.from(this.selectedUids));
            if (
                !this.root.keyMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_12__["KEYMAPPINGS"].massSelect.confirmMassDelete).isCurrentlyPressed()
            ) {
                this.selectedUids = new Set();
            }
            this.root.soundProxy.playUiClick();
        } else {
            this.root.soundProxy.playUiError();
        }
    }

    /**
     * mouse down pre handler
     * @param {Vector} pos
     * @param {enumMouseButton} mouseButton
     */
    onMouseDown(pos, mouseButton) {
        if (!this.root.keyMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_12__["KEYMAPPINGS"].massSelect.massSelectStart).isCurrentlyPressed()) {
            return;
        }

        if (mouseButton !== _camera__WEBPACK_IMPORTED_MODULE_10__["enumMouseButton"].left) {
            return;
        }

        if (
            !this.root.keyMapper
                .getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_12__["KEYMAPPINGS"].massSelect.massSelectSelectMultiple)
                .isCurrentlyPressed()
        ) {
            // Start new selection
            this.selectedUids = new Set();
        }

        this.currentSelectionStart = pos.copy();
        this.currentSelectionStartWorld = this.root.camera.screenToWorld(this.currentSelectionStart);
        this.currentSelectionEnd = pos.copy();
        return _core_signal__WEBPACK_IMPORTED_MODULE_2__["STOP_PROPAGATION"];
    }

    /**
     * mouse move pre handler
     * @param {Vector} pos
     */
    onMouseMove(pos) {
        if (this.currentSelectionStart) {
            this.currentSelectionEnd = pos.copy();
        }
    }

    onMouseUp() {
        if (this.currentSelectionStart) {
            const worldStart = this.currentSelectionStartWorld;
            const worldEnd = this.root.camera.screenToWorld(this.currentSelectionEnd);

            const tileStart = worldStart.toTileSpace();
            const tileEnd = worldEnd.toTileSpace();

            const realTileStart = tileStart.min(tileEnd);
            const realTileEnd = tileStart.max(tileEnd);

            for (let x = realTileStart.x; x <= realTileEnd.x; ++x) {
                for (let y = realTileStart.y; y <= realTileEnd.y; ++y) {
                    const contents = this.root.map.getTileContentXY(x, y);
                    if (contents && this.root.logic.canDeleteBuilding(contents)) {
                        this.selectedUids.add(contents.uid);
                    }
                }
            }

            this.currentSelectionStart = null;
            this.currentSelectionStartWorld = null;
            this.currentSelectionEnd = null;
        }
    }

    update() {
        this.domAttach.update(this.selectedUids.size > 0);
    }

    /**
     *
     * @param {DrawParameters} parameters
     */
    draw(parameters) {
        const boundsBorder = 2;

        if (this.currentSelectionStart) {
            const worldStart = this.currentSelectionStartWorld;
            const worldEnd = this.root.camera.screenToWorld(this.currentSelectionEnd);

            const realWorldStart = worldStart.min(worldEnd);
            const realWorldEnd = worldStart.max(worldEnd);

            const tileStart = worldStart.toTileSpace();
            const tileEnd = worldEnd.toTileSpace();

            const realTileStart = tileStart.min(tileEnd);
            const realTileEnd = tileStart.max(tileEnd);

            parameters.context.lineWidth = 1;
            parameters.context.fillStyle = _theme__WEBPACK_IMPORTED_MODULE_13__["THEME"].map.selectionBackground;
            parameters.context.strokeStyle = _theme__WEBPACK_IMPORTED_MODULE_13__["THEME"].map.selectionOutline;
            parameters.context.beginPath();
            parameters.context.rect(
                realWorldStart.x,
                realWorldStart.y,
                realWorldEnd.x - realWorldStart.x,
                realWorldEnd.y - realWorldStart.y
            );
            parameters.context.fill();
            parameters.context.stroke();

            parameters.context.fillStyle = _theme__WEBPACK_IMPORTED_MODULE_13__["THEME"].map.selectionOverlay;

            for (let x = realTileStart.x; x <= realTileEnd.x; ++x) {
                for (let y = realTileStart.y; y <= realTileEnd.y; ++y) {
                    const contents = this.root.map.getTileContentXY(x, y);
                    if (contents && this.root.logic.canDeleteBuilding(contents)) {
                        const staticComp = contents.components.StaticMapEntity;
                        const bounds = staticComp.getTileSpaceBounds();
                        parameters.context.beginRoundedRect(
                            bounds.x * _core_config__WEBPACK_IMPORTED_MODULE_6__["globalConfig"].tileSize + boundsBorder,
                            bounds.y * _core_config__WEBPACK_IMPORTED_MODULE_6__["globalConfig"].tileSize + boundsBorder,
                            bounds.w * _core_config__WEBPACK_IMPORTED_MODULE_6__["globalConfig"].tileSize - 2 * boundsBorder,
                            bounds.h * _core_config__WEBPACK_IMPORTED_MODULE_6__["globalConfig"].tileSize - 2 * boundsBorder,
                            2
                        );
                        parameters.context.fill();
                    }
                }
            }
        }

        parameters.context.fillStyle = _theme__WEBPACK_IMPORTED_MODULE_13__["THEME"].map.selectionOverlay;
        this.selectedUids.forEach(uid => {
            const entity = this.root.entityMgr.findByUid(uid);
            const staticComp = entity.components.StaticMapEntity;
            const bounds = staticComp.getTileSpaceBounds();
            parameters.context.beginRoundedRect(
                bounds.x * _core_config__WEBPACK_IMPORTED_MODULE_6__["globalConfig"].tileSize + boundsBorder,
                bounds.y * _core_config__WEBPACK_IMPORTED_MODULE_6__["globalConfig"].tileSize + boundsBorder,
                bounds.w * _core_config__WEBPACK_IMPORTED_MODULE_6__["globalConfig"].tileSize - 2 * boundsBorder,
                bounds.h * _core_config__WEBPACK_IMPORTED_MODULE_6__["globalConfig"].tileSize - 2 * boundsBorder,
                2
            );
            parameters.context.fill();
        });
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/modal_dialogs.js":
/*!************************************************!*\
  !*** ./src/js/game/hud/parts/modal_dialogs.js ***!
  \************************************************/
/*! exports provided: HUDModalDialogs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDModalDialogs", function() { return HUDModalDialogs; });
/* harmony import */ var _platform_sound__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/sound */ "./src/js/platform/sound.js");
/* harmony import */ var _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dynamic_dom_attach */ "./src/js/game/hud/dynamic_dom_attach.js");
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _core_modal_dialog_elements__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/modal_dialog_elements */ "./src/js/core/modal_dialog_elements.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../translations */ "./src/js/translations.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/config */ "./src/js/core/config.js");










class HUDModalDialogs extends _base_hud_part__WEBPACK_IMPORTED_MODULE_2__["BaseHUDPart"] {
    constructor(root, app) {
        // Important: Root is not always available here! Its also used in the main menu
        super(root);

        /** @type {Application} */
        this.app = root ? root.app : app;

        this.dialogParent = null;
        this.dialogStack = [];
    }

    // For use inside of the game, implementation of base hud part
    initialize() {
        this.dialogParent = document.getElementById("ingame_HUD_ModalDialogs");
        this.domWatcher = new _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_1__["DynamicDomAttach"](this.root, this.dialogParent);
    }

    shouldPauseRendering() {
        return this.dialogStack.length > 0;
    }

    shouldPauseGame() {
        return this.shouldPauseRendering();
    }

    createElements(parent) {
        return Object(_core_utils__WEBPACK_IMPORTED_MODULE_4__["makeDiv"])(parent, "ingame_HUD_ModalDialogs");
    }

    // For use outside of the game
    initializeToElement(element) {
        window.assert(element, "No element for dialogs given");
        this.dialogParent = element;
    }

    // Methods

    /**
     * @param {string} title
     * @param {string} text
     * @param {Array<string>} buttons
     */
    showInfo(title, text, buttons = ["ok:good"]) {
        const dialog = new _core_modal_dialog_elements__WEBPACK_IMPORTED_MODULE_3__["Dialog"]({
            app: this.app,
            title: title,
            contentHTML: text,
            buttons: buttons,
            type: "info",
        });
        this.internalShowDialog(dialog);

        if (this.app) {
            this.app.sound.playUiSound(_platform_sound__WEBPACK_IMPORTED_MODULE_0__["SOUNDS"].dialogOk);
        }

        return dialog.buttonSignals;
    }

    /**
     * @param {string} title
     * @param {string} text
     * @param {Array<string>} buttons
     */
    showWarning(title, text, buttons = ["ok:good"]) {
        const dialog = new _core_modal_dialog_elements__WEBPACK_IMPORTED_MODULE_3__["Dialog"]({
            app: this.app,
            title: title,
            contentHTML: text,
            buttons: buttons,
            type: "warning",
        });
        this.internalShowDialog(dialog);

        if (this.app) {
            this.app.sound.playUiSound(_platform_sound__WEBPACK_IMPORTED_MODULE_0__["SOUNDS"].dialogError);
        }

        return dialog.buttonSignals;
    }

    /**
     * @param {string} feature
     * @param {string} textPrefab
     */
    showFeatureRestrictionInfo(feature, textPrefab = _translations__WEBPACK_IMPORTED_MODULE_5__["T"].dialogs.featureRestriction.desc) {
        const dialog = new _core_modal_dialog_elements__WEBPACK_IMPORTED_MODULE_3__["Dialog"]({
            app: this.app,
            title: _translations__WEBPACK_IMPORTED_MODULE_5__["T"].dialogs.featureRestriction.title,
            contentHTML: textPrefab.replace("<feature>", feature),
            buttons: ["cancel:bad", "getStandalone:good"],
            type: "warning",
        });
        this.internalShowDialog(dialog);

        if (this.app) {
            this.app.sound.playUiSound(_platform_sound__WEBPACK_IMPORTED_MODULE_0__["SOUNDS"].dialogOk);
        }

        this.app.analytics.trackUiClick("demo_dialog_show");

        dialog.buttonSignals.cancel.add(() => {
            this.app.analytics.trackUiClick("demo_dialog_cancel");
        });

        dialog.buttonSignals.getStandalone.add(() => {
            this.app.analytics.trackUiClick("demo_dialog_click");
            window.open(_core_config__WEBPACK_IMPORTED_MODULE_6__["THIRDPARTY_URLS"].standaloneStorePage);
        });

        return dialog.buttonSignals;
    }

    showOptionChooser(title, options) {
        const dialog = new _core_modal_dialog_elements__WEBPACK_IMPORTED_MODULE_3__["DialogOptionChooser"]({
            app: this.app,
            title,
            options,
        });
        this.internalShowDialog(dialog);
        return dialog.buttonSignals;
    }

    // Returns method to be called when laoding finishd
    showLoadingDialog() {
        const dialog = new _core_modal_dialog_elements__WEBPACK_IMPORTED_MODULE_3__["DialogLoading"](this.app);
        this.internalShowDialog(dialog);
        return this.closeDialog.bind(this, dialog);
    }

    internalShowDialog(dialog) {
        const elem = dialog.createElement();
        dialog.setIndex(this.dialogStack.length);

        // Hide last dialog in queue
        if (this.dialogStack.length > 0) {
            this.dialogStack[this.dialogStack.length - 1].hide();
        }

        this.dialogStack.push(dialog);

        // Append dialog
        dialog.show();
        dialog.closeRequested.add(this.closeDialog.bind(this, dialog));

        // Append to HTML
        this.dialogParent.appendChild(elem);

        document.body.classList.toggle("modalDialogActive", this.dialogStack.length > 0);

        // IMPORTANT: Attach element directly, otherwise double submit is possible
        this.update();
    }

    update() {
        if (this.domWatcher) {
            this.domWatcher.update(this.dialogStack.length > 0);
        }
    }

    closeDialog(dialog) {
        dialog.destroy();

        let index = -1;
        for (let i = 0; i < this.dialogStack.length; ++i) {
            if (this.dialogStack[i] === dialog) {
                index = i;
                break;
            }
        }
        window.assert(index >= 0, "Dialog not in dialog stack");
        this.dialogStack.splice(index, 1);

        if (this.dialogStack.length > 0) {
            // Show the dialog which was previously open
            this.dialogStack[this.dialogStack.length - 1].show();
        }

        document.body.classList.toggle("modalDialogActive", this.dialogStack.length > 0);
    }

    close() {
        for (let i = 0; i < this.dialogStack.length; ++i) {
            const dialog = this.dialogStack[i];
            dialog.destroy();
        }
        this.dialogStack = [];
    }

    cleanup() {
        super.cleanup();
        for (let i = 0; i < this.dialogStack.length; ++i) {
            this.dialogStack[i].destroy();
        }
        this.dialogStack = [];
        this.dialogParent = null;
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/notifications.js":
/*!************************************************!*\
  !*** ./src/js/game/hud/parts/notifications.js ***!
  \************************************************/
/*! exports provided: enumNotificationType, HUDNotifications */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumNotificationType", function() { return enumNotificationType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDNotifications", function() { return HUDNotifications; });
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../translations */ "./src/js/translations.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/config */ "./src/js/core/config.js");





/** @enum {string} */
const enumNotificationType = {
    saved: "saved",
    upgrade: "upgrade",
    success: "success",
};

const notificationDuration = 3;

class HUDNotifications extends _base_hud_part__WEBPACK_IMPORTED_MODULE_0__["BaseHUDPart"] {
    createElements(parent) {
        this.element = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(parent, "ingame_HUD_Notifications", [], ``);
    }

    initialize() {
        this.root.hud.signals.notification.add(this.onNotification, this);

        /** @type {Array<{ element: HTMLElement, expireAt: number}>} */
        this.notificationElements = [];

        // Automatic notifications
        this.root.signals.gameSaved.add(() =>
            this.onNotification(_translations__WEBPACK_IMPORTED_MODULE_2__["T"].ingame.notifications.gameSaved, enumNotificationType.saved)
        );
    }

    /**
     * @param {string} message
     * @param {enumNotificationType} type
     */
    onNotification(message, type) {
        const element = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(this.element, null, ["notification", "type-" + type], message);
        element.setAttribute("data-icon", "icons/notification_" + type + ".png");

        this.notificationElements.push({
            element,
            expireAt: this.root.time.realtimeNow() + notificationDuration,
        });
    }

    update() {
        const now = this.root.time.realtimeNow();
        for (let i = 0; i < this.notificationElements.length; ++i) {
            const handle = this.notificationElements[i];
            if (handle.expireAt <= now) {
                handle.element.remove();
                this.notificationElements.splice(i, 1);
            }
        }
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/pinned_shapes.js":
/*!************************************************!*\
  !*** ./src/js/game/hud/parts/pinned_shapes.js ***!
  \************************************************/
/*! exports provided: HUDPinnedShapes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDPinnedShapes", function() { return HUDPinnedShapes; });
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_click_detector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/click_detector */ "./src/js/core/click_detector.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _shape_definition__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shape_definition */ "./src/js/game/shape_definition.js");
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _upgrades__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../upgrades */ "./src/js/game/upgrades.js");
/* harmony import */ var _tutorial_goals__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../tutorial_goals */ "./src/js/game/tutorial_goals.js");








class HUDPinnedShapes extends _base_hud_part__WEBPACK_IMPORTED_MODULE_4__["BaseHUDPart"] {
    createElements(parent) {
        this.element = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(parent, "ingame_HUD_PinnedShapes", []);
    }

    serialize() {
        return {
            shapes: this.pinnedShapes,
        };
    }

    deserialize(data) {
        if (!data || !data.shapes || !Array.isArray(data.shapes)) {
            return "Invalid pinned shapes data";
        }
        this.pinnedShapes = data.shapes;
    }

    initialize() {
        /** @type {Array<{ key: string, goal: number }>} */
        this.pinnedShapes = [];

        /** @type {Array<{key: string, amountLabel: HTMLElement, lastRenderedValue: number, goal?: number, element: HTMLElement, detector?: ClickDetector}>} */
        this.handles = [];
        this.rerenderFull();

        this.root.signals.storyGoalCompleted.add(this.rerenderFull, this);
        this.root.signals.postLoadHook.add(this.rerenderFull, this);
        this.root.hud.signals.shapePinRequested.add(this.pinNewShape, this);
    }

    /**
     * Returns whether a given shape is pinned
     * @param {string} key
     */
    isShapePinned(key) {
        if (!this.pinnedShapes) {
            return false;
        }
        if (key === this.root.hubGoals.currentGoal.definition.getHash()) {
            return true;
        }
        if (key === _upgrades__WEBPACK_IMPORTED_MODULE_5__["blueprintShape"]) {
            return true;
        }

        for (let i = 0; i < this.pinnedShapes.length; ++i) {
            if (this.pinnedShapes[i].key === key) {
                return true;
            }
        }
        return false;
    }

    rerenderFull() {
        const currentGoal = this.root.hubGoals.currentGoal;
        const currentKey = currentGoal.definition.getHash();

        // First, remove old ones
        for (let i = 0; i < this.handles.length; ++i) {
            this.handles[i].element.remove();
            const detector = this.handles[i].detector;
            if (detector) {
                detector.cleanup();
            }
        }
        this.handles = [];

        this.internalPinShape(currentKey, currentGoal.required, false, "goal");

        if (this.root.hubGoals.isRewardUnlocked(_tutorial_goals__WEBPACK_IMPORTED_MODULE_6__["enumHubGoalRewards"].reward_blueprints)) {
            this.internalPinShape(_upgrades__WEBPACK_IMPORTED_MODULE_5__["blueprintShape"], null, false, "blueprint");
        }

        for (let i = 0; i < this.pinnedShapes.length; ++i) {
            const key = this.pinnedShapes[i].key;
            if (key !== currentKey) {
                this.internalPinShape(key, this.pinnedShapes[i].goal);
            }
        }
    }

    /**
     * Pins a shape
     * @param {string} key
     * @param {number} goal
     * @param {boolean} canUnpin
     * @param {string=} className
     */
    internalPinShape(key, goal, canUnpin = true, className = null) {
        const definition = this.root.shapeDefinitionMgr.getShapeFromShortKey(key);

        const element = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(this.element, null, ["shape"]);
        const canvas = definition.generateAsCanvas(120);
        element.appendChild(canvas);

        if (className) {
            element.classList.add(className);
        }

        let detector = null;
        if (canUnpin) {
            element.classList.add("unpinable");
            detector = new _core_click_detector__WEBPACK_IMPORTED_MODULE_1__["ClickDetector"](element, {
                consumeEvents: true,
                preventDefault: true,
            });
            detector.click.add(() => this.unpinShape(key));
        } else {
            element.classList.add("marked");
        }

        const amountLabel = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(element, null, ["amountLabel"], "");

        if (goal) {
            Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(element, null, ["goalLabel"], "/" + Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["formatBigNumber"])(goal));
        }

        this.handles.push({
            key,
            element,
            amountLabel,
            lastRenderedValue: -1,
            goal,
        });
    }

    update() {
        for (let i = 0; i < this.handles.length; ++i) {
            const handle = this.handles[i];

            const currentValue = this.root.hubGoals.getShapesStoredByKey(handle.key);
            if (currentValue !== handle.lastRenderedValue) {
                handle.lastRenderedValue = currentValue;
                let text = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["formatBigNumber"])(currentValue);
                if (handle.goal && currentValue >= handle.goal) {
                    text = "✓ " + text;
                    handle.element.classList.toggle("amountReached", true);
                }
                handle.amountLabel.innerText = text;
            }
        }
    }

    /**
     * Unpins a shape
     * @param {string} key
     */
    unpinShape(key) {
        for (let i = 0; i < this.pinnedShapes.length; ++i) {
            if (this.pinnedShapes[i].key === key) {
                this.pinnedShapes.splice(i, 1);
                this.rerenderFull();
                return;
            }
        }
    }

    /**
     * @param {ShapeDefinition} definition
     * @param {number} goal
     */
    pinNewShape(definition, goal) {
        const key = definition.getHash();
        if (key === this.root.hubGoals.currentGoal.definition.getHash()) {
            // Can not pin current goal
            return;
        }

        if (key === _upgrades__WEBPACK_IMPORTED_MODULE_5__["blueprintShape"]) {
            return;
        }

        for (let i = 0; i < this.pinnedShapes.length; ++i) {
            if (this.pinnedShapes[i].key === key) {
                // Already pinned
                this.pinnedShapes[i].goal = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_max"])(this.pinnedShapes[i].goal, goal);
                return;
            }
        }

        this.pinnedShapes.push({ key, goal });
        this.rerenderFull();
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/processing_overlay.js":
/*!*****************************************************!*\
  !*** ./src/js/game/hud/parts/processing_overlay.js ***!
  \*****************************************************/
/*! exports provided: HUDProcessingOverlay */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDProcessingOverlay", function() { return HUDProcessingOverlay; });
/* harmony import */ var _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dynamic_dom_attach */ "./src/js/game/hud/dynamic_dom_attach.js");
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_signal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/signal */ "./src/js/core/signal.js");
/* harmony import */ var _core_input_receiver__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/input_receiver */ "./src/js/core/input_receiver.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/logging */ "./src/js/core/logging.js");








const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_6__["createLogger"])("hud/processing_overlay");

class HUDProcessingOverlay extends _base_hud_part__WEBPACK_IMPORTED_MODULE_1__["BaseHUDPart"] {
    constructor(root) {
        super(root);
        this.tasks = [];
        this.computeTimeout = null;

        this.root.signals.performAsync.add(this.queueTask, this);

        this.allTasksFinished = new _core_signal__WEBPACK_IMPORTED_MODULE_4__["Signal"]();
        this.inputReceiver = new _core_input_receiver__WEBPACK_IMPORTED_MODULE_5__["InputReceiver"]("processing-overlay");

        this.root.signals.aboutToDestruct.add(() =>
            this.root.app.inputMgr.destroyReceiver(this.inputReceiver)
        );
    }

    createElements(parent) {
        this.element = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(
            parent,
            "rg_HUD_ProcessingOverlay",
            ["hudElement"],
            `
            <span class="prefab_LoadingTextWithAnim">
            Computing
            </span>
        `
        );
    }

    initialize() {
        this.domWatcher = new _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_0__["DynamicDomAttach"](this.root, this.element, {
            timeToKeepSeconds: 0,
        });
    }

    queueTask(task, name) {
        if (!this.root.gameInitialized) {
            // Tasks before the game started can be done directlry
            task();
            return;
        }
        task.__name = name;
        this.tasks.push(task);
    }

    hasTasks() {
        return this.tasks.length > 0;
    }

    isRunning() {
        return this.computeTimeout !== null;
    }

    processSync() {
        const now = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_2__["performanceNow"])();
        while (this.tasks.length > 0) {
            const workload = this.tasks[0];
            workload.call();
            this.tasks.shift();
        }
        const duration = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_2__["performanceNow"])() - now;
        if (duration > 100) {
            logger.log("Tasks done slow (SYNC!) within", (Object(_core_builtins__WEBPACK_IMPORTED_MODULE_2__["performanceNow"])() - now).toFixed(2), "ms");
        }
    }

    process() {
        this.root.app.inputMgr.makeSureAttachedAndOnTop(this.inputReceiver);

        this.domWatcher.update(true);
        if (this.tasks.length === 0) {
            logger.warn("No tasks but still called process");
            return;
        }

        if (this.computeTimeout) {
            window.assert(false, "Double compute queued");
            clearTimeout(this.computeTimeout);
        }

        this.computeTimeout = setTimeout(() => {
            const now = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_2__["performanceNow"])();
            while (this.tasks.length > 0) {
                const workload = this.tasks[0];
                workload.call();
                this.tasks.shift();
            }
            const duration = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_2__["performanceNow"])() - now;
            if (duration > 100) {
                logger.log("Tasks done slow within", (Object(_core_builtins__WEBPACK_IMPORTED_MODULE_2__["performanceNow"])() - now).toFixed(2), "ms");
            }

            this.domWatcher.update(false);

            this.root.app.inputMgr.makeSureDetached(this.inputReceiver);

            clearTimeout(this.computeTimeout);
            this.computeTimeout = null;

            this.allTasksFinished.dispatch();
        });
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/settings_menu.js":
/*!************************************************!*\
  !*** ./src/js/game/hud/parts/settings_menu.js ***!
  \************************************************/
/*! exports provided: HUDSettingsMenu */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDSettingsMenu", function() { return HUDSettingsMenu; });
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dynamic_dom_attach */ "./src/js/game/hud/dynamic_dom_attach.js");
/* harmony import */ var _core_input_receiver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/input_receiver */ "./src/js/core/input_receiver.js");
/* harmony import */ var _key_action_mapper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../key_action_mapper */ "./src/js/game/key_action_mapper.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../translations */ "./src/js/translations.js");
/* harmony import */ var _components_static_map_entity__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../components/static_map_entity */ "./src/js/game/components/static_map_entity.js");
/* harmony import */ var _components_item_processor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../components/item_processor */ "./src/js/game/components/item_processor.js");
/* harmony import */ var _components_belt__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../components/belt */ "./src/js/game/components/belt.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../core/config */ "./src/js/core/config.js");











class HUDSettingsMenu extends _base_hud_part__WEBPACK_IMPORTED_MODULE_0__["BaseHUDPart"] {
    createElements(parent) {
        this.background = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(parent, "ingame_HUD_SettingsMenu", ["ingameDialog"]);

        this.menuElement = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(this.background, null, ["menuElement"]);

        this.statsElement = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(
            this.background,
            null,
            ["statsElement"],
            `
            <strong>${_translations__WEBPACK_IMPORTED_MODULE_5__["T"].ingame.settingsMenu.beltsPlaced}</strong><span class="beltsPlaced"></span>
            <strong>${_translations__WEBPACK_IMPORTED_MODULE_5__["T"].ingame.settingsMenu.buildingsPlaced}</strong><span class="buildingsPlaced"></span>
            <strong>${_translations__WEBPACK_IMPORTED_MODULE_5__["T"].ingame.settingsMenu.playtime}</strong><span class="playtime"></span>
            
            `
        );

        this.buttonContainer = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(this.menuElement, null, ["buttons"]);

        const buttons = [
            {
                title: _translations__WEBPACK_IMPORTED_MODULE_5__["T"].ingame.settingsMenu.buttons.continue,
                action: () => this.close(),
            },
            {
                title: _translations__WEBPACK_IMPORTED_MODULE_5__["T"].ingame.settingsMenu.buttons.settings,
                action: () => this.goToSettings(),
            },
            {
                title: _translations__WEBPACK_IMPORTED_MODULE_5__["T"].ingame.settingsMenu.buttons.menu,
                action: () => this.returnToMenu(),
            },
        ];

        for (let i = 0; i < buttons.length; ++i) {
            const { title, action } = buttons[i];

            const element = document.createElement("button");
            element.classList.add("styledButton");
            element.innerText = title;
            this.buttonContainer.appendChild(element);

            this.trackClicks(element, action);
        }
    }

    returnToMenu() {
        // if (IS_DEMO) {
        //     const { cancel, deleteGame } = this.root.hud.parts.dialogs.showWarning(
        //         T.dialogs.leaveNotPossibleInDemo.title,
        //         T.dialogs.leaveNotPossibleInDemo.desc,
        //         ["cancel:good", "deleteGame:bad"]
        //     );
        //     deleteGame.add(() => this.root.gameState.goBackToMenu());
        // } else {
        this.root.gameState.goBackToMenu();
        // }
    }

    goToSettings() {
        this.root.gameState.goToSettings();
    }

    shouldPauseGame() {
        return this.visible;
    }

    shouldPauseRendering() {
        return this.visible;
    }

    initialize() {
        this.root.keyMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_4__["KEYMAPPINGS"].general.back).add(this.show, this);

        this.domAttach = new _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_2__["DynamicDomAttach"](this.root, this.background, {
            attachClass: "visible",
        });

        this.inputReciever = new _core_input_receiver__WEBPACK_IMPORTED_MODULE_3__["InputReceiver"]("settingsmenu");
        this.keyActionMapper = new _key_action_mapper__WEBPACK_IMPORTED_MODULE_4__["KeyActionMapper"](this.root, this.inputReciever);
        this.keyActionMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_4__["KEYMAPPINGS"].general.back).add(this.close, this);

        this.close();
    }

    cleanup() {
        document.body.classList.remove("ingameDialogOpen");
    }

    show() {
        this.visible = true;
        document.body.classList.add("ingameDialogOpen");
        // this.background.classList.add("visible");
        this.root.app.inputMgr.makeSureAttachedAndOnTop(this.inputReciever);

        const totalMinutesPlayed = Math.ceil(this.root.time.now() / 60);
        this.statsElement.querySelector(".playtime").innerText = _translations__WEBPACK_IMPORTED_MODULE_5__["T"].global.time.xMinutes.replace(
            "<x>",
            "" + totalMinutesPlayed
        );

        this.statsElement.querySelector(".buildingsPlaced").innerText = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["formatBigNumberFull"])(
            this.root.entityMgr.getAllWithComponent(_components_static_map_entity__WEBPACK_IMPORTED_MODULE_6__["StaticMapEntityComponent"]).length -
                this.root.entityMgr.getAllWithComponent(_components_belt__WEBPACK_IMPORTED_MODULE_8__["BeltComponent"]).length
        );
        this.statsElement.querySelector(".beltsPlaced").innerText = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["formatBigNumberFull"])(
            this.root.entityMgr.getAllWithComponent(_components_belt__WEBPACK_IMPORTED_MODULE_8__["BeltComponent"]).length
        );
    }

    close() {
        this.visible = false;
        document.body.classList.remove("ingameDialogOpen");
        this.root.app.inputMgr.makeSureDetached(this.inputReciever);
        this.update();
    }

    update() {
        this.domAttach.update(this.visible);
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/shop.js":
/*!***************************************!*\
  !*** ./src/js/game/hud/parts/shop.js ***!
  \***************************************/
/*! exports provided: HUDShop */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDShop", function() { return HUDShop; });
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_click_detector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/click_detector */ "./src/js/core/click_detector.js");
/* harmony import */ var _core_input_receiver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/input_receiver */ "./src/js/core/input_receiver.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../translations */ "./src/js/translations.js");
/* harmony import */ var _key_action_mapper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../key_action_mapper */ "./src/js/game/key_action_mapper.js");
/* harmony import */ var _upgrades__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../upgrades */ "./src/js/game/upgrades.js");
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dynamic_dom_attach */ "./src/js/game/hud/dynamic_dom_attach.js");










class HUDShop extends _base_hud_part__WEBPACK_IMPORTED_MODULE_7__["BaseHUDPart"] {
    createElements(parent) {
        this.background = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(parent, "ingame_HUD_Shop", ["ingameDialog"]);

        // DIALOG Inner / Wrapper
        this.dialogInner = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(this.background, null, ["dialogInner"]);
        this.title = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(this.dialogInner, null, ["title"], _translations__WEBPACK_IMPORTED_MODULE_4__["T"].ingame.shop.title);
        this.closeButton = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(this.title, null, ["closeButton"]);
        this.trackClicks(this.closeButton, this.close);
        this.contentDiv = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(this.dialogInner, null, ["content"]);

        this.upgradeToElements = {};

        // Upgrades
        for (const upgradeId in _upgrades__WEBPACK_IMPORTED_MODULE_6__["UPGRADES"]) {
            const handle = {};
            handle.requireIndexToElement = [];

            // Wrapper
            handle.elem = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(this.contentDiv, null, ["upgrade"]);
            handle.elem.setAttribute("data-upgrade-id", upgradeId);

            // Title
            const title = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(handle.elem, null, ["title"], _translations__WEBPACK_IMPORTED_MODULE_4__["T"].shopUpgrades[upgradeId].name);

            // Title > Tier
            handle.elemTierLabel = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(title, null, ["tier"]);

            // Icon
            handle.icon = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(handle.elem, null, ["icon"]);
            handle.icon.setAttribute("data-icon", "upgrades/" + upgradeId + ".png");

            // Description
            handle.elemDescription = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(handle.elem, null, ["description"], "??");
            handle.elemRequirements = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(handle.elem, null, ["requirements"]);

            // Buy button
            handle.buyButton = document.createElement("button");
            handle.buyButton.classList.add("buy", "styledButton");
            handle.buyButton.innerText = _translations__WEBPACK_IMPORTED_MODULE_4__["T"].ingame.shop.buttonUnlock;
            handle.elem.appendChild(handle.buyButton);

            this.trackClicks(handle.buyButton, () => this.tryUnlockNextTier(upgradeId));

            // Assign handle
            this.upgradeToElements[upgradeId] = handle;
        }
    }

    rerenderFull() {
        for (const upgradeId in this.upgradeToElements) {
            const handle = this.upgradeToElements[upgradeId];
            const { tiers } = _upgrades__WEBPACK_IMPORTED_MODULE_6__["UPGRADES"][upgradeId];

            const currentTier = this.root.hubGoals.getUpgradeLevel(upgradeId);
            const currentTierMultiplier = this.root.hubGoals.upgradeImprovements[upgradeId];
            const tierHandle = tiers[currentTier];

            // Set tier
            handle.elemTierLabel.innerText = _translations__WEBPACK_IMPORTED_MODULE_4__["T"].ingame.shop.tier.replace(
                "<x>",
                "" + _translations__WEBPACK_IMPORTED_MODULE_4__["T"].ingame.shop.tierLabels[currentTier]
            );

            handle.elemTierLabel.setAttribute("data-tier", currentTier);

            // Cleanup detectors
            for (let i = 0; i < handle.requireIndexToElement.length; ++i) {
                const requiredHandle = handle.requireIndexToElement[i];
                requiredHandle.container.remove();
                requiredHandle.pinDetector.cleanup();
            }

            // Cleanup
            handle.requireIndexToElement = [];

            handle.elem.classList.toggle("maxLevel", !tierHandle);

            if (!tierHandle) {
                // Max level
                handle.elemDescription.innerText = _translations__WEBPACK_IMPORTED_MODULE_4__["T"].ingame.shop.maximumLevel.replace(
                    "<currentMult>",
                    currentTierMultiplier.toString()
                );
                continue;
            }

            // Set description
            handle.elemDescription.innerText = _translations__WEBPACK_IMPORTED_MODULE_4__["T"].shopUpgrades[upgradeId].description
                .replace("<currentMult>", currentTierMultiplier.toString())
                .replace("<newMult>", (currentTierMultiplier + tierHandle.improvement).toString());

            tierHandle.required.forEach(({ shape, amount }) => {
                const container = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(handle.elemRequirements, null, ["requirement"]);

                const shapeDef = this.root.shapeDefinitionMgr.getShapeFromShortKey(shape);
                const shapeCanvas = shapeDef.generateAsCanvas(120);
                shapeCanvas.classList.add();
                container.appendChild(shapeCanvas);

                const progressContainer = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(container, null, ["amount"]);
                const progressBar = document.createElement("label");
                progressBar.classList.add("progressBar");
                progressContainer.appendChild(progressBar);

                const progressLabel = document.createElement("label");
                progressContainer.appendChild(progressLabel);

                const pinButton = document.createElement("button");
                pinButton.classList.add("pin");
                container.appendChild(pinButton);

                if (this.root.hud.parts.pinnedShapes.isShapePinned(shape)) {
                    pinButton.classList.add("alreadyPinned");
                }

                const pinDetector = new _core_click_detector__WEBPACK_IMPORTED_MODULE_1__["ClickDetector"](pinButton, {
                    consumeEvents: true,
                    preventDefault: true,
                });
                pinDetector.click.add(() => {
                    this.root.hud.signals.shapePinRequested.dispatch(shapeDef, amount);
                    pinButton.classList.add("pinned");
                });

                handle.requireIndexToElement.push({
                    container,
                    progressLabel,
                    progressBar,
                    definition: shapeDef,
                    required: amount,
                    pinDetector,
                });
            });
        }
    }

    renderCountsAndStatus() {
        for (const upgradeId in this.upgradeToElements) {
            const handle = this.upgradeToElements[upgradeId];
            for (let i = 0; i < handle.requireIndexToElement.length; ++i) {
                const { progressLabel, progressBar, definition, required } = handle.requireIndexToElement[i];

                const haveAmount = this.root.hubGoals.getShapesStored(definition);
                const progress = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_min"])(haveAmount / required, 1.0);

                progressLabel.innerText = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["formatBigNumber"])(haveAmount) + " / " + Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["formatBigNumber"])(required);
                progressBar.style.width = progress * 100.0 + "%";
                progressBar.classList.toggle("complete", progress >= 1.0);
            }

            handle.buyButton.classList.toggle("buyable", this.root.hubGoals.canUnlockUpgrade(upgradeId));
        }
    }

    initialize() {
        this.domAttach = new _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_8__["DynamicDomAttach"](this.root, this.background, {
            attachClass: "visible",
        });

        this.inputReciever = new _core_input_receiver__WEBPACK_IMPORTED_MODULE_2__["InputReceiver"]("shop");
        this.keyActionMapper = new _key_action_mapper__WEBPACK_IMPORTED_MODULE_5__["KeyActionMapper"](this.root, this.inputReciever);

        this.keyActionMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_5__["KEYMAPPINGS"].general.back).add(this.close, this);
        this.keyActionMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_5__["KEYMAPPINGS"].ingame.menuOpenShop).add(this.close, this);

        this.close();

        this.rerenderFull();
        this.root.signals.upgradePurchased.add(this.rerenderFull, this);
    }

    cleanup() {
        document.body.classList.remove("ingameDialogOpen");

        // Cleanup detectors
        for (const upgradeId in this.upgradeToElements) {
            const handle = this.upgradeToElements[upgradeId];
            for (let i = 0; i < handle.requireIndexToElement.length; ++i) {
                const requiredHandle = handle.requireIndexToElement[i];
                requiredHandle.container.remove();
                requiredHandle.pinDetector.cleanup();
            }
            handle.requireIndexToElement = [];
        }
    }

    show() {
        this.visible = true;
        document.body.classList.add("ingameDialogOpen");
        // this.background.classList.add("visible");
        this.root.app.inputMgr.makeSureAttachedAndOnTop(this.inputReciever);
        this.rerenderFull();
    }

    close() {
        this.visible = false;
        document.body.classList.remove("ingameDialogOpen");
        this.root.app.inputMgr.makeSureDetached(this.inputReciever);
        this.update();
    }

    update() {
        this.domAttach.update(this.visible);
        if (this.visible) {
            this.renderCountsAndStatus();
        }
    }

    tryUnlockNextTier(upgradeId) {
        // Nothing
        this.root.hubGoals.tryUnlockUgprade(upgradeId);
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/statistics.js":
/*!*********************************************!*\
  !*** ./src/js/game/hud/parts/statistics.js ***!
  \*********************************************/
/*! exports provided: HUDStatistics */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDStatistics", function() { return HUDStatistics; });
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_input_receiver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/input_receiver */ "./src/js/core/input_receiver.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _key_action_mapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../key_action_mapper */ "./src/js/game/key_action_mapper.js");
/* harmony import */ var _production_analytics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../production_analytics */ "./src/js/game/production_analytics.js");
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dynamic_dom_attach */ "./src/js/game/hud/dynamic_dom_attach.js");
/* harmony import */ var _statistics_handle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./statistics_handle */ "./src/js/game/hud/parts/statistics_handle.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../translations */ "./src/js/translations.js");










class HUDStatistics extends _base_hud_part__WEBPACK_IMPORTED_MODULE_5__["BaseHUDPart"] {
    createElements(parent) {
        this.background = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(parent, "ingame_HUD_Statistics", ["ingameDialog"]);

        // DIALOG Inner / Wrapper
        this.dialogInner = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(this.background, null, ["dialogInner"]);
        this.title = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(this.dialogInner, null, ["title"], _translations__WEBPACK_IMPORTED_MODULE_8__["T"].ingame.statistics.title);
        this.closeButton = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(this.title, null, ["closeButton"]);
        this.trackClicks(this.closeButton, this.close);

        this.filterHeader = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(this.dialogInner, null, ["filterHeader"]);
        this.sourceExplanation = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(this.dialogInner, null, ["sourceExplanation"]);

        this.filtersDataSource = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(this.filterHeader, null, ["filtersDataSource"]);
        this.filtersDisplayMode = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(this.filterHeader, null, ["filtersDisplayMode"]);

        const dataSources = [
            _production_analytics__WEBPACK_IMPORTED_MODULE_4__["enumAnalyticsDataSource"].produced,
            _production_analytics__WEBPACK_IMPORTED_MODULE_4__["enumAnalyticsDataSource"].delivered,
            _production_analytics__WEBPACK_IMPORTED_MODULE_4__["enumAnalyticsDataSource"].stored,
        ];

        for (let i = 0; i < dataSources.length; ++i) {
            const dataSource = dataSources[i];
            const button = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeButton"])(
                this.filtersDataSource,
                ["mode" + Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["capitalizeFirstLetter"])(dataSource)],
                _translations__WEBPACK_IMPORTED_MODULE_8__["T"].ingame.statistics.dataSources[dataSource].title
            );
            this.trackClicks(button, () => this.setDataSource(dataSource));
        }

        const buttonDisplayDetailed = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeButton"])(this.filtersDisplayMode, ["displayDetailed"]);
        const buttonDisplayIcons = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeButton"])(this.filtersDisplayMode, ["displayIcons"]);

        this.trackClicks(buttonDisplayIcons, () => this.setDisplayMode(_statistics_handle__WEBPACK_IMPORTED_MODULE_7__["enumDisplayMode"].icons));
        this.trackClicks(buttonDisplayDetailed, () => this.setDisplayMode(_statistics_handle__WEBPACK_IMPORTED_MODULE_7__["enumDisplayMode"].detailed));

        this.contentDiv = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(this.dialogInner, null, ["content"]);
    }

    /**
     * @param {enumAnalyticsDataSource} source
     */
    setDataSource(source) {
        this.dataSource = source;
        this.dialogInner.setAttribute("data-datasource", source);

        this.sourceExplanation.innerText = _translations__WEBPACK_IMPORTED_MODULE_8__["T"].ingame.statistics.dataSources[source].description;
        if (this.visible) {
            this.rerenderFull();
        }
    }

    /**
     * @param {enumDisplayMode} mode
     */
    setDisplayMode(mode) {
        this.displayMode = mode;
        this.dialogInner.setAttribute("data-displaymode", mode);
        if (this.visible) {
            this.rerenderFull();
        }
    }

    initialize() {
        this.domAttach = new _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_6__["DynamicDomAttach"](this.root, this.background, {
            attachClass: "visible",
        });

        this.inputReciever = new _core_input_receiver__WEBPACK_IMPORTED_MODULE_1__["InputReceiver"]("statistics");
        this.keyActionMapper = new _key_action_mapper__WEBPACK_IMPORTED_MODULE_3__["KeyActionMapper"](this.root, this.inputReciever);

        this.keyActionMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_3__["KEYMAPPINGS"].general.back).add(this.close, this);
        this.keyActionMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_3__["KEYMAPPINGS"].ingame.menuOpenStats).add(this.close, this);

        /** @type {Object.<string, HUDShapeStatisticsHandle>} */
        this.activeHandles = {};

        this.setDataSource(_production_analytics__WEBPACK_IMPORTED_MODULE_4__["enumAnalyticsDataSource"].produced);
        this.setDisplayMode(_statistics_handle__WEBPACK_IMPORTED_MODULE_7__["enumDisplayMode"].detailed);

        this.intersectionObserver = new IntersectionObserver(this.intersectionCallback.bind(this), {
            root: this.contentDiv,
        });

        this.lastFullRerender = 0;

        this.close();
        this.rerenderFull();
    }

    intersectionCallback(entries) {
        for (let i = 0; i < entries.length; ++i) {
            const entry = entries[i];
            const handle = this.activeHandles[entry.target.getAttribute("data-shape-key")];
            if (handle) {
                handle.setVisible(entry.intersectionRatio > 0);
            }
        }
    }

    cleanup() {
        document.body.classList.remove("ingameDialogOpen");
    }

    show() {
        this.visible = true;
        document.body.classList.add("ingameDialogOpen");
        this.root.app.inputMgr.makeSureAttachedAndOnTop(this.inputReciever);
        this.rerenderFull();
        this.update();
    }

    close() {
        this.visible = false;
        document.body.classList.remove("ingameDialogOpen");
        this.root.app.inputMgr.makeSureDetached(this.inputReciever);
        this.update();
    }

    update() {
        this.domAttach.update(this.visible);
        if (this.visible) {
            if (this.root.time.now() - this.lastFullRerender > 1) {
                this.lastFullRerender = this.root.time.now();
                this.lastPartialRerender = this.root.time.now();
                this.rerenderFull();
            }
            this.rerenderPartial();
        }
    }

    /**
     * Performs a partial rerender, only updating graphs and counts
     */
    rerenderPartial() {
        for (const key in this.activeHandles) {
            const handle = this.activeHandles[key];
            handle.update(this.displayMode, this.dataSource);
        }
    }

    /**
     * Performs a full rerender, regenerating everything
     */
    rerenderFull() {
        for (const key in this.activeHandles) {
            this.activeHandles[key].detach();
        }
        Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["removeAllChildren"])(this.contentDiv);

        // Now, attach new ones

        let entries = null;
        switch (this.dataSource) {
            case _production_analytics__WEBPACK_IMPORTED_MODULE_4__["enumAnalyticsDataSource"].stored: {
                entries = Object.entries(this.root.hubGoals.storedShapes);
                break;
            }
            case _production_analytics__WEBPACK_IMPORTED_MODULE_4__["enumAnalyticsDataSource"].produced:
            case _production_analytics__WEBPACK_IMPORTED_MODULE_4__["enumAnalyticsDataSource"].delivered: {
                entries = Object.entries(this.root.productionAnalytics.getCurrentShapeRates(this.dataSource));
                break;
            }
        }

        entries.sort((a, b) => b[1] - a[1]);

        let rendered = new Set();

        for (let i = 0; i < Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_min"])(entries.length, 200); ++i) {
            const entry = entries[i];
            const shapeKey = entry[0];

            let handle = this.activeHandles[shapeKey];
            if (!handle) {
                const definition = this.root.shapeDefinitionMgr.getShapeFromShortKey(shapeKey);
                handle = this.activeHandles[shapeKey] = new _statistics_handle__WEBPACK_IMPORTED_MODULE_7__["HUDShapeStatisticsHandle"](
                    this.root,
                    definition,
                    this.intersectionObserver
                );
            }

            rendered.add(shapeKey);
            handle.attach(this.contentDiv);
        }

        for (const key in this.activeHandles) {
            if (!rendered.has(key)) {
                this.activeHandles[key].destroy();
                delete this.activeHandles[key];
            }
        }

        if (entries.length === 0) {
            this.contentDiv.innerHTML = `
            <strong class="noEntries">${_translations__WEBPACK_IMPORTED_MODULE_8__["T"].ingame.statistics.noShapesProduced}</strong>`;
        }

        this.contentDiv.classList.toggle("hasEntries", entries.length > 0);
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/statistics_handle.js":
/*!****************************************************!*\
  !*** ./src/js/game/hud/parts/statistics_handle.js ***!
  \****************************************************/
/*! exports provided: enumDisplayMode, HUDShapeStatisticsHandle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumDisplayMode", function() { return enumDisplayMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDShapeStatisticsHandle", function() { return HUDShapeStatisticsHandle; });
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../root */ "./src/js/game/root.js");
/* harmony import */ var _shape_definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shape_definition */ "./src/js/game/shape_definition.js");
/* harmony import */ var _production_analytics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../production_analytics */ "./src/js/game/production_analytics.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_buffer_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/buffer_utils */ "./src/js/core/buffer_utils.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../translations */ "./src/js/translations.js");








/** @enum {string} */
const enumDisplayMode = {
    icons: "icons",
    detailed: "detailed",
};

/**
 * Simple wrapper for a shape definition within the shape statistics
 */
class HUDShapeStatisticsHandle {
    /**
     * @param {GameRoot} root
     * @param {ShapeDefinition} definition
     * @param {IntersectionObserver} intersectionObserver
     */
    constructor(root, definition, intersectionObserver) {
        this.definition = definition;
        this.root = root;
        this.intersectionObserver = intersectionObserver;

        this.visible = false;
    }

    initElement() {
        this.element = document.createElement("div");
        this.element.setAttribute("data-shape-key", this.definition.getHash());

        this.counter = document.createElement("span");
        this.counter.classList.add("counter");
        this.element.appendChild(this.counter);
    }

    /**
     * Sets whether the shape handle is visible currently
     * @param {boolean} visibility
     */
    setVisible(visibility) {
        if (visibility === this.visible) {
            return;
        }
        this.visible = visibility;
        if (visibility) {
            if (!this.shapeCanvas) {
                // Create elements
                this.shapeCanvas = this.definition.generateAsCanvas(100);
                this.shapeCanvas.classList.add("icon");
                this.element.appendChild(this.shapeCanvas);
            }
        } else {
            // Drop elements
            this.cleanupChildElements();
        }
    }

    /**
     *
     * @param {enumDisplayMode} displayMode
     * @param {enumAnalyticsDataSource} dataSource
     * @param {boolean=} forced
     */
    update(displayMode, dataSource, forced = false) {
        if (!this.element) {
            return;
        }
        if (!this.visible && !forced) {
            return;
        }

        switch (dataSource) {
            case _production_analytics__WEBPACK_IMPORTED_MODULE_2__["enumAnalyticsDataSource"].stored: {
                this.counter.innerText = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["formatBigNumber"])(
                    this.root.hubGoals.storedShapes[this.definition.getHash()] || 0
                );
                break;
            }
            case _production_analytics__WEBPACK_IMPORTED_MODULE_2__["enumAnalyticsDataSource"].delivered:
            case _production_analytics__WEBPACK_IMPORTED_MODULE_2__["enumAnalyticsDataSource"].produced: {
                let rate =
                    (this.root.productionAnalytics.getCurrentShapeRate(dataSource, this.definition) /
                        _core_config__WEBPACK_IMPORTED_MODULE_4__["globalConfig"].analyticsSliceDurationSeconds) *
                    60;
                this.counter.innerText = _translations__WEBPACK_IMPORTED_MODULE_6__["T"].ingame.statistics.shapesPerMinute.replace(
                    "<shapes>",
                    Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["formatBigNumber"])(rate)
                );
                break;
            }
        }

        if (displayMode === enumDisplayMode.detailed) {
            const graphDpi = _core_config__WEBPACK_IMPORTED_MODULE_4__["globalConfig"].statisticsGraphDpi;

            const w = 270;
            const h = 40;

            if (!this.graphCanvas) {
                const [canvas, context] = Object(_core_buffer_utils__WEBPACK_IMPORTED_MODULE_5__["makeOffscreenBuffer"])(w * graphDpi, h * graphDpi, {
                    smooth: true,
                    reusable: false,
                    label: "statgraph-" + this.definition.getHash(),
                });
                context.scale(graphDpi, graphDpi);
                canvas.classList.add("graph");
                this.graphCanvas = canvas;
                this.graphContext = context;
                this.element.appendChild(this.graphCanvas);
            }

            this.graphContext.clearRect(0, 0, w, h);

            this.graphContext.fillStyle = "#bee0db";
            this.graphContext.strokeStyle = "#66ccbc";
            this.graphContext.lineWidth = 1.5;

            const sliceWidth = w / (_core_config__WEBPACK_IMPORTED_MODULE_4__["globalConfig"].statisticsGraphSlices - 1);

            let values = [];
            let maxValue = 1;

            for (let i = 0; i < _core_config__WEBPACK_IMPORTED_MODULE_4__["globalConfig"].statisticsGraphSlices - 2; ++i) {
                const value = this.root.productionAnalytics.getPastShapeRate(
                    dataSource,
                    this.definition,
                    _core_config__WEBPACK_IMPORTED_MODULE_4__["globalConfig"].statisticsGraphSlices - i - 2
                );
                if (value > maxValue) {
                    maxValue = value;
                }
                values.push(value);
            }

            this.graphContext.beginPath();
            this.graphContext.moveTo(0.75, h + 5);
            for (let i = 0; i < values.length; ++i) {
                const yValue = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["clamp"])((1 - values[i] / maxValue) * h, 0.75, h - 0.75);
                const x = i * sliceWidth;
                if (i === 0) {
                    this.graphContext.lineTo(0.75, yValue);
                }
                this.graphContext.lineTo(x, yValue);
                if (i === values.length - 1) {
                    this.graphContext.lineTo(w + 100, yValue);
                    this.graphContext.lineTo(w + 100, h + 5);
                }
            }

            this.graphContext.closePath();
            this.graphContext.stroke();
            this.graphContext.fill();
        } else {
            if (this.graphCanvas) {
                this.graphCanvas.remove();
                delete this.graphCanvas;
                delete this.graphContext;
            }
        }
    }

    /**
     * Attaches the handle
     * @param {HTMLElement} parent
     */
    attach(parent) {
        if (!this.element) {
            this.initElement();
        }
        if (this.element.parentElement !== parent) {
            parent.appendChild(this.element);
            this.intersectionObserver.observe(this.element);
        }
    }

    /**
     * Detaches the handle
     */
    detach() {
        if (this.element && this.element.parentElement) {
            this.element.parentElement.removeChild(this.element);
            this.intersectionObserver.unobserve(this.element);
        }
    }

    /**
     * Cleans up all child elements
     */
    cleanupChildElements() {
        if (this.shapeCanvas) {
            this.shapeCanvas.remove();
            delete this.shapeCanvas;
        }

        if (this.graphCanvas) {
            this.graphCanvas.remove();
            delete this.graphCanvas;
            delete this.graphContext;
        }
    }

    /**
     * Destroys the handle
     */
    destroy() {
        this.cleanupChildElements();
        if (this.element) {
            this.intersectionObserver.unobserve(this.element);
            this.element.remove();
            delete this.element;

            // Remove handle
            delete this.counter;
        }
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/tutorial_hints.js":
/*!*************************************************!*\
  !*** ./src/js/game/hud/parts/tutorial_hints.js ***!
  \*************************************************/
/*! exports provided: HUDPartTutorialHints */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDPartTutorialHints", function() { return HUDPartTutorialHints; });
/* harmony import */ var _core_cachebust__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/cachebust */ "./src/js/core/cachebust.js");
/* harmony import */ var _core_input_receiver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/input_receiver */ "./src/js/core/input_receiver.js");
/* harmony import */ var _core_tracked_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/tracked_state */ "./src/js/core/tracked_state.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _key_action_mapper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../key_action_mapper */ "./src/js/game/key_action_mapper.js");
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dynamic_dom_attach */ "./src/js/game/hud/dynamic_dom_attach.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../translations */ "./src/js/translations.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../core/config */ "./src/js/core/config.js");










const tutorialVideos = [1, 2, 3, 4, 5, 6, 7, 9, 10, 11];

class HUDPartTutorialHints extends _base_hud_part__WEBPACK_IMPORTED_MODULE_5__["BaseHUDPart"] {
    createElements(parent) {
        this.element = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(
            parent,
            "ingame_HUD_TutorialHints",
            [],
            `
        <div class="header">
            <span>${_translations__WEBPACK_IMPORTED_MODULE_7__["T"].ingame.tutorialHints.title}</span>
            <button class="styledButton toggleHint">
                <span class="show">${_translations__WEBPACK_IMPORTED_MODULE_7__["T"].ingame.tutorialHints.showHint}</span>
                <span class="hide">${_translations__WEBPACK_IMPORTED_MODULE_7__["T"].ingame.tutorialHints.hideHint}</span>
            </button>
        </div>

        <video autoplay muted loop class="fullscreenBackgroundVideo">
            <source type="video/webm">
        </video>
        `
        );

        this.videoElement = this.element.querySelector("video");
    }

    shouldPauseGame() {
        return this.enlarged;
    }

    initialize() {
        this.trackClicks(this.element.querySelector(".toggleHint"), this.toggleHintEnlarged);

        this.videoAttach = new _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_6__["DynamicDomAttach"](this.root, this.videoElement, {
            timeToKeepSeconds: 0.3,
        });

        this.videoAttach.update(false);
        this.enlarged = false;

        this.inputReciever = new _core_input_receiver__WEBPACK_IMPORTED_MODULE_1__["InputReceiver"]("tutorial_hints");
        this.keyActionMapper = new _key_action_mapper__WEBPACK_IMPORTED_MODULE_4__["KeyActionMapper"](this.root, this.inputReciever);
        this.keyActionMapper.getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_4__["KEYMAPPINGS"].general.back).add(this.close, this);

        this.domAttach = new _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_6__["DynamicDomAttach"](this.root, this.element);

        this.currentShownLevel = new _core_tracked_state__WEBPACK_IMPORTED_MODULE_2__["TrackedState"](this.updateVideoUrl, this);

        this.root.signals.postLoadHook.add(() => {
            if (this.root.hubGoals.level === 1 && !( true && _core_config__WEBPACK_IMPORTED_MODULE_8__["globalConfig"].debug.disableTutorialHints)) {
                this.root.hud.parts.dialogs.showInfo(
                    _translations__WEBPACK_IMPORTED_MODULE_7__["T"].dialogs.hintDescription.title,
                    _translations__WEBPACK_IMPORTED_MODULE_7__["T"].dialogs.hintDescription.desc
                );
            }
        });
    }

    updateVideoUrl(level) {
        if (tutorialVideos.indexOf(level) < 0) {
            this.videoElement.querySelector("source").setAttribute("src", "");
            this.videoElement.pause();
        } else {
            this.videoElement
                .querySelector("source")
                .setAttribute("src", "https://static.shapez.io/tutorial_videos/level_" + level + ".webm");
            this.videoElement.currentTime = 0;
            this.videoElement.load();
        }
    }

    close() {
        this.enlarged = false;
        document.body.classList.remove("ingameDialogOpen");
        this.element.classList.remove("enlarged", "noBlur");
        this.root.app.inputMgr.makeSureDetached(this.inputReciever);
        this.update();
    }

    show() {
        this.root.app.analytics.trackUiClick("tutorial_hint_show");
        this.root.app.analytics.trackUiClick("tutorial_hint_show_lvl_" + this.root.hubGoals.level);

        document.body.classList.add("ingameDialogOpen");
        this.element.classList.add("enlarged", "noBlur");
        this.enlarged = true;
        this.root.app.inputMgr.makeSureAttachedAndOnTop(this.inputReciever);
        this.update();

        this.videoElement.currentTime = 0;
        this.videoElement.play();
    }

    update() {
        this.videoAttach.update(this.enlarged);

        this.currentShownLevel.set(this.root.hubGoals.level);

        const tutorialVisible = tutorialVideos.indexOf(this.root.hubGoals.level) >= 0;
        this.domAttach.update(tutorialVisible);
    }

    toggleHintEnlarged() {
        if (this.enlarged) {
            this.close();
        } else {
            this.show();
        }
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/unlock_notification.js":
/*!******************************************************!*\
  !*** ./src/js/game/hud/parts/unlock_notification.js ***!
  \******************************************************/
/*! exports provided: HUDUnlockNotification */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDUnlockNotification", function() { return HUDUnlockNotification; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/global_registries */ "./src/js/core/global_registries.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _platform_sound__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../platform/sound */ "./src/js/platform/sound.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../translations */ "./src/js/translations.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _tutorial_goals__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../tutorial_goals */ "./src/js/game/tutorial_goals.js");
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dynamic_dom_attach */ "./src/js/game/hud/dynamic_dom_attach.js");
/* harmony import */ var _tutorial_goals_mappings__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../tutorial_goals_mappings */ "./src/js/game/tutorial_goals_mappings.js");
/* harmony import */ var _core_input_receiver__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../core/input_receiver */ "./src/js/core/input_receiver.js");












class HUDUnlockNotification extends _base_hud_part__WEBPACK_IMPORTED_MODULE_7__["BaseHUDPart"] {
    initialize() {
        this.visible = false;

        this.domAttach = new _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_8__["DynamicDomAttach"](this.root, this.element, {
            timeToKeepSeconds: 0,
        });

        if (!( true && _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug.disableUnlockDialog)) {
            this.root.signals.storyGoalCompleted.add(this.showForLevel, this);
        }

        this.buttonShowTimeout = null;
    }

    createElements(parent) {
        this.inputReciever = new _core_input_receiver__WEBPACK_IMPORTED_MODULE_10__["InputReceiver"]("unlock-notification");

        this.element = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(parent, "ingame_HUD_UnlockNotification", []);

        const dialog = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(this.element, null, ["dialog"]);

        this.elemTitle = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(dialog, null, ["title"]);
        this.elemSubTitle = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(dialog, null, ["subTitle"], _translations__WEBPACK_IMPORTED_MODULE_4__["T"].ingame.levelCompleteNotification.completed);

        this.elemContents = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(dialog, null, ["contents"]);

        this.btnClose = document.createElement("button");
        this.btnClose.classList.add("close", "styledButton");
        this.btnClose.innerText = "Next level";
        dialog.appendChild(this.btnClose);

        this.trackClicks(this.btnClose, this.requestClose);
    }

    /**
     * @param {number} level
     * @param {enumHubGoalRewards} reward
     */
    showForLevel(level, reward) {
        this.root.app.inputMgr.makeSureAttachedAndOnTop(this.inputReciever);
        this.elemTitle.innerText = _translations__WEBPACK_IMPORTED_MODULE_4__["T"].ingame.levelCompleteNotification.levelTitle.replace(
            "<level>",
            ("" + level).padStart(2, "0")
        );

        const rewardName = _translations__WEBPACK_IMPORTED_MODULE_4__["T"].storyRewards[reward].title;

        let html = `
        <div class="rewardName">
            ${_translations__WEBPACK_IMPORTED_MODULE_4__["T"].ingame.levelCompleteNotification.unlockText.replace("<reward>", rewardName)}
        </div>
        
        <div class="rewardDesc">
            ${_translations__WEBPACK_IMPORTED_MODULE_4__["T"].storyRewards[reward].desc}
        </div>

        `;

        html += "<div class='images'>";
        const gained = _tutorial_goals_mappings__WEBPACK_IMPORTED_MODULE_9__["enumHubGoalRewardsToContentUnlocked"][reward];
        if (gained) {
            gained.forEach(([metaBuildingClass, variant]) => {
                const metaBuilding = _core_global_registries__WEBPACK_IMPORTED_MODULE_1__["gMetaBuildingRegistry"].findByClass(metaBuildingClass);
                html += `<div class="buildingExplanation" data-icon="building_tutorials/${
                    metaBuilding.getId() + (variant === _meta_building__WEBPACK_IMPORTED_MODULE_5__["defaultBuildingVariant"] ? "" : "-" + variant)
                }.png"></div>`;
            });
        }
        html += "</div>";

        this.elemContents.innerHTML = html;
        this.visible = true;
        this.root.soundProxy.playUi(_platform_sound__WEBPACK_IMPORTED_MODULE_3__["SOUNDS"].levelComplete);

        if (this.buttonShowTimeout) {
            clearTimeout(this.buttonShowTimeout);
        }

        this.element.querySelector("button.close").classList.remove("unlocked");

        if (this.root.app.settings.getAllSettings().offerHints) {
            this.buttonShowTimeout = setTimeout(
                () => this.element.querySelector("button.close").classList.add("unlocked"),
                 true ? 100 : undefined
            );
        } else {
            this.element.querySelector("button.close").classList.add("unlocked");
        }
    }

    cleanup() {
        this.root.app.inputMgr.makeSureDetached(this.inputReciever);
        if (this.buttonShowTimeout) {
            clearTimeout(this.buttonShowTimeout);
            this.buttonShowTimeout = null;
        }
    }

    requestClose() {
        this.root.app.adProvider.showVideoAd().then(() => {
            this.close();

            if (!this.root.app.settings.getAllSettings().offerHints) {
                return;
            }

            if (this.root.hubGoals.level === 3) {
                const { showUpgrades } = this.root.hud.parts.dialogs.showInfo(
                    _translations__WEBPACK_IMPORTED_MODULE_4__["T"].dialogs.upgradesIntroduction.title,
                    _translations__WEBPACK_IMPORTED_MODULE_4__["T"].dialogs.upgradesIntroduction.desc,
                    ["showUpgrades:good:timeout"]
                );
                showUpgrades.add(() => this.root.hud.parts.shop.show());
            }

            if (this.root.hubGoals.level === 5) {
                const { showKeybindings } = this.root.hud.parts.dialogs.showInfo(
                    _translations__WEBPACK_IMPORTED_MODULE_4__["T"].dialogs.keybindingsIntroduction.title,
                    _translations__WEBPACK_IMPORTED_MODULE_4__["T"].dialogs.keybindingsIntroduction.desc,
                    ["showKeybindings:misc", "ok:good:timeout"]
                );
                showKeybindings.add(() => this.root.gameState.goToKeybindings());
            }
        });
    }

    close() {
        this.root.app.inputMgr.makeSureDetached(this.inputReciever);
        if (this.buttonShowTimeout) {
            clearTimeout(this.buttonShowTimeout);
            this.buttonShowTimeout = null;
        }
        this.visible = false;
    }

    update() {
        this.domAttach.update(this.visible);
        if (!this.visible && this.buttonShowTimeout) {
            clearTimeout(this.buttonShowTimeout);
            this.buttonShowTimeout = null;
        }
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/vignette_overlay.js":
/*!***************************************************!*\
  !*** ./src/js/game/hud/parts/vignette_overlay.js ***!
  \***************************************************/
/*! exports provided: HUDVignetteOverlay */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDVignetteOverlay", function() { return HUDVignetteOverlay; });
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");



class HUDVignetteOverlay extends _base_hud_part__WEBPACK_IMPORTED_MODULE_0__["BaseHUDPart"] {
    createElements(parent) {
        this.element = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["makeDiv"])(parent, "ingame_VignetteOverlay");
    }

    initialize() {}
}


/***/ }),

/***/ "./src/js/game/hud/parts/watermark.js":
/*!********************************************!*\
  !*** ./src/js/game/hud/parts/watermark.js ***!
  \********************************************/
/*! exports provided: HUDWatermark */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDWatermark", function() { return HUDWatermark; });
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/config */ "./src/js/core/config.js");





class HUDWatermark extends _base_hud_part__WEBPACK_IMPORTED_MODULE_0__["BaseHUDPart"] {
    createElements(parent) {
        this.element = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["makeDiv"])(parent, "ingame_HUD_Watermark");
    }

    initialize() {
        this.trackClicks(this.element, this.onWatermarkClick);
    }

    onWatermarkClick() {
        this.root.app.analytics.trackUiClick("watermark_click");
        this.root.app.platformWrapper.openExternalLink(_core_config__WEBPACK_IMPORTED_MODULE_3__["THIRDPARTY_URLS"].standaloneStorePage);
    }

    /**
     *
     * @param {DrawParameters} parameters
     */
    drawOverlays(parameters) {
        const w = this.root.gameWidth;
        const x = 280 * this.root.app.getEffectiveUiScale();

        parameters.context.fillStyle = "#f77";
        parameters.context.font = "bold " + this.root.app.getEffectiveUiScale() * 17 + "px GameFont";
        // parameters.context.textAlign = "center";
        parameters.context.fillText("DEMO VERSION", x, this.root.app.getEffectiveUiScale() * 27);

        parameters.context.font = "bold " + this.root.app.getEffectiveUiScale() * 12 + "px GameFont";
        // parameters.context.textAlign = "center";
        parameters.context.fillText(
            "Please consider to buy the full version!",
            x,
            this.root.app.getEffectiveUiScale() * 45
        );

        // parameters.context.textAlign = "left";
    }
}


/***/ }),

/***/ "./src/js/game/hud/parts/waypoints.js":
/*!********************************************!*\
  !*** ./src/js/game/hud/parts/waypoints.js ***!
  \********************************************/
/*! exports provided: HUDWaypoints */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HUDWaypoints", function() { return HUDWaypoints; });
/* harmony import */ var _core_buffer_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/buffer_utils */ "./src/js/core/buffer_utils.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _core_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/loader */ "./src/js/core/loader.js");
/* harmony import */ var _core_modal_dialog_elements__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/modal_dialog_elements */ "./src/js/core/modal_dialog_elements.js");
/* harmony import */ var _core_modal_dialog_forms__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/modal_dialog_forms */ "./src/js/core/modal_dialog_forms.js");
/* harmony import */ var _core_rectangle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/rectangle */ "./src/js/core/rectangle.js");
/* harmony import */ var _core_signal__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../core/signal */ "./src/js/core/signal.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../translations */ "./src/js/translations.js");
/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../camera */ "./src/js/game/camera.js");
/* harmony import */ var _key_action_mapper__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../key_action_mapper */ "./src/js/game/key_action_mapper.js");
/* harmony import */ var _base_hud_part__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../base_hud_part */ "./src/js/game/hud/base_hud_part.js");
/* harmony import */ var _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../dynamic_dom_attach */ "./src/js/game/hud/dynamic_dom_attach.js");
/* harmony import */ var _notifications__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./notifications */ "./src/js/game/hud/parts/notifications.js");


















/** @typedef {{
 *   label: string,
 *   center: { x: number, y: number },
 *   zoomLevel: number,
 *   deletable: boolean
 * }} Waypoint */

class HUDWaypoints extends _base_hud_part__WEBPACK_IMPORTED_MODULE_14__["BaseHUDPart"] {
    createElements(parent) {
        if (this.root.app.settings.getAllSettings().offerHints) {
            this.hintElement = Object(_core_utils__WEBPACK_IMPORTED_MODULE_9__["makeDiv"])(
                parent,
                "ingame_HUD_Waypoints_Hint",
                [],
                `
            <strong class='title'>${_translations__WEBPACK_IMPORTED_MODULE_11__["T"].ingame.waypoints.waypoints}</strong>
            <span class='desc'>${_translations__WEBPACK_IMPORTED_MODULE_11__["T"].ingame.waypoints.description.replace(
                "<keybinding>",
                `<code class='keybinding'>${this.root.keyMapper
                    .getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_13__["KEYMAPPINGS"].navigation.createMarker)
                    .getKeyCodeString()}</code>`
            )}</span>
        `
            );
        }

        this.waypointSprite = _core_loader__WEBPACK_IMPORTED_MODULE_4__["Loader"].getSprite("sprites/misc/waypoint.png");

        this.waypointsListElement = Object(_core_utils__WEBPACK_IMPORTED_MODULE_9__["makeDiv"])(parent, "ingame_HUD_Waypoints", [], "Waypoints");
    }

    serialize() {
        return {
            waypoints: this.waypoints,
        };
    }

    deserialize(data) {
        if (!data || !data.waypoints || !Array.isArray(data.waypoints)) {
            return "Invalid waypoints data";
        }
        this.waypoints = data.waypoints;
        this.rerenderWaypointList();
    }

    rerenderWaypointList() {
        Object(_core_utils__WEBPACK_IMPORTED_MODULE_9__["removeAllChildren"])(this.waypointsListElement);
        this.cleanupClickDetectors();

        for (let i = 0; i < this.waypoints.length; ++i) {
            const waypoint = this.waypoints[i];

            const element = Object(_core_utils__WEBPACK_IMPORTED_MODULE_9__["makeDiv"])(this.waypointsListElement, null, ["waypoint"]);
            element.innerText = waypoint.label;

            if (waypoint.deletable) {
                const deleteButton = Object(_core_utils__WEBPACK_IMPORTED_MODULE_9__["makeDiv"])(element, null, ["deleteButton"]);
                this.trackClicks(deleteButton, () => this.deleteWaypoint(waypoint));
            }

            this.trackClicks(element, () => this.moveToWaypoint(waypoint), {
                targetOnly: true,
            });
        }
    }

    /**
     * @param {Waypoint} waypoint
     */
    moveToWaypoint(waypoint) {
        this.root.camera.setDesiredCenter(new _core_vector__WEBPACK_IMPORTED_MODULE_10__["Vector"](waypoint.center.x, waypoint.center.y));
        this.root.camera.setDesiredZoom(waypoint.zoomLevel);
    }

    /**
     * @param {Waypoint} waypoint
     */
    deleteWaypoint(waypoint) {
        Object(_core_utils__WEBPACK_IMPORTED_MODULE_9__["arrayDeleteValue"])(this.waypoints, waypoint);
        this.rerenderWaypointList();
    }

    initialize() {
        /** @type {Array<Waypoint>}
         */
        this.waypoints = [
            {
                label: _translations__WEBPACK_IMPORTED_MODULE_11__["T"].ingame.waypoints.hub,
                center: { x: 0, y: 0 },
                zoomLevel: 3,
                deletable: false,
            },
        ];

        this.dummyBuffer = Object(_core_buffer_utils__WEBPACK_IMPORTED_MODULE_0__["makeOffscreenBuffer"])(1, 1, {
            reusable: false,
            label: "waypoints-measure-canvas",
        })[1];

        this.root.camera.downPreHandler.add(this.onMouseDown, this);

        if (this.hintElement) {
            this.domAttach = new _dynamic_dom_attach__WEBPACK_IMPORTED_MODULE_15__["DynamicDomAttach"](this.root, this.hintElement);
        }

        this.root.keyMapper
            .getBinding(_key_action_mapper__WEBPACK_IMPORTED_MODULE_13__["KEYMAPPINGS"].navigation.createMarker)
            .add(this.requestCreateMarker, this);

        this.currentMarkerOpacity = 1;
        this.rerenderWaypointList();
    }

    /**
     * @param {Vector=} worldPos Override the world pos, otherwise it is the camera position
     */
    requestCreateMarker(worldPos = null) {
        if (_core_config__WEBPACK_IMPORTED_MODULE_2__["IS_DEMO"]) {
            this.root.hud.parts.dialogs.showFeatureRestrictionInfo(_translations__WEBPACK_IMPORTED_MODULE_11__["T"].demo.features.creatingMarkers);
            return;
        }

        const markerNameInput = new _core_modal_dialog_forms__WEBPACK_IMPORTED_MODULE_6__["FormElementInput"]({
            id: "markerName",
            label: null,
            placeholder: "",
            validator: val => val.length > 0 && val.length < 15,
        });

        const dialog = new _core_modal_dialog_elements__WEBPACK_IMPORTED_MODULE_5__["DialogWithForm"]({
            app: this.root.app,
            title: _translations__WEBPACK_IMPORTED_MODULE_11__["T"].dialogs.createMarker.title,
            desc: _translations__WEBPACK_IMPORTED_MODULE_11__["T"].dialogs.createMarker.desc,
            formElements: [markerNameInput],
        });

        this.root.hud.parts.dialogs.internalShowDialog(dialog);

        const center = worldPos || this.root.camera.center;

        dialog.buttonSignals.ok.add(() => {
            this.waypoints.push({
                label: markerNameInput.getValue(),
                center: { x: center.x, y: center.y },
                zoomLevel: Object(_core_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(this.root.camera.zoomLevel, _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].mapChunkOverviewMinZoom + 0.05),
                deletable: true,
            });
            this.waypoints.sort((a, b) => a.label.padStart(20, "0").localeCompare(b.label.padStart(20, "0")));
            this.root.hud.signals.notification.dispatch(
                _translations__WEBPACK_IMPORTED_MODULE_11__["T"].ingame.waypoints.creationSuccessNotification,
                _notifications__WEBPACK_IMPORTED_MODULE_16__["enumNotificationType"].success
            );
            this.rerenderWaypointList();
        });
    }

    update() {
        if (this.domAttach) {
            this.domAttach.update(this.root.camera.getIsMapOverlayActive());
        }
    }

    findCurrentIntersectedWaypoint() {
        const mousePos = this.root.app.mousePosition;
        if (!mousePos) {
            return;
        }

        if (!this.root.camera.getIsMapOverlayActive()) {
            return;
        }

        const scale = this.root.app.getEffectiveUiScale();

        this.dummyBuffer.font = "bold " + 12 * scale + "px GameFont";

        for (let i = 0; i < this.waypoints.length; ++i) {
            const waypoint = this.waypoints[i];
            const screenPos = this.root.camera.worldToScreen(
                new _core_vector__WEBPACK_IMPORTED_MODULE_10__["Vector"](waypoint.center.x, waypoint.center.y)
            );
            const intersectionRect = new _core_rectangle__WEBPACK_IMPORTED_MODULE_7__["Rectangle"](
                screenPos.x - 7 * scale,
                screenPos.y - 12 * scale,
                15 * scale + this.dummyBuffer.measureText(waypoint.label).width,
                15 * scale
            );
            if (intersectionRect.containsPoint(mousePos.x, mousePos.y)) {
                return waypoint;
            }
        }
    }

    /**
     *
     * @param {Vector} pos
     * @param {enumMouseButton} button
     */
    onMouseDown(pos, button) {
        const waypoint = this.findCurrentIntersectedWaypoint();
        if (waypoint) {
            if (button === _camera__WEBPACK_IMPORTED_MODULE_12__["enumMouseButton"].left) {
                this.root.soundProxy.playUiClick();
                this.moveToWaypoint(waypoint);
            } else if (button === _camera__WEBPACK_IMPORTED_MODULE_12__["enumMouseButton"].right) {
                if (waypoint.deletable) {
                    this.root.soundProxy.playUiClick();
                    this.deleteWaypoint(waypoint);
                } else {
                    this.root.soundProxy.playUiError();
                }
            }

            return _core_signal__WEBPACK_IMPORTED_MODULE_8__["STOP_PROPAGATION"];
        } else {
            // Allow right click to create a marker
            if (button === _camera__WEBPACK_IMPORTED_MODULE_12__["enumMouseButton"].right) {
                if (this.root.camera.getIsMapOverlayActive()) {
                    const worldPos = this.root.camera.screenToWorld(pos);
                    this.requestCreateMarker(worldPos);
                    return _core_signal__WEBPACK_IMPORTED_MODULE_8__["STOP_PROPAGATION"];
                }
            }
        }
    }

    /**
     *
     * @param {DrawParameters} parameters
     */
    draw(parameters) {
        const desiredOpacity = this.root.camera.getIsMapOverlayActive() ? 1 : 0;
        this.currentMarkerOpacity = Object(_core_utils__WEBPACK_IMPORTED_MODULE_9__["lerp"])(this.currentMarkerOpacity, desiredOpacity, 0.08);

        if (this.currentMarkerOpacity < 0.01) {
            return;
        }

        const selected = this.findCurrentIntersectedWaypoint();

        const scale = (1 / this.root.camera.zoomLevel) * this.root.app.getEffectiveUiScale();

        for (let i = 0; i < this.waypoints.length; ++i) {
            const waypoint = this.waypoints[i];

            const pos = waypoint.center;

            parameters.context.globalAlpha = this.currentMarkerOpacity * (selected === waypoint ? 1 : 0.7);

            const yOffset = -5 * scale;

            parameters.context.font = "bold " + 12 * scale + "px GameFont";

            parameters.context.fillStyle = "rgba(255, 255, 255, 0.7)";
            parameters.context.fillRect(
                pos.x - 7 * scale,
                pos.y - 12 * scale,
                15 * scale + this.dummyBuffer.measureText(waypoint.label).width / this.root.camera.zoomLevel,
                15 * scale
            );

            parameters.context.fillStyle = "#000";
            parameters.context.textAlign = "left";
            parameters.context.textBaseline = "middle";
            parameters.context.fillText(waypoint.label, pos.x + 6 * scale, pos.y + 0.5 * scale + yOffset);

            parameters.context.textBaseline = "alphabetic";
            parameters.context.textAlign = "left";

            this.waypointSprite.drawCentered(parameters.context, pos.x, pos.y + yOffset, 10 * scale);
        }
        parameters.context.globalAlpha = 1;
    }
}


/***/ }),

/***/ "./src/js/game/hud/trailer_maker.js":
/*!******************************************!*\
  !*** ./src/js/game/hud/trailer_maker.js ***!
  \******************************************/
/*! exports provided: TrailerMaker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrailerMaker", function() { return TrailerMaker; });
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../root */ "./src/js/game/root.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _trailer_points__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./trailer_points */ "./src/js/game/hud/trailer_points.js");
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/global_registries */ "./src/js/core/global_registries.js");
/* harmony import */ var _buildings_belt_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../buildings/belt_base */ "./src/js/game/buildings/belt_base.js");
/* harmony import */ var _components_miner__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../components/miner */ "./src/js/game/components/miner.js");






/* dev:start */





const tickrate = 1 / 165;

class TrailerMaker {
    /**
     *
     * @param {GameRoot} root
     */
    constructor(root) {
        this.root = root;

        this.markers = [];
        this.playbackMarkers = null;
        this.currentPlaybackOrigin = new _core_vector__WEBPACK_IMPORTED_MODULE_2__["Vector"]();
        this.currentPlaybackZoom = 3;

        window.addEventListener("keydown", ev => {
            if (ev.key === "j") {
                console.log("Record");
                this.markers.push({
                    pos: this.root.camera.center.copy(),
                    zoom: this.root.camera.zoomLevel,
                    time: 1,
                    wait: 0,
                });
            } else if (ev.key === "k") {
                console.log("Export");
                const json = JSON.stringify(this.markers);
                const handle = window.open("about:blank");
                handle.document.write(json);
            } else if (ev.key === "u") {
                if (this.playbackMarkers && this.playbackMarkers.length > 0) {
                    this.playbackMarkers = [];
                    return;
                }
                console.log("Playback");
                this.playbackMarkers = _trailer_points__WEBPACK_IMPORTED_MODULE_5__["default"].map(p => Object.assign({}, p));
                this.playbackMarkers.unshift(this.playbackMarkers[0]);
                this.currentPlaybackOrigin = _core_vector__WEBPACK_IMPORTED_MODULE_2__["Vector"].fromSerializedObject(this.playbackMarkers[0].pos);

                this.currentPlaybackZoom = this.playbackMarkers[0].zoom;
                this.root.camera.center = this.currentPlaybackOrigin.copy();
                this.root.camera.zoomLevel = this.currentPlaybackZoom;
                console.log("STart at", this.currentPlaybackOrigin);

                // this.root.entityMgr.getAllWithComponent(MinerComponent).forEach(miner => {
                //     miner.components.Miner.itemChainBuffer = [];
                //     miner.components.Miner.lastMiningTime = this.root.time.now() + 5;
                //     miner.components.ItemEjector.slots.forEach(slot => (slot.item = null));
                // });

                // this.root.logic.tryPlaceBuilding({
                //     origin: new Vector(-428, -15),
                //     building: gMetaBuildingRegistry.findByClass(MetaBeltBaseBuilding),
                //     originalRotation: 0,
                //     rotation: 0,
                //     variant: "default",
                //     rotationVariant: 0,
                // });

                // this.root.logic.tryPlaceBuilding({
                //     origin: new Vector(-427, -15),
                //     building: gMetaBuildingRegistry.findByClass(MetaBeltBaseBuilding),
                //     originalRotation: 0,
                //     rotation: 0,
                //     variant: "default",
                //     rotationVariant: 0,
                // });
            }
        });
    }

    update() {
        if (this.playbackMarkers && this.playbackMarkers.length > 0) {
            const nextMarker = this.playbackMarkers[0];

            if (!nextMarker.startTime) {
                console.log("Starting to approach", nextMarker.pos);
                nextMarker.startTime = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_3__["performanceNow"])() / 1000.0;
            }

            const speed =
                _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize *
                _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].beltSpeedItemsPerSecond *
                _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].itemSpacingOnBelts;
            // let time =
            //     this.currentPlaybackOrigin.distance(Vector.fromSerializedObject(nextMarker.pos)) / speed;
            const time = nextMarker.time;

            const progress = (Object(_core_builtins__WEBPACK_IMPORTED_MODULE_3__["performanceNow"])() / 1000.0 - nextMarker.startTime) / time;

            if (progress > 1.0) {
                if (nextMarker.wait > 0) {
                    nextMarker.wait -= tickrate;
                } else {
                    console.log("Approached");
                    this.currentPlaybackOrigin = this.root.camera.center.copy();
                    this.currentPlaybackZoom = this.root.camera.zoomLevel;
                    this.playbackMarkers.shift();
                }
                return;
            }

            const targetPos = _core_vector__WEBPACK_IMPORTED_MODULE_2__["Vector"].fromSerializedObject(nextMarker.pos);
            const targetZoom = nextMarker.zoom;

            const pos = Object(_core_vector__WEBPACK_IMPORTED_MODULE_2__["mixVector"])(this.currentPlaybackOrigin, targetPos, progress);
            const zoom = Object(_core_utils__WEBPACK_IMPORTED_MODULE_4__["lerp"])(this.currentPlaybackZoom, targetZoom, progress);
            this.root.camera.zoomLevel = zoom;
            this.root.camera.center = pos;
        }
    }
}

/* dev:end */


/***/ }),

/***/ "./src/js/game/hud/trailer_points.js":
/*!*******************************************!*\
  !*** ./src/js/game/hud/trailer_points.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ([
    // // initial
    // { pos: { x: -13665, y: -434 }, zoom: 6, time: 1, wait: 8 },

    // // Go up to first curve
    // { pos: { x: -13665, y: -580 }, zoom: 6, time: 1, wait: 0 },

    // // To balancers
    // { pos: { x: -13450, y: -580 }, zoom: 6, time: 1, wait: 0 },

    // // To cutters
    // { pos: { x: -13350, y: -580 }, zoom: 3, time: 1, wait: 2 },

    // // To initial cutters
    // { pos: { x: -12713, y: -580 }, zoom: 3, time: 1, wait: 2.5 },

    // // To rotaters 3,2,1,0
    // { pos: { x: -12402, y: -580 }, zoom: 3, time: 1, wait: 0 },

    // // Zoom in further to stackers
    // { pos: { x: -12045, y: -580 }, zoom: 6, time: 1, wait: 4 },

    // // Focus on painter
    // { pos: { x: -11700, y: -660 }, zoom: 6, time: 1, wait: 3.5 },

    // // Zoom in to mixers
    // { pos: { x: -11463, y: -520 }, zoom: 6, time: 1, wait: 3.8 },

    // // Focus to second painter
    // { pos: { x: -11290, y: -610 }, zoom: 6, time: 1, wait: 1 },

    // // Second stacker
    // { pos: { x: -11022, y: -610 }, zoom: 6, time: 1, wait: 0 },

    // // Go right until first curve
    // { pos: { x: -10859, y: -650 }, zoom: 6, time: 1, wait: 0 },

    // // Go up to stacker
    // { pos: { x: -10859, y: -1120 }, zoom: 6, time: 1, wait: 0 },

    // // Go further up
    // { pos: { x: -10859, y: -1260 }, zoom: 6, time: 1, wait: 0 },

    // // Go left
    // { pos: { x: -11235, y: -1260 }, zoom: 6, time: 1, wait: 1 },

    // OWO Savegames
    // { pos: { x: -4939.356940622392, y: 71.76431237675517 }, zoom: 5.06640625, time: 1, wait: 1 },
    // { pos: { x: -4275.441641063683, y: 26.3603982512193 }, zoom: 0.45, time: 32, wait: 0 },

    // Eve

    //     { pos: { x: -277.22574043554704, y: 2151.1873666983033 }, zoom: 3.1, time: 0, wait: 2 },
    //     { pos: { x: -43.64015426578788, y: 1577.5520572108883 }, zoom: 1.4, time: 16, wait: 0 },
    //     { pos: { x: 133.22735227708466, y: 957.2211413984563 }, zoom: 1.4, time: 8, wait: 0 },
    //     { pos: { x: 480.20365842184424, y: -313.5485044644265 }, zoom: 1.4, time: 8, wait: 0 },
    //     {
    //         pos: { x: 452.56528647804333, y: -1341.6422407571154 },
    //         zoom: 1.4,
    //         time: 8,
    //         wait: 0,
    //     },

    // D
    { pos: { x: -7506.562977380196, y: 1777.6671860680613 }, zoom: 2.3764616075569833, time: 0, wait: 1 },
    { pos: { x: -7506.562977380196, y: 1777.6671860680613 }, zoom: 2.3764616075569833, time: 1, wait: 0 },
    { pos: { x: -6592.471896026158, y: 1841.974816890533 }, zoom: 1.4594444847409322, time: 24, wait: 0 },
    { pos: { x: -7274.384090342281, y: 729.3783696229457 }, zoom: 1.4594444847409322, time: 24, wait: 0 },
    { pos: { x: -6048.006011617565, y: 764.6297752493597 }, zoom: 1.1853320776932916, time: 24, wait: 0 },
    {
        pos: { x: -3674.7204249483366, y: 658.6366426023269 },
        zoom: 0.25332031250000003,
        time: 24,
        wait: 0,
    },
    {
        pos: { x: -1213.9916574596728, y: -1387.1496772071198 },
        zoom: 0.443058809814453,
        time: 24,
        wait: 0,
    },
    {
        pos: { x: 1722.5210292405573, y: -2457.2072755163636 },
        zoom: 0.6313986260996299,
        time: 24,
        wait: 0,
    },
    { pos: { x: 3533.263459106946, y: -1806.6756300805193 }, zoom: 1.551908182277415, time: 24, wait: 0 },
]);


/***/ }),

/***/ "./src/js/game/item_registry.js":
/*!**************************************!*\
  !*** ./src/js/game/item_registry.js ***!
  \**************************************/
/*! exports provided: initItemRegistry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initItemRegistry", function() { return initItemRegistry; });
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/global_registries */ "./src/js/core/global_registries.js");
/* harmony import */ var _items_shape_item__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./items/shape_item */ "./src/js/game/items/shape_item.js");
/* harmony import */ var _items_color_item__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./items/color_item */ "./src/js/game/items/color_item.js");




function initItemRegistry() {
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gItemRegistry"].register(_items_shape_item__WEBPACK_IMPORTED_MODULE_1__["ShapeItem"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gItemRegistry"].register(_items_color_item__WEBPACK_IMPORTED_MODULE_2__["ColorItem"]);
}


/***/ }),

/***/ "./src/js/game/items/color_item.js":
/*!*****************************************!*\
  !*** ./src/js/game/items/color_item.js ***!
  \*****************************************/
/*! exports provided: ColorItem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorItem", function() { return ColorItem; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_dpi_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/dpi_manager */ "./src/js/core/dpi_manager.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../savegame/serialization */ "./src/js/savegame/serialization.js");
/* harmony import */ var _base_item__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base_item */ "./src/js/game/base_item.js");
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../colors */ "./src/js/game/colors.js");
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../theme */ "./src/js/game/theme.js");








class ColorItem extends _base_item__WEBPACK_IMPORTED_MODULE_4__["BaseItem"] {
    static getId() {
        return "color";
    }

    static getSchema() {
        return _savegame_serialization__WEBPACK_IMPORTED_MODULE_3__["types"].enum(_colors__WEBPACK_IMPORTED_MODULE_5__["enumColors"]);
    }

    serialize() {
        return this.color;
    }

    deserialize(data) {
        this.color = data;
    }

    /**
     * @param {enumColors} color
     */
    constructor(color) {
        super();
        this.color = color;
        this.bufferGenerator = null;
    }

    getBackgroundColorAsResource() {
        return _theme__WEBPACK_IMPORTED_MODULE_6__["THEME"].map.resources[this.color];
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {number} size
     * @param {DrawParameters} parameters
     */
    draw(x, y, parameters, size = 12) {
        if (!this.bufferGenerator) {
            this.bufferGenerator = this.internalGenerateColorBuffer.bind(this);
        }

        const dpi = Object(_core_dpi_manager__WEBPACK_IMPORTED_MODULE_1__["smoothenDpi"])(_core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].shapesSharpness * parameters.zoomLevel);

        const key = size + "/" + dpi;
        const canvas = parameters.root.buffers.getForKey(
            key,
            this.color,
            size,
            size,
            dpi,
            this.bufferGenerator
        );
        parameters.context.drawImage(canvas, x - size / 2, y - size / 2, size, size);
    }
    /**
     *
     * @param {HTMLCanvasElement} canvas
     * @param {CanvasRenderingContext2D} context
     * @param {number} w
     * @param {number} h
     * @param {number} dpi
     */
    internalGenerateColorBuffer(canvas, context, w, h, dpi) {
        context.translate((w * dpi) / 2, (h * dpi) / 2);
        context.scale((dpi * w) / 12, (dpi * h) / 12);

        context.fillStyle = _colors__WEBPACK_IMPORTED_MODULE_5__["enumColorsToHexCode"][this.color];
        context.strokeStyle = _theme__WEBPACK_IMPORTED_MODULE_6__["THEME"].items.outline;
        context.lineWidth = 2 * _theme__WEBPACK_IMPORTED_MODULE_6__["THEME"].items.outlineWidth;
        context.beginCircle(2, -1, 3);
        context.stroke();
        context.fill();
        context.beginCircle(-2, -1, 3);
        context.stroke();
        context.fill();
        context.beginCircle(0, 2, 3);
        context.closePath();
        context.stroke();
        context.fill();
    }
}


/***/ }),

/***/ "./src/js/game/items/shape_item.js":
/*!*****************************************!*\
  !*** ./src/js/game/items/shape_item.js ***!
  \*****************************************/
/*! exports provided: ShapeItem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeItem", function() { return ShapeItem; });
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../savegame/serialization */ "./src/js/savegame/serialization.js");
/* harmony import */ var _base_item__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base_item */ "./src/js/game/base_item.js");
/* harmony import */ var _shape_definition__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shape_definition */ "./src/js/game/shape_definition.js");
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../theme */ "./src/js/game/theme.js");






class ShapeItem extends _base_item__WEBPACK_IMPORTED_MODULE_2__["BaseItem"] {
    static getId() {
        return "shape";
    }

    static getSchema() {
        return _savegame_serialization__WEBPACK_IMPORTED_MODULE_1__["types"].string;
    }

    serialize() {
        return this.definition.getHash();
    }

    deserialize(data) {
        this.definition = _shape_definition__WEBPACK_IMPORTED_MODULE_3__["ShapeDefinition"].fromShortKey(data);
    }

    /**
     * @param {ShapeDefinition} definition
     */
    constructor(definition) {
        super();
        // logger.log("New shape item for shape definition", definition.generateId(), "created");

        /**
         * This property must not be modified on runtime, you have to clone the class in order to change the definition
         */
        this.definition = definition;
    }

    getBackgroundColorAsResource() {
        return _theme__WEBPACK_IMPORTED_MODULE_4__["THEME"].map.resources.shape;
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {DrawParameters} parameters
     * @param {number=} size
     */
    draw(x, y, parameters, size) {
        this.definition.draw(x, y, parameters, size);
    }
}


/***/ }),

/***/ "./src/js/game/key_action_mapper.js":
/*!******************************************!*\
  !*** ./src/js/game/key_action_mapper.js ***!
  \******************************************/
/*! exports provided: KEYMAPPINGS, getStringForKeyCode, Keybinding, KeyActionMapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KEYMAPPINGS", function() { return KEYMAPPINGS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStringForKeyCode", function() { return getStringForKeyCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Keybinding", function() { return Keybinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyActionMapper", function() { return KeyActionMapper; });
/* harmony import */ var _core_signal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/signal */ "./src/js/core/signal.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../translations */ "./src/js/translations.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");







function key(str) {
    return str.toUpperCase().charCodeAt(0);
}

const KEYMAPPINGS = {
    general: {
        confirm: { keyCode: 13 }, // enter
        back: { keyCode: 27, builtin: true }, // escape
    },

    ingame: {
        menuOpenShop: { keyCode: key("F") },
        menuOpenStats: { keyCode: key("G") },

        toggleHud: { keyCode: 113 }, // F2
        toggleFPSInfo: { keyCode: 115 }, // F1
    },

    navigation: {
        mapMoveUp: { keyCode: key("W") },
        mapMoveRight: { keyCode: key("D") },
        mapMoveDown: { keyCode: key("S") },
        mapMoveLeft: { keyCode: key("A") },

        centerMap: { keyCode: 32 }, // SPACE
        mapZoomIn: { keyCode: 187, repeated: true }, // "+"
        mapZoomOut: { keyCode: 189, repeated: true }, // "-"

        createMarker: { keyCode: key("M") },
    },

    buildings: {
        belt: { keyCode: key("1") },
        splitter: { keyCode: key("2") },
        underground_belt: { keyCode: key("3") },
        miner: { keyCode: key("4") },
        cutter: { keyCode: key("5") },
        rotater: { keyCode: key("6") },
        stacker: { keyCode: key("7") },
        mixer: { keyCode: key("8") },
        painter: { keyCode: key("9") },
        trash: { keyCode: key("0") },
        sorter: { keyCode: key("-") },
    },

    placement: {
        abortBuildingPlacement: { keyCode: key("Q") },
        rotateWhilePlacing: { keyCode: key("R") },
        rotateInverseModifier: { keyCode: 16 }, // SHIFT
        cycleBuildingVariants: { keyCode: key("T") },
        cycleBuildings: { keyCode: 9 }, // TAB
        pipette: { keyCode: key("Q") },
    },

    massSelect: {
        massSelectStart: { keyCode: 17 }, // CTRL
        massSelectSelectMultiple: { keyCode: 16 }, // SHIFT
        massSelectCopy: { keyCode: key("C") },
        confirmMassDelete: { keyCode: 46 }, // DEL
    },

    placementModifiers: {
        placementDisableAutoOrientation: { keyCode: 17 }, // CTRL
        placeMultiple: { keyCode: 16 }, // SHIFT
        placeInverse: { keyCode: 18 }, // ALT
    },
};

// Assign ids
for (const categoryId in KEYMAPPINGS) {
    for (const mappingId in KEYMAPPINGS[categoryId]) {
        KEYMAPPINGS[categoryId][mappingId].id = mappingId;
    }
}

/**
 * Returns a keycode -> string
 * @param {number} code
 * @returns {string}
 */
function getStringForKeyCode(code) {
    switch (code) {
        case 1:
            return "LMB";
        case 2:
            return "MMB";
        case 3:
            return "RMB";
        case 4:
            return "MB4";
        case 5:
            return "MB5";
        case 8:
            return "⌫";
        case 9:
            return _translations__WEBPACK_IMPORTED_MODULE_2__["T"].global.keys.tab;
        case 13:
            return "⏎";
        case 16:
            return "⇪";
        case 17:
            return _translations__WEBPACK_IMPORTED_MODULE_2__["T"].global.keys.control;
        case 18:
            return _translations__WEBPACK_IMPORTED_MODULE_2__["T"].global.keys.alt;
        case 19:
            return "PAUSE";
        case 20:
            return "CAPS";
        case 27:
            return _translations__WEBPACK_IMPORTED_MODULE_2__["T"].global.keys.escape;
        case 32:
            return _translations__WEBPACK_IMPORTED_MODULE_2__["T"].global.keys.space;
        case 33:
            return "PGUP";
        case 34:
            return "PGDOWN";
        case 35:
            return "END";
        case 36:
            return "HOME";
        case 37:
            return "⬅";
        case 38:
            return "⬆";
        case 39:
            return "➡";
        case 40:
            return "⬇";
        case 44:
            return "PRNT";
        case 45:
            return "INS";
        case 46:
            return "DEL";
        case 93:
            return "SEL";
        case 96:
            return "NUM 0";
        case 97:
            return "NUM 1";
        case 98:
            return "NUM 2";
        case 99:
            return "NUM 3";
        case 100:
            return "NUM 4";
        case 101:
            return "NUM 5";
        case 102:
            return "NUM 6";
        case 103:
            return "NUM 7";
        case 104:
            return "NUM 8";
        case 105:
            return "NUM 9";
        case 106:
            return "*";
        case 107:
            return "+";
        case 109:
            return "-";
        case 110:
            return ".";
        case 111:
            return "/";
        case 112:
            return "F1";
        case 113:
            return "F2";
        case 114:
            return "F3";
        case 115:
            return "F4";
        case 116:
            return "F4";
        case 117:
            return "F5";
        case 118:
            return "F6";
        case 119:
            return "F7";
        case 120:
            return "F8";
        case 121:
            return "F9";
        case 122:
            return "F10";
        case 123:
            return "F11";
        case 124:
            return "F12";

        case 144:
            return "NUMLOCK";
        case 145:
            return "SCRLOCK";
        case 182:
            return "COMP";
        case 183:
            return "CALC";
        case 186:
            return ";";
        case 187:
            return "+";
        case 188:
            return ",";
        case 189:
            return "-";
        case 191:
            return "/";
        case 219:
            return "[";
        case 220:
            return "\\";
        case 221:
            return "]";
        case 222:
            return "'";
    }

    // TODO
    return String.fromCharCode(code);
}

class Keybinding {
    /**
     *
     * @param {KeyActionMapper} keyMapper
     * @param {Application} app
     * @param {object} param0
     * @param {number} param0.keyCode
     * @param {number} param0.keyCode2
     * @param {boolean=} param0.builtin
     * @param {boolean=} param0.repeated
     */
    constructor(keyMapper, app, { keyCode, keyCode2 = 0, builtin = false, repeated = false }) {
        window.assert(keyCode && Number.isInteger(keyCode), "Invalid key code: " + keyCode);
        this.keyMapper = keyMapper;
        this.app = app;
        this.keyCode = keyCode;
        this.keyCode2 = keyCode2;
        this.builtin = builtin;
        this.repeated = repeated;

        this.signal = new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]();
        this.toggled = new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]();
    }

    /**
     * Returns whether this binding is currently pressed
     */
    isCurrentlyPressed() {
        // Check if the key is down
        if (this.app.inputMgr.keysDown.has(this.keyCode) || this.app.inputMgr.keysDown.has(this.keyCode2)) {
            // Check if it is the top reciever
            const reciever = this.keyMapper.inputReceiver;
            return this.app.inputMgr.getTopReciever() === reciever;
        }
    }

    /**
     * Adds an event listener
     * @param {function() : void} receiver
     * @param {object=} scope
     */
    add(receiver, scope = null) {
        this.signal.add(receiver, scope);
    }

    /**
     * @param {Element} elem
     * @returns {HTMLElement} the created element, or null if the keybindings are not shown
     *  */
    appendLabelToElement(elem) {
        if (_core_config__WEBPACK_IMPORTED_MODULE_1__["IS_MOBILE"]) {
            return null;
        }
        const spacer = document.createElement("code");
        spacer.classList.add("keybinding");
        spacer.innerHTML = getStringForKeyCode(this.keyCode);
        elem.appendChild(spacer);
        return spacer;
    }

    /**
     * Returns the key code as a nice string
     */
    getKeyCodeString() {
        return getStringForKeyCode(this.keyCode);
    }
    getKeyCodeString2() {
        return getStringForKeyCode(this.keyCode2);
    }

    /**
     * Remvoes all signal receivers
     */
    clearSignalReceivers() {
        this.signal.removeAll();
    }
}

class KeyActionMapper {
    /**
     *
     * @param {GameRoot} root
     * @param {InputReceiver} inputReciever
     */
    constructor(root, inputReciever) {
        this.root = root;
        this.inputReceiver = inputReciever;

        inputReciever.keydown.add(this.handleKeydown, this);
        inputReciever.keyup.add(this.handleKeyup, this);

        /** @type {Object.<string, Keybinding>} */
        this.keybindings = {};

        const overrides = root.app.settings.getKeybindingOverrides();

        for (const category in KEYMAPPINGS) {
            for (const key in KEYMAPPINGS[category]) {
                let payload = Object.assign({}, KEYMAPPINGS[category][key]);
                if (overrides[key]) {
                    payload.keyCode = overrides[key];
                }
                if (overrides[key + "_2"]) {
                    payload.keyCode2 = overrides[key + "_2"];
                }

                this.keybindings[key] = new Keybinding(this, this.root.app, payload);
            }
        }

        inputReciever.pageBlur.add(this.onPageBlur, this);
        inputReciever.destroyed.add(this.cleanup, this);
    }

    /**
     * Returns all keybindings starting with the given id
     * @param {string} pattern
     * @returns {Array<Keybinding>}
     */
    getKeybindingsStartingWith(pattern) {
        let result = [];
        for (const key in this.keybindings) {
            if (key.startsWith(pattern)) {
                result.push(this.keybindings[key]);
            }
        }
        return result;
    }

    /**
     * Forwards the given events to the other mapper (used in tooltips)
     * @param {KeyActionMapper} receiver
     * @param {Array<string>} bindings
     */
    forward(receiver, bindings) {
        for (let i = 0; i < bindings.length; ++i) {
            const key = bindings[i];
            this.keybindings[key].signal.add((...args) => receiver.keybindings[key].signal.dispatch(...args));
        }
    }

    cleanup() {
        for (const key in this.keybindings) {
            this.keybindings[key].signal.removeAll();
        }
    }

    onPageBlur() {
        // Reset all down states
        // Find mapping
        for (const key in this.keybindings) {
            /** @type {Keybinding} */
            const binding = this.keybindings[key];
        }
    }

    /**
     * Internal keydown handler
     * @param {object} param0
     * @param {number} param0.keyCode
     * @param {boolean} param0.shift
     * @param {boolean} param0.alt
     * @param {boolean=} param0.initial
     */
    handleKeydown({ keyCode, shift, alt, initial }) {
        let stop = false;

        // Find mapping
        for (const key in this.keybindings) {
            /** @type {Keybinding} */
            const binding = this.keybindings[key];
            if (
                (binding.keyCode === keyCode || binding.keyCode2 == keyCode) &&
                (initial || binding.repeated)
            ) {
                /** @type {Signal} */
                const signal = this.keybindings[key].signal;
                if (signal.dispatch() === _core_signal__WEBPACK_IMPORTED_MODULE_0__["STOP_PROPAGATION"]) {
                    return;
                }
            }
        }

        if (stop) {
            return _core_signal__WEBPACK_IMPORTED_MODULE_0__["STOP_PROPAGATION"];
        }
    }

    /**
     * Internal keyup handler
     * @param {object} param0
     * @param {number} param0.keyCode
     * @param {boolean} param0.shift
     * @param {boolean} param0.alt
     */
    handleKeyup({ keyCode, shift, alt }) {
        // Empty
    }

    /**
     * Returns a given keybinding
     * @param {{ keyCode: number }} binding
     * @returns {Keybinding}
     */
    getBinding(binding) {
        // @ts-ignore
        const id = binding.id;
        window.assert(id, "Not a valid keybinding: " + Object(_core_builtins__WEBPACK_IMPORTED_MODULE_3__["JSON_stringify"])(binding));
        window.assert(this.keybindings[id], "Keybinding " + id + " not known!");
        return this.keybindings[id];
    }
}


/***/ }),

/***/ "./src/js/game/logic.js":
/*!******************************!*\
  !*** ./src/js/game/logic.js ***!
  \******************************/
/*! exports provided: GameLogic */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameLogic", function() { return GameLogic; });
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./root */ "./src/js/game/root.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./entity */ "./src/js/game/entity.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _components_static_map_entity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/static_map_entity */ "./src/js/game/components/static_map_entity.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _buildings_belt_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./buildings/belt_base */ "./src/js/game/buildings/belt_base.js");
/* harmony import */ var _platform_sound__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../platform/sound */ "./src/js/platform/sound.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");












const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_6__["createLogger"])("ingame/logic");

/**
 * Typing helper
 * @typedef {Array<{
 *  entity: Entity,
 *  slot: import("./components/item_ejector").ItemEjectorSlot,
 *  fromTile: Vector,
 *  toDirection: enumDirection
 * }>} EjectorsAffectingTile
 */

/**
 * Typing helper
 * @typedef {Array<{
 *  entity: Entity,
 *  slot: import("./components/item_acceptor").ItemAcceptorSlot,
 *  toTile: Vector,
 *  fromDirection: enumDirection
 * }>} AcceptorsAffectingTile
 */

/**
 * @typedef {{
 *     acceptors: AcceptorsAffectingTile,
 *     ejectors: EjectorsAffectingTile
 * }} AcceptorsAndEjectorsAffectingTile
 */

class GameLogic {
    /**
     *
     * @param {GameRoot} root
     */
    constructor(root) {
        this.root = root;
    }

    /**
     * @param {object} param0
     * @param {Vector} param0.origin
     * @param {number} param0.rotation
     * @param {number} param0.rotationVariant
     * @param {string} param0.variant
     * @param {MetaBuilding} param0.building
     * @returns {boolean}
     */
    isAreaFreeToBuild({ origin, rotation, rotationVariant, variant, building }) {
        const checker = new _components_static_map_entity__WEBPACK_IMPORTED_MODULE_4__["StaticMapEntityComponent"]({
            origin,
            tileSize: building.getDimensions(variant),
            rotation,
            blueprintSpriteKey: "",
        });

        const rect = checker.getTileSpaceBounds();

        for (let x = rect.x; x < rect.x + rect.w; ++x) {
            for (let y = rect.y; y < rect.y + rect.h; ++y) {
                const contents = this.root.map.getTileContentXY(x, y);
                if (contents) {
                    if (
                        !this.checkCanReplaceBuilding({
                            original: contents,
                            origin,
                            building,
                            rotation,
                            rotationVariant,
                        })
                    ) {
                        // Content already has same rotation
                        return false;
                    }
                }
            }
        }
        return true;
    }

    /**
     * Checks if the given building can be replaced by another
     * @param {object} param0
     * @param {Entity} param0.original
     * @param {Vector} param0.origin
     * @param {number} param0.rotation
     * @param {number} param0.rotationVariant
     * @param {MetaBuilding} param0.building
     * @returns {boolean}
     */
    checkCanReplaceBuilding({ original, origin, building, rotation, rotationVariant }) {
        if (!original.components.ReplaceableMapEntity) {
            // Can not get replaced at all
            return false;
        }

        const staticComp = original.components.StaticMapEntity;
        window.assert(staticComp, "Building is not static");
        const beltComp = original.components.Belt;
        if (beltComp && building instanceof _buildings_belt_base__WEBPACK_IMPORTED_MODULE_7__["MetaBeltBaseBuilding"]) {
            // Its a belt, check if it differs in either rotation or rotation variant
            if (staticComp.rotation !== rotation) {
                return true;
            }
            if (beltComp.direction !== _buildings_belt_base__WEBPACK_IMPORTED_MODULE_7__["arrayBeltVariantToRotation"][rotationVariant]) {
                return true;
            }
        }

        return true;
    }

    /**
     * @param {object} param0
     * @param {Vector} param0.origin
     * @param {number} param0.rotation
     * @param {number} param0.rotationVariant
     * @param {string} param0.variant
     * @param {MetaBuilding} param0.building
     */
    checkCanPlaceBuilding({ origin, rotation, rotationVariant, variant, building }) {
        if (!building.getIsUnlocked(this.root)) {
            return false;
        }

        return this.isAreaFreeToBuild({
            origin,
            rotation,
            rotationVariant,
            variant,
            building,
        });
    }

    /**
     *
     * @param {object} param0
     * @param {Vector} param0.origin
     * @param {number} param0.rotation
     * @param {number} param0.originalRotation
     * @param {number} param0.rotationVariant
     * @param {string} param0.variant
     * @param {MetaBuilding} param0.building
     */
    tryPlaceBuilding({ origin, rotation, rotationVariant, originalRotation, variant, building }) {
        if (this.checkCanPlaceBuilding({ origin, rotation, rotationVariant, variant, building })) {
            // Remove any removeable entities below
            const checker = new _components_static_map_entity__WEBPACK_IMPORTED_MODULE_4__["StaticMapEntityComponent"]({
                origin,
                tileSize: building.getDimensions(variant),
                rotation,
                blueprintSpriteKey: "",
            });

            const rect = checker.getTileSpaceBounds();

            for (let x = rect.x; x < rect.x + rect.w; ++x) {
                for (let y = rect.y; y < rect.y + rect.h; ++y) {
                    const contents = this.root.map.getTileContentXY(x, y);
                    if (contents) {
                        if (!this.tryDeleteBuilding(contents)) {
                            logger.error("Building has replaceable component but is also unremovable");
                            return false;
                        }
                    }
                }
            }

            building.createAndPlaceEntity({
                root: this.root,
                origin,
                rotation,
                rotationVariant,
                originalRotation,
                variant,
            });

            this.root.soundProxy.playUi(building.getPlacementSound());

            return true;
        }
        return false;
    }

    /**
     * Performs a bulk operation, not updating caches in the meantime
     * @param {function} operation
     */
    performBulkOperation(operation) {
        logger.log("Running bulk operation ...");
        window.assert(!this.root.bulkOperationRunning, "Can not run two bulk operations twice");
        this.root.bulkOperationRunning =  true && !_core_config__WEBPACK_IMPORTED_MODULE_10__["globalConfig"].debug.disableBulkOperations;
        const now = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_5__["performanceNow"])();
        const returnValue = operation();
        const duration = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_5__["performanceNow"])() - now;
        logger.log("Done in", Object(_core_utils__WEBPACK_IMPORTED_MODULE_9__["round2Digits"])(duration), "ms");
        window.assert(
            this.root.bulkOperationRunning || _core_config__WEBPACK_IMPORTED_MODULE_10__["globalConfig"].debug.disableBulkOperations,
            "Bulk operation = false while bulk operation was running"
        );
        this.root.bulkOperationRunning = false;
        this.root.signals.bulkOperationFinished.dispatch();
        return returnValue;
    }

    /**
     * Returns whether the given building can get removed
     * @param {Entity} building
     */
    canDeleteBuilding(building) {
        return building.components.StaticMapEntity && !building.components.Unremovable;
    }

    /**
     * Tries to delete the given building
     * @param {Entity} building
     */
    tryDeleteBuilding(building) {
        if (!this.canDeleteBuilding(building)) {
            return false;
        }
        this.root.map.removeStaticEntity(building);
        this.root.entityMgr.destroyEntity(building);
        return true;
    }

    /**
     * Returns the acceptors and ejectors which affect the current tile
     * @param {Vector} tile
     * @returns {AcceptorsAndEjectorsAffectingTile}
     */
    getEjectorsAndAcceptorsAtTile(tile) {
        /** @type {EjectorsAffectingTile} */
        let ejectors = [];
        /** @type {AcceptorsAffectingTile} */
        let acceptors = [];

        for (let dx = -1; dx <= 1; ++dx) {
            for (let dy = -1; dy <= 1; ++dy) {
                if (Object(_core_builtins__WEBPACK_IMPORTED_MODULE_5__["Math_abs"])(dx) + Object(_core_builtins__WEBPACK_IMPORTED_MODULE_5__["Math_abs"])(dy) !== 1) {
                    continue;
                }

                const entity = this.root.map.getTileContentXY(tile.x + dx, tile.y + dy);
                if (entity) {
                    const staticComp = entity.components.StaticMapEntity;
                    const itemEjector = entity.components.ItemEjector;
                    if (itemEjector) {
                        for (let ejectorSlot = 0; ejectorSlot < itemEjector.slots.length; ++ejectorSlot) {
                            const slot = itemEjector.slots[ejectorSlot];
                            const wsTile = staticComp.localTileToWorld(slot.pos);
                            const wsDirection = staticComp.localDirectionToWorld(slot.direction);
                            const targetTile = wsTile.add(_core_vector__WEBPACK_IMPORTED_MODULE_2__["enumDirectionToVector"][wsDirection]);
                            if (targetTile.equals(tile)) {
                                ejectors.push({
                                    entity,
                                    slot,
                                    fromTile: wsTile,
                                    toDirection: wsDirection,
                                });
                            }
                        }
                    }

                    const itemAcceptor = entity.components.ItemAcceptor;
                    if (itemAcceptor) {
                        for (let acceptorSlot = 0; acceptorSlot < itemAcceptor.slots.length; ++acceptorSlot) {
                            const slot = itemAcceptor.slots[acceptorSlot];
                            const wsTile = staticComp.localTileToWorld(slot.pos);
                            for (let k = 0; k < slot.directions.length; ++k) {
                                const direction = slot.directions[k];
                                const wsDirection = staticComp.localDirectionToWorld(direction);

                                const sourceTile = wsTile.add(_core_vector__WEBPACK_IMPORTED_MODULE_2__["enumDirectionToVector"][wsDirection]);
                                if (sourceTile.equals(tile)) {
                                    acceptors.push({
                                        entity,
                                        slot,
                                        toTile: wsTile,
                                        fromDirection: wsDirection,
                                    });
                                }
                            }
                        }
                    }
                }
            }
        }
        return { ejectors, acceptors };
    }
}


/***/ }),

/***/ "./src/js/game/map.js":
/*!****************************!*\
  !*** ./src/js/game/map.js ***!
  \****************************/
/*! exports provided: BaseMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseMap", function() { return BaseMap; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./entity */ "./src/js/game/entity.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _base_item__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base_item */ "./src/js/game/base_item.js");
/* harmony import */ var _map_chunk_view__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./map_chunk_view */ "./src/js/game/map_chunk_view.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../savegame/serialization */ "./src/js/savegame/serialization.js");












const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_4__["createLogger"])("map");

class BaseMap extends _savegame_serialization__WEBPACK_IMPORTED_MODULE_8__["BasicSerializableObject"] {
    static getId() {
        return "Map";
    }

    static getSchema() {
        return {
            seed: _savegame_serialization__WEBPACK_IMPORTED_MODULE_8__["types"].uint,
        };
    }

    /**
     *
     * @param {GameRoot} root
     */
    constructor(root) {
        super();
        this.root = root;

        this.seed = 0;

        /**
         * Mapping of 'X|Y' to chunk
         * @type {Map<string, MapChunkView>} */
        this.chunksById = new Map();
    }

    /**
     * Returns the given chunk by index
     * @param {number} chunkX
     * @param {number} chunkY
     */
    getChunk(chunkX, chunkY, createIfNotExistent = false) {
        // TODO: Better generation
        const chunkIdentifier = chunkX + "|" + chunkY;
        let storedChunk;

        if ((storedChunk = this.chunksById.get(chunkIdentifier))) {
            return storedChunk;
        }

        if (createIfNotExistent) {
            const instance = new _map_chunk_view__WEBPACK_IMPORTED_MODULE_6__["MapChunkView"](this.root, chunkX, chunkY);
            this.chunksById.set(chunkIdentifier, instance);
            return instance;
        }

        return null;
    }

    /**
     * Gets or creates a new chunk if not existent for the given tile
     * @param {number} tileX
     * @param {number} tileY
     * @returns {MapChunkView}
     */
    getOrCreateChunkAtTile(tileX, tileY) {
        const chunkX = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_3__["Math_floor"])(tileX / _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].mapChunkSize);
        const chunkY = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_3__["Math_floor"])(tileY / _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].mapChunkSize);
        return this.getChunk(chunkX, chunkY, true);
    }

    /**
     * Gets a chunk if not existent for the given tile
     * @param {number} tileX
     * @param {number} tileY
     * @returns {MapChunkView?}
     */
    getChunkAtTileOrNull(tileX, tileY) {
        const chunkX = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_3__["Math_floor"])(tileX / _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].mapChunkSize);
        const chunkY = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_3__["Math_floor"])(tileY / _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].mapChunkSize);
        return this.getChunk(chunkX, chunkY, false);
    }

    /**
     * Checks if a given tile is within the map bounds
     * @param {Vector} tile
     * @returns {boolean}
     */
    isValidTile(tile) {
        if ( true && !_core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug.disableInternalCheckTile) {
            window.assert(tile instanceof _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"], "tile is not a vector");
        }
        return Number.isInteger(tile.x) && Number.isInteger(tile.y);
    }

    /**
     * Returns the tile content of a given tile
     * @param {Vector} tile
     * @returns {Entity} Entity or null
     */
    getTileContent(tile) {
        if ( true && !_core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug.disableInternalCheckTile) {
            this.internalCheckTile(tile);
        }
        const chunk = this.getChunkAtTileOrNull(tile.x, tile.y);
        return chunk && chunk.getTileContentFromWorldCoords(tile.x, tile.y);
    }

    /**
     * Returns the lower layers content of the given tile
     * @param {number} x
     * @param {number} y
     * @returns {BaseItem=}
     */
    getLowerLayerContentXY(x, y) {
        return this.getOrCreateChunkAtTile(x, y).getLowerLayerFromWorldCoords(x, y);
    }

    /**
     * Returns the tile content of a given tile
     * @param {number} x
     * @param {number} y
     * @returns {Entity} Entity or null
     */
    getTileContentXY(x, y) {
        const chunk = this.getChunkAtTileOrNull(x, y);
        return chunk && chunk.getTileContentFromWorldCoords(x, y);
    }

    /**
     * Checks if the tile is used
     * @param {Vector} tile
     * @returns {boolean}
     */
    isTileUsed(tile) {
        if ( true && !_core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug.disableInternalCheckTile) {
            this.internalCheckTile(tile);
        }
        const chunk = this.getChunkAtTileOrNull(tile.x, tile.y);
        return chunk && chunk.getTileContentFromWorldCoords(tile.x, tile.y) != null;
    }

    /**
     * Checks if the tile is used
     * @param {number} x
     * @param {number} y
     * @returns {boolean}
     */
    isTileUsedXY(x, y) {
        const chunk = this.getChunkAtTileOrNull(x, y);
        return chunk && chunk.getTileContentFromWorldCoords(x, y) != null;
    }

    /**
     * Sets the tiles content
     * @param {Vector} tile
     * @param {Entity} entity
     */
    setTileContent(tile, entity) {
        if ( true && !_core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug.disableInternalCheckTile) {
            this.internalCheckTile(tile);
        }

        this.getOrCreateChunkAtTile(tile.x, tile.y).setTileContentFromWorldCords(tile.x, tile.y, entity);

        const staticComponent = entity.components.StaticMapEntity;
        window.assert(staticComponent, "Can only place static map entities in tiles");
    }

    /**
     * Places an entity with the StaticMapEntity component
     * @param {Entity} entity
     */
    placeStaticEntity(entity) {
        window.assert(entity.components.StaticMapEntity, "Entity is not static");
        const staticComp = entity.components.StaticMapEntity;
        const rect = staticComp.getTileSpaceBounds();
        for (let dx = 0; dx < rect.w; ++dx) {
            for (let dy = 0; dy < rect.h; ++dy) {
                const x = rect.x + dx;
                const y = rect.y + dy;
                this.getOrCreateChunkAtTile(x, y).setTileContentFromWorldCords(x, y, entity);
            }
        }
    }

    /**
     * Removes an entity with the StaticMapEntity component
     * @param {Entity} entity
     */
    removeStaticEntity(entity) {
        window.assert(entity.components.StaticMapEntity, "Entity is not static");
        const staticComp = entity.components.StaticMapEntity;
        const rect = staticComp.getTileSpaceBounds();
        for (let dx = 0; dx < rect.w; ++dx) {
            for (let dy = 0; dy < rect.h; ++dy) {
                const x = rect.x + dx;
                const y = rect.y + dy;
                this.getOrCreateChunkAtTile(x, y).setTileContentFromWorldCords(x, y, null);
            }
        }
    }

    /**
     * Resets the tiles content
     * @param {Vector} tile
     */
    clearTile(tile) {
        if ( true && !_core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug.disableInternalCheckTile) {
            this.internalCheckTile(tile);
        }
        this.getOrCreateChunkAtTile(tile.x, tile.y).setTileContentFromWorldCords(tile.x, tile.y, null);
    }

    // Internal

    /**
     * Checks a given tile for validty
     * @param {Vector} tile
     */
    internalCheckTile(tile) {
        window.assert(tile instanceof _core_vector__WEBPACK_IMPORTED_MODULE_1__["Vector"], "tile is not a vector: " + tile);
        window.assert(tile.x % 1 === 0, "Tile X is not a valid integer: " + tile.x);
        window.assert(tile.y % 1 === 0, "Tile Y is not a valid integer: " + tile.y);
    }
}


/***/ }),

/***/ "./src/js/game/map_chunk.js":
/*!**********************************!*\
  !*** ./src/js/game/map_chunk.js ***!
  \**********************************/
/*! exports provided: MapChunk */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MapChunk", function() { return MapChunk; });
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _base_item__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base_item */ "./src/js/game/base_item.js");
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./colors */ "./src/js/game/colors.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./entity */ "./src/js/game/entity.js");
/* harmony import */ var _items_color_item__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./items/color_item */ "./src/js/game/items/color_item.js");
/* harmony import */ var _items_shape_item__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./items/shape_item */ "./src/js/game/items/shape_item.js");
/* harmony import */ var _shape_definition__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./shape_definition */ "./src/js/game/shape_definition.js");
/* harmony import */ var _core_rng__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../core/rng */ "./src/js/core/rng.js");















const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_2__["createLogger"])("map_chunk");

class MapChunk {
    /**
     *
     * @param {GameRoot} root
     * @param {number} x
     * @param {number} y
     */
    constructor(root, x, y) {
        this.root = root;
        this.x = x;
        this.y = y;
        this.tileX = x * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize;
        this.tileY = y * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize;

        /** @type {Array<Array<?Entity>>} */
        this.contents = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["make2DUndefinedArray"])(
            _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize,
            _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize,
            "map-chunk@" + this.x + "|" + this.y
        );

        /** @type {Array<Array<?BaseItem>>} */
        this.lowerLayer = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["make2DUndefinedArray"])(
            _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize,
            _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize,
            "map-chunk-lower@" + this.x + "|" + this.y
        );

        /** @type {Array<Entity>} */
        this.containedEntities = [];

        /**
         * Store which patches we have so we can render them in the overview
         * @type {Array<{pos: Vector, item: BaseItem, size: number }>}
         */
        this.patches = [];

        this.generateLowerLayer();
    }

    /**
     * Generates a patch filled with the given item
     * @param {RandomNumberGenerator} rng
     * @param {number} patchSize
     * @param {BaseItem} item
     * @param {number=} overrideX Override the X position of the patch
     * @param {number=} overrideY Override the Y position of the patch
     */
    internalGeneratePatch(rng, patchSize, item, overrideX = null, overrideY = null) {
        const border = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_ceil"])(patchSize / 2 + 3);

        // Find a position within the chunk which is not blocked
        let patchX = rng.nextIntRange(border, _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize - border - 1);
        let patchY = rng.nextIntRange(border, _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize - border - 1);

        if (overrideX !== null) {
            patchX = overrideX;
        }

        if (overrideY !== null) {
            patchY = overrideY;
        }

        const avgPos = new _core_vector__WEBPACK_IMPORTED_MODULE_4__["Vector"](0, 0);
        let patchesDrawn = 0;

        // Each patch consists of multiple circles
        const numCircles = patchSize;

        for (let i = 0; i <= numCircles; ++i) {
            // Determine circle parameters
            const circleRadius = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_min"])(1 + i, patchSize);
            const circleRadiusSquare = circleRadius * circleRadius;
            const circleOffsetRadius = (numCircles - i) / 2 + 2;

            // We draw an elipsis actually
            const circleScaleX = rng.nextRange(0.9, 1.1);
            const circleScaleY = rng.nextRange(0.9, 1.1);

            const circleX = patchX + rng.nextIntRange(-circleOffsetRadius, circleOffsetRadius);
            const circleY = patchY + rng.nextIntRange(-circleOffsetRadius, circleOffsetRadius);

            for (let dx = -circleRadius * circleScaleX - 2; dx <= circleRadius * circleScaleX + 2; ++dx) {
                for (let dy = -circleRadius * circleScaleY - 2; dy <= circleRadius * circleScaleY + 2; ++dy) {
                    const x = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_round"])(circleX + dx);
                    const y = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_round"])(circleY + dy);
                    if (x >= 0 && x < _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize && y >= 0 && y <= _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize) {
                        const originalDx = dx / circleScaleX;
                        const originalDy = dy / circleScaleY;
                        if (originalDx * originalDx + originalDy * originalDy <= circleRadiusSquare) {
                            if (!this.lowerLayer[x][y]) {
                                this.lowerLayer[x][y] = item;
                                ++patchesDrawn;
                                avgPos.x += x;
                                avgPos.y += y;
                            }
                        }
                    } else {
                        // logger.warn("Tried to spawn resource out of chunk");
                    }
                }
            }
        }

        this.patches.push({
            pos: avgPos.divideScalar(patchesDrawn),
            item,
            size: patchSize,
        });
    }

    /**
     * Generates a color patch
     * @param {RandomNumberGenerator} rng
     * @param {number} colorPatchSize
     * @param {number} distanceToOriginInChunks
     */
    internalGenerateColorPatch(rng, colorPatchSize, distanceToOriginInChunks) {
        // First, determine available colors
        let availableColors = [_colors__WEBPACK_IMPORTED_MODULE_6__["enumColors"].red, _colors__WEBPACK_IMPORTED_MODULE_6__["enumColors"].green];
        if (distanceToOriginInChunks > 2) {
            availableColors.push(_colors__WEBPACK_IMPORTED_MODULE_6__["enumColors"].blue);
        }
        if (distanceToOriginInChunks > 5) {
            availableColors.push(_colors__WEBPACK_IMPORTED_MODULE_6__["enumColors"].black);
        }
        this.internalGeneratePatch(rng, colorPatchSize, new _items_color_item__WEBPACK_IMPORTED_MODULE_8__["ColorItem"](rng.choice(availableColors)));
    }

    /**
     * Generates a shape patch
     * @param {RandomNumberGenerator} rng
     * @param {number} shapePatchSize
     * @param {number} distanceToOriginInChunks
     */
    internalGenerateShapePatch(rng, shapePatchSize, distanceToOriginInChunks) {
        /** @type {[enumSubShape, enumSubShape, enumSubShape, enumSubShape]} */
        let subShapes = null;

        let weights = {};

        // Later there is a mix of everything
        weights = {
            [_shape_definition__WEBPACK_IMPORTED_MODULE_10__["enumSubShape"].rect]: 100,
            [_shape_definition__WEBPACK_IMPORTED_MODULE_10__["enumSubShape"].circle]: Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_round"])(50 + Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["clamp"])(distanceToOriginInChunks * 2, 0, 50)),
            [_shape_definition__WEBPACK_IMPORTED_MODULE_10__["enumSubShape"].star]: Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_round"])(20 + Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["clamp"])(distanceToOriginInChunks, 0, 30)),
            [_shape_definition__WEBPACK_IMPORTED_MODULE_10__["enumSubShape"].windmill]: Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_round"])(6 + Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["clamp"])(distanceToOriginInChunks / 2, 0, 20)),
        };
        for (let k in _shape_definition__WEBPACK_IMPORTED_MODULE_10__["enumSubShape"]) {
            if (weights[_shape_definition__WEBPACK_IMPORTED_MODULE_10__["enumSubShape"][k]]) continue;
            weights[_shape_definition__WEBPACK_IMPORTED_MODULE_10__["enumSubShape"][k]] = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_round"])(2 + Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["clamp"])(distanceToOriginInChunks / 3, 0, 10));
        }

        if (distanceToOriginInChunks < 7) {
            // Initial chunks can not spawn the good stuff
            weights[_shape_definition__WEBPACK_IMPORTED_MODULE_10__["enumSubShape"].star] = 0;
            weights[_shape_definition__WEBPACK_IMPORTED_MODULE_10__["enumSubShape"].windmill] = 0;
        }

        if (distanceToOriginInChunks < 10) {
            // Initial chunk patches always have the same shape
            const subShape = this.internalGenerateRandomSubShape(rng, weights);
            subShapes = [subShape, subShape, subShape, subShape];
        } else if (distanceToOriginInChunks < 15) {
            // Later patches can also have mixed ones
            const subShapeA = this.internalGenerateRandomSubShape(rng, weights);
            const subShapeB = this.internalGenerateRandomSubShape(rng, weights);
            subShapes = [subShapeA, subShapeA, subShapeB, subShapeB];
        } else {
            // Finally there is a mix of everything
            subShapes = [
                this.internalGenerateRandomSubShape(rng, weights),
                this.internalGenerateRandomSubShape(rng, weights),
                this.internalGenerateRandomSubShape(rng, weights),
                this.internalGenerateRandomSubShape(rng, weights),
            ];
        }

        // Makes sure windmills never spawn as whole
        let windmillCount = 0;
        for (let i = 0; i < subShapes.length; ++i) {
            if (subShapes[i] === _shape_definition__WEBPACK_IMPORTED_MODULE_10__["enumSubShape"].windmill) {
                ++windmillCount;
            }
        }
        if (windmillCount > 1) {
            subShapes[0] = _shape_definition__WEBPACK_IMPORTED_MODULE_10__["enumSubShape"].rect;
            subShapes[1] = _shape_definition__WEBPACK_IMPORTED_MODULE_10__["enumSubShape"].rect;
        }

        const colors = [
            _shape_definition__WEBPACK_IMPORTED_MODULE_10__["enumDefaultSubShapeColor"][subShapes[0]],
            _shape_definition__WEBPACK_IMPORTED_MODULE_10__["enumDefaultSubShapeColor"][subShapes[1]],
            _shape_definition__WEBPACK_IMPORTED_MODULE_10__["enumDefaultSubShapeColor"][subShapes[2]],
            _shape_definition__WEBPACK_IMPORTED_MODULE_10__["enumDefaultSubShapeColor"][subShapes[3]],
        ];

        const definition = this.root.shapeDefinitionMgr.getDefinitionFromSimpleShapesAndColors(
            subShapes,
            colors
        );
        this.internalGeneratePatch(rng, shapePatchSize, new _items_shape_item__WEBPACK_IMPORTED_MODULE_9__["ShapeItem"](definition));
    }

    /**
     * Chooses a random shape with the given weights
     * @param {RandomNumberGenerator} rng
     * @param {Object.<enumSubShape, number>} weights
     * @returns {enumSubShape}
     */
    internalGenerateRandomSubShape(rng, weights) {
        // @ts-ignore
        const sum = Object.values(weights).reduce((a, b) => a + b, 0);

        const chosenNumber = rng.nextIntRange(0, sum - 1);
        let accumulated = 0;
        for (const key in weights) {
            const weight = weights[key];
            if (accumulated + weight > chosenNumber) {
                return key;
            }
            accumulated += weight;
        }

        logger.error("Failed to find matching shape in chunk generation");
        return _shape_definition__WEBPACK_IMPORTED_MODULE_10__["enumSubShape"].circle;
    }

    /**
     * Generates the lower layer "terrain"
     */
    generateLowerLayer() {
        const rng = new _core_rng__WEBPACK_IMPORTED_MODULE_11__["RandomNumberGenerator"](this.x + "|" + this.y + "|" + this.root.map.seed);

        if (this.generatePredefined(rng)) {
            return;
        }

        const chunkCenter = new _core_vector__WEBPACK_IMPORTED_MODULE_4__["Vector"](this.x, this.y).addScalar(0.5);
        const distanceToOriginInChunks = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_round"])(chunkCenter.length());

        // Determine how likely it is that there is a color patch
        const colorPatchChance = 0.9 - Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["clamp"])(distanceToOriginInChunks / 25, 0, 1) * 0.5;

        if (rng.next() < colorPatchChance / 4) {
            const colorPatchSize = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_max"])(2, Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_round"])(1 + Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["clamp"])(distanceToOriginInChunks / 8, 0, 4)));
            this.internalGenerateColorPatch(rng, colorPatchSize, distanceToOriginInChunks);
        }

        // Determine how likely it is that there is a shape patch
        const shapePatchChance = 0.9 - Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["clamp"])(distanceToOriginInChunks / 25, 0, 1) * 0.5;
        if (rng.next() < shapePatchChance / 4) {
            const shapePatchSize = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_max"])(2, Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_round"])(1 + Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["clamp"])(distanceToOriginInChunks / 8, 0, 4)));
            this.internalGenerateShapePatch(rng, shapePatchSize, distanceToOriginInChunks);
        }
    }

    /**
     * Checks if this chunk has predefined contents, and if so returns true and generates the
     * predefined contents
     * @param {RandomNumberGenerator} rng
     * @returns {boolean}
     */
    generatePredefined(rng) {
        if (this.x === 0 && this.y === 0) {
            this.internalGeneratePatch(rng, 2, new _items_color_item__WEBPACK_IMPORTED_MODULE_8__["ColorItem"](_colors__WEBPACK_IMPORTED_MODULE_6__["enumColors"].red), 7, 7);
            return true;
        }
        if (this.x === -1 && this.y === 0) {
            const definition = this.root.shapeDefinitionMgr.getShapeFromShortKey("CuCuCuCu");
            this.internalGeneratePatch(rng, 2, new _items_shape_item__WEBPACK_IMPORTED_MODULE_9__["ShapeItem"](definition), _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize - 9, 7);
            return true;
        }
        if (this.x === 0 && this.y === -1) {
            const definition = this.root.shapeDefinitionMgr.getShapeFromShortKey("RuRuRuRu");
            this.internalGeneratePatch(rng, 2, new _items_shape_item__WEBPACK_IMPORTED_MODULE_9__["ShapeItem"](definition), 5, _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize - 7);
            return true;
        }

        if (this.x === -1 && this.y === -1) {
            this.internalGeneratePatch(rng, 2, new _items_color_item__WEBPACK_IMPORTED_MODULE_8__["ColorItem"](_colors__WEBPACK_IMPORTED_MODULE_6__["enumColors"].green));
            return true;
        }

        if (this.x === 5 && this.y === -2) {
            const definition = this.root.shapeDefinitionMgr.getShapeFromShortKey("SuSuSuSu");
            this.internalGeneratePatch(rng, 2, new _items_shape_item__WEBPACK_IMPORTED_MODULE_9__["ShapeItem"](definition), 5, _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize - 7);
            return true;
        }

        return false;
    }

    /**
     *
     * @param {number} worldX
     * @param {number} worldY
     * @returns {BaseItem=}
     */
    getLowerLayerFromWorldCoords(worldX, worldY) {
        const localX = worldX - this.tileX;
        const localY = worldY - this.tileY;
        window.assert(localX >= 0, "Local X is < 0");
        window.assert(localY >= 0, "Local Y is < 0");
        window.assert(localX < _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize, "Local X is >= chunk size");
        window.assert(localY < _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize, "Local Y is >= chunk size");
        return this.lowerLayer[localX][localY] || null;
    }

    /**
     * Returns the contents of this chunk from the given world space coordinates
     * @param {number} worldX
     * @param {number} worldY
     * @returns {Entity=}
     */
    getTileContentFromWorldCoords(worldX, worldY) {
        const localX = worldX - this.tileX;
        const localY = worldY - this.tileY;
        if (!_core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].debug.disableGetTileAsserts) {
            window.assert(localX >= 0, "Local X is < 0");
            window.assert(localY >= 0, "Local Y is < 0");
            window.assert(localX < _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize, "Local X is >= chunk size");
            window.assert(localY < _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize, "Local Y is >= chunk size");
        }
        return this.contents[localX][localY] || null;
    }

    /**
     * Returns the chunks contents from the given local coordinates
     * @param {number} localX
     * @param {number} localY
     * @returns {Entity=}
     */
    getTileContentFromLocalCoords(localX, localY) {
        window.assert(localX >= 0, "Local X is < 0");
        window.assert(localY >= 0, "Local Y is < 0");
        window.assert(localX < _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize, "Local X is >= chunk size");
        window.assert(localY < _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize, "Local Y is >= chunk size");

        return this.contents[localX][localY] || null;
    }

    /**
     * Sets the chunks contents
     * @param {number} tileX
     * @param {number} tileY
     * @param {Entity=} contents
     */
    setTileContentFromWorldCords(tileX, tileY, contents) {
        const localX = tileX - this.tileX;
        const localY = tileY - this.tileY;
        window.assert(localX >= 0, "Local X is < 0");
        window.assert(localY >= 0, "Local Y is < 0");
        window.assert(localX < _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize, "Local X is >= chunk size");
        window.assert(localY < _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize, "Local Y is >= chunk size");
        const oldContents = this.contents[localX][localY];
        window.assert(contents === null || !oldContents, "Tile already used: " + tileX + " / " + tileY);

        if (oldContents) {
            // Remove from list
            Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["fastArrayDeleteValueIfContained"])(this.containedEntities, oldContents);
        }
        this.contents[localX][localY] = contents;
        if (contents) {
            if (this.containedEntities.indexOf(contents) < 0) {
                this.containedEntities.push(contents);
            }
        }
    }
}


/***/ }),

/***/ "./src/js/game/map_chunk_view.js":
/*!***************************************!*\
  !*** ./src/js/game/map_chunk_view.js ***!
  \***************************************/
/*! exports provided: MapChunkView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MapChunkView", function() { return MapChunkView; });
/* harmony import */ var _map_chunk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map_chunk */ "./src/js/game/map_chunk.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./root */ "./src/js/game/root.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_rectangle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/rectangle */ "./src/js/core/rectangle.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_dpi_manager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/dpi_manager */ "./src/js/core/dpi_manager.js");
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./theme */ "./src/js/game/theme.js");











const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_7__["createLogger"])("chunk");
const chunkSizePixels = _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].mapChunkSize * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize;

class MapChunkView extends _map_chunk__WEBPACK_IMPORTED_MODULE_0__["MapChunk"] {
    /**
     *
     * @param {GameRoot} root
     * @param {number} x
     * @param {number} y
     */
    constructor(root, x, y) {
        super(root, x, y);

        this.boundInternalDrawBackgroundToContext = this.internalDrawBackgroundToContext.bind(this);
        this.boundInternalDrawForegroundToContext = this.internalDrawForegroundToContext.bind(this);

        /**
         * Whenever something changes, we increase this number - so we know we need to redraw
         */
        this.renderIteration = 0;

        this.markDirty();
    }

    /**
     * Marks this chunk as dirty, rerendering all caches
     */
    markDirty() {
        ++this.renderIteration;
        this.renderKey = this.x + "/" + this.y + "@" + this.renderIteration;
    }

    /**
     * Draws the background layer
     * @param {DrawParameters} parameters
     */
    drawBackgroundLayer(parameters) {
        if (parameters.zoomLevel > _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].mapChunkPrerenderMinZoom) {
            this.internalDrawBackgroundSystems(parameters);
            return;
        }

        const dpi = Object(_core_dpi_manager__WEBPACK_IMPORTED_MODULE_8__["smoothenDpi"])(parameters.zoomLevel);
        const buffer = this.root.buffers.getForKey(
            "" + dpi,
            this.renderKey + "@bg",
            chunkSizePixels,
            chunkSizePixels,
            dpi,
            this.boundInternalDrawBackgroundToContext,
            { zoomLevel: parameters.zoomLevel }
        );

        parameters.context.drawImage(
            buffer,
            this.tileX * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize,
            this.tileY * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize,
            chunkSizePixels,
            chunkSizePixels
        );
    }

    /**
     * Draws the foreground layer
     * @param {DrawParameters} parameters
     */
    drawForegroundLayer(parameters) {
        if (parameters.zoomLevel > _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].mapChunkPrerenderMinZoom) {
            this.internalDrawForegroundSystems(parameters);
            return;
        }

        const dpi = Object(_core_dpi_manager__WEBPACK_IMPORTED_MODULE_8__["smoothenDpi"])(parameters.zoomLevel);
        const buffer = this.root.buffers.getForKey(
            "" + dpi,
            this.renderKey + "@fg",
            chunkSizePixels,
            chunkSizePixels,
            dpi,
            this.boundInternalDrawForegroundToContext,
            { zoomLevel: parameters.zoomLevel }
        );
        parameters.context.drawImage(
            buffer,
            this.tileX * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize,
            this.tileY * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize,
            chunkSizePixels,
            chunkSizePixels
        );
    }

    /**
     *
     * @param {HTMLCanvasElement} canvas
     * @param {CanvasRenderingContext2D} context
     * @param {number} w
     * @param {number} h
     * @param {number} dpi
     */
    internalDrawBackgroundToContext(canvas, context, w, h, dpi, { zoomLevel }) {
        const pattern = context.createPattern(this.root.map.cachedBackgroundCanvas, "repeat");
        context.scale(dpi, dpi);

        if (zoomLevel >= _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].mapChunkOverviewMinZoom) {
            const bgDpi = this.root.map.backgroundCacheDPI;
            context.scale(1 / bgDpi, 1 / bgDpi);
            context.fillStyle = pattern;
            context.fillRect(0, 0, chunkSizePixels * bgDpi, chunkSizePixels * bgDpi);
            context.scale(bgDpi, bgDpi);
        } else {
            if (this.containedEntities.length > 0) {
                context.fillStyle = _theme__WEBPACK_IMPORTED_MODULE_9__["THEME"].map.chunkOverview.filled;
            } else {
                context.fillStyle = _theme__WEBPACK_IMPORTED_MODULE_9__["THEME"].map.chunkOverview.empty;
            }
            context.fillRect(0, 0, 10000, 10000);
        }

        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].debug.showChunkBorders) {
            context.fillStyle = "rgba(0, 0, 255, 0.1)";
            context.fillRect(0, 0, 10000, 10000);
        }

        const parameters = new _core_draw_parameters__WEBPACK_IMPORTED_MODULE_3__["DrawParameters"]({
            context,
            visibleRect: new _core_rectangle__WEBPACK_IMPORTED_MODULE_6__["Rectangle"](
                this.tileX * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize,
                this.tileY * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize,
                chunkSizePixels,
                chunkSizePixels
            ),
            desiredAtlasScale: "1",
            zoomLevel,
            root: this.root,
        });

        parameters.context.translate(
            -this.tileX * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize,
            -this.tileY * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize
        );
        this.internalDrawBackgroundSystems(parameters);
    }

    /**
     *
     * @param {HTMLCanvasElement} canvas
     * @param {CanvasRenderingContext2D} context
     * @param {number} w
     * @param {number} h
     * @param {number} dpi
     */
    internalDrawForegroundToContext(canvas, context, w, h, dpi, { zoomLevel }) {
        context.scale(dpi, dpi);

        const parameters = new _core_draw_parameters__WEBPACK_IMPORTED_MODULE_3__["DrawParameters"]({
            context,
            visibleRect: new _core_rectangle__WEBPACK_IMPORTED_MODULE_6__["Rectangle"](
                this.tileX * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize,
                this.tileY * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize,
                chunkSizePixels,
                chunkSizePixels
            ),
            desiredAtlasScale: "1",
            zoomLevel,
            root: this.root,
        });
        parameters.context.translate(
            -this.tileX * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize,
            -this.tileY * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize
        );
        this.internalDrawForegroundSystems(parameters);
    }

    /**
     * @param {DrawParameters} parameters
     */
    internalDrawBackgroundSystems(parameters) {
        const systems = this.root.systemMgr.systems;
        systems.mapResources.drawChunk(parameters, this);
        systems.belt.drawChunk(parameters, this);
    }

    /**
     * @param {DrawParameters} parameters
     */
    internalDrawForegroundSystems(parameters) {
        const systems = this.root.systemMgr.systems;
        systems.miner.drawChunk(parameters, this);
        systems.staticMapEntities.drawChunk(parameters, this);
    }
}


/***/ }),

/***/ "./src/js/game/map_view.js":
/*!*********************************!*\
  !*** ./src/js/game/map_view.js ***!
  \*********************************/
/*! exports provided: MapView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MapView", function() { return MapView; });
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./map */ "./src/js/game/map.js");
/* harmony import */ var _core_buffer_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/buffer_utils */ "./src/js/core/buffer_utils.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./entity */ "./src/js/game/entity.js");
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./theme */ "./src/js/game/theme.js");








/**
 * This is the view of the map, it extends the map which is the raw model and allows
 * to draw it
 */
class MapView extends _map__WEBPACK_IMPORTED_MODULE_3__["BaseMap"] {
    constructor(root) {
        super(root);

        /**
         * DPI of the background cache images, required in some places
         */
        this.backgroundCacheDPI = 2;

        /**
         * The cached background sprite, containing the flat background
         * @type {HTMLCanvasElement} */
        this.cachedBackgroundCanvas = null;

        /** @type {CanvasRenderingContext2D} */
        this.cachedBackgroundContext = null;
        /**
         * Cached pattern of the stripes background
         * @type {CanvasPattern} */
        this.cachedBackgroundPattern = null;

        this.internalInitializeCachedBackgroundCanvases();
        this.root.signals.aboutToDestruct.add(this.cleanup, this);

        this.root.signals.entityAdded.add(this.onEntityChanged, this);
        this.root.signals.entityDestroyed.add(this.onEntityChanged, this);
    }

    cleanup() {
        Object(_core_buffer_utils__WEBPACK_IMPORTED_MODULE_4__["freeCanvas"])(this.cachedBackgroundCanvas);
        this.cachedBackgroundCanvas = null;
        this.cachedBackgroundPattern = null;
    }

    /**
     * Called when an entity was added or removed
     * @param {Entity} entity
     */
    onEntityChanged(entity) {
        const staticComp = entity.components.StaticMapEntity;
        if (staticComp) {
            const rect = staticComp.getTileSpaceBounds();
            for (let x = rect.x; x <= rect.right(); ++x) {
                for (let y = rect.y; y <= rect.bottom(); ++y) {
                    this.root.map.getOrCreateChunkAtTile(x, y).markDirty();
                }
            }
        }
    }

    /**
     * Draws all static entities like buildings etc.
     * @param {DrawParameters} drawParameters
     */
    drawStaticEntities(drawParameters) {
        const cullRange = drawParameters.visibleRect.toTileCullRectangle();
        const top = cullRange.top();
        const right = cullRange.right();
        const bottom = cullRange.bottom();
        const left = cullRange.left();

        const border = 1;

        const minY = top - border;
        const maxY = bottom + border;
        const minX = left - border;
        const maxX = right + border - 1;

        // Render y from top down for proper blending
        for (let y = minY; y <= maxY; ++y) {
            for (let x = minX; x <= maxX; ++x) {
                // const content = this.tiles[x][y];
                const chunk = this.getChunkAtTileOrNull(x, y);
                if (!chunk) {
                    continue;
                }
                const content = chunk.getTileContentFromWorldCoords(x, y);
                if (content) {
                    let isBorder = x <= left - 1 || x >= right + 1 || y <= top - 1 || y >= bottom + 1;
                    if (!isBorder) {
                        content.draw(drawParameters);
                    }
                }
            }
        }
    }

    /**
     * Initializes all canvases used for background rendering
     */
    internalInitializeCachedBackgroundCanvases() {
        // Background canvas
        const dims = _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize;
        const dpi = this.backgroundCacheDPI;
        const [canvas, context] = Object(_core_buffer_utils__WEBPACK_IMPORTED_MODULE_4__["makeOffscreenBuffer"])(dims * dpi, dims * dpi, {
            smooth: false,
            label: "map-cached-bg",
        });
        context.scale(dpi, dpi);

        context.fillStyle = _theme__WEBPACK_IMPORTED_MODULE_6__["THEME"].map.background;
        context.fillRect(0, 0, dims, dims);

        const borderWidth = _theme__WEBPACK_IMPORTED_MODULE_6__["THEME"].map.gridLineWidth;
        context.fillStyle = _theme__WEBPACK_IMPORTED_MODULE_6__["THEME"].map.grid;
        context.fillRect(0, 0, dims, borderWidth);
        context.fillRect(0, borderWidth, borderWidth, dims);

        context.fillRect(dims - borderWidth, borderWidth, borderWidth, dims - 2 * borderWidth);
        context.fillRect(borderWidth, dims - borderWidth, dims, borderWidth);

        this.cachedBackgroundCanvas = canvas;
        this.cachedBackgroundContext = context;
    }

    /**
     * Draws the maps foreground
     * @param {DrawParameters} parameters
     */
    drawForeground(parameters) {
        const cullRange = parameters.visibleRect.toTileCullRectangle();
        const top = cullRange.top();
        const right = cullRange.right();
        const bottom = cullRange.bottom();
        const left = cullRange.left();

        const border = 1;
        const minY = top - border;
        const maxY = bottom + border;
        const minX = left - border;
        const maxX = right + border - 1;

        const chunkStartX = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_floor"])(minX / _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize);
        const chunkStartY = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_floor"])(minY / _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize);

        const chunkEndX = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_ceil"])(maxX / _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize);
        const chunkEndY = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_ceil"])(maxY / _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize);

        // Render y from top down for proper blending
        for (let chunkX = chunkStartX; chunkX <= chunkEndX; ++chunkX) {
            for (let chunkY = chunkStartY; chunkY <= chunkEndY; ++chunkY) {
                const chunk = this.root.map.getChunk(chunkX, chunkY, true);
                chunk.drawForegroundLayer(parameters);
            }
        }
    }

    /**
     * Draws the map background
     * @param {DrawParameters} parameters
     */
    drawBackground(parameters) {
        // If not using prerendered, draw background
        if (parameters.zoomLevel > _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkPrerenderMinZoom) {
            if (!this.cachedBackgroundPattern) {
                this.cachedBackgroundPattern = parameters.context.createPattern(
                    this.cachedBackgroundCanvas,
                    "repeat"
                );
            }

            const dpi = this.backgroundCacheDPI;
            parameters.context.scale(1 / dpi, 1 / dpi);

            parameters.context.fillStyle = this.cachedBackgroundPattern;
            parameters.context.fillRect(
                parameters.visibleRect.x * dpi,
                parameters.visibleRect.y * dpi,
                parameters.visibleRect.w * dpi,
                parameters.visibleRect.h * dpi
            );
            parameters.context.scale(dpi, dpi);
        }

        const cullRange = parameters.visibleRect.toTileCullRectangle();
        const top = cullRange.top();
        const right = cullRange.right();
        const bottom = cullRange.bottom();
        const left = cullRange.left();

        const border = 1;
        const minY = top - border;
        const maxY = bottom + border;
        const minX = left - border;
        const maxX = right + border - 1;

        const chunkStartX = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_floor"])(minX / _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize);
        const chunkStartY = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_floor"])(minY / _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize);

        const chunkEndX = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_ceil"])(maxX / _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize);
        const chunkEndY = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_ceil"])(maxY / _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize);

        // Render y from top down for proper blending
        for (let chunkX = chunkStartX; chunkX <= chunkEndX; ++chunkX) {
            for (let chunkY = chunkStartY; chunkY <= chunkEndY; ++chunkY) {
                const chunk = this.root.map.getChunk(chunkX, chunkY, true);
                chunk.drawBackgroundLayer(parameters);
            }
        }

        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].debug.showChunkBorders) {
            const cullRange = parameters.visibleRect.toTileCullRectangle();
            const top = cullRange.top();
            const right = cullRange.right();
            const bottom = cullRange.bottom();
            const left = cullRange.left();

            const border = 1;
            const minY = top - border;
            const maxY = bottom + border;
            const minX = left - border;
            const maxX = right + border - 1;

            const chunkStartX = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_floor"])(minX / _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize);
            const chunkStartY = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_floor"])(minY / _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize);

            const chunkEndX = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_ceil"])(maxX / _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize);
            const chunkEndY = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_ceil"])(maxY / _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize);

            // Render y from top down for proper blending
            for (let chunkX = chunkStartX; chunkX <= chunkEndX; ++chunkX) {
                for (let chunkY = chunkStartY; chunkY <= chunkEndY; ++chunkY) {
                    parameters.context.fillStyle = "#ffaaaa";
                    parameters.context.fillRect(
                        chunkX * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize,
                        chunkY * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize,
                        _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize,
                        3
                    );
                    parameters.context.fillRect(
                        chunkX * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize,
                        chunkY * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize,
                        3,
                        _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize
                    );
                }
            }
        }
    }
}


/***/ }),

/***/ "./src/js/game/meta_building.js":
/*!**************************************!*\
  !*** ./src/js/game/meta_building.js ***!
  \**************************************/
/*! exports provided: defaultBuildingVariant, MetaBuilding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultBuildingVariant", function() { return defaultBuildingVariant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MetaBuilding", function() { return MetaBuilding; });
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _core_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/loader */ "./src/js/core/loader.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./root */ "./src/js/game/root.js");
/* harmony import */ var _core_sprites__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/sprites */ "./src/js/core/sprites.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./entity */ "./src/js/game/entity.js");
/* harmony import */ var _components_static_map_entity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/static_map_entity */ "./src/js/game/components/static_map_entity.js");
/* harmony import */ var _platform_sound__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../platform/sound */ "./src/js/platform/sound.js");








const defaultBuildingVariant = "default";

class MetaBuilding {
    /**
     *
     * @param {string} id Building id
     */
    constructor(id) {
        this.id = id;
    }

    /**
     * Returns the id of this building
     */
    getId() {
        return this.id;
    }

    /**
     * Should return the dimensions of the building
     */
    getDimensions(variant = defaultBuildingVariant) {
        return new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](1, 1);
    }

    /**
     * Whether to stay in placement mode after having placed a building
     */
    getStayInPlacementMode() {
        return false;
    }

    /**
     * Should return additional statistics about this building
     * @param {GameRoot} root
     * @param {string} variant
     * @returns {Array<[string, string]>}
     */
    getAdditionalStatistics(root, variant) {
        return [];
    }

    /**
     * Whether to flip the orientation after a building has been placed - useful
     * for tunnels.
     */
    getFlipOrientationAfterPlacement() {
        return false;
    }

    /**
     * Whether to rotate automatically in the dragging direction while placing
     * @param {string} variant
     */
    getRotateAutomaticallyWhilePlacing(variant) {
        return false;
    }

    /**
     * Returns the placement sound
     * @returns {string}
     */
    getPlacementSound() {
        return _platform_sound__WEBPACK_IMPORTED_MODULE_6__["SOUNDS"].placeBuilding;
    }

    /**
     * @param {GameRoot} root
     */
    getAvailableVariants(root) {
        return [defaultBuildingVariant];
    }

    /**
     * Returns a preview sprite
     * @returns {AtlasSprite}
     */
    getPreviewSprite(rotationVariant = 0, variant = defaultBuildingVariant) {
        return _core_loader__WEBPACK_IMPORTED_MODULE_1__["Loader"].getSprite(
            "sprites/buildings/" +
                this.id +
                (variant === defaultBuildingVariant ? "" : "-" + variant) +
                ".png"
        );
    }

    /**
     * Returns a sprite for blueprints
     * @returns {AtlasSprite}
     */
    getBlueprintSprite(rotationVariant = 0, variant = defaultBuildingVariant) {
        return _core_loader__WEBPACK_IMPORTED_MODULE_1__["Loader"].getSprite(
            "sprites/blueprints/" +
                this.id +
                (variant === defaultBuildingVariant ? "" : "-" + variant) +
                ".png"
        );
    }

    /**
     * Returns whether this building is rotateable
     * @param {string} variant
     * @returns {boolean}
     */
    isRotateable(variant) {
        return true;
    }

    /**
     * Returns whether this building is unlocked for the given game
     * @param {GameRoot} root
     */
    getIsUnlocked(root) {
        return true;
    }

    /**
     * Should return a silhouette color for the map overview or null if not set
     */
    getSilhouetteColor() {
        return null;
    }

    /**
     * Creates the entity at the given location
     * @param {object} param0
     * @param {GameRoot} param0.root
     * @param {Vector} param0.origin Origin tile
     * @param {number=} param0.rotation Rotation
     * @param {number} param0.originalRotation Original Rotation
     * @param {number} param0.rotationVariant Rotation variant
     * @param {string} param0.variant
     */
    createAndPlaceEntity({ root, origin, rotation, originalRotation, rotationVariant, variant }) {
        const entity = new _entity__WEBPACK_IMPORTED_MODULE_4__["Entity"](root);

        const blueprintSprite = this.getBlueprintSprite(rotationVariant, variant);

        entity.addComponent(
            new _components_static_map_entity__WEBPACK_IMPORTED_MODULE_5__["StaticMapEntityComponent"]({
                spriteKey:
                    "sprites/buildings/" +
                    this.id +
                    (variant === defaultBuildingVariant ? "" : "-" + variant) +
                    ".png",
                origin: new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](origin.x, origin.y),
                rotation,
                originalRotation,
                tileSize: this.getDimensions(variant).copy(),
                silhouetteColor: this.getSilhouetteColor(),
                blueprintSpriteKey: blueprintSprite ? blueprintSprite.spriteName : "",
            })
        );

        this.setupEntityComponents(entity, root);
        this.updateVariants(entity, rotationVariant, variant);

        root.map.placeStaticEntity(entity);
        root.entityMgr.registerEntity(entity);
        return entity;
    }

    /**
     * Should compute the optimal rotation variant on the given tile
     * @param {GameRoot} root
     * @param {Vector} tile
     * @param {number} rotation
     * @param {string} variant
     * @return {{ rotation: number, rotationVariant: number, connectedEntities?: Array<Entity> }}
     */
    computeOptimalDirectionAndRotationVariantAtTile(root, tile, rotation, variant) {
        if (!this.isRotateable(variant)) {
            return {
                rotation: 0,
                rotationVariant: 0,
            };
        }
        return {
            rotation,
            rotationVariant: 0,
        };
    }

    /**
     * Should update the entity to match the given variants
     * @param {Entity} entity
     * @param {number} rotationVariant
     * @param {string} variant
     */
    updateVariants(entity, rotationVariant, variant) {}

    // PRIVATE INTERFACE

    /**
     * Should setup the entity components
     * @param {Entity} entity
     * @param {GameRoot} root
     */
    setupEntityComponents(entity, root) {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }
}


/***/ }),

/***/ "./src/js/game/meta_building_registry.js":
/*!***********************************************!*\
  !*** ./src/js/game/meta_building_registry.js ***!
  \***********************************************/
/*! exports provided: initMetaBuildingRegistry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initMetaBuildingRegistry", function() { return initMetaBuildingRegistry; });
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/global_registries */ "./src/js/core/global_registries.js");
/* harmony import */ var _buildings_belt_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buildings/belt_base */ "./src/js/game/buildings/belt_base.js");
/* harmony import */ var _buildings_cutter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buildings/cutter */ "./src/js/game/buildings/cutter.js");
/* harmony import */ var _buildings_miner__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./buildings/miner */ "./src/js/game/buildings/miner.js");
/* harmony import */ var _buildings_mixer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./buildings/mixer */ "./src/js/game/buildings/mixer.js");
/* harmony import */ var _buildings_painter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./buildings/painter */ "./src/js/game/buildings/painter.js");
/* harmony import */ var _buildings_rotater__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./buildings/rotater */ "./src/js/game/buildings/rotater.js");
/* harmony import */ var _buildings_splitter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./buildings/splitter */ "./src/js/game/buildings/splitter.js");
/* harmony import */ var _buildings_stacker__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./buildings/stacker */ "./src/js/game/buildings/stacker.js");
/* harmony import */ var _buildings_trash__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./buildings/trash */ "./src/js/game/buildings/trash.js");
/* harmony import */ var _buildings_sorter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./buildings/sorter */ "./src/js/game/buildings/sorter.js");
/* harmony import */ var _buildings_underground_belt__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./buildings/underground_belt */ "./src/js/game/buildings/underground_belt.js");
/* harmony import */ var _buildings_hub__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./buildings/hub */ "./src/js/game/buildings/hub.js");














function initMetaBuildingRegistry() {
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gMetaBuildingRegistry"].register(_buildings_splitter__WEBPACK_IMPORTED_MODULE_7__["MetaSplitterBuilding"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gMetaBuildingRegistry"].register(_buildings_sorter__WEBPACK_IMPORTED_MODULE_10__["MetaSorterBuilding"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gMetaBuildingRegistry"].register(_buildings_miner__WEBPACK_IMPORTED_MODULE_3__["MetaMinerBuilding"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gMetaBuildingRegistry"].register(_buildings_cutter__WEBPACK_IMPORTED_MODULE_2__["MetaCutterBuilding"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gMetaBuildingRegistry"].register(_buildings_rotater__WEBPACK_IMPORTED_MODULE_6__["MetaRotaterBuilding"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gMetaBuildingRegistry"].register(_buildings_stacker__WEBPACK_IMPORTED_MODULE_8__["MetaStackerBuilding"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gMetaBuildingRegistry"].register(_buildings_mixer__WEBPACK_IMPORTED_MODULE_4__["MetaMixerBuilding"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gMetaBuildingRegistry"].register(_buildings_painter__WEBPACK_IMPORTED_MODULE_5__["MetaPainterBuilding"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gMetaBuildingRegistry"].register(_buildings_trash__WEBPACK_IMPORTED_MODULE_9__["MetaTrashBuilding"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gMetaBuildingRegistry"].register(_buildings_belt_base__WEBPACK_IMPORTED_MODULE_1__["MetaBeltBaseBuilding"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gMetaBuildingRegistry"].register(_buildings_underground_belt__WEBPACK_IMPORTED_MODULE_11__["MetaUndergroundBeltBuilding"]);
    _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gMetaBuildingRegistry"].register(_buildings_hub__WEBPACK_IMPORTED_MODULE_12__["MetaHubBuilding"]);
}


/***/ }),

/***/ "./src/js/game/production_analytics.js":
/*!*********************************************!*\
  !*** ./src/js/game/production_analytics.js ***!
  \*********************************************/
/*! exports provided: enumAnalyticsDataSource, ProductionAnalytics */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumAnalyticsDataSource", function() { return enumAnalyticsDataSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ProductionAnalytics", function() { return ProductionAnalytics; });
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./root */ "./src/js/game/root.js");
/* harmony import */ var _shape_definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shape_definition */ "./src/js/game/shape_definition.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _base_item__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base_item */ "./src/js/game/base_item.js");
/* harmony import */ var _items_shape_item__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./items/shape_item */ "./src/js/game/items/shape_item.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../savegame/serialization */ "./src/js/savegame/serialization.js");







/** @enum {string} */
const enumAnalyticsDataSource = {
    produced: "produced",
    stored: "stored",
    delivered: "delivered",
};

class ProductionAnalytics extends _savegame_serialization__WEBPACK_IMPORTED_MODULE_5__["BasicSerializableObject"] {
    static getId() {
        return "ProductionAnalytics";
    }

    /**
     * @param {GameRoot} root
     */
    constructor(root) {
        super();
        this.root = root;

        this.history = {
            [enumAnalyticsDataSource.produced]: [],
            [enumAnalyticsDataSource.stored]: [],
            [enumAnalyticsDataSource.delivered]: [],
        };

        for (let i = 0; i < _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].statisticsGraphSlices; ++i) {
            this.startNewSlice();
        }

        this.root.signals.shapeDelivered.add(this.onShapeDelivered, this);
        this.root.signals.itemProduced.add(this.onItemProduced, this);

        this.lastAnalyticsSlice = 0;
    }

    /**
     * @param {ShapeDefinition} definition
     */
    onShapeDelivered(definition) {
        const key = definition.getHash();
        const entry = this.history[enumAnalyticsDataSource.delivered];
        entry[entry.length - 1][key] = (entry[entry.length - 1][key] || 0) + 1;
    }

    /**
     * @param {BaseItem} item
     */
    onItemProduced(item) {
        if (item instanceof _items_shape_item__WEBPACK_IMPORTED_MODULE_4__["ShapeItem"]) {
            const definition = item.definition;
            const key = definition.getHash();
            const entry = this.history[enumAnalyticsDataSource.produced];
            entry[entry.length - 1][key] = (entry[entry.length - 1][key] || 0) + 1;
        }
    }

    /**
     * Starts a new time slice
     */
    startNewSlice() {
        for (const key in this.history) {
            if (key === enumAnalyticsDataSource.stored) {
                // Copy stored data
                this.history[key].push(Object.assign({}, this.root.hubGoals.storedShapes));
            } else {
                this.history[key].push({});
            }
            while (this.history[key].length > _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].statisticsGraphSlices) {
                this.history[key].shift();
            }
        }
    }

    /**
     * Returns the current rate of a given shape
     * @param {enumAnalyticsDataSource} dataSource
     * @param {ShapeDefinition} definition
     */
    getCurrentShapeRate(dataSource, definition) {
        const slices = this.history[dataSource];
        return slices[slices.length - 2][definition.getHash()] || 0;
    }

    /**
     * Returns the rate of a given shape, <historyOffset> frames ago
     * @param {enumAnalyticsDataSource} dataSource
     * @param {ShapeDefinition} definition
     * @param {number} historyOffset
     */
    getPastShapeRate(dataSource, definition, historyOffset) {
        window.assert(
            historyOffset >= 0 && historyOffset < _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].statisticsGraphSlices - 1,
            "Invalid slice offset: " + historyOffset
        );

        const slices = this.history[dataSource];
        return slices[slices.length - 2 - historyOffset][definition.getHash()] || 0;
    }

    /**
     * Returns the rates of all shapes
     * @param {enumAnalyticsDataSource} dataSource
     */
    getCurrentShapeRates(dataSource) {
        const slices = this.history[dataSource];

        // First, copy current slice
        const baseValues = Object.assign({}, slices[slices.length - 2]);

        // Add past values
        for (let i = 0; i < 10; ++i) {
            const pastValues = slices[slices.length - i - 3];
            for (const key in pastValues) {
                baseValues[key] = baseValues[key] || 0;
            }
        }

        return baseValues;
    }

    update() {
        if (this.root.time.now() - this.lastAnalyticsSlice > _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].analyticsSliceDurationSeconds) {
            this.lastAnalyticsSlice = this.root.time.now();
            this.startNewSlice();
        }
    }
}


/***/ }),

/***/ "./src/js/game/root.js":
/*!*****************************!*\
  !*** ./src/js/game/root.js ***!
  \*****************************/
/*! exports provided: GameRoot */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameRoot", function() { return GameRoot; });
/* harmony import */ var _core_signal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/signal */ "./src/js/core/signal.js");
/* harmony import */ var _core_rng__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/rng */ "./src/js/core/rng.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* eslint-disable no-unused-vars */





// Type hints


const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_2__["createLogger"])("game/root");

/**
 * The game root is basically the whole game state at a given point,
 * combining all important classes. We don't have globals, but this
 * class is passed to almost all game classes.
 */
class GameRoot {
    /**
     * Constructs a new game root
     * @param {Application} app
     */
    constructor(app) {
        this.app = app;

        /** @type {Savegame} */
        this.savegame = null;

        /** @type {InGameState} */
        this.gameState = null;

        /** @type {KeyActionMapper} */
        this.keyMapper = null;

        // Store game dimensions
        this.gameWidth = 500;
        this.gameHeight = 500;

        // Stores whether the current session is a fresh game (true), or was continued (false)
        /** @type {boolean} */
        this.gameIsFresh = true;

        // Stores whether the logic is already initialized
        /** @type {boolean} */
        this.logicInitialized = false;

        // Stores whether the game is already initialized, that is, all systems etc have been created
        /** @type {boolean} */
        this.gameInitialized = false;

        /**
         * Whether a bulk operation is running
         */
        this.bulkOperationRunning = false;

        //////// Other properties ///////

        /** @type {Camera} */
        this.camera = null;

        /** @type {HTMLCanvasElement} */
        this.canvas = null;

        /** @type {CanvasRenderingContext2D} */
        this.context = null;

        /** @type {MapView} */
        this.map = null;

        /** @type {GameLogic} */
        this.logic = null;

        /** @type {EntityManager} */
        this.entityMgr = null;

        /** @type {GameHUD} */
        this.hud = null;

        /** @type {GameSystemManager} */
        this.systemMgr = null;

        /** @type {GameTime} */
        this.time = null;

        /** @type {HubGoals} */
        this.hubGoals = null;

        /** @type {BufferMaintainer} */
        this.buffers = null;

        /** @type {CanvasClickInterceptor} */
        this.canvasClickInterceptor = null;

        /** @type {AutomaticSave} */
        this.automaticSave = null;

        /** @type {SoundProxy} */
        this.soundProxy = null;

        /** @type {ShapeDefinitionManager} */
        this.shapeDefinitionMgr = null;

        /** @type {ProductionAnalytics} */
        this.productionAnalytics = null;

        /** @type {DynamicTickrate} */
        this.dynamicTickrate = null;

        this.signals = {
            // Entities
            entityAdded: /** @type {TypedSignal<[Entity]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()),
            entityGotNewComponent: /** @type {TypedSignal<[Entity]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()),
            entityComponentRemoved: /** @type {TypedSignal<[Entity]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()),
            entityQueuedForDestroy: /** @type {TypedSignal<[Entity]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()),
            entityDestroyed: /** @type {TypedSignal<[Entity]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()),

            // Global
            resized: /** @type {TypedSignal<[number, number]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()),
            readyToRender: /** @type {TypedSignal<[]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()),
            aboutToDestruct: /** @type {TypedSignal<[]>} */ new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"](),

            // Game Hooks
            gameSaved: /** @type {TypedSignal<[]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()), // Game got saved
            gameRestored: /** @type {TypedSignal<[]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()), // Game got restored

            storyGoalCompleted: /** @type {TypedSignal<[number, string]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()),
            upgradePurchased: /** @type {TypedSignal<[string]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()),

            // Called right after game is initialized
            postLoadHook: /** @type {TypedSignal<[]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()),

            // Can be used to trigger an async task
            performAsync: /** @type {TypedSignal<[function]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()),

            shapeDelivered: /** @type {TypedSignal<[ShapeDefinition]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()),
            itemProduced: /** @type {TypedSignal<[BaseItem]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()),

            bulkOperationFinished: /** @type {TypedSignal<[]>} */ (new _core_signal__WEBPACK_IMPORTED_MODULE_0__["Signal"]()),
        };

        // RNG's
        /** @type {Object.<string, Object.<string, RandomNumberGenerator>>} */
        this.rngs = {};

        // Work queue
        this.queue = {
            requireRedraw: false,
        };
    }

    /**
     * Destructs the game root
     */
    destruct() {
        logger.log("destructing root");
        this.signals.aboutToDestruct.dispatch();

        this.reset();
    }

    /**
     * Resets the whole root and removes all properties
     */
    reset() {
        if (this.signals) {
            // Destruct all signals
            for (let i = 0; i < this.signals.length; ++i) {
                this.signals[i].removeAll();
            }
        }

        if (this.hud) {
            this.hud.cleanup();
        }
        if (this.camera) {
            this.camera.cleanup();
        }

        // Finally free all properties
        for (let prop in this) {
            if (this.hasOwnProperty(prop)) {
                delete this[prop];
            }
        }
    }
}


/***/ }),

/***/ "./src/js/game/shape_definition.js":
/*!*****************************************!*\
  !*** ./src/js/game/shape_definition.js ***!
  \*****************************************/
/*! exports provided: enumSubShape, enumSubShapeToShortcode, enumDefaultSubShapeColor, enumShortcodeToSubShape, createSimpleShape, ShapeDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumSubShape", function() { return enumSubShape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumSubShapeToShortcode", function() { return enumSubShapeToShortcode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumDefaultSubShapeColor", function() { return enumDefaultSubShapeColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumShortcodeToSubShape", function() { return enumShortcodeToSubShape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSimpleShape", function() { return createSimpleShape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeDefinition", function() { return ShapeDefinition; });
/* harmony import */ var _core_buffer_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/buffer_utils */ "./src/js/core/buffer_utils.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_dpi_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/dpi_manager */ "./src/js/core/dpi_manager.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../savegame/serialization */ "./src/js/savegame/serialization.js");
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./colors */ "./src/js/game/colors.js");
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./theme */ "./src/js/game/theme.js");











const rusha = __webpack_require__(/*! rusha */ "./node_modules/rusha/dist/rusha.js");

const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_5__["createLogger"])("shape_definition");

/**
 * @typedef {{
 *   subShape: enumSubShape,
 *   color: enumColors,
 * }} ShapeLayerItem
 */

/**
 * Order is Q1 (tr), Q2(br), Q3(bl), Q4(tl)
 * @typedef {[ShapeLayerItem?, ShapeLayerItem?, ShapeLayerItem?, ShapeLayerItem?]} ShapeLayer
 */

const arrayQuadrantIndexToOffset = [
    new _core_vector__WEBPACK_IMPORTED_MODULE_6__["Vector"](1, -1), // tr
    new _core_vector__WEBPACK_IMPORTED_MODULE_6__["Vector"](1, 1), // br
    new _core_vector__WEBPACK_IMPORTED_MODULE_6__["Vector"](-1, 1), // bl
    new _core_vector__WEBPACK_IMPORTED_MODULE_6__["Vector"](-1, -1), // tl
];

/** @enum {string} */
const enumSubShape = {
    rect: "rect",
    circle: "circle",
    star: "star",
    windmill: "windmill",

    clover: "clover",
    star8: "star8",
    rhombus: "rhombus",
    plus: "plus",
    razor: "razor",
    sun: "sun",
};

/** @enum {string} */
const enumSubShapeToShortcode = {
    [enumSubShape.rect]: "R",
    [enumSubShape.circle]: "C",
    [enumSubShape.star]: "S",
    [enumSubShape.windmill]: "W",

    [enumSubShape.clover]: "L",
    [enumSubShape.star8]: "T",
    [enumSubShape.rhombus]: "B",
    [enumSubShape.plus]: "P",
    [enumSubShape.razor]: "Z",
    [enumSubShape.sun]: "U",
};

/** @enum {string} */
const enumDefaultSubShapeColor = {
    [enumSubShape.clover]: _colors__WEBPACK_IMPORTED_MODULE_8__["enumColors"].green,
    [enumSubShape.sun]: _colors__WEBPACK_IMPORTED_MODULE_8__["enumColors"].yellow,
};

/** @enum {enumSubShape} */
const enumShortcodeToSubShape = {};
for (const key in enumSubShapeToShortcode) {
    enumShortcodeToSubShape[enumSubShapeToShortcode[key]] = key;
    if (!enumDefaultSubShapeColor[key]) enumDefaultSubShapeColor[key] = _colors__WEBPACK_IMPORTED_MODULE_8__["enumColors"].uncolored;
}

/**
 * Converts the given parameters to a valid shape definition
 * @param {*} layers
 * @returns {Array<import("./shape_definition").ShapeLayer>}
 */
function createSimpleShape(layers) {
    layers.forEach(layer => {
        layer.forEach(item => {
            if (item) {
                item.color = item.color || _colors__WEBPACK_IMPORTED_MODULE_8__["enumColors"].uncolored;
            }
        });
    });
    return layers;
}

class ShapeDefinition extends _savegame_serialization__WEBPACK_IMPORTED_MODULE_7__["BasicSerializableObject"] {
    static getId() {
        return "ShapeDefinition";
    }

    static getSchema() {
        return {};
    }

    deserialize(data) {
        const errorCode = super.deserialize(data);
        if (errorCode) {
            return errorCode;
        }
        const definition = ShapeDefinition.fromShortKey(data);
        this.layers = definition.layers;
    }

    serialize() {
        return this.getHash();
    }

    /**
     *
     * @param {object} param0
     * @param {Array<ShapeLayer>=} param0.layers
     */
    constructor({ layers = [] }) {
        super();

        /**
         * The layers from bottom to top
         * @type {Array<ShapeLayer>} */
        this.layers = layers;

        /** @type {string} */
        this.cachedHash = null;

        // Set on demand
        this.bufferGenerator = null;
    }

    /**
     * Generates the definition from the given short key
     */
    static fromShortKey(key) {
        const sourceLayers = key.split(":");
        let layers = [];
        for (let i = 0; i < sourceLayers.length; ++i) {
            const text = sourceLayers[i];
            window.assert(text.length === 8, "Invalid shape short key: " + key);

            /** @type {ShapeLayer} */
            const quads = [null, null, null, null];
            for (let quad = 0; quad < 4; ++quad) {
                const shapeText = text[quad * 2 + 0];
                const subShape = enumShortcodeToSubShape[shapeText];
                const color = _colors__WEBPACK_IMPORTED_MODULE_8__["enumShortcodeToColor"][text[quad * 2 + 1]];
                if (subShape) {
                    window.assert(color, "Invalid shape short key:", key);
                    quads[quad] = {
                        subShape,
                        color,
                    };
                } else if (shapeText !== "-") {
                    window.assert(false, "Invalid shape key: " + shapeText);
                }
            }
            layers.push(quads);
        }

        const definition = new ShapeDefinition({ layers });
        // We know the hash so save some work
        definition.cachedHash = key;
        return definition;
    }

    /**
     * Internal method to clone the shape definition
     * @returns {Array<ShapeLayer>}
     */
    internalCloneLayers() {
        return Object(_core_builtins__WEBPACK_IMPORTED_MODULE_1__["JSON_parse"])(Object(_core_builtins__WEBPACK_IMPORTED_MODULE_1__["JSON_stringify"])(this.layers));
    }

    /**
     * Returns if the definition is entirely empty^
     * @returns {boolean}
     */
    isEntirelyEmpty() {
        return this.layers.length === 0;
    }

    /**
     * Returns a unique id for this shape
     * @returns {string}
     */
    getHash() {
        if (this.cachedHash) {
            return this.cachedHash;
        }

        let id = "";
        for (let layerIndex = 0; layerIndex < this.layers.length; ++layerIndex) {
            const layer = this.layers[layerIndex];

            for (let quadrant = 0; quadrant < layer.length; ++quadrant) {
                const item = layer[quadrant];
                if (item) {
                    id += enumSubShapeToShortcode[item.subShape] + _colors__WEBPACK_IMPORTED_MODULE_8__["enumColorToShortcode"][item.color];
                } else {
                    id += "--";
                }
            }

            if (layerIndex < this.layers.length - 1) {
                id += ":";
            }
        }
        this.cachedHash = id;
        return id;
    }

    /**
     * Draws the shape definition
     * @param {number} x
     * @param {number} y
     * @param {DrawParameters} parameters
     */
    draw(x, y, parameters, size = 20) {
        const dpi = Object(_core_dpi_manager__WEBPACK_IMPORTED_MODULE_3__["smoothenDpi"])(_core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].shapesSharpness * parameters.zoomLevel);

        if (!this.bufferGenerator) {
            this.bufferGenerator = this.internalGenerateShapeBuffer.bind(this);
        }

        const key = size + "/" + dpi;
        const canvas = parameters.root.buffers.getForKey(
            key,
            this.cachedHash,
            size,
            size,
            dpi,
            this.bufferGenerator
        );
        parameters.context.drawImage(canvas, x - size / 2, y - size / 2, size, size);
    }

    /**
     * Generates this shape as a canvas
     * @param {number} size
     */
    generateAsCanvas(size = 120) {
        const [canvas, context] = Object(_core_buffer_utils__WEBPACK_IMPORTED_MODULE_0__["makeOffscreenBuffer"])(size, size, {
            smooth: true,
            label: "definition-canvas-cache-" + this.getHash(),
            reusable: false,
        });

        this.internalGenerateShapeBuffer(canvas, context, size, size, 1);
        return canvas;
    }

    /**
     *
     * @param {HTMLCanvasElement} canvas
     * @param {CanvasRenderingContext2D} context
     * @param {number} w
     * @param {number} h
     * @param {number} dpi
     */
    internalGenerateShapeBuffer(canvas, context, w, h, dpi) {
        context.translate((w * dpi) / 2, (h * dpi) / 2);
        context.scale((dpi * w) / 23, (dpi * h) / 23);

        context.fillStyle = "#e9ecf7";

        const quadrantSize = 10;
        const quadrantHalfSize = quadrantSize / 2;

        context.fillStyle = "rgba(40, 50, 65, 0.1)";
        context.beginCircle(0, 0, quadrantSize * 1.15);
        context.fill();

        for (let layerIndex = 0; layerIndex < this.layers.length; ++layerIndex) {
            const quadrants = this.layers[layerIndex];

            const layerScale = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_max"])(0.1, 0.9 - layerIndex * 0.22);

            for (let quadrantIndex = 0; quadrantIndex < 4; ++quadrantIndex) {
                if (!quadrants[quadrantIndex]) {
                    continue;
                }
                const { subShape, color } = quadrants[quadrantIndex];

                const quadrantPos = arrayQuadrantIndexToOffset[quadrantIndex];
                const centerQuadrantX = quadrantPos.x * quadrantHalfSize;
                const centerQuadrantY = quadrantPos.y * quadrantHalfSize;

                const rotation = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_1__["Math_radians"])(quadrantIndex * 90);

                context.translate(centerQuadrantX, centerQuadrantY);
                context.rotate(rotation);

                context.fillStyle = _colors__WEBPACK_IMPORTED_MODULE_8__["enumColorsToHexCode"][color];
                context.strokeStyle = _theme__WEBPACK_IMPORTED_MODULE_9__["THEME"].items.outline;
                context.lineWidth = _theme__WEBPACK_IMPORTED_MODULE_9__["THEME"].items.outlineWidth;

                const insetPadding = 0.0;

                const dims = quadrantSize * layerScale;
                const innerDims = insetPadding - quadrantHalfSize;
                switch (subShape) {
                    case enumSubShape.rect: {
                        context.beginPath();
                        const dims = quadrantSize * layerScale;
                        context.rect(
                            insetPadding + -quadrantHalfSize,
                            -insetPadding + quadrantHalfSize - dims,
                            dims,
                            dims
                        );

                        break;
                    }
                    case enumSubShape.star: {
                        context.beginPath();
                        const dims = quadrantSize * layerScale;

                        let originX = insetPadding - quadrantHalfSize;
                        let originY = -insetPadding + quadrantHalfSize - dims;

                        const moveInwards = dims * 0.4;
                        context.moveTo(originX, originY + moveInwards);
                        context.lineTo(originX + dims, originY);
                        context.lineTo(originX + dims - moveInwards, originY + dims);
                        context.lineTo(originX, originY + dims);
                        context.closePath();
                        break;
                    }

                    case enumSubShape.windmill: {
                        context.beginPath();
                        const dims = quadrantSize * layerScale;

                        let originX = insetPadding - quadrantHalfSize;
                        let originY = -insetPadding + quadrantHalfSize - dims;
                        const moveInwards = dims * 0.4;
                        context.moveTo(originX, originY + moveInwards);
                        context.lineTo(originX + dims, originY);
                        context.lineTo(originX + dims, originY + dims);
                        context.lineTo(originX, originY + dims);
                        context.closePath();
                        break;
                    }

                    case enumSubShape.circle: {
                        context.beginPath();
                        context.moveTo(insetPadding + -quadrantHalfSize, -insetPadding + quadrantHalfSize);
                        context.arc(
                            insetPadding + -quadrantHalfSize,
                            -insetPadding + quadrantHalfSize,
                            quadrantSize * layerScale,
                            -Math.PI * 0.5,
                            0
                        );
                        context.closePath();
                        break;
                    }

                    case enumSubShape.clover: {
                        context.save();
                        context.translate(innerDims, -innerDims);
                        context.scale(dims, -dims);
                        context.beginPath();

                        const inner = 0.5;
                        const inner_center = 0.45;
                        const size = 1.3;
                        context.scale(size, size);

                        context.moveTo(0, 0);
                        context.lineTo(0, inner);
                        context.bezierCurveTo(0, 1, inner, 1, inner_center, inner_center);
                        context.bezierCurveTo(1, inner, 1, 0, inner, 0);

                        context.closePath();
                        context.restore();
                        break;
                    }
                    case enumSubShape.star8: {
                        context.save();
                        context.translate(innerDims, -innerDims);
                        context.scale(dims, -dims);
                        context.beginPath();

                        const inner = 0.5;
                        const size = 1.22;
                        context.scale(size, size);

                        context.moveTo(0, 0);
                        context.lineTo(0, inner);
                        context.lineTo(Math.sin(Math.PI / 8), Math.cos(Math.PI / 8));
                        context.lineTo(inner * Math.sin(Math.PI / 4), inner * Math.cos(Math.PI / 4));
                        context.lineTo(Math.sin((Math.PI * 3) / 8), Math.cos((Math.PI * 3) / 8));
                        context.lineTo(inner, 0);

                        context.closePath();
                        context.restore();
                        break;
                    }
                    case enumSubShape.rhombus: {
                        context.save();
                        context.translate(innerDims, -innerDims);
                        context.scale(dims, -dims);
                        context.beginPath();

                        const rad = 0.001;
                        const size = 1.2;
                        context.scale(size, size);

                        // with rounded borders
                        context.moveTo(0, 0);
                        context.arcTo(0, 1, 1, 0, rad);
                        context.arcTo(1, 0, 0, 0, rad);

                        context.closePath();
                        context.restore();
                        break;
                    }
                    case enumSubShape.plus: {
                        context.save();
                        context.translate(innerDims, -innerDims);
                        context.scale(dims, -dims);
                        context.beginPath();

                        const inner = 0.4;
                        const size = 1.2;
                        context.scale(size, size);

                        context.moveTo(0, 0);
                        context.lineTo(1, 0);
                        context.lineTo(1, inner);
                        context.lineTo(inner, inner);
                        context.lineTo(inner, 1);
                        context.lineTo(0, 1);

                        context.closePath();
                        context.restore();
                        break;
                    }
                    case enumSubShape.razor: {
                        context.save();
                        context.translate(innerDims, -innerDims);
                        context.scale(dims, -dims);
                        context.beginPath();

                        const inner = 0.5;
                        const size = 1.1;
                        context.scale(size, size);

                        context.moveTo(0, 0);
                        context.lineTo(inner, 0);
                        context.bezierCurveTo(inner, 0.3, 1, 0.3, 1, 0);
                        context.bezierCurveTo(
                            1,
                            inner,
                            inner * Math.SQRT2 * 0.9,
                            inner * Math.SQRT2 * 0.9,
                            inner * Math.SQRT1_2,
                            inner * Math.SQRT1_2
                        );
                        context.rotate(Math.PI / 4);
                        context.bezierCurveTo(inner, 0.3, 1, 0.3, 1, 0);
                        context.bezierCurveTo(
                            1,
                            inner,
                            inner * Math.SQRT2 * 0.9,
                            inner * Math.SQRT2 * 0.9,
                            inner * Math.SQRT1_2,
                            inner * Math.SQRT1_2
                        );

                        context.closePath();
                        context.restore();
                        break;
                    }
                    case enumSubShape.sun: {
                        context.save();
                        context.translate(innerDims, -innerDims);
                        context.scale(dims, -dims);
                        context.beginPath();

                        const inner = 0.4;
                        const rad = 0.02;
                        const size = 1.22;
                        context.scale(size, size);

                        const PI = Math.PI;
                        const PI3 = (PI * 3) / 8;

                        const c = 1 / Math.cos(Math.PI / 8);
                        const b = c * Math.sin(Math.PI / 8);

                        context.moveTo(0, 0);
                        context.rotate(Math.PI / 2);
                        context.arc(c, 0, b, -PI, -PI + PI3);
                        context.rotate(-Math.PI / 4);
                        context.arc(c, 0, b, -PI - PI3, -PI + PI3);
                        context.rotate(-Math.PI / 4);
                        context.arc(c, 0, b, PI - PI3, PI);

                        context.closePath();
                        context.restore();
                        break;
                    }
                    // case enumSubShape.none:
                    //     {
                    //         context.beginPath();
                    //         break;
                    //     }
                    default: {
                        context.save();
                        context.translate(innerDims, -innerDims);
                        context.scale(dims / 8, dims / 8);
                        context.beginPath();
                        context.fillText(subShape || "?", 0, 0);
                        context.restore();
                    }
                }

                context.fill();
                context.stroke();

                context.rotate(-rotation);
                context.translate(-centerQuadrantX, -centerQuadrantY);
            }
        }
    }

    /**
     * Returns a definition with only the given quadrants
     * @param {Array<number>} includeQuadrants
     * @returns {ShapeDefinition}
     */
    cloneFilteredByQuadrants(includeQuadrants) {
        const newLayers = this.internalCloneLayers();
        for (let layerIndex = 0; layerIndex < newLayers.length; ++layerIndex) {
            const quadrants = newLayers[layerIndex];
            let anyContents = false;
            for (let quadrantIndex = 0; quadrantIndex < 4; ++quadrantIndex) {
                if (includeQuadrants.indexOf(quadrantIndex) < 0) {
                    quadrants[quadrantIndex] = null;
                } else if (quadrants[quadrantIndex]) {
                    anyContents = true;
                }
            }

            // Check if the layer is entirely empty
            if (!anyContents) {
                newLayers.splice(layerIndex, 1);
                layerIndex -= 1;
            }
        }
        return new ShapeDefinition({ layers: newLayers });
    }

    /**
     * Returns a definition which was rotated clockwise
     * @returns {ShapeDefinition}
     */
    cloneRotateCW() {
        const newLayers = this.internalCloneLayers();
        for (let layerIndex = 0; layerIndex < newLayers.length; ++layerIndex) {
            const quadrants = newLayers[layerIndex];
            quadrants.unshift(quadrants[3]);
            quadrants.pop();
        }
        return new ShapeDefinition({ layers: newLayers });
    }

    /**
     * Returns a definition which was rotated counter clockwise
     * @returns {ShapeDefinition}
     */
    cloneRotateCCW() {
        const newLayers = this.internalCloneLayers();
        for (let layerIndex = 0; layerIndex < newLayers.length; ++layerIndex) {
            const quadrants = newLayers[layerIndex];
            quadrants.push(quadrants[0]);
            quadrants.shift();
        }
        return new ShapeDefinition({ layers: newLayers });
    }

    /**
     * Stacks the given shape definition on top.
     * @param {ShapeDefinition} definition
     */
    cloneAndStackWith(definition) {
        const newLayers = this.internalCloneLayers();

        if (this.isEntirelyEmpty() || definition.isEntirelyEmpty()) {
            window.assert(false, "Can not stack entirely empty definition");
        }

        // Put layer for layer on top
        for (let i = 0; i < definition.layers.length; ++i) {
            const layerToAdd = definition.layers[i];

            // On which layer we can merge this upper layer
            let mergeOnLayerIndex = null;

            // Go from top to bottom and check if there is anything intercepting it
            for (let k = newLayers.length - 1; k >= 0; --k) {
                const lowerLayer = newLayers[k];

                let canMerge = true;
                for (let quadrantIndex = 0; quadrantIndex < 4; ++quadrantIndex) {
                    const upperItem = layerToAdd[quadrantIndex];
                    const lowerItem = lowerLayer[quadrantIndex];

                    if (upperItem && lowerItem) {
                        // so, we can't merge it because two items conflict
                        canMerge = false;
                        break;
                    }
                }

                // If we can merge it, store it - since we go from top to bottom
                // we can simply override it
                if (canMerge) {
                    mergeOnLayerIndex = k;
                }
            }

            if (mergeOnLayerIndex !== null) {
                // Simply merge using an OR mask
                for (let quadrantIndex = 0; quadrantIndex < 4; ++quadrantIndex) {
                    newLayers[mergeOnLayerIndex][quadrantIndex] =
                        newLayers[mergeOnLayerIndex][quadrantIndex] || layerToAdd[quadrantIndex];
                }
            } else {
                // Add new layer
                newLayers.push(layerToAdd);
            }
        }

        newLayers.splice(4);

        return new ShapeDefinition({ layers: newLayers });
    }

    /**
     * Clones the shape and colors everything in the given color
     * @param {enumColors} color
     */
    cloneAndPaintWith(color) {
        const newLayers = this.internalCloneLayers();

        for (let layerIndex = 0; layerIndex < newLayers.length; ++layerIndex) {
            const quadrants = newLayers[layerIndex];
            for (let quadrantIndex = 0; quadrantIndex < 4; ++quadrantIndex) {
                const item = quadrants[quadrantIndex];
                if (item) {
                    item.color = color;
                }
            }
        }
        return new ShapeDefinition({ layers: newLayers });
    }

    /**
     * Clones the shape and colors everything in the given colors
     * @param {[enumColors, enumColors, enumColors, enumColors]} colors
     */
    cloneAndPaintWith4Colors(colors) {
        const newLayers = this.internalCloneLayers();

        for (let layerIndex = 0; layerIndex < newLayers.length; ++layerIndex) {
            const quadrants = newLayers[layerIndex];
            for (let quadrantIndex = 0; quadrantIndex < 4; ++quadrantIndex) {
                const item = quadrants[quadrantIndex];
                if (item) {
                    item.color = colors[quadrantIndex];
                }
            }
        }
        return new ShapeDefinition({ layers: newLayers });
    }
}


/***/ }),

/***/ "./src/js/game/shape_definition_manager.js":
/*!*************************************************!*\
  !*** ./src/js/game/shape_definition_manager.js ***!
  \*************************************************/
/*! exports provided: ShapeDefinitionManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeDefinitionManager", function() { return ShapeDefinitionManager; });
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../savegame/serialization */ "./src/js/savegame/serialization.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./root */ "./src/js/game/root.js");
/* harmony import */ var _shape_definition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shape_definition */ "./src/js/game/shape_definition.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./colors */ "./src/js/game/colors.js");






const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_3__["createLogger"])("shape_definition_manager");

class ShapeDefinitionManager extends _savegame_serialization__WEBPACK_IMPORTED_MODULE_0__["BasicSerializableObject"] {
    static getId() {
        return "ShapeDefinitionManager";
    }

    /**
     *
     * @param {GameRoot} root
     */
    constructor(root) {
        super();
        this.root = root;

        this.shapeKeyToDefinition = {};

        // Caches operations in the form of 'operation:def1[:def2]'
        /** @type {Object.<string, Array<ShapeDefinition>|ShapeDefinition>} */
        this.operationCache = {};
    }

    /**
     *
     * @param {string} hash
     * @returns {ShapeDefinition}
     */
    getShapeFromShortKey(hash) {
        const cached = this.shapeKeyToDefinition[hash];
        if (cached) {
            return cached;
        }
        return (this.shapeKeyToDefinition[hash] = _shape_definition__WEBPACK_IMPORTED_MODULE_2__["ShapeDefinition"].fromShortKey(hash));
    }

    /**
     * Registers a new shape definition
     * @param {ShapeDefinition} definition
     */
    registerShapeDefinition(definition) {
        const id = definition.getHash();
        window.assert(!this.shapeKeyToDefinition[id], "Shape Definition " + id + " already exists");
        this.shapeKeyToDefinition[id] = definition;
        // logger.log("Registered shape with key", id);
    }

    /**
     * Generates a definition for splitting a shape definition in two halfs
     * @param {ShapeDefinition} definition
     * @returns {[ShapeDefinition, ShapeDefinition]}
     */
    shapeActionCutHalf(definition) {
        const key = "cut:" + definition.getHash();
        if (this.operationCache[key]) {
            return /** @type {[ShapeDefinition, ShapeDefinition]} */ (this.operationCache[key]);
        }
        const rightSide = definition.cloneFilteredByQuadrants([2, 3]);
        const leftSide = definition.cloneFilteredByQuadrants([0, 1]);

        return /** @type {[ShapeDefinition, ShapeDefinition]} */ (this.operationCache[key] = [
            this.registerOrReturnHandle(rightSide),
            this.registerOrReturnHandle(leftSide),
        ]);
    }

    /**
     * Generates a definition for splitting a shape definition in four quads
     * @param {ShapeDefinition} definition
     * @returns {[ShapeDefinition, ShapeDefinition, ShapeDefinition, ShapeDefinition]}
     */
    shapeActionCutQuad(definition) {
        const key = "cut-quad:" + definition.getHash();
        if (this.operationCache[key]) {
            return /** @type {[ShapeDefinition, ShapeDefinition, ShapeDefinition, ShapeDefinition]} */ (this
                .operationCache[key]);
        }

        return /** @type {[ShapeDefinition, ShapeDefinition, ShapeDefinition, ShapeDefinition]} */ (this.operationCache[
            key
        ] = [
            this.registerOrReturnHandle(definition.cloneFilteredByQuadrants([0])),
            this.registerOrReturnHandle(definition.cloneFilteredByQuadrants([1])),
            this.registerOrReturnHandle(definition.cloneFilteredByQuadrants([2])),
            this.registerOrReturnHandle(definition.cloneFilteredByQuadrants([3])),
        ]);
    }

    /**
     * Generates a definition for rotating a shape clockwise
     * @param {ShapeDefinition} definition
     * @returns {ShapeDefinition}
     */
    shapeActionRotateCW(definition) {
        const key = "rotate-cw:" + definition.getHash();
        if (this.operationCache[key]) {
            return /** @type {ShapeDefinition} */ (this.operationCache[key]);
        }

        const rotated = definition.cloneRotateCW();

        return /** @type {ShapeDefinition} */ (this.operationCache[key] = this.registerOrReturnHandle(
            rotated
        ));
    }

    /**
     * Generates a definition for rotating a shape counter clockwise
     * @param {ShapeDefinition} definition
     * @returns {ShapeDefinition}
     */
    shapeActionRotateCCW(definition) {
        const key = "rotate-ccw:" + definition.getHash();
        if (this.operationCache[key]) {
            return /** @type {ShapeDefinition} */ (this.operationCache[key]);
        }

        const rotated = definition.cloneRotateCCW();

        return /** @type {ShapeDefinition} */ (this.operationCache[key] = this.registerOrReturnHandle(
            rotated
        ));
    }

    /**
     * Generates a definition for stacking the upper definition onto the lower one
     * @param {ShapeDefinition} lowerDefinition
     * @param {ShapeDefinition} upperDefinition
     * @returns {ShapeDefinition}
     */
    shapeActionStack(lowerDefinition, upperDefinition) {
        const key = "stack:" + lowerDefinition.getHash() + ":" + upperDefinition.getHash();
        if (this.operationCache[key]) {
            return /** @type {ShapeDefinition} */ (this.operationCache[key]);
        }
        const stacked = lowerDefinition.cloneAndStackWith(upperDefinition);
        return /** @type {ShapeDefinition} */ (this.operationCache[key] = this.registerOrReturnHandle(
            stacked
        ));
    }

    /**
     * Generates a definition for painting it with the given color
     * @param {ShapeDefinition} definition
     * @param {enumColors} color
     * @returns {ShapeDefinition}
     */
    shapeActionPaintWith(definition, color) {
        const key = "paint:" + definition.getHash() + ":" + color;
        if (this.operationCache[key]) {
            return /** @type {ShapeDefinition} */ (this.operationCache[key]);
        }
        const colorized = definition.cloneAndPaintWith(color);
        return /** @type {ShapeDefinition} */ (this.operationCache[key] = this.registerOrReturnHandle(
            colorized
        ));
    }

    /**
     * Generates a definition for painting it with the 4 colors
     * @param {ShapeDefinition} definition
     * @param {[enumColors, enumColors, enumColors, enumColors]} colors
     * @returns {ShapeDefinition}
     */
    shapeActionPaintWith4Colors(definition, colors) {
        const key = "paint4:" + definition.getHash() + ":" + colors.join(",");
        if (this.operationCache[key]) {
            return /** @type {ShapeDefinition} */ (this.operationCache[key]);
        }
        const colorized = definition.cloneAndPaintWith4Colors(colors);
        return /** @type {ShapeDefinition} */ (this.operationCache[key] = this.registerOrReturnHandle(
            colorized
        ));
    }

    /**
     * Checks if we already have cached this definition, and if so throws it away and returns the already
     * cached variant
     * @param {ShapeDefinition} definition
     */
    registerOrReturnHandle(definition) {
        const id = definition.getHash();
        if (this.shapeKeyToDefinition[id]) {
            return this.shapeKeyToDefinition[id];
        }
        this.shapeKeyToDefinition[id] = definition;
        // logger.log("Registered shape with key (2)", id);
        return definition;
    }

    /**
     *
     * @param {[enumSubShape, enumSubShape, enumSubShape, enumSubShape]} subShapes
     * @returns {ShapeDefinition}
     */
    getDefinitionFromSimpleShapes(subShapes, color = _colors__WEBPACK_IMPORTED_MODULE_4__["enumColors"].uncolored) {
        const shapeLayer = /** @type {import("./shape_definition").ShapeLayer} */ (subShapes.map(
            subShape => ({ subShape, color })
        ));

        return this.registerOrReturnHandle(new _shape_definition__WEBPACK_IMPORTED_MODULE_2__["ShapeDefinition"]({ layers: [shapeLayer] }));
    }

    /**
     *
     * @param {[enumSubShape, enumSubShape, enumSubShape, enumSubShape]} subShapes
     * @param {[enumColors, enumColors, enumColors, enumColors]} colors
     * @returns {ShapeDefinition}
     */
    getDefinitionFromSimpleShapesAndColors(subShapes, colors) {
        const shapeLayer = /** @type {import("./shape_definition").ShapeLayer} */ (subShapes.map(
            (subShape, i) => ({ subShape, color: colors[i] })
        ));

        return this.registerOrReturnHandle(new _shape_definition__WEBPACK_IMPORTED_MODULE_2__["ShapeDefinition"]({ layers: [shapeLayer] }));
    }
}


/***/ }),

/***/ "./src/js/game/sound_proxy.js":
/*!************************************!*\
  !*** ./src/js/game/sound_proxy.js ***!
  \************************************/
/*! exports provided: SoundProxy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SoundProxy", function() { return SoundProxy; });
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _platform_sound__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/sound */ "./src/js/platform/sound.js");





const avgSoundDurationSeconds = 0.25;
const maxOngoingSounds = 10;

// Proxy to the application sound instance
class SoundProxy {
    /**
     * @param {GameRoot} root
     */
    constructor(root) {
        this.root = root;

        // Store a list of sounds and when we started them
        this.playingSounds = [];
    }

    /**
     * Plays a new ui sound
     * @param {string} id Sound ID
     */
    playUi(id) {
        window.assert(typeof id === "string", "Not a valid sound id: " + id);
        this.root.app.sound.playUiSound(id);
    }

    /**
     * Plays the ui click sound
     */
    playUiClick() {
        this.playUi(_platform_sound__WEBPACK_IMPORTED_MODULE_1__["SOUNDS"].uiClick);
    }

    /**
     * Plays the ui error sound
     */
    playUiError() {
        this.playUi(_platform_sound__WEBPACK_IMPORTED_MODULE_1__["SOUNDS"].uiError);
    }

    /**
     * Plays a 3D sound whose volume is scaled based on where it was emitted
     * @param {string} id Sound ID
     * @param {Vector} pos World space position
     */
    play3D(id, pos) {
        window.assert(typeof id === "string", "Not a valid sound id: " + id);
        window.assert(pos instanceof _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"], "Invalid sound position");
        this.internalUpdateOngoingSounds();

        if (this.playingSounds.length > maxOngoingSounds) {
            // Too many ongoing sounds
            return false;
        }

        this.root.app.sound.play3DSound(id, pos, this.root);
        this.playingSounds.push(this.root.time.realtimeNow());
        return true;
    }

    /**
     * Updates the list of ongoing sounds
     */
    internalUpdateOngoingSounds() {
        const now = this.root.time.realtimeNow();
        for (let i = 0; i < this.playingSounds.length; ++i) {
            if (now - this.playingSounds[i] > avgSoundDurationSeconds) {
                this.playingSounds.splice(i, 1);
                i -= 1;
            }
        }
    }
}


/***/ }),

/***/ "./src/js/game/systems/belt.js":
/*!*************************************!*\
  !*** ./src/js/game/systems/belt.js ***!
  \*************************************/
/*! exports provided: BeltSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BeltSystem", function() { return BeltSystem; });
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _core_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/loader */ "./src/js/core/loader.js");
/* harmony import */ var _core_sprites__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/sprites */ "./src/js/core/sprites.js");
/* harmony import */ var _components_belt__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/belt */ "./src/js/game/components/belt.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _game_system_with_filter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../game_system_with_filter */ "./src/js/game/game_system_with_filter.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _map_chunk_view__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../map_chunk_view */ "./src/js/game/map_chunk_view.js");
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/global_registries */ "./src/js/core/global_registries.js");
/* harmony import */ var _buildings_belt_base__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../buildings/belt_base */ "./src/js/game/buildings/belt_base.js");
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../root */ "./src/js/game/root.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../core/logging */ "./src/js/core/logging.js");
















const BELT_ANIM_COUNT = 6;

const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_14__["createLogger"])("belt");

/** @typedef {Array<{ entity: Entity, followUp: Entity }>} BeltCache */

class BeltSystem extends _game_system_with_filter__WEBPACK_IMPORTED_MODULE_7__["GameSystemWithFilter"] {
    constructor(root) {
        super(root, [_components_belt__WEBPACK_IMPORTED_MODULE_5__["BeltComponent"]]);
        /**
         * @type {Object.<enumDirection, Array<AtlasSprite>>}
         */
        this.beltSprites = {
            [_core_vector__WEBPACK_IMPORTED_MODULE_8__["enumDirection"].top]: _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/forward_0.png"),
            [_core_vector__WEBPACK_IMPORTED_MODULE_8__["enumDirection"].left]: _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/left_0.png"),
            [_core_vector__WEBPACK_IMPORTED_MODULE_8__["enumDirection"].right]: _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/right_0.png"),
        };
        /**b
         * @type {Object.<enumDirection, Array<AtlasSprite>>}
         */
        this.beltAnimations = {
            [_core_vector__WEBPACK_IMPORTED_MODULE_8__["enumDirection"].top]: [
                _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/forward_0.png"),
                _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/forward_1.png"),
                _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/forward_2.png"),
                _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/forward_3.png"),
                _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/forward_4.png"),
                _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/forward_5.png"),
            ],
            [_core_vector__WEBPACK_IMPORTED_MODULE_8__["enumDirection"].left]: [
                _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/left_0.png"),
                _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/left_1.png"),
                _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/left_2.png"),
                _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/left_3.png"),
                _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/left_4.png"),
                _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/left_5.png"),
            ],
            [_core_vector__WEBPACK_IMPORTED_MODULE_8__["enumDirection"].right]: [
                _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/right_0.png"),
                _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/right_1.png"),
                _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/right_2.png"),
                _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/right_3.png"),
                _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/right_4.png"),
                _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite("sprites/belt/right_5.png"),
            ],
        };

        this.root.signals.entityAdded.add(this.updateSurroundingBeltPlacement, this);
        this.root.signals.entityDestroyed.add(this.updateSurroundingBeltPlacement, this);

        this.cacheNeedsUpdate = true;

        /** @type {BeltCache} */
        this.beltCache = [];
    }

    /**
     * Updates the belt placement after an entity has been added / deleted
     * @param {Entity} entity
     */
    updateSurroundingBeltPlacement(entity) {
        if (!this.root.gameInitialized) {
            return;
        }

        const staticComp = entity.components.StaticMapEntity;
        if (!staticComp) {
            return;
        }

        if (entity.components.Belt) {
            this.cacheNeedsUpdate = true;
        }

        const metaBelt = _core_global_registries__WEBPACK_IMPORTED_MODULE_10__["gMetaBuildingRegistry"].findByClass(_buildings_belt_base__WEBPACK_IMPORTED_MODULE_11__["MetaBeltBaseBuilding"]);

        // Compute affected area
        const originalRect = staticComp.getTileSpaceBounds();
        const affectedArea = originalRect.expandedInAllDirections(1);
        for (let x = affectedArea.x; x < affectedArea.right(); ++x) {
            for (let y = affectedArea.y; y < affectedArea.bottom(); ++y) {
                if (!originalRect.containsPoint(x, y)) {
                    const targetEntity = this.root.map.getTileContentXY(x, y);
                    if (targetEntity) {
                        const targetBeltComp = targetEntity.components.Belt;
                        if (targetBeltComp) {
                            const targetStaticComp = targetEntity.components.StaticMapEntity;
                            const {
                                rotation,
                                rotationVariant,
                            } = metaBelt.computeOptimalDirectionAndRotationVariantAtTile(
                                this.root,
                                new _core_vector__WEBPACK_IMPORTED_MODULE_8__["Vector"](x, y),
                                targetStaticComp.originalRotation,
                                _meta_building__WEBPACK_IMPORTED_MODULE_12__["defaultBuildingVariant"]
                            );
                            targetStaticComp.rotation = rotation;
                            metaBelt.updateVariants(targetEntity, rotationVariant, _meta_building__WEBPACK_IMPORTED_MODULE_12__["defaultBuildingVariant"]);
                            this.cacheNeedsUpdate = true;
                        }
                    }
                }
            }
        }
    }

    draw(parameters) {
        this.forEachMatchingEntityOnScreen(parameters, this.drawEntityItems.bind(this));
    }

    /**
     * Finds the follow up entity for a given belt. Used for building the dependencies
     * @param {Entity} entity
     */
    findFollowUpEntity(entity) {
        const staticComp = entity.components.StaticMapEntity;
        const beltComp = entity.components.Belt;

        const followUpDirection = staticComp.localDirectionToWorld(beltComp.direction);
        const followUpVector = _core_vector__WEBPACK_IMPORTED_MODULE_8__["enumDirectionToVector"][followUpDirection];

        const followUpTile = staticComp.origin.add(followUpVector);
        const followUpEntity = this.root.map.getTileContent(followUpTile);

        // Check if theres a belt at the tile we point to
        if (followUpEntity) {
            const followUpBeltComp = followUpEntity.components.Belt;
            if (followUpBeltComp) {
                const followUpStatic = followUpEntity.components.StaticMapEntity;
                const followUpAcceptor = followUpEntity.components.ItemAcceptor;

                // Check if the belt accepts items from our direction
                const acceptorSlots = followUpAcceptor.slots;
                for (let i = 0; i < acceptorSlots.length; ++i) {
                    const slot = acceptorSlots[i];
                    for (let k = 0; k < slot.directions.length; ++k) {
                        const localDirection = followUpStatic.localDirectionToWorld(slot.directions[k]);
                        if (_core_vector__WEBPACK_IMPORTED_MODULE_8__["enumInvertedDirections"][localDirection] === followUpDirection) {
                            return followUpEntity;
                        }
                    }
                }
            }
        }

        return null;
    }

    /**
     * Adds a single entity to the cache
     * @param {Entity} entity
     * @param {BeltCache} cache
     * @param {Set} visited
     */
    computeSingleBeltCache(entity, cache, visited) {
        // Check for double visit
        if (visited.has(entity.uid)) {
            return;
        }
        visited.add(entity.uid);

        if (entity.components.Belt) {
            entity.components.ItemEjector.instantEject = true;
        }

        const followUp = this.findFollowUpEntity(entity);
        if (followUp) {
            // Process followup first
            this.computeSingleBeltCache(followUp, cache, visited);
        }

        cache.push({ entity, followUp });
    }

    computeBeltCache() {
        logger.log("Updating belt cache");

        let cache = [];
        let visited = new Set();
        for (let i = 0; i < this.allEntities.length; ++i) {
            this.computeSingleBeltCache(this.allEntities[i], cache, visited);
        }
        window.assert(
            cache.length === this.allEntities.length,
            "Belt cache mismatch: Has " + cache.length + " entries but should have " + this.allEntities.length
        );

        this.beltCache = cache;
    }

    update() {
        if (this.cacheNeedsUpdate) {
            this.cacheNeedsUpdate = false;
            this.computeBeltCache();
        }

        // Divide by item spacing on belts since we use throughput and not speed
        let beltSpeed =
            this.root.hubGoals.getBeltBaseSpeed() *
            this.root.dynamicTickrate.deltaSeconds *
            _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].itemSpacingOnBelts;
        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].debug.instantBelts) {
            beltSpeed *= 100;
        }

        for (let i = 0; i < this.beltCache.length; ++i) {
            const { entity, followUp } = this.beltCache[i];

            const beltComp = entity.components.Belt;
            const items = beltComp.sortedItems;

            if (items.length === 0) {
                // Fast out for performance
                continue;
            }

            const ejectorComp = entity.components.ItemEjector;
            let maxProgress = 1;

            // When ejecting, we can not go further than the item spacing since it
            // will be on the corner
            if (ejectorComp.isAnySlotEjecting()) {
                maxProgress = 1 - _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].itemSpacingOnBelts;
            } else {
                // Otherwise our progress depends on the follow up
                if (followUp) {
                    const spacingOnBelt = followUp.components.Belt.getDistanceToFirstItemCenter();
                    maxProgress = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_min"])(2, 1 - _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].itemSpacingOnBelts + spacingOnBelt);
                    window.assert(maxProgress >= 0.0, "max progress < 0 (I)");
                }
            }

            let speedMultiplier = 1;
            if (beltComp.direction !== _core_vector__WEBPACK_IMPORTED_MODULE_8__["enumDirection"].top) {
                // Shaped belts are longer, thus being quicker
                speedMultiplier = 1.41;
            }

            // Not really nice. haven't found the reason for this yet.
            if (items.length > 2 / _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].itemSpacingOnBelts) {
                logger.error("Fixing broken belt:", entity, items);
                beltComp.sortedItems = [];
            }

            for (let itemIndex = items.length - 1; itemIndex >= 0; --itemIndex) {
                const progressAndItem = items[itemIndex];

                progressAndItem[0] = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_min"])(maxProgress, progressAndItem[0] + speedMultiplier * beltSpeed);

                if (progressAndItem[0] >= 1.0) {
                    if (followUp) {
                        const followUpBelt = followUp.components.Belt;
                        if (followUpBelt.canAcceptItem()) {
                            followUpBelt.takeItem(progressAndItem[1], progressAndItem[0] - 1.0);
                            items.splice(itemIndex, 1);
                        } else {
                            // Well, we couldn't really take it to a follow up belt, keep it at
                            // max progress
                            progressAndItem[0] = 1.0;
                            maxProgress = 1 - _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].itemSpacingOnBelts;
                        }
                    } else {
                        // Try to give this item to a new belt
                        const freeSlot = ejectorComp.getFirstFreeSlot();
                        if (freeSlot === null) {
                            // So, we don't have a free slot - damned!
                            progressAndItem[0] = 1.0;
                            maxProgress = 1 - _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].itemSpacingOnBelts;
                        } else {
                            // We got a free slot, remove this item and keep it on the ejector slot
                            if (!ejectorComp.tryEject(freeSlot, progressAndItem[1])) {
                                window.assert(false, "Ejection failed");
                            }
                            items.splice(itemIndex, 1);

                            // NOTICE: Do not override max progress here at all, this leads to issues
                        }
                    }
                } else {
                    // We just moved this item forward, so determine the maximum progress of other items
                    maxProgress = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_max"])(0, progressAndItem[0] - _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].itemSpacingOnBelts);
                }
            }
        }
    }

    /**
     *
     * @param {DrawParameters} parameters
     * @param {MapChunkView} chunk
     */
    drawChunk(parameters, chunk) {
        if (parameters.zoomLevel < _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkOverviewMinZoom) {
            return;
        }

        const speedMultiplier = this.root.hubGoals.getBeltBaseSpeed();

        // SYNC with systems/item_acceptor.js:drawEntityUnderlays!
        // 126 / 42 is the exact animation speed of the png animation
        const animationIndex = Math.floor(
            ((this.root.time.now() * speedMultiplier * BELT_ANIM_COUNT * 126) / 42) *
                _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].itemSpacingOnBelts
        );
        const contents = chunk.contents;
        for (let y = 0; y < _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize; ++y) {
            for (let x = 0; x < _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].mapChunkSize; ++x) {
                const entity = contents[x][y];

                if (entity && entity.components.Belt) {
                    const direction = entity.components.Belt.direction;
                    const sprite = this.beltAnimations[direction][animationIndex % BELT_ANIM_COUNT];

                    entity.components.StaticMapEntity.drawSpriteOnFullEntityBounds(
                        parameters,
                        sprite,
                        0,
                        false
                    );
                }
            }
        }
        1;
    }

    /**
     * @param {DrawParameters} parameters
     * @param {Entity} entity
     */
    drawEntityItems(parameters, entity) {
        const beltComp = entity.components.Belt;
        const staticComp = entity.components.StaticMapEntity;

        const items = beltComp.sortedItems;

        if (items.length === 0) {
            // Fast out for performance
            return;
        }

        if (!staticComp.shouldBeDrawn(parameters)) {
            return;
        }

        for (let i = 0; i < items.length; ++i) {
            const itemAndProgress = items[i];

            // Nice would be const [pos, item] = itemAndPos;  but that gets polyfilled and is super slow then
            const progress = itemAndProgress[0];
            const item = itemAndProgress[1];

            const position = staticComp.applyRotationToVector(beltComp.transformBeltToLocalSpace(progress));

            item.draw(
                (staticComp.origin.x + position.x + 0.5) * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize,
                (staticComp.origin.y + position.y + 0.5) * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize,
                parameters
            );
        }
    }
}


/***/ }),

/***/ "./src/js/game/systems/hub.js":
/*!************************************!*\
  !*** ./src/js/game/systems/hub.js ***!
  \************************************/
/*! exports provided: HubSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HubSystem", function() { return HubSystem; });
/* harmony import */ var _game_system_with_filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game_system_with_filter */ "./src/js/game/game_system_with_filter.js");
/* harmony import */ var _components_hub__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/hub */ "./src/js/game/components/hub.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_loader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/loader */ "./src/js/core/loader.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../translations */ "./src/js/translations.js");








class HubSystem extends _game_system_with_filter__WEBPACK_IMPORTED_MODULE_0__["GameSystemWithFilter"] {
    constructor(root) {
        super(root, [_components_hub__WEBPACK_IMPORTED_MODULE_1__["HubComponent"]]);

        this.hubSprite = _core_loader__WEBPACK_IMPORTED_MODULE_5__["Loader"].getSprite("sprites/buildings/hub.png");
    }

    draw(parameters) {
        this.forEachMatchingEntityOnScreen(parameters, this.drawEntity.bind(this));
    }

    update() {
        for (let i = 0; i < this.allEntities.length; ++i) {
            const entity = this.allEntities[i];

            const hubComponent = entity.components.Hub;

            const queue = hubComponent.definitionsToAnalyze;
            for (let k = 0; k < queue.length; ++k) {
                const definition = queue[k];
                this.root.hubGoals.handleDefinitionDelivered(definition);
            }

            hubComponent.definitionsToAnalyze = [];
        }
    }

    /**
     * @param {DrawParameters} parameters
     * @param {Entity} entity
     */
    drawEntity(parameters, entity) {
        const context = parameters.context;
        const staticComp = entity.components.StaticMapEntity;

        if (!staticComp.shouldBeDrawn(parameters)) {
            return;
        }

        const pos = staticComp.getTileSpaceBounds().getCenter().toWorldSpace();

        // Background
        staticComp.drawSpriteOnFullEntityBounds(parameters, this.hubSprite, 2.2);

        const definition = this.root.hubGoals.currentGoal.definition;

        definition.draw(pos.x - 25, pos.y - 10, parameters, 40);

        const goals = this.root.hubGoals.currentGoal;

        const textOffsetX = 2;
        const textOffsetY = -6;

        // Deliver count
        const delivered = this.root.hubGoals.getCurrentGoalDelivered();

        if (delivered > 9999) {
            context.font = "bold 16px GameFont";
        } else if (delivered > 999) {
            context.font = "bold 20px GameFont";
        } else {
            context.font = "bold 25px GameFont";
        }
        context.fillStyle = "#64666e";
        context.textAlign = "left";
        context.fillText("" + Object(_core_utils__WEBPACK_IMPORTED_MODULE_4__["formatBigNumber"])(delivered), pos.x + textOffsetX, pos.y + textOffsetY);

        // Required

        context.font = "13px GameFont";

        context.fillStyle = "#a4a6b0";
        context.fillText(
            "/ " + Object(_core_utils__WEBPACK_IMPORTED_MODULE_4__["formatBigNumber"])(goals.required),
            pos.x + textOffsetX,
            pos.y + textOffsetY + 13
        );

        // Reward
        context.font = "bold 11px GameFont";
        context.fillStyle = "#fd0752";
        context.textAlign = "center";
        context.fillText(_translations__WEBPACK_IMPORTED_MODULE_6__["T"].storyRewards[goals.reward].title.toUpperCase(), pos.x, pos.y + 46);

        // Level
        context.font = "bold 11px GameFont";
        context.fillStyle = "#fff";
        context.fillText("" + this.root.hubGoals.level, pos.x - 42, pos.y - 36);

        context.textAlign = "left";
    }
}


/***/ }),

/***/ "./src/js/game/systems/item_acceptor.js":
/*!**********************************************!*\
  !*** ./src/js/game/systems/item_acceptor.js ***!
  \**********************************************/
/*! exports provided: ItemAcceptorSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ItemAcceptorSystem", function() { return ItemAcceptorSystem; });
/* harmony import */ var _game_system_with_filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game_system_with_filter */ "./src/js/game/game_system_with_filter.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _components_item_acceptor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/item_acceptor */ "./src/js/game/components/item_acceptor.js");
/* harmony import */ var _core_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/loader */ "./src/js/core/loader.js");
/* harmony import */ var _core_draw_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/draw_utils */ "./src/js/core/draw_utils.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/builtins */ "./src/js/core/builtins.js");










class ItemAcceptorSystem extends _game_system_with_filter__WEBPACK_IMPORTED_MODULE_0__["GameSystemWithFilter"] {
    constructor(root) {
        super(root, [_components_item_acceptor__WEBPACK_IMPORTED_MODULE_5__["ItemAcceptorComponent"]]);

        this.underlayBeltSprites = [
            _core_loader__WEBPACK_IMPORTED_MODULE_6__["Loader"].getSprite("sprites/belt/forward_0.png"),
            _core_loader__WEBPACK_IMPORTED_MODULE_6__["Loader"].getSprite("sprites/belt/forward_1.png"),
            _core_loader__WEBPACK_IMPORTED_MODULE_6__["Loader"].getSprite("sprites/belt/forward_2.png"),
            _core_loader__WEBPACK_IMPORTED_MODULE_6__["Loader"].getSprite("sprites/belt/forward_3.png"),
            _core_loader__WEBPACK_IMPORTED_MODULE_6__["Loader"].getSprite("sprites/belt/forward_4.png"),
            _core_loader__WEBPACK_IMPORTED_MODULE_6__["Loader"].getSprite("sprites/belt/forward_5.png"),
        ];
    }

    update() {
        for (let i = 0; i < this.allEntities.length; ++i) {
            const entity = this.allEntities[i];
            const aceptorComp = entity.components.ItemAcceptor;

            // Process item consumption animations to avoid items popping from the belts
            for (let animIndex = 0; animIndex < aceptorComp.itemConsumptionAnimations.length; ++animIndex) {
                const anim = aceptorComp.itemConsumptionAnimations[animIndex];
                anim.animProgress +=
                    this.root.dynamicTickrate.deltaSeconds *
                    this.root.hubGoals.getBeltBaseSpeed() *
                    2 *
                    _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].itemSpacingOnBelts;
                if (anim.animProgress > 1) {
                    aceptorComp.itemConsumptionAnimations.splice(animIndex, 1);
                    animIndex -= 1;
                }
            }
        }
    }

    draw(parameters) {
        this.forEachMatchingEntityOnScreen(parameters, this.drawEntity.bind(this));
    }

    drawUnderlays(parameters) {
        this.forEachMatchingEntityOnScreen(parameters, this.drawEntityUnderlays.bind(this));
    }

    /**
     * @param {DrawParameters} parameters
     * @param {Entity} entity
     */
    drawEntity(parameters, entity) {
        const staticComp = entity.components.StaticMapEntity;
        const acceptorComp = entity.components.ItemAcceptor;

        if (!staticComp.shouldBeDrawn(parameters)) {
            return;
        }

        for (let animIndex = 0; animIndex < acceptorComp.itemConsumptionAnimations.length; ++animIndex) {
            const { item, slotIndex, animProgress, direction } = acceptorComp.itemConsumptionAnimations[
                animIndex
            ];

            const slotData = acceptorComp.slots[slotIndex];
            const slotWorldPos = staticComp.applyRotationToVector(slotData.pos).add(staticComp.origin);

            const fadeOutDirection = _core_vector__WEBPACK_IMPORTED_MODULE_4__["enumDirectionToVector"][staticComp.localDirectionToWorld(direction)];
            const finalTile = slotWorldPos.subScalars(
                fadeOutDirection.x * (animProgress / 2 - 0.5),
                fadeOutDirection.y * (animProgress / 2 - 0.5)
            );
            item.draw(
                (finalTile.x + 0.5) * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize,
                (finalTile.y + 0.5) * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize,
                parameters
            );
        }
    }

    /**
     * @param {DrawParameters} parameters
     * @param {Entity} entity
     */
    drawEntityUnderlays(parameters, entity) {
        const staticComp = entity.components.StaticMapEntity;
        const acceptorComp = entity.components.ItemAcceptor;

        if (!staticComp.shouldBeDrawn(parameters)) {
            return;
        }

        const underlays = acceptorComp.beltUnderlays;
        for (let i = 0; i < underlays.length; ++i) {
            const { pos, direction } = underlays[i];

            const transformedPos = staticComp.localTileToWorld(pos);
            const angle = _core_vector__WEBPACK_IMPORTED_MODULE_4__["enumDirectionToAngle"][staticComp.localDirectionToWorld(direction)];

            // SYNC with systems/belt.js:drawSingleEntity!
            const animationIndex = Math.floor(
                ((this.root.time.now() *
                    this.root.hubGoals.getBeltBaseSpeed() *
                    this.underlayBeltSprites.length *
                    126) /
                    42) *
                    _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].itemSpacingOnBelts
            );

            Object(_core_draw_utils__WEBPACK_IMPORTED_MODULE_7__["drawRotatedSprite"])({
                parameters,
                sprite: this.underlayBeltSprites[animationIndex % this.underlayBeltSprites.length],
                x: (transformedPos.x + 0.5) * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize,
                y: (transformedPos.y + 0.5) * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize,
                angle: Object(_core_builtins__WEBPACK_IMPORTED_MODULE_8__["Math_radians"])(angle),
                size: _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].tileSize,
            });
        }
    }
}


/***/ }),

/***/ "./src/js/game/systems/item_ejector.js":
/*!*********************************************!*\
  !*** ./src/js/game/systems/item_ejector.js ***!
  \*********************************************/
/*! exports provided: ItemEjectorSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ItemEjectorSystem", function() { return ItemEjectorSystem; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _base_item__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base_item */ "./src/js/game/base_item.js");
/* harmony import */ var _components_item_ejector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/item_ejector */ "./src/js/game/components/item_ejector.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _game_system_with_filter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../game_system_with_filter */ "./src/js/game/game_system_with_filter.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/builtins */ "./src/js/core/builtins.js");









class ItemEjectorSystem extends _game_system_with_filter__WEBPACK_IMPORTED_MODULE_6__["GameSystemWithFilter"] {
    constructor(root) {
        super(root, [_components_item_ejector__WEBPACK_IMPORTED_MODULE_4__["ItemEjectorComponent"]]);
    }

    update() {
        const effectiveBeltSpeed = this.root.hubGoals.getBeltBaseSpeed() * _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].itemSpacingOnBelts;
        let progressGrowth = (effectiveBeltSpeed / 0.5) * this.root.dynamicTickrate.deltaSeconds;

        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug.instantBelts) {
            progressGrowth = 1;
        }

        // Try to find acceptors for every ejector
        for (let i = 0; i < this.allEntities.length; ++i) {
            const entity = this.allEntities[i];
            const ejectorComp = entity.components.ItemEjector;
            const staticComp = entity.components.StaticMapEntity;

            // For every ejector slot, try to find an acceptor
            for (let ejectorSlotIndex = 0; ejectorSlotIndex < ejectorComp.slots.length; ++ejectorSlotIndex) {
                const ejectorSlot = ejectorComp.slots[ejectorSlotIndex];
                const ejectingItem = ejectorSlot.item;
                if (!ejectingItem) {
                    // No item ejected
                    continue;
                }

                ejectorSlot.progress = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_7__["Math_min"])(1, ejectorSlot.progress + progressGrowth);
                if (ejectorSlot.progress < 1.0) {
                    // Still ejecting
                    continue;
                }

                // Figure out where and into which direction we eject items
                const ejectSlotWsTile = staticComp.localTileToWorld(ejectorSlot.pos);
                const ejectSlotWsDirection = staticComp.localDirectionToWorld(ejectorSlot.direction);
                const ejectSlotWsDirectionVector = _core_vector__WEBPACK_IMPORTED_MODULE_2__["enumDirectionToVector"][ejectSlotWsDirection];
                const ejectSlotTargetWsTile = ejectSlotWsTile.add(ejectSlotWsDirectionVector);

                // Try to find the given acceptor component to take the item
                const targetEntity = this.root.map.getTileContent(ejectSlotTargetWsTile);
                if (!targetEntity) {
                    // No consumer for item
                    continue;
                }

                const targetAcceptorComp = targetEntity.components.ItemAcceptor;
                const targetStaticComp = targetEntity.components.StaticMapEntity;
                if (!targetAcceptorComp) {
                    // Entity doesn't accept items
                    continue;
                }

                const matchingSlot = targetAcceptorComp.findMatchingSlot(
                    targetStaticComp.worldToLocalTile(ejectSlotTargetWsTile),
                    targetStaticComp.worldDirectionToLocal(ejectSlotWsDirection)
                );

                if (!matchingSlot) {
                    // No matching slot found
                    continue;
                }

                if (!targetAcceptorComp.canAcceptItem(matchingSlot.index, ejectingItem)) {
                    // Can not accept item
                    continue;
                }

                if (this.tryPassOverItem(ejectingItem, targetEntity, matchingSlot.index)) {
                    targetAcceptorComp.onItemAccepted(
                        matchingSlot.index,
                        matchingSlot.acceptedDirection,
                        ejectingItem
                    );
                    ejectorSlot.item = null;
                    continue;
                }
            }
        }
    }

    /**
     *
     * @param {BaseItem} item
     * @param {Entity} receiver
     * @param {number} slotIndex
     */
    tryPassOverItem(item, receiver, slotIndex) {
        // Try figuring out how what to do with the item
        // TODO: Kinda hacky. How to solve this properly? Don't want to go through inheritance hell.
        // Also its just a few cases (hope it stays like this .. :x).

        const beltComp = receiver.components.Belt;
        if (beltComp) {
            // Ayy, its a belt!
            if (beltComp.canAcceptItem()) {
                beltComp.takeItem(item);
                return true;
            }
        }

        const storageComp = receiver.components.Storage;
        if (storageComp) {
            // It's a storage
            if (storageComp.canAcceptItem(item)) {
                storageComp.takeItem(item);
                return true;
            }
        }

        const itemProcessorComp = receiver.components.ItemProcessor;
        if (itemProcessorComp) {
            // Its an item processor ..
            if (itemProcessorComp.tryTakeItem(item, slotIndex)) {
                return true;
            }
        }

        const undergroundBeltComp = receiver.components.UndergroundBelt;
        if (undergroundBeltComp) {
            // Its an underground belt. yay.
            if (
                undergroundBeltComp.tryAcceptExternalItem(
                    item,
                    this.root.hubGoals.getUndergroundBeltBaseSpeed()
                )
            ) {
                return true;
            }
        }

        return false;
    }

    draw(parameters) {
        this.forEachMatchingEntityOnScreen(parameters, this.drawSingleEntity.bind(this));
    }

    /**
     * @param {DrawParameters} parameters
     * @param {Entity} entity
     */
    drawSingleEntity(parameters, entity) {
        const ejectorComp = entity.components.ItemEjector;
        const staticComp = entity.components.StaticMapEntity;

        if (!staticComp.shouldBeDrawn(parameters)) {
            return;
        }

        for (let i = 0; i < ejectorComp.slots.length; ++i) {
            const slot = ejectorComp.slots[i];
            const ejectedItem = slot.item;
            if (!ejectedItem) {
                // No item
                continue;
            }

            const realPosition = slot.pos.rotateFastMultipleOf90(staticComp.rotation);
            const realDirection = _core_vector__WEBPACK_IMPORTED_MODULE_2__["Vector"].transformDirectionFromMultipleOf90(
                slot.direction,
                staticComp.rotation
            );
            const realDirectionVector = _core_vector__WEBPACK_IMPORTED_MODULE_2__["enumDirectionToVector"][realDirection];

            const tileX =
                staticComp.origin.x + realPosition.x + 0.5 + realDirectionVector.x * 0.5 * slot.progress;
            const tileY =
                staticComp.origin.y + realPosition.y + 0.5 + realDirectionVector.y * 0.5 * slot.progress;

            const worldX = tileX * _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize;
            const worldY = tileY * _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize;

            ejectedItem.draw(worldX, worldY, parameters);
        }
    }
}


/***/ }),

/***/ "./src/js/game/systems/item_processor.js":
/*!***********************************************!*\
  !*** ./src/js/game/systems/item_processor.js ***!
  \***********************************************/
/*! exports provided: ItemProcessorSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ItemProcessorSystem", function() { return ItemProcessorSystem; });
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _base_item__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base_item */ "./src/js/game/base_item.js");
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../colors */ "./src/js/game/colors.js");
/* harmony import */ var _components_item_processor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/item_processor */ "./src/js/game/components/item_processor.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _game_system_with_filter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../game_system_with_filter */ "./src/js/game/game_system_with_filter.js");
/* harmony import */ var _items_color_item__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../items/color_item */ "./src/js/game/items/color_item.js");
/* harmony import */ var _items_shape_item__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../items/shape_item */ "./src/js/game/items/shape_item.js");










class ItemProcessorSystem extends _game_system_with_filter__WEBPACK_IMPORTED_MODULE_6__["GameSystemWithFilter"] {
    constructor(root) {
        super(root, [_components_item_processor__WEBPACK_IMPORTED_MODULE_4__["ItemProcessorComponent"]]);
    }

    update() {
        for (let i = 0; i < this.allEntities.length; ++i) {
            const entity = this.allEntities[i];

            const processorComp = entity.components.ItemProcessor;
            const ejectorComp = entity.components.ItemEjector;

            // First of all, process the current recipe
            processorComp.secondsUntilEject = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_max"])(
                0,
                processorComp.secondsUntilEject - this.root.dynamicTickrate.deltaSeconds
            );

            if ( true && _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].debug.instantProcessors) {
                processorComp.secondsUntilEject = 0;
            }

            // Check if we have any finished items we can eject
            if (
                processorComp.secondsUntilEject === 0 && // it was processed in time
                processorComp.itemsToEject.length > 0 // we have some items left to eject
            ) {
                for (let itemIndex = 0; itemIndex < processorComp.itemsToEject.length; ++itemIndex) {
                    const { item, requiredSlot, preferredSlot } = processorComp.itemsToEject[itemIndex];

                    let slot = null;
                    if (requiredSlot !== null && requiredSlot !== undefined) {
                        // We have a slot override, check if that is free
                        if (ejectorComp.canEjectOnSlot(requiredSlot)) {
                            slot = requiredSlot;
                        }
                    } else if (preferredSlot !== null && preferredSlot !== undefined) {
                        // We have a slot preference, try using it but otherwise use a free slot
                        if (ejectorComp.canEjectOnSlot(preferredSlot)) {
                            slot = preferredSlot;
                        } else {
                            slot = ejectorComp.getFirstFreeSlot();
                        }
                    } else {
                        // We can eject on any slot
                        slot = ejectorComp.getFirstFreeSlot();
                    }

                    if (slot !== null) {
                        // Alright, we can actually eject
                        if (!ejectorComp.tryEject(slot, item)) {
                            window.assert(false, "Failed to eject");
                        } else {
                            processorComp.itemsToEject.splice(itemIndex, 1);
                            itemIndex -= 1;
                        }
                    }
                }
            }

            // Check if we have an empty queue and can start a new charge
            if (processorComp.itemsToEject.length === 0) {
                if (processorComp.inputSlots.length >= processorComp.inputsPerCharge) {
                    this.startNewCharge(entity);
                }
            }
        }
    }

    /**
     * Starts a new charge for the entity
     * @param {Entity} entity
     */
    startNewCharge(entity) {
        const processorComp = entity.components.ItemProcessor;

        // First, take items
        const items = processorComp.inputSlots;
        processorComp.inputSlots = [];

        /** @type {Object.<string, { item: BaseItem, sourceSlot: number }>} */
        const itemsBySlot = {};
        for (let i = 0; i < items.length; ++i) {
            itemsBySlot[items[i].sourceSlot] = items[i];
        }

        const baseSpeed = this.root.hubGoals.getProcessorBaseSpeed(processorComp.type);
        processorComp.secondsUntilEject = 1 / baseSpeed;

        /** @type {Array<{item: BaseItem, requiredSlot?: number, preferredSlot?: number}>} */
        const outItems = [];

        // Whether to track the production towards the analytics
        let trackProduction = true;

        // DO SOME MAGIC

        switch (processorComp.type) {
            // SPLITTER
            case _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].splitter: {
                trackProduction = false;
                const availableSlots = entity.components.ItemEjector.slots.length;

                let nextSlot = processorComp.nextOutputSlot++ % availableSlots;
                for (let i = 0; i < items.length; ++i) {
                    outItems.push({
                        item: items[i].item,
                        preferredSlot: (nextSlot + i) % availableSlots,
                    });
                }
                break;
            }

            // SORTER
            case _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].sorter: {
                const inputItem = /** @type {ShapeItem} */ (items[0].item);
                trackProduction = false;
                const availableSlots = entity.components.ItemEjector.slots.length - 1;
                window.assert(inputItem instanceof _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"], "Input for sorting is not a shape");
                if (
                    inputItem.serialize() == entity.components.Sorter.filter &&
                    entity.components.Sorter.isfil
                ) {
                    let nextSlot = processorComp.nextOutputSlot++ % availableSlots;
                    outItems.push({
                        item: inputItem,
                        requiredSlot: 1,
                    });
                } else if (!entity.components.Sorter.isfil) {
                    entity.components.Sorter.isfil = true;
                    entity.components.Sorter.filter = inputItem.serialize();
                    outItems.push({
                        item: inputItem,
                        requiredSlot: 1,
                    });
                } else {
                    outItems.push({
                        item: inputItem,
                        requiredSlot: 0,
                    });
                }
                break;
            }

            // CUTTER
            case _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].cutter: {
                const inputItem = /** @type {ShapeItem} */ (items[0].item);
                window.assert(inputItem instanceof _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"], "Input for cut is not a shape");
                const inputDefinition = inputItem.definition;

                const cutDefinitions = this.root.shapeDefinitionMgr.shapeActionCutHalf(inputDefinition);

                for (let i = 0; i < cutDefinitions.length; ++i) {
                    const definition = cutDefinitions[i];
                    if (!definition.isEntirelyEmpty()) {
                        outItems.push({
                            item: new _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"](definition),
                            requiredSlot: i,
                        });
                    }
                }

                break;
            }

            // CUTTER (Quad)
            case _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].cutterQuad: {
                const inputItem = /** @type {ShapeItem} */ (items[0].item);
                window.assert(inputItem instanceof _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"], "Input for cut is not a shape");
                const inputDefinition = inputItem.definition;

                const cutDefinitions = this.root.shapeDefinitionMgr.shapeActionCutQuad(inputDefinition);

                for (let i = 0; i < cutDefinitions.length; ++i) {
                    const definition = cutDefinitions[i];
                    if (!definition.isEntirelyEmpty()) {
                        outItems.push({
                            item: new _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"](definition),
                            requiredSlot: i,
                        });
                    }
                }

                break;
            }

            // ROTATER
            case _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].rotater: {
                const inputItem = /** @type {ShapeItem} */ (items[0].item);
                window.assert(inputItem instanceof _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"], "Input for rotation is not a shape");
                const inputDefinition = inputItem.definition;

                const rotatedDefinition = this.root.shapeDefinitionMgr.shapeActionRotateCW(inputDefinition);
                outItems.push({
                    item: new _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"](rotatedDefinition),
                });
                break;
            }

            // ROTATER ( CCW)
            case _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].rotaterCCW: {
                const inputItem = /** @type {ShapeItem} */ (items[0].item);
                window.assert(inputItem instanceof _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"], "Input for rotation is not a shape");
                const inputDefinition = inputItem.definition;

                const rotatedDefinition = this.root.shapeDefinitionMgr.shapeActionRotateCCW(inputDefinition);
                outItems.push({
                    item: new _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"](rotatedDefinition),
                });
                break;
            }

            // STACKER

            case _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].stacker: {
                const lowerItem = /** @type {ShapeItem} */ (itemsBySlot[0].item);
                const upperItem = /** @type {ShapeItem} */ (itemsBySlot[1].item);

                window.assert(lowerItem instanceof _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"], "Input for lower stack is not a shape");
                window.assert(upperItem instanceof _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"], "Input for upper stack is not a shape");

                const stackedDefinition = this.root.shapeDefinitionMgr.shapeActionStack(
                    lowerItem.definition,
                    upperItem.definition
                );
                outItems.push({
                    item: new _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"](stackedDefinition),
                });
                break;
            }

            // TRASH

            case _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].trash: {
                // Well this one is easy .. simply do nothing with the item
                break;
            }

            // MIXER

            case _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].mixer: {
                // Find both colors and combine them
                const item1 = /** @type {ColorItem} */ (items[0].item);
                const item2 = /** @type {ColorItem} */ (items[1].item);
                window.assert(item1 instanceof _items_color_item__WEBPACK_IMPORTED_MODULE_7__["ColorItem"], "Input for color mixer is not a color");
                window.assert(item2 instanceof _items_color_item__WEBPACK_IMPORTED_MODULE_7__["ColorItem"], "Input for color mixer is not a color");

                const color1 = item1.color;
                const color2 = item2.color;

                // Try finding mixer color, and if we can't mix it we simply return the same color
                const mixedColor = _colors__WEBPACK_IMPORTED_MODULE_3__["enumColorMixingResults"][color1][color2];
                let resultColor = color1;
                if (mixedColor) {
                    resultColor = mixedColor;
                }
                outItems.push({
                    item: new _items_color_item__WEBPACK_IMPORTED_MODULE_7__["ColorItem"](resultColor),
                });

                break;
            }

            // PAINTER

            case _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].painter: {
                const shapeItem = /** @type {ShapeItem} */ (itemsBySlot[0].item);
                const colorItem = /** @type {ColorItem} */ (itemsBySlot[1].item);

                const colorizedDefinition = this.root.shapeDefinitionMgr.shapeActionPaintWith(
                    shapeItem.definition,
                    colorItem.color
                );

                outItems.push({
                    item: new _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"](colorizedDefinition),
                });

                break;
            }

            // PAINTER (DOUBLE)

            case _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].painterDouble: {
                const shapeItem1 = /** @type {ShapeItem} */ (itemsBySlot[0].item);
                const shapeItem2 = /** @type {ShapeItem} */ (itemsBySlot[1].item);
                const colorItem = /** @type {ColorItem} */ (itemsBySlot[2].item);

                window.assert(shapeItem1 instanceof _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"], "Input for painter is not a shape");
                window.assert(shapeItem2 instanceof _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"], "Input for painter is not a shape");
                window.assert(colorItem instanceof _items_color_item__WEBPACK_IMPORTED_MODULE_7__["ColorItem"], "Input for painter is not a color");

                const colorizedDefinition1 = this.root.shapeDefinitionMgr.shapeActionPaintWith(
                    shapeItem1.definition,
                    colorItem.color
                );

                const colorizedDefinition2 = this.root.shapeDefinitionMgr.shapeActionPaintWith(
                    shapeItem2.definition,
                    colorItem.color
                );
                outItems.push({
                    item: new _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"](colorizedDefinition1),
                });

                outItems.push({
                    item: new _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"](colorizedDefinition2),
                });

                break;
            }

            // PAINTER (QUAD)

            case _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].painterQuad: {
                const shapeItem = /** @type {ShapeItem} */ (itemsBySlot[0].item);
                const colorItem1 = /** @type {ColorItem} */ (itemsBySlot[1].item);
                const colorItem2 = /** @type {ColorItem} */ (itemsBySlot[2].item);
                const colorItem3 = /** @type {ColorItem} */ (itemsBySlot[3].item);
                const colorItem4 = /** @type {ColorItem} */ (itemsBySlot[4].item);

                window.assert(shapeItem instanceof _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"], "Input for painter is not a shape");
                window.assert(colorItem1 instanceof _items_color_item__WEBPACK_IMPORTED_MODULE_7__["ColorItem"], "Input for painter is not a color");
                window.assert(colorItem2 instanceof _items_color_item__WEBPACK_IMPORTED_MODULE_7__["ColorItem"], "Input for painter is not a color");
                window.assert(colorItem3 instanceof _items_color_item__WEBPACK_IMPORTED_MODULE_7__["ColorItem"], "Input for painter is not a color");
                window.assert(colorItem4 instanceof _items_color_item__WEBPACK_IMPORTED_MODULE_7__["ColorItem"], "Input for painter is not a color");

                const colorizedDefinition = this.root.shapeDefinitionMgr.shapeActionPaintWith4Colors(
                    shapeItem.definition,
                    [colorItem2.color, colorItem3.color, colorItem4.color, colorItem1.color]
                );

                outItems.push({
                    item: new _items_shape_item__WEBPACK_IMPORTED_MODULE_8__["ShapeItem"](colorizedDefinition),
                });

                break;
            }

            // HUB

            case _components_item_processor__WEBPACK_IMPORTED_MODULE_4__["enumItemProcessorTypes"].hub: {
                trackProduction = false;

                const hubComponent = entity.components.Hub;
                window.assert(hubComponent, "Hub item processor has no hub component");

                for (let i = 0; i < items.length; ++i) {
                    const shapeItem = /** @type {ShapeItem} */ (items[i].item);
                    hubComponent.queueShapeDefinition(shapeItem.definition);
                }

                break;
            }

            default:
                window.assert(false, "Unkown item processor type: " + processorComp.type);
        }

        // Track produced items
        if (trackProduction) {
            for (let i = 0; i < outItems.length; ++i) {
                this.root.signals.itemProduced.dispatch(outItems[i].item);
            }
        }

        processorComp.itemsToEject = outItems;
    }
}


/***/ }),

/***/ "./src/js/game/systems/map_resources.js":
/*!**********************************************!*\
  !*** ./src/js/game/systems/map_resources.js ***!
  \**********************************************/
/*! exports provided: MapResourcesSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MapResourcesSystem", function() { return MapResourcesSystem; });
/* harmony import */ var _game_system__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game_system */ "./src/js/game/game_system.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _map_chunk_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../map_chunk_view */ "./src/js/game/map_chunk_view.js");





class MapResourcesSystem extends _game_system__WEBPACK_IMPORTED_MODULE_0__["GameSystem"] {
    /**
     * Draws the map resources
     * @param {DrawParameters} parameters
     * @param {MapChunkView} chunk
     */
    drawChunk(parameters, chunk) {
        const renderItems = parameters.zoomLevel >= _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].mapChunkOverviewMinZoom;

        parameters.context.globalAlpha = 0.5;

        const layer = chunk.lowerLayer;
        for (let x = 0; x < _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].mapChunkSize; ++x) {
            const row = layer[x];
            const worldX = (chunk.tileX + x) * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize;
            for (let y = 0; y < _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].mapChunkSize; ++y) {
                const lowerItem = row[y];
                if (lowerItem) {
                    const worldY = (chunk.tileY + y) * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize;

                    if (
                        !parameters.visibleRect.containsRect4Params(
                            worldX,
                            worldY,
                            _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize,
                            _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize
                        )
                    ) {
                        // Clipped
                        continue;
                    }

                    parameters.context.fillStyle = lowerItem.getBackgroundColorAsResource();
                    parameters.context.fillRect(worldX, worldY, _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize, _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize);
                    if (renderItems) {
                        lowerItem.draw(
                            worldX + _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].halfTileSize,
                            worldY + _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].halfTileSize,
                            parameters
                        );
                    }
                }
            }
        }
        parameters.context.globalAlpha = 1;

        if (!renderItems) {
            // Render patches instead
            const patches = chunk.patches;
            for (let i = 0; i < patches.length; ++i) {
                const { pos, item, size } = patches[i];

                item.draw(
                    (chunk.tileX + pos.x + 0.5) * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize,
                    (chunk.tileY + pos.y + 0.5) * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize,
                    parameters,
                    80
                );
            }
        }
    }
}


/***/ }),

/***/ "./src/js/game/systems/miner.js":
/*!**************************************!*\
  !*** ./src/js/game/systems/miner.js ***!
  \**************************************/
/*! exports provided: MinerSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MinerSystem", function() { return MinerSystem; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _base_item__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base_item */ "./src/js/game/base_item.js");
/* harmony import */ var _components_miner__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/miner */ "./src/js/game/components/miner.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _game_system_with_filter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../game_system_with_filter */ "./src/js/game/game_system_with_filter.js");
/* harmony import */ var _map_chunk_view__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../map_chunk_view */ "./src/js/game/map_chunk_view.js");









class MinerSystem extends _game_system_with_filter__WEBPACK_IMPORTED_MODULE_6__["GameSystemWithFilter"] {
    constructor(root) {
        super(root, [_components_miner__WEBPACK_IMPORTED_MODULE_4__["MinerComponent"]]);
    }

    update() {
        let miningSpeed = this.root.hubGoals.getMinerBaseSpeed();
        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug.instantMiners) {
            miningSpeed *= 100;
        }

        for (let i = 0; i < this.allEntities.length; ++i) {
            const entity = this.allEntities[i];

            // Check if miner is above an actual tile

            const minerComp = entity.components.Miner;
            const staticComp = entity.components.StaticMapEntity;

            const tileBelow = this.root.map.getLowerLayerContentXY(staticComp.origin.x, staticComp.origin.y);
            if (!tileBelow) {
                continue;
            }

            // First, try to get rid of chained items
            if (minerComp.itemChainBuffer.length > 0) {
                if (this.tryPerformMinerEject(entity, minerComp.itemChainBuffer[0])) {
                    minerComp.itemChainBuffer.shift();
                    continue;
                }
            }

            if (this.root.time.isIngameTimerExpired(minerComp.lastMiningTime, 1 / miningSpeed)) {
                const lowerLayerItem = this.root.map.getLowerLayerContentXY(
                    staticComp.origin.x,
                    staticComp.origin.y
                );

                // TODO: Should not be required actually
                if (!lowerLayerItem) {
                    // Nothing below;
                    continue;
                }

                if (this.tryPerformMinerEject(entity, lowerLayerItem)) {
                    // Analytics hook
                    this.root.signals.itemProduced.dispatch(lowerLayerItem);

                    // Actually mine
                    minerComp.lastMiningTime = this.root.time.now();
                }
            }
        }
    }

    /**
     *
     * @param {Entity} entity
     * @param {BaseItem} item
     */
    tryPerformMinerEject(entity, item) {
        const minerComp = entity.components.Miner;
        const ejectComp = entity.components.ItemEjector;
        const staticComp = entity.components.StaticMapEntity;

        // Check if we are a chained miner
        if (minerComp.chainable) {
            const ejectingSlot = ejectComp.slots[0];
            const ejectingPos = staticComp.localTileToWorld(ejectingSlot.pos);
            const ejectingDirection = staticComp.localDirectionToWorld(ejectingSlot.direction);

            const targetTile = ejectingPos.add(_core_vector__WEBPACK_IMPORTED_MODULE_2__["enumDirectionToVector"][ejectingDirection]);
            const targetContents = this.root.map.getTileContent(targetTile);

            // Check if we are connected to another miner and thus do not eject directly
            if (targetContents) {
                const targetMinerComp = targetContents.components.Miner;
                if (targetMinerComp) {
                    if (targetMinerComp.tryAcceptChainedItem(item)) {
                        return true;
                    } else {
                        return false;
                    }
                }
            }
        }

        // Seems we are a regular miner or at the end of a row, try actually ejecting
        if (ejectComp.tryEject(0, item)) {
            return true;
        }
        return false;
    }

    /**
     *
     * @param {DrawParameters} parameters
     * @param {MapChunkView} chunk
     */
    drawChunk(parameters, chunk) {
        const contents = chunk.contents;
        for (let y = 0; y < _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].mapChunkSize; ++y) {
            for (let x = 0; x < _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].mapChunkSize; ++x) {
                const entity = contents[x][y];

                if (entity && entity.components.Miner) {
                    const staticComp = entity.components.StaticMapEntity;
                    if (!staticComp.shouldBeDrawn(parameters)) {
                        continue;
                    }

                    const lowerLayerItem = this.root.map.getLowerLayerContentXY(
                        staticComp.origin.x,
                        staticComp.origin.y
                    );

                    if (lowerLayerItem) {
                        const padding = 3;
                        parameters.context.fillStyle = lowerLayerItem.getBackgroundColorAsResource();
                        parameters.context.fillRect(
                            staticComp.origin.x * _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize + padding,
                            staticComp.origin.y * _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize + padding,
                            _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize - 2 * padding,
                            _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize - 2 * padding
                        );
                    }

                    if (lowerLayerItem) {
                        lowerLayerItem.draw(
                            (0.5 + staticComp.origin.x) * _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize,
                            (0.5 + staticComp.origin.y) * _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].tileSize,
                            parameters
                        );
                    }
                }
            }
        }
    }
}


/***/ }),

/***/ "./src/js/game/systems/static_map_entity.js":
/*!**************************************************!*\
  !*** ./src/js/game/systems/static_map_entity.js ***!
  \**************************************************/
/*! exports provided: StaticMapEntitySystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticMapEntitySystem", function() { return StaticMapEntitySystem; });
/* harmony import */ var _game_system__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game_system */ "./src/js/game/game_system.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _map_chunk_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../map_chunk_view */ "./src/js/game/map_chunk_view.js");
/* harmony import */ var _core_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/loader */ "./src/js/core/loader.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");







class StaticMapEntitySystem extends _game_system__WEBPACK_IMPORTED_MODULE_0__["GameSystem"] {
    constructor(root) {
        super(root);

        this.beltOverviewSprites = {
            [_core_vector__WEBPACK_IMPORTED_MODULE_5__["enumDirection"].top]: _core_loader__WEBPACK_IMPORTED_MODULE_4__["Loader"].getSprite("sprites/map_overview/belt_forward.png"),
            [_core_vector__WEBPACK_IMPORTED_MODULE_5__["enumDirection"].right]: _core_loader__WEBPACK_IMPORTED_MODULE_4__["Loader"].getSprite("sprites/map_overview/belt_right.png"),
            [_core_vector__WEBPACK_IMPORTED_MODULE_5__["enumDirection"].left]: _core_loader__WEBPACK_IMPORTED_MODULE_4__["Loader"].getSprite("sprites/map_overview/belt_left.png"),
        };
    }

    /**
     * Draws the static entities
     * @param {DrawParameters} parameters
     * @param {MapChunkView} chunk
     */
    drawChunk(parameters, chunk) {
        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].debug.doNotRenderStatics) {
            return;
        }

        const drawOutlinesOnly = parameters.zoomLevel < _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].mapChunkOverviewMinZoom;

        const drawnUids = new Set();

        const contents = chunk.contents;
        for (let y = 0; y < _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].mapChunkSize; ++y) {
            for (let x = 0; x < _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].mapChunkSize; ++x) {
                const entity = contents[x][y];

                if (entity) {
                    if (drawnUids.has(entity.uid)) {
                        continue;
                    }
                    drawnUids.add(entity.uid);

                    const staticComp = entity.components.StaticMapEntity;
                    if (drawOutlinesOnly) {
                        const rect = staticComp.getTileSpaceBounds();
                        parameters.context.fillStyle = staticComp.silhouetteColor || "#aaa";
                        const beltComp = entity.components.Belt;
                        if (beltComp) {
                            const sprite = this.beltOverviewSprites[beltComp.direction];
                            staticComp.drawSpriteOnFullEntityBounds(parameters, sprite, 0, false);
                        } else {
                            parameters.context.fillRect(
                                rect.x * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize,
                                rect.y * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize,
                                rect.w * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize,
                                rect.h * _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].tileSize
                            );
                        }
                    } else {
                        const spriteKey = staticComp.spriteKey;
                        if (spriteKey) {
                            const sprite = _core_loader__WEBPACK_IMPORTED_MODULE_4__["Loader"].getSprite(spriteKey);
                            staticComp.drawSpriteOnFullEntityBounds(parameters, sprite, 2, false);
                        }
                    }
                }
            }
        }
    }
}


/***/ }),

/***/ "./src/js/game/systems/storage.js":
/*!****************************************!*\
  !*** ./src/js/game/systems/storage.js ***!
  \****************************************/
/*! exports provided: StorageSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StorageSystem", function() { return StorageSystem; });
/* harmony import */ var _game_system_with_filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game_system_with_filter */ "./src/js/game/game_system_with_filter.js");
/* harmony import */ var _components_storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/storage */ "./src/js/game/components/storage.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/draw_parameters */ "./src/js/core/draw_parameters.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_loader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/loader */ "./src/js/core/loader.js");







class StorageSystem extends _game_system_with_filter__WEBPACK_IMPORTED_MODULE_0__["GameSystemWithFilter"] {
    constructor(root) {
        super(root, [_components_storage__WEBPACK_IMPORTED_MODULE_1__["StorageComponent"]]);

        this.storageOverlaySprite = _core_loader__WEBPACK_IMPORTED_MODULE_5__["Loader"].getSprite("sprites/misc/storage_overlay.png");
    }

    update() {
        for (let i = 0; i < this.allEntities.length; ++i) {
            const entity = this.allEntities[i];
            const storageComp = entity.components.Storage;

            // Eject from storage
            if (storageComp.storedItem && storageComp.storedCount > 0) {
                const ejectorComp = entity.components.ItemEjector;
                const nextSlot = ejectorComp.getFirstFreeSlot();
                if (nextSlot !== null) {
                    if (ejectorComp.tryEject(nextSlot, storageComp.storedItem)) {
                        storageComp.storedCount--;

                        if (storageComp.storedCount === 0) {
                            storageComp.storedItem = null;
                        }
                    }
                }
            }

            let targetAlpha = storageComp.storedCount > 0 ? 1 : 0;
            storageComp.overlayOpacity = Object(_core_utils__WEBPACK_IMPORTED_MODULE_4__["lerp"])(storageComp.overlayOpacity, targetAlpha, 0.05);
        }
    }

    draw(parameters) {
        this.forEachMatchingEntityOnScreen(parameters, this.drawEntity.bind(this));
    }

    /**
     * @param {DrawParameters} parameters
     * @param {Entity} entity
     */
    drawEntity(parameters, entity) {
        const context = parameters.context;
        const staticComp = entity.components.StaticMapEntity;

        if (!staticComp.shouldBeDrawn(parameters)) {
            return;
        }

        const storageComp = entity.components.Storage;

        const storedItem = storageComp.storedItem;
        if (storedItem !== null) {
            context.globalAlpha = storageComp.overlayOpacity;
            const center = staticComp.getTileSpaceBounds().getCenter().toWorldSpace();
            storedItem.draw(center.x, center.y, parameters, 30);

            this.storageOverlaySprite.drawCached(parameters, center.x - 15, center.y + 15, 30, 15);

            context.font = "bold 10px GameFont";
            context.textAlign = "center";
            context.fillStyle = "#64666e";
            context.fillText(Object(_core_utils__WEBPACK_IMPORTED_MODULE_4__["formatBigNumber"])(storageComp.storedCount), center.x, center.y + 25.5);

            context.textAlign = "left";
            context.globalAlpha = 1;
        }
    }
}


/***/ }),

/***/ "./src/js/game/systems/underground_belt.js":
/*!*************************************************!*\
  !*** ./src/js/game/systems/underground_belt.js ***!
  \*************************************************/
/*! exports provided: UndergroundBeltSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UndergroundBeltSystem", function() { return UndergroundBeltSystem; });
/* harmony import */ var _game_system_with_filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game_system_with_filter */ "./src/js/game/game_system_with_filter.js");
/* harmony import */ var _components_underground_belt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/underground_belt */ "./src/js/game/components/underground_belt.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../entity */ "./src/js/game/entity.js");
/* harmony import */ var _core_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/loader */ "./src/js/core/loader.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _map_chunk_view__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../map_chunk_view */ "./src/js/game/map_chunk_view.js");
/* harmony import */ var _core_draw_parameters__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/draw_parameters */ "./src/js/core/draw_parameters.js");










class UndergroundBeltSystem extends _game_system_with_filter__WEBPACK_IMPORTED_MODULE_0__["GameSystemWithFilter"] {
    constructor(root) {
        super(root, [_components_underground_belt__WEBPACK_IMPORTED_MODULE_1__["UndergroundBeltComponent"]]);

        this.beltSprites = {
            [_components_underground_belt__WEBPACK_IMPORTED_MODULE_1__["enumUndergroundBeltMode"].sender]: _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite(
                "sprites/buildings/underground_belt_entry.png"
            ),
            [_components_underground_belt__WEBPACK_IMPORTED_MODULE_1__["enumUndergroundBeltMode"].receiver]: _core_loader__WEBPACK_IMPORTED_MODULE_3__["Loader"].getSprite(
                "sprites/buildings/underground_belt_exit.png"
            ),
        };
    }

    update() {
        for (let i = 0; i < this.allEntities.length; ++i) {
            const entity = this.allEntities[i];

            const undergroundComp = entity.components.UndergroundBelt;

            // Decrease remaining time of all items in belt
            for (let k = 0; k < undergroundComp.pendingItems.length; ++k) {
                const item = undergroundComp.pendingItems[k];
                item[1] = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_4__["Math_max"])(0, item[1] - this.root.dynamicTickrate.deltaSeconds);

                if ( true && _core_config__WEBPACK_IMPORTED_MODULE_5__["globalConfig"].debug.instantBelts) {
                    item[1] = 0;
                }
            }

            if (undergroundComp.mode === _components_underground_belt__WEBPACK_IMPORTED_MODULE_1__["enumUndergroundBeltMode"].sender) {
                this.handleSender(entity);
            } else {
                this.handleReceiver(entity);
            }
        }
    }

    /**
     *
     * @param {Entity} entity
     */
    handleSender(entity) {
        const staticComp = entity.components.StaticMapEntity;
        const undergroundComp = entity.components.UndergroundBelt;

        // Check if we have any item

        if (undergroundComp.pendingItems.length > 0) {
            const nextItemAndDuration = undergroundComp.pendingItems[0];
            const remainingTime = nextItemAndDuration[1];
            const nextItem = nextItemAndDuration[0];

            if (remainingTime === 0) {
                // Try to find a receiver
                const searchDirection = staticComp.localDirectionToWorld(_core_vector__WEBPACK_IMPORTED_MODULE_6__["enumDirection"].top);
                const searchVector = _core_vector__WEBPACK_IMPORTED_MODULE_6__["enumDirectionToVector"][searchDirection];
                const targetRotation = _core_vector__WEBPACK_IMPORTED_MODULE_6__["enumDirectionToAngle"][searchDirection];

                let currentTile = staticComp.origin;

                for (
                    let searchOffset = 0;
                    searchOffset < _core_config__WEBPACK_IMPORTED_MODULE_5__["globalConfig"].undergroundBeltMaxTilesByTier[undergroundComp.tier];
                    ++searchOffset
                ) {
                    currentTile = currentTile.add(searchVector);

                    const contents = this.root.map.getTileContent(currentTile);
                    if (contents) {
                        const receiverUndergroundComp = contents.components.UndergroundBelt;
                        if (
                            receiverUndergroundComp &&
                            receiverUndergroundComp.tier === undergroundComp.tier
                        ) {
                            const receiverStaticComp = contents.components.StaticMapEntity;
                            if (receiverStaticComp.rotation === targetRotation) {
                                if (receiverUndergroundComp.mode === _components_underground_belt__WEBPACK_IMPORTED_MODULE_1__["enumUndergroundBeltMode"].receiver) {
                                    // Try to pass over the item to the receiver
                                    if (
                                        receiverUndergroundComp.tryAcceptTunneledItem(
                                            nextItem,
                                            searchOffset,
                                            this.root.hubGoals.getUndergroundBeltBaseSpeed()
                                        )
                                    ) {
                                        undergroundComp.pendingItems = [];
                                    }
                                }

                                // When we hit some underground belt, always stop, no matter what
                                break;
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     *
     * @param {Entity} entity
     */
    handleReceiver(entity) {
        const undergroundComp = entity.components.UndergroundBelt;

        // Try to eject items, we only check the first one cuz its sorted by remaining time
        const items = undergroundComp.pendingItems;
        if (items.length > 0) {
            const nextItemAndDuration = undergroundComp.pendingItems[0];
            const remainingTime = nextItemAndDuration[1];
            const nextItem = nextItemAndDuration[0];

            if (remainingTime <= 0) {
                const ejectorComp = entity.components.ItemEjector;
                const nextSlotIndex = ejectorComp.getFirstFreeSlot();
                if (nextSlotIndex !== null) {
                    if (ejectorComp.tryEject(nextSlotIndex, nextItem)) {
                        items.shift();
                    }
                }
            }
        }
    }
}


/***/ }),

/***/ "./src/js/game/theme.js":
/*!******************************!*\
  !*** ./src/js/game/theme.js ***!
  \******************************/
/*! exports provided: THEMES, THEME, applyGameTheme */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "THEMES", function() { return THEMES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "THEME", function() { return THEME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyGameTheme", function() { return applyGameTheme; });
const THEMES = {
    dark: __webpack_require__(/*! ./themes/dark.json */ "./src/js/game/themes/dark.json"),
    light: __webpack_require__(/*! ./themes/light.json */ "./src/js/game/themes/light.json"),
};

let THEME = THEMES.light;

function applyGameTheme(id) {
    THEME = THEMES[id];
}


/***/ }),

/***/ "./src/js/game/themes/dark.json":
/*!**************************************!*\
  !*** ./src/js/game/themes/dark.json ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (function() {
        return JSON.parse(__webpack_require__(/*! global-compression */ "./src/js/core/lzstring.js").decompressX64("N4WAUABFEEQK4EsDKAXAngGwKYwFywBMBDAJwGsYAacaWAWyIAc8JRJboYAjIgYzIDmJAPZwAdgRYwAxACYssgGYBmAOxUaHKDCEJJ+GCQE8AFLICs5yhAtWbl6wAYAdI9kBKDey06SegDIIYlgA6nooABYsLlbgmj4AzljYvCgIwmIA8gBuWCQYRGhSRqaqACzWAIwAbMrWsrJ1EC6qntTeHDBJKWkZmXAoGEE4BiVEJuVVtfWNTs7mbfGd3Vip6WIAQnyCIuL6sGMTFRA1TQ1NLh5eS7SGWAmiJLz3LGxaiRFMI7DSygTKijKRC8706JCw+xkQL+AJBoM4QiwWDEUl+WGhkna8M4XAwcG+MmU5mUAA4gXDsdwCvxUTDAcCbtAAL5Y94wXgRcRkHJ5bIILAAd1ejJ8WDojHQqLK0pJ5mqFPhMEUCAw2Eh0mqZWqXFUkhFECZSxZcQ6MAQKDFCWFHVuokGw1RlSdZUqJIVtoGQ2CYQIkWizlU5iN4ENYCAA"));
    })()

/***/ }),

/***/ "./src/js/game/themes/light.json":
/*!***************************************!*\
  !*** ./src/js/game/themes/light.json ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (function() {
        return JSON.parse(__webpack_require__(/*! global-compression */ "./src/js/core/lzstring.js").decompressX64("N4WAUABFEEQK4EsDKAXAngGwKYwFywwQHMALFGAGnGlgFsBDABzwlEhuhgCN6BjAayIAnAPZwAdgBMWMAMQAzRZWocoMYQmn458+rt3L2q9UM0AZBOKwB1TShIsAjFTArjAZyzZeKBCPEA8gBuWEIY9GgyQkQ8ABQA7AAsFBCOAGwAzCkATNlZEAAMAHTxAJSGqmqe3r7+AXAohFZRMfQJyamZOXkpxQCs5S6VsNVYPn7iAEJ8gqISWrDRcUkp6fm5+cXZg+BuHDBCWO5iQrxHLGzDNDDuJEw42rJY9FhcYxVXaocLOvJc8rxHB9PiYsFhxDJZLx-gDEsCrtwMHAHrBZP9JHp5PDhoiZpDnq93nsaABfFzEzi8EgSfjBUJBBBYADuFwpxiwtEY6Eh9DSei4XGxlRg8gQGGwPyhfV4vEkaRgbIgJL2ZN2RlgCBQHPcrPV1zEjUsKLkfVN8T69CFagNTRsdgc+GK5pV4GVYCAA"));
    })()

/***/ }),

/***/ "./src/js/game/time/base_game_speed.js":
/*!*********************************************!*\
  !*** ./src/js/game/time/base_game_speed.js ***!
  \*********************************************/
/*! exports provided: BaseGameSpeed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseGameSpeed", function() { return BaseGameSpeed; });
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../savegame/serialization */ "./src/js/savegame/serialization.js");




class BaseGameSpeed extends _savegame_serialization__WEBPACK_IMPORTED_MODULE_0__["BasicSerializableObject"] {
    /**
     * @param {GameRoot} root
     */
    constructor(root) {
        super();
        this.root = root;
        this.initializeAfterDeserialize(root);
    }

    /** @returns {string} */
    static getId() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return "unknown-speed";
    }

    getId() {
        // @ts-ignore
        return this.constructor.getId();
    }

    static getSchema() {
        return {};
    }

    initializeAfterDeserialize(root) {
        this.root = root;
    }

    /**
     * Returns the time multiplier
     */
    getTimeMultiplier() {
        return 1;
    }

    /**
     * Returns how many logic steps there may be queued
     */
    getMaxLogicStepsInQueue() {
        return 3;
    }

    // Internals
    /** @returns {BaseGameSpeed} */
    newSpeed(instance) {
        return new instance(this.root);
    }
}


/***/ }),

/***/ "./src/js/game/time/fast_forward_game_speed.js":
/*!*****************************************************!*\
  !*** ./src/js/game/time/fast_forward_game_speed.js ***!
  \*****************************************************/
/*! exports provided: FastForwardGameSpeed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FastForwardGameSpeed", function() { return FastForwardGameSpeed; });
/* harmony import */ var _base_game_speed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base_game_speed */ "./src/js/game/time/base_game_speed.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");



class FastForwardGameSpeed extends _base_game_speed__WEBPACK_IMPORTED_MODULE_0__["BaseGameSpeed"] {
    static getId() {
        return "fast-forward";
    }

    getTimeMultiplier() {
        return _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].fastForwardSpeed;
    }

    getMaxLogicStepsInQueue() {
        return 3 * _core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].fastForwardSpeed;
    }
}


/***/ }),

/***/ "./src/js/game/time/game_time.js":
/*!***************************************!*\
  !*** ./src/js/game/time/game_time.js ***!
  \***************************************/
/*! exports provided: GameTime */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameTime", function() { return GameTime; });
/* harmony import */ var _savegame_serialization__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../savegame/serialization */ "./src/js/savegame/serialization.js");
/* harmony import */ var _regular_game_speed__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./regular_game_speed */ "./src/js/game/time/regular_game_speed.js");
/* harmony import */ var _base_game_speed__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base_game_speed */ "./src/js/game/time/base_game_speed.js");
/* harmony import */ var _paused_game_speed__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./paused_game_speed */ "./src/js/game/time/paused_game_speed.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _fast_forward_game_speed__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fast_forward_game_speed */ "./src/js/game/time/fast_forward_game_speed.js");
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/global_registries */ "./src/js/core/global_registries.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/logging */ "./src/js/core/logging.js");













const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_9__["createLogger"])("game_time");

class GameTime extends _savegame_serialization__WEBPACK_IMPORTED_MODULE_0__["BasicSerializableObject"] {
    /**
     * @param {GameRoot} root
     */
    constructor(root) {
        super();
        this.root = root;

        // Current ingame time seconds, not incremented while paused
        this.timeSeconds = 0;

        // Current "realtime", a timer which always is incremented no matter whether the game is paused or no
        this.realtimeSeconds = 0;

        // The adjustment, used when loading savegames so we can continue where we were
        this.realtimeAdjust = 0;

        /** @type {BaseGameSpeed} */
        this.speed = new _regular_game_speed__WEBPACK_IMPORTED_MODULE_1__["RegularGameSpeed"](this.root);

        // Store how much time we have in bucket
        this.logicTimeBudget = 0;
    }

    static getId() {
        return "GameTime";
    }

    static getSchema() {
        return {
            timeSeconds: _savegame_serialization__WEBPACK_IMPORTED_MODULE_0__["types"].float,
            speed: _savegame_serialization__WEBPACK_IMPORTED_MODULE_0__["types"].obj(_core_global_registries__WEBPACK_IMPORTED_MODULE_6__["gGameSpeedRegistry"]),
            realtimeSeconds: _savegame_serialization__WEBPACK_IMPORTED_MODULE_0__["types"].float,
        };
    }

    /**
     * Fetches the new "real" time, called from the core once per frame, since performance now() is kinda slow
     */
    updateRealtimeNow() {
        this.realtimeSeconds = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_4__["performanceNow"])() / 1000.0 + this.realtimeAdjust;
    }

    /**
     * Returns the ingame time in milliseconds
     */
    getTimeMs() {
        return this.timeSeconds * 1000.0;
    }

    /**
     * Safe check to check if a timer is expired. quantizes numbers
     * @param {number} lastTick Last tick of the timer
     * @param {number} tickRateSeconds Interval of the timer in seconds
     */
    isIngameTimerExpired(lastTick, tickRateSeconds) {
        return Object(_core_utils__WEBPACK_IMPORTED_MODULE_8__["checkTimerExpired"])(this.timeSeconds, lastTick, tickRateSeconds);
    }

    /**
     * Returns how many seconds we are in the grace period
     * @returns {number}
     */
    getRemainingGracePeriodSeconds() {
        return 0;
    }

    /**
     * Returns if we are currently in the grace period
     * @returns {boolean}
     */
    getIsWithinGracePeriod() {
        return this.getRemainingGracePeriodSeconds() > 0;
    }

    /**
     * Internal method to generate new logic time budget
     * @param {number} deltaMs
     */
    internalAddDeltaToBudget(deltaMs) {
        // Only update if game is supposed to update
        if (this.root.hud.shouldPauseGame()) {
            this.logicTimeBudget = 0;
        } else {
            const multiplier = this.getSpeed().getTimeMultiplier();
            this.logicTimeBudget += deltaMs * multiplier;
        }

        // Check for too big pile of updates -> reduce it to 1
        let maxLogicSteps = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_4__["Math_max"])(
            3,
            (this.speed.getMaxLogicStepsInQueue() * this.root.dynamicTickrate.currentTickRate) / 60
        );
        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_7__["globalConfig"].debug.framePausesBetweenTicks) {
            maxLogicSteps *= 1 + _core_config__WEBPACK_IMPORTED_MODULE_7__["globalConfig"].debug.framePausesBetweenTicks;
        }

        if (this.logicTimeBudget > this.root.dynamicTickrate.deltaMs * maxLogicSteps) {
            this.logicTimeBudget = this.root.dynamicTickrate.deltaMs * maxLogicSteps;
        }
    }

    /**
     * Performs update ticks based on the queued logic budget
     * @param {number} deltaMs
     * @param {function():boolean} updateMethod
     */
    performTicks(deltaMs, updateMethod) {
        this.internalAddDeltaToBudget(deltaMs);

        const speedAtStart = this.root.time.getSpeed();

        let effectiveDelta = this.root.dynamicTickrate.deltaMs;
        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_7__["globalConfig"].debug.framePausesBetweenTicks) {
            effectiveDelta += _core_config__WEBPACK_IMPORTED_MODULE_7__["globalConfig"].debug.framePausesBetweenTicks * this.root.dynamicTickrate.deltaMs;
        }

        // Update physics & logic
        while (this.logicTimeBudget >= effectiveDelta) {
            this.logicTimeBudget -= effectiveDelta;

            if (!updateMethod()) {
                // Gameover happened or so, do not update anymore
                return;
            }

            // Step game time
            this.timeSeconds = Object(_core_utils__WEBPACK_IMPORTED_MODULE_8__["quantizeFloat"])(this.timeSeconds + this.root.dynamicTickrate.deltaSeconds);

            // Game time speed changed, need to abort since our logic steps are no longer valid
            if (speedAtStart.getId() !== this.speed.getId()) {
                logger.warn(
                    "Skipping update because speed changed from",
                    speedAtStart.getId(),
                    "to",
                    this.speed.getId()
                );
                break;
            }

            // If we queued async tasks, perform them next frame and do not update anymore
            if (this.root.hud.parts.processingOverlay.hasTasks()) {
                break;
            }
        }
    }

    /**
     * Returns ingame time in seconds
     * @returns {number} seconds
     */
    now() {
        return this.timeSeconds;
    }

    /**
     * Returns "real" time in seconds
     * @returns {number} seconds
     */
    realtimeNow() {
        return this.realtimeSeconds;
    }

    /**
     * Returns "real" time in seconds
     * @returns {number} seconds
     */
    systemNow() {
        return (this.realtimeSeconds - this.realtimeAdjust) * 1000.0;
    }

    getIsPaused() {
        return this.speed.getId() === _paused_game_speed__WEBPACK_IMPORTED_MODULE_3__["PausedGameSpeed"].getId();
    }

    getSpeed() {
        return this.speed;
    }

    setSpeed(speed) {
        window.assert(speed instanceof _base_game_speed__WEBPACK_IMPORTED_MODULE_2__["BaseGameSpeed"], "Not a valid game speed");
        if (this.speed.getId() === speed.getId()) {
            logger.warn("Same speed set than current one:", speed.constructor.getId());
        }
        this.speed = speed;
    }

    deserialize(data) {
        const errorCode = super.deserialize(data);
        if (errorCode) {
            return errorCode;
        }

        // Adjust realtime now difference so they match
        this.realtimeAdjust = this.realtimeSeconds - Object(_core_builtins__WEBPACK_IMPORTED_MODULE_4__["performanceNow"])() / 1000.0;
        this.updateRealtimeNow();

        // Make sure we have a quantizied time
        this.timeSeconds = Object(_core_utils__WEBPACK_IMPORTED_MODULE_8__["quantizeFloat"])(this.timeSeconds);

        this.speed.initializeAfterDeserialize(this.root);
    }
}


/***/ }),

/***/ "./src/js/game/time/paused_game_speed.js":
/*!***********************************************!*\
  !*** ./src/js/game/time/paused_game_speed.js ***!
  \***********************************************/
/*! exports provided: PausedGameSpeed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PausedGameSpeed", function() { return PausedGameSpeed; });
/* harmony import */ var _base_game_speed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base_game_speed */ "./src/js/game/time/base_game_speed.js");


class PausedGameSpeed extends _base_game_speed__WEBPACK_IMPORTED_MODULE_0__["BaseGameSpeed"] {
    static getId() {
        return "paused";
    }

    getTimeMultiplier() {
        return 0;
    }

    getMaxLogicStepsInQueue() {
        return 0;
    }
}


/***/ }),

/***/ "./src/js/game/time/regular_game_speed.js":
/*!************************************************!*\
  !*** ./src/js/game/time/regular_game_speed.js ***!
  \************************************************/
/*! exports provided: RegularGameSpeed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RegularGameSpeed", function() { return RegularGameSpeed; });
/* harmony import */ var _base_game_speed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base_game_speed */ "./src/js/game/time/base_game_speed.js");


class RegularGameSpeed extends _base_game_speed__WEBPACK_IMPORTED_MODULE_0__["BaseGameSpeed"] {
    static getId() {
        return "regular";
    }

    getTimeMultiplier() {
        return 1;
    }
}


/***/ }),

/***/ "./src/js/game/tutorial_goals.js":
/*!***************************************!*\
  !*** ./src/js/game/tutorial_goals.js ***!
  \***************************************/
/*! exports provided: enumHubGoalRewards, tutorialGoals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumHubGoalRewards", function() { return enumHubGoalRewards; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tutorialGoals", function() { return tutorialGoals; });
/* harmony import */ var _shape_definition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shape_definition */ "./src/js/game/shape_definition.js");
/* harmony import */ var _upgrades__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./upgrades */ "./src/js/game/upgrades.js");



/**
 * Don't forget to also update tutorial_goals_mappings.js as well as the translations!
 * @enum {string}
 */
const enumHubGoalRewards = {
    reward_cutter_and_trash: "reward_cutter_and_trash",
    reward_rotater: "reward_rotater",
    reward_painter: "reward_painter",
    reward_mixer: "reward_mixer",
    reward_stacker: "reward_stacker",
    reward_splitter: "reward_splitter",
    reward_tunnel: "reward_tunnel",

    reward_rotater_ccw: "reward_rotater_ccw",
    reward_miner_chainable: "reward_miner_chainable",
    reward_underground_belt_tier_2: "reward_underground_belt_tier_2",
    reward_storage: "reward_storage",
    reward_splitter_compact: "reward_splitter_compact",
    reward_cutter_quad: "reward_cutter_quad",
    reward_painter_double: "reward_painter_double",
    reward_sorter: "reward_sorter",
    reward_painter_quad: "reward_painter_quad",

    reward_blueprints: "reward_blueprints",
    reward_freeplay: "reward_freeplay",

    no_reward: "no_reward",
    no_reward_freeplay: "no_reward_freeplay",
};

const tutorialGoals = [
    // 1
    // Circle
    {
        shape: "CuCuCuCu", // belts t1
        required: 20,
        reward: enumHubGoalRewards.reward_cutter_and_trash,
    },

    // 2
    // Cutter
    {
        shape: "----CuCu", //
        required: 40,
        reward: enumHubGoalRewards.no_reward,
    },

    // 3
    // Rectangle
    {
        shape: "RuRuRuRu", // miners t1
        required: 100,
        reward: enumHubGoalRewards.reward_splitter,
    },

    // 4
    {
        shape: "RuRu----", // processors t2
        required: 120,
        reward: enumHubGoalRewards.reward_rotater,
    },

    // 5
    // Rotater
    {
        shape: "Cu----Cu", // belts t2
        required: 200,
        reward: enumHubGoalRewards.reward_tunnel,
    },

    // 6
    {
        shape: "Cu------", // miners t2
        required: 400,
        reward: enumHubGoalRewards.reward_painter,
    },

    // 7
    // Painter
    {
        shape: "CrCrCrCr", // unused
        required: 800,
        reward: enumHubGoalRewards.reward_rotater_ccw,
    },

    // 8
    {
        shape: "RbRb----", // painter t2
        required: 1250,
        reward: enumHubGoalRewards.reward_mixer,
    },

    // 9
    // Mixing (purple)
    {
        shape: "CpCpCpCp", // belts t3
        required: 1750,
        reward: enumHubGoalRewards.reward_splitter_compact,
    },

    // 10
    // Star shape + cyan
    {
        shape: "ScScScSc", // miners t3
        required: 2250,
        reward: enumHubGoalRewards.reward_stacker,
    },

    // 11
    // Stacker
    {
        shape: "CgScScCg", // processors t3
        required: 3000,
        reward: enumHubGoalRewards.reward_miner_chainable,
    },

    // 12
    // Blueprints
    {
        shape: "CbCbCbRb:CwCwCwCw",
        required: 4000,
        reward: enumHubGoalRewards.reward_blueprints,
    },

    // 13
    {
        shape: "RpRpRpRp:CwCwCwCw", // painting t3
        required: 12000,
        reward: enumHubGoalRewards.reward_underground_belt_tier_2,
    },

    // 14
    {
        shape: "SrSrSrSr:CyCyCyCy", // unused
        required: 16000,
        reward: enumHubGoalRewards.reward_storage,
    },

    // 15
    {
        shape: "SrSrSrSr:CyCyCyCy:SwSwSwSw", // belts t4 (two variants)
        required: 25000,
        reward: enumHubGoalRewards.reward_cutter_quad,
    },

    // 16
    {
        shape: "CbRbRbCb:CwCwCwCw:WbWbWbWb", // miner t4 (two variants)
        required: 50000,
        reward: enumHubGoalRewards.reward_painter_double,
    },

    // 17
    {
        shape: "WrRgWrRg:CwCrCwCr:SgSgSgSg", // processors t4 (two varinats)
        required: 100000,
        reward: enumHubGoalRewards.reward_painter_quad,
    },

    // 18
    {
        shape: _upgrades__WEBPACK_IMPORTED_MODULE_1__["finalGameShape"],
        required: 250000,
        reward: enumHubGoalRewards.reward_freeplay,
    },
];

if (true) {
    tutorialGoals.forEach(({ shape, required, reward }) => {
        try {
            _shape_definition__WEBPACK_IMPORTED_MODULE_0__["ShapeDefinition"].fromShortKey(shape);
        } catch (ex) {
            throw new Error("Invalid tutorial goal: '" + ex + "' for shape" + shape);
        }
    });
}


/***/ }),

/***/ "./src/js/game/tutorial_goals_mappings.js":
/*!************************************************!*\
  !*** ./src/js/game/tutorial_goals_mappings.js ***!
  \************************************************/
/*! exports provided: enumHubGoalRewardsToContentUnlocked */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumHubGoalRewardsToContentUnlocked", function() { return enumHubGoalRewardsToContentUnlocked; });
/* harmony import */ var _meta_building__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./meta_building */ "./src/js/game/meta_building.js");
/* harmony import */ var _buildings_cutter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buildings/cutter */ "./src/js/game/buildings/cutter.js");
/* harmony import */ var _buildings_rotater__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buildings/rotater */ "./src/js/game/buildings/rotater.js");
/* harmony import */ var _buildings_painter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./buildings/painter */ "./src/js/game/buildings/painter.js");
/* harmony import */ var _buildings_mixer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./buildings/mixer */ "./src/js/game/buildings/mixer.js");
/* harmony import */ var _buildings_stacker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./buildings/stacker */ "./src/js/game/buildings/stacker.js");
/* harmony import */ var _buildings_splitter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./buildings/splitter */ "./src/js/game/buildings/splitter.js");
/* harmony import */ var _buildings_underground_belt__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./buildings/underground_belt */ "./src/js/game/buildings/underground_belt.js");
/* harmony import */ var _buildings_miner__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./buildings/miner */ "./src/js/game/buildings/miner.js");
/* harmony import */ var _buildings_trash__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./buildings/trash */ "./src/js/game/buildings/trash.js");
/* harmony import */ var _tutorial_goals__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tutorial_goals */ "./src/js/game/tutorial_goals.js");











/** @typedef {Array<[typeof MetaBuilding, string]>} TutorialGoalReward */



/**
 * Helper method for proper types
 *  @returns {TutorialGoalReward}
 */
const typed = x => x;

/**
 * Stores which reward unlocks what
 * @enum {TutorialGoalReward?}
 */
const enumHubGoalRewardsToContentUnlocked = {
    [_tutorial_goals__WEBPACK_IMPORTED_MODULE_10__["enumHubGoalRewards"].reward_cutter_and_trash]: typed([[_buildings_cutter__WEBPACK_IMPORTED_MODULE_1__["MetaCutterBuilding"], _meta_building__WEBPACK_IMPORTED_MODULE_0__["defaultBuildingVariant"]]]),
    [_tutorial_goals__WEBPACK_IMPORTED_MODULE_10__["enumHubGoalRewards"].reward_rotater]: typed([[_buildings_rotater__WEBPACK_IMPORTED_MODULE_2__["MetaRotaterBuilding"], _meta_building__WEBPACK_IMPORTED_MODULE_0__["defaultBuildingVariant"]]]),
    [_tutorial_goals__WEBPACK_IMPORTED_MODULE_10__["enumHubGoalRewards"].reward_painter]: typed([[_buildings_painter__WEBPACK_IMPORTED_MODULE_3__["MetaPainterBuilding"], _meta_building__WEBPACK_IMPORTED_MODULE_0__["defaultBuildingVariant"]]]),
    [_tutorial_goals__WEBPACK_IMPORTED_MODULE_10__["enumHubGoalRewards"].reward_mixer]: typed([[_buildings_mixer__WEBPACK_IMPORTED_MODULE_4__["MetaMixerBuilding"], _meta_building__WEBPACK_IMPORTED_MODULE_0__["defaultBuildingVariant"]]]),
    [_tutorial_goals__WEBPACK_IMPORTED_MODULE_10__["enumHubGoalRewards"].reward_stacker]: typed([[_buildings_stacker__WEBPACK_IMPORTED_MODULE_5__["MetaStackerBuilding"], _meta_building__WEBPACK_IMPORTED_MODULE_0__["defaultBuildingVariant"]]]),
    [_tutorial_goals__WEBPACK_IMPORTED_MODULE_10__["enumHubGoalRewards"].reward_splitter]: typed([[_buildings_splitter__WEBPACK_IMPORTED_MODULE_6__["MetaSplitterBuilding"], _meta_building__WEBPACK_IMPORTED_MODULE_0__["defaultBuildingVariant"]]]),
    [_tutorial_goals__WEBPACK_IMPORTED_MODULE_10__["enumHubGoalRewards"].reward_tunnel]: typed([[_buildings_underground_belt__WEBPACK_IMPORTED_MODULE_7__["MetaUndergroundBeltBuilding"], _meta_building__WEBPACK_IMPORTED_MODULE_0__["defaultBuildingVariant"]]]),

    [_tutorial_goals__WEBPACK_IMPORTED_MODULE_10__["enumHubGoalRewards"].reward_rotater_ccw]: typed([[_buildings_rotater__WEBPACK_IMPORTED_MODULE_2__["MetaRotaterBuilding"], _buildings_rotater__WEBPACK_IMPORTED_MODULE_2__["enumRotaterVariants"].ccw]]),
    [_tutorial_goals__WEBPACK_IMPORTED_MODULE_10__["enumHubGoalRewards"].reward_miner_chainable]: typed([[_buildings_miner__WEBPACK_IMPORTED_MODULE_8__["MetaMinerBuilding"], _buildings_miner__WEBPACK_IMPORTED_MODULE_8__["enumMinerVariants"].chainable]]),
    [_tutorial_goals__WEBPACK_IMPORTED_MODULE_10__["enumHubGoalRewards"].reward_underground_belt_tier_2]: typed([
        [_buildings_underground_belt__WEBPACK_IMPORTED_MODULE_7__["MetaUndergroundBeltBuilding"], _buildings_underground_belt__WEBPACK_IMPORTED_MODULE_7__["enumUndergroundBeltVariants"].tier2],
    ]),
    [_tutorial_goals__WEBPACK_IMPORTED_MODULE_10__["enumHubGoalRewards"].reward_splitter_compact]: typed([
        [_buildings_splitter__WEBPACK_IMPORTED_MODULE_6__["MetaSplitterBuilding"], _buildings_splitter__WEBPACK_IMPORTED_MODULE_6__["enumSplitterVariants"].compact],
    ]),
    [_tutorial_goals__WEBPACK_IMPORTED_MODULE_10__["enumHubGoalRewards"].reward_cutter_quad]: typed([[_buildings_cutter__WEBPACK_IMPORTED_MODULE_1__["MetaCutterBuilding"], _buildings_cutter__WEBPACK_IMPORTED_MODULE_1__["enumCutterVariants"].quad]]),
    [_tutorial_goals__WEBPACK_IMPORTED_MODULE_10__["enumHubGoalRewards"].reward_painter_double]: typed([[_buildings_painter__WEBPACK_IMPORTED_MODULE_3__["MetaPainterBuilding"], _buildings_painter__WEBPACK_IMPORTED_MODULE_3__["enumPainterVariants"].double]]),
    [_tutorial_goals__WEBPACK_IMPORTED_MODULE_10__["enumHubGoalRewards"].reward_painter_quad]: typed([[_buildings_painter__WEBPACK_IMPORTED_MODULE_3__["MetaPainterBuilding"], _buildings_painter__WEBPACK_IMPORTED_MODULE_3__["enumPainterVariants"].quad]]),
    [_tutorial_goals__WEBPACK_IMPORTED_MODULE_10__["enumHubGoalRewards"].reward_storage]: typed([[_buildings_trash__WEBPACK_IMPORTED_MODULE_9__["MetaTrashBuilding"], _buildings_trash__WEBPACK_IMPORTED_MODULE_9__["enumTrashVariants"].storage]]),

    [_tutorial_goals__WEBPACK_IMPORTED_MODULE_10__["enumHubGoalRewards"].reward_freeplay]: null,
    [_tutorial_goals__WEBPACK_IMPORTED_MODULE_10__["enumHubGoalRewards"].no_reward]: null,
    [_tutorial_goals__WEBPACK_IMPORTED_MODULE_10__["enumHubGoalRewards"].no_reward_freeplay]: null,
};


/***/ }),

/***/ "./src/js/game/upgrades.js":
/*!*********************************!*\
  !*** ./src/js/game/upgrades.js ***!
  \*********************************/
/*! exports provided: finalGameShape, blueprintShape, UPGRADES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "finalGameShape", function() { return finalGameShape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blueprintShape", function() { return blueprintShape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UPGRADES", function() { return UPGRADES; });
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _shape_definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shape_definition */ "./src/js/game/shape_definition.js");



const finalGameShape = "RuCw--Cw:----Ru--";
const blueprintShape = "CbCbCbRb:CwCwCwCw";

const UPGRADES = {
    belt: {
        tiers: [
            {
                required: [{ shape: "CuCuCuCu", amount: 150 }],
                improvement: 1,
            },
            {
                required: [{ shape: "--CuCu--", amount: 1500 }],
                improvement: 2,
            },
            {
                required: [{ shape: "CpCpCpCp", amount: 15000 }],
                improvement: 2,
            },
            {
                required: [{ shape: "SrSrSrSr:CyCyCyCy", amount: 40000 }],
                improvement: 2,
            },
            {
                required: [{ shape: "SrSrSrSr:CyCyCyCy:SwSwSwSw", amount: 40000 }],
                improvement: 2,
            },
            {
                required: [{ shape: finalGameShape, amount: 150000 }],
                improvement: 5,
                excludePrevious: true,
            },
        ],
    },

    miner: {
        tiers: [
            {
                required: [{ shape: "RuRuRuRu", amount: 400 }],
                improvement: 1,
            },
            {
                required: [{ shape: "Cu------", amount: 5500 }],
                improvement: 2,
            },
            {
                required: [{ shape: "ScScScSc", amount: 20000 }],
                improvement: 2,
            },
            {
                required: [{ shape: "CwCwCwCw:WbWbWbWb", amount: 40000 }],
                improvement: 2,
            },
            {
                required: [{ shape: "CbRbRbCb:CwCwCwCw:WbWbWbWb", amount: 40000 }],
                improvement: 2,
            },
            {
                required: [{ shape: finalGameShape, amount: 150000 }],
                improvement: 5,
                excludePrevious: true,
            },
        ],
    },

    processors: {
        tiers: [
            {
                required: [{ shape: "SuSuSuSu", amount: 1000 }],
                improvement: 1,
            },
            {
                required: [{ shape: "RuRu----", amount: 2000 }],
                improvement: 2,
            },
            {
                required: [{ shape: "CgScScCg", amount: 25000 }],
                improvement: 2,
            },
            {
                required: [{ shape: "CwCrCwCr:SgSgSgSg", amount: 40000 }],
                improvement: 2,
            },
            {
                required: [{ shape: "WrRgWrRg:CwCrCwCr:SgSgSgSg", amount: 40000 }],
                improvement: 2,
            },
            {
                required: [{ shape: finalGameShape, amount: 150000 }],
                improvement: 5,
                excludePrevious: true,
            },
        ],
    },

    painting: {
        tiers: [
            {
                required: [{ shape: "RbRb----", amount: 1500 }],
                improvement: 2,
            },
            {
                required: [{ shape: "WrWrWrWr", amount: 5000 }],
                improvement: 1,
            },
            {
                required: [{ shape: "RpRpRpRp:CwCwCwCw", amount: 30000 }],
                improvement: 2,
            },
            {
                required: [{ shape: "WpWpWpWp:CwCwCwCw:WpWpWpWp", amount: 40000 }],
                improvement: 2,
            },
            {
                required: [{ shape: "WpWpWpWp:CwCwCwCw:WpWpWpWp:CwCwCwCw", amount: 40000 }],
                improvement: 2,
            },
            {
                required: [{ shape: finalGameShape, amount: 150000 }],
                improvement: 5,
                excludePrevious: true,
            },
        ],
    },
};

// Tiers need % of the previous tier as requirement too
const tierGrowth = 2.5;

// Automatically generate tier levels
for (const upgradeId in UPGRADES) {
    const upgrade = UPGRADES[upgradeId];

    let currentTierRequirements = [];
    for (let i = 0; i < upgrade.tiers.length; ++i) {
        const tierHandle = upgrade.tiers[i];
        const originalRequired = tierHandle.required.slice();

        for (let k = currentTierRequirements.length - 1; k >= 0; --k) {
            const oldTierRequirement = currentTierRequirements[k];
            if (!tierHandle.excludePrevious) {
                tierHandle.required.unshift({
                    shape: oldTierRequirement.shape,
                    amount: oldTierRequirement.amount,
                });
            }
        }
        currentTierRequirements.push(
            ...originalRequired.map(req => ({
                amount: req.amount,
                shape: req.shape,
            }))
        );
        currentTierRequirements.forEach(tier => {
            tier.amount = Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__["findNiceIntegerValue"])(tier.amount * tierGrowth);
        });
    }
}

if (true) {
    for (const upgradeId in UPGRADES) {
        const upgrade = UPGRADES[upgradeId];
        upgrade.tiers.forEach(tier => {
            tier.required.forEach(({ shape }) => {
                try {
                    _shape_definition__WEBPACK_IMPORTED_MODULE_1__["ShapeDefinition"].fromShortKey(shape);
                } catch (ex) {
                    throw new Error("Invalid upgrade goal: '" + ex + "' for shape" + shape);
                }
            });
        });
    }
}


/***/ }),

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _core_polyfills__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/polyfills */ "./src/js/core/polyfills.js");
/* harmony import */ var _core_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/assert */ "./src/js/core/assert.js");
/* harmony import */ var _core_error_handler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/error_handler */ "./src/js/core/error_handler.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _application__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./application */ "./src/js/application.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/config */ "./src/js/core/config.js");
/* harmony import */ var _game_component_registry__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./game/component_registry */ "./src/js/game/component_registry.js");
/* harmony import */ var _core_draw_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./core/draw_utils */ "./src/js/core/draw_utils.js");
/* harmony import */ var _game_item_registry__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./game/item_registry */ "./src/js/game/item_registry.js");
/* harmony import */ var _game_meta_building_registry__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./game/meta_building_registry */ "./src/js/game/meta_building_registry.js");
/* harmony import */ var _game_game_speed_registry__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./game/game_speed_registry */ "./src/js/game/game_speed_registry.js");













const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_3__["createLogger"])("main");

if (window.coreThreadLoadedCb) {
    logger.log("Javascript parsed, calling html thread");
    window.coreThreadLoadedCb();
}

console.log(
    `%cshapez.io ️%c\n© 2020 Tobias Springer IT Solutions\nCommit %c${"4eaaf87"}%c on %c${new Date(
        1591112380633
    ).toLocaleString()}\n`,
    "font-size: 35px; font-family: Arial;font-weight: bold; padding: 10px 0;",
    "color: #aaa",
    "color: #7f7",
    "color: #aaa",
    "color: #7f7"
);

console.log("Environment: %c" + "dev", "color: #fff");

if ( true && _core_config__WEBPACK_IMPORTED_MODULE_5__["IS_DEBUG"]) {
    console.log("\n%c🛑 DEBUG ENVIRONMENT 🛑\n", "color: #f77");
}



/* dev:start */
console.log("%cDEVCODE BUILT IN", "color: #f77");
/* dev:end */

Object(_core_logging__WEBPACK_IMPORTED_MODULE_3__["logSection"])("Boot Process", "#f9a825");

Object(_core_draw_utils__WEBPACK_IMPORTED_MODULE_7__["initDrawUtils"])();
Object(_game_component_registry__WEBPACK_IMPORTED_MODULE_6__["initComponentRegistry"])();
Object(_game_item_registry__WEBPACK_IMPORTED_MODULE_8__["initItemRegistry"])();
Object(_game_meta_building_registry__WEBPACK_IMPORTED_MODULE_9__["initMetaBuildingRegistry"])();
Object(_game_game_speed_registry__WEBPACK_IMPORTED_MODULE_10__["initGameSpeedRegistry"])();

let app = null;

function bootApp() {
    logger.log("Page Loaded");
    app = new _application__WEBPACK_IMPORTED_MODULE_4__["Application"]();
    app.boot();
}

window.addEventListener("load", bootApp);


/***/ }),

/***/ "./src/js/platform/ad_provider.js":
/*!****************************************!*\
  !*** ./src/js/platform/ad_provider.js ***!
  \****************************************/
/*! exports provided: AdProviderInterface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdProviderInterface", function() { return AdProviderInterface; });


class AdProviderInterface {
    /** @param {Application} app */
    constructor(app) {
        this.app = app;
    }

    /**
     * Initializes the storage
     * @returns {Promise<void>}
     */
    initialize() {
        return Promise.resolve();
    }

    /**
     * Returns if this provider serves ads at all
     * @returns {boolean}
     */
    getHasAds() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return false;
    }

    /**
     * Returns if it would be possible to show a video ad *now*. This can be false if for
     * example the last video ad is
     * @returns {boolean}
     */
    getCanShowVideoAd() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return false;
    }

    /**
     * Shows an video ad
     * @returns {Promise<void>}
     */
    showVideoAd() {
        return Promise.resolve();
    }
}


/***/ }),

/***/ "./src/js/platform/ad_providers/gamedistribution.js":
/*!**********************************************************!*\
  !*** ./src/js/platform/ad_providers/gamedistribution.js ***!
  \**********************************************************/
/*! exports provided: GamedistributionAdProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GamedistributionAdProvider", function() { return GamedistributionAdProvider; });
/* harmony import */ var _ad_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ad_provider */ "./src/js/platform/ad_provider.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/logging */ "./src/js/core/logging.js");






const minimumTimeBetweenVideoAdsMs =  true ? 1 : undefined;

const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_2__["createLogger"])("gamedistribution");

class GamedistributionAdProvider extends _ad_provider__WEBPACK_IMPORTED_MODULE_0__["AdProviderInterface"] {
    /**
     *
     * @param {Application} app
     */
    constructor(app) {
        super(app);

        /**
         * The resolve function to finish the current video ad. Null if none is currently running
         * @type {Function}
         */
        this.videoAdResolveFunction = null;

        /**
         * The current timer which will timeout the resolve
         */
        this.videoAdResolveTimer = null;

        /**
         * When we showed the last video ad
         */
        this.lastVideoAdShowTime = -1e20;

        console.error("X");
    }

    getHasAds() {
        return true;
    }

    getCanShowVideoAd() {
        return (
            this.getHasAds() &&
            !this.videoAdResolveFunction &&
            Object(_core_builtins__WEBPACK_IMPORTED_MODULE_1__["performanceNow"])() - this.lastVideoAdShowTime > minimumTimeBetweenVideoAdsMs
        );
    }

    initialize() {
        // No point to initialize everything if ads are not supported
        if (!this.getHasAds()) {
            return Promise.resolve();
        }

        logger.log("🎬 Initializing gamedistribution ads");

        try {
            parent.postMessage("shapezio://gd.game_loaded", "*");
        } catch (ex) {
            return Promise.reject("Frame communication not allowed");
        }

        window.addEventListener(
            "message",
            event => {
                if (event.data === "shapezio://gd.ad_started") {
                    console.log("🎬 Got ad started callback");
                } else if (event.data === "shapezio://gd.ad_finished") {
                    console.log("🎬 Got ad finished callback");
                    if (this.videoAdResolveFunction) {
                        this.videoAdResolveFunction();
                    }
                }
            },
            false
        );

        return Promise.resolve();
    }

    showVideoAd() {
        window.assert(this.getHasAds(), "Called showVideoAd but ads are not supported!");
        window.assert(!this.videoAdResolveFunction, "Video ad still running, can not show again!");
        this.lastVideoAdShowTime = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_1__["performanceNow"])();

        console.log("🎬 Gamedistribution: Start ad");
        try {
            parent.postMessage("shapezio://gd.show_ad", "*");
        } catch (ex) {
            logger.warn("🎬 Failed to send message for gd ad:", ex);
            return Promise.resolve();
        }

        document.body.classList.add("externalAdOpen");

        return new Promise(resolve => {
            // So, wait for the remove call but also remove after N seconds
            this.videoAdResolveFunction = () => {
                this.videoAdResolveFunction = null;
                clearTimeout(this.videoAdResolveTimer);
                this.videoAdResolveTimer = null;

                // When the ad closed, also set the time
                this.lastVideoAdShowTime = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_1__["performanceNow"])();
                resolve();
            };

            this.videoAdResolveTimer = setTimeout(() => {
                logger.warn("Automatically closing ad after not receiving callback");
                if (this.videoAdResolveFunction) {
                    this.videoAdResolveFunction();
                }
            }, 35000);
        })
            .catch(err => {
                logger.error(this, "Error while resolving video ad:", err);
            })
            .then(() => {
                document.body.classList.remove("externalAdOpen");
            });
    }
}


/***/ }),

/***/ "./src/js/platform/ad_providers/no_ad_provider.js":
/*!********************************************************!*\
  !*** ./src/js/platform/ad_providers/no_ad_provider.js ***!
  \********************************************************/
/*! exports provided: NoAdProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoAdProvider", function() { return NoAdProvider; });
/* harmony import */ var _ad_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ad_provider */ "./src/js/platform/ad_provider.js");


class NoAdProvider extends _ad_provider__WEBPACK_IMPORTED_MODULE_0__["AdProviderInterface"] {
    getHasAds() {
        return false;
    }

    getCanShowVideoAd() {
        return false;
    }
}


/***/ }),

/***/ "./src/js/platform/analytics.js":
/*!**************************************!*\
  !*** ./src/js/platform/analytics.js ***!
  \**************************************/
/*! exports provided: AnalyticsInterface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnalyticsInterface", function() { return AnalyticsInterface; });


class AnalyticsInterface {
    constructor(app) {
        /** @type {Application} */
        this.app = app;
    }

    /**
     * Initializes the analytics
     * @returns {Promise<void>}
     */
    initialize() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return Promise.reject();
    }

    /**
     * Sets the player name for analytics
     * @param {string} userName
     */
    setUserContext(userName) {}

    /**
     * Tracks a click no an ui element
     * @param {string} elementName
     */
    trackUiClick(elementName) {}

    /**
     * Tracks when a new state is entered
     * @param {string} stateId
     */
    trackStateEnter(stateId) {}

    /**
     * Tracks a new user decision
     * @param {string} name
     */
    trackDecision(name) {}
}


/***/ }),

/***/ "./src/js/platform/browser/game_analytics.js":
/*!***************************************************!*\
  !*** ./src/js/platform/browser/game_analytics.js ***!
  \***************************************************/
/*! exports provided: ShapezGameAnalytics */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapezGameAnalytics", function() { return ShapezGameAnalytics; });
/* harmony import */ var _game_analytics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game_analytics */ "./src/js/platform/game_analytics.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _game_shape_definition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../game/shape_definition */ "./src/js/game/shape_definition.js");
/* harmony import */ var _savegame_savegame__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../savegame/savegame */ "./src/js/savegame/savegame.js");
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../storage */ "./src/js/platform/storage.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _states_ingame__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../states/ingame */ "./src/js/states/ingame.js");
/* harmony import */ var _game_root__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../game/root */ "./src/js/game/root.js");
/* harmony import */ var _game_components_static_map_entity__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../game/components/static_map_entity */ "./src/js/game/components/static_map_entity.js");










const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_1__["createLogger"])("game_analytics");

const analyticsUrl =  true ? "http://localhost:8001" : undefined;

// Be sure to increment the ID whenever it changes to make sure all
// users are tracked
const analyticsLocalFile = "analytics_token.3.bin";

class ShapezGameAnalytics extends _game_analytics__WEBPACK_IMPORTED_MODULE_0__["GameAnalyticsInterface"] {
    /**
     * @returns {Promise<void>}
     */
    initialize() {
        this.syncKey = null;

        setInterval(() => this.sendTimePoints(), 120 * 1000);

        // Retrieve sync key from player
        return this.app.storage.readFileAsync(analyticsLocalFile).then(
            syncKey => {
                this.syncKey = syncKey;
                logger.log("Player sync key read:", this.syncKey);
            },
            error => {
                // File was not found, retrieve new key
                if (error === _storage__WEBPACK_IMPORTED_MODULE_4__["FILE_NOT_FOUND"]) {
                    logger.log("Retrieving new player key");

                    // Perform call to get a new key from the API
                    this.sendToApi("/v1/register", {
                        environment: "dev",
                    })
                        .then(res => {
                            // Try to read and parse the key from the api
                            if (res.key && typeof res.key === "string" && res.key.length === 40) {
                                this.syncKey = res.key;
                                logger.log("Key retrieved:", this.syncKey);
                                this.app.storage.writeFileAsync(analyticsLocalFile, res.key);
                            } else {
                                throw new Error("Bad response from analytics server: " + res);
                            }
                        })
                        .catch(err => {
                            logger.error("Failed to register on analytics api:", err);
                        });
                } else {
                    logger.error("Failed to read ga key:", error);
                }
                return;
            }
        );
    }

    /**
     * Sends a request to the api
     * @param {string} endpoint Endpoint without base url
     * @param {object} data payload
     * @returns {Promise<any>}
     */
    sendToApi(endpoint, data) {
        return Promise.race([
            new Promise((resolve, reject) => {
                setTimeout(() => reject("Request to " + endpoint + " timed out"), 20000);
            }),
            fetch(analyticsUrl + endpoint, {
                method: "POST",
                mode: "cors",
                cache: "no-cache",
                referrer: "no-referrer",
                credentials: "omit",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                    "x-api-key": _core_config__WEBPACK_IMPORTED_MODULE_5__["globalConfig"].info.analyticsApiKey,
                },
                body: JSON.stringify(data),
            })
                .then(res => {
                    if (!res.ok || res.status !== 200) {
                        throw new Error("Fetch error: Bad status " + res.status);
                    }
                    return res;
                })
                .then(res => res.json()),
        ]);
    }

    /**
     * Sends a game event to the analytics
     * @param {string} category
     * @param {string} value
     */
    sendGameEvent(category, value) {
        if (!this.syncKey) {
            logger.warn("Can not send event due to missing sync key");
            return;
        }

        const gameState = this.app.stateMgr.currentState;
        if (!(gameState instanceof _states_ingame__WEBPACK_IMPORTED_MODULE_6__["InGameState"])) {
            logger.warn("Trying to send analytics event outside of ingame state");
            return;
        }

        const savegame = gameState.savegame;
        if (!savegame) {
            logger.warn("Ingame state has empty savegame");
            return;
        }

        const savegameId = savegame.internalId;
        if (!gameState.core) {
            logger.warn("Game state has no core");
            return;
        }
        const root = gameState.core.root;
        if (!root) {
            logger.warn("Root is not initialized");
            return;
        }

        logger.log("Sending event", category, value);

        this.sendToApi("/v1/game-event", {
            playerKey: this.syncKey,
            gameKey: savegameId,
            ingameTime: root.time.now(),
            category,
            value,
            version: "1.1.3",
            gameDump: this.generateGameDump(root, category === "sync"),
        });
    }

    sendTimePoints() {
        const gameState = this.app.stateMgr.currentState;
        if (gameState instanceof _states_ingame__WEBPACK_IMPORTED_MODULE_6__["InGameState"]) {
            logger.log("Syncing analytics");
            this.sendGameEvent("sync", "");
        }
    }

    /**
     * Generates a game dump
     * @param {GameRoot} root
     * @param {boolean=} metaOnly
     */
    generateGameDump(root, metaOnly = false) {
        let staticEntities = [];

        const entities = root.entityMgr.getAllWithComponent(_game_components_static_map_entity__WEBPACK_IMPORTED_MODULE_8__["StaticMapEntityComponent"]);

        // Limit the entities
        if (!metaOnly && entities.length < 500) {
            for (let i = 0; i < entities.length; ++i) {
                const entity = entities[i];
                const staticComp = entity.components.StaticMapEntity;
                const payload = {};
                payload.origin = staticComp.origin;
                payload.tileSize = staticComp.tileSize;
                payload.rotation = staticComp.rotation;

                if (entity.components.Belt) {
                    payload.type = "belt";
                } else if (entity.components.UndergroundBelt) {
                    payload.type = "tunnel";
                } else if (entity.components.ItemProcessor) {
                    payload.type = entity.components.ItemProcessor.type;
                } else if (entity.components.Miner) {
                    payload.type = "extractor";
                } else {
                    logger.warn("Unkown entity type", entity);
                }
                staticEntities.push(payload);
            }
        }

        return {
            storedShapes: root.hubGoals.storedShapes,
            gainedRewards: root.hubGoals.gainedRewards,
            upgradeLevels: root.hubGoals.upgradeLevels,
            staticEntities,
        };
    }

    /**
     * @param {ShapeDefinition} definition
     */
    handleShapeDelivered(definition) {}

    /**
     */
    handleGameStarted() {
        this.sendGameEvent("game_start", "");
    }

    /**
     * Handles the given level completed
     * @param {number} level
     */
    handleLevelCompleted(level) {
        logger.log("Complete level", level);
        this.sendGameEvent("level_complete", "" + level);
    }

    /**
     * Handles the given upgrade completed
     * @param {string} id
     * @param {number} level
     */
    handleUpgradeUnlocked(id, level) {
        logger.log("Unlock upgrade", id, level);
        this.sendGameEvent("upgrade_unlock", id + "@" + level);
    }
}


/***/ }),

/***/ "./src/js/platform/browser/google_analytics.js":
/*!*****************************************************!*\
  !*** ./src/js/platform/browser/google_analytics.js ***!
  \*****************************************************/
/*! exports provided: GoogleAnalyticsImpl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GoogleAnalyticsImpl", function() { return GoogleAnalyticsImpl; });
/* harmony import */ var _analytics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../analytics */ "./src/js/platform/analytics.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/logging */ "./src/js/core/logging.js");




const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_2__["createLogger"])("ga");

class GoogleAnalyticsImpl extends _analytics__WEBPACK_IMPORTED_MODULE_0__["AnalyticsInterface"] {
    initialize() {
        this.lastUiClickTracked = -1000;

        setInterval(() => this.internalTrackAfkEvent(), 120 * 1000);

        // Analytics is already loaded in the html
        return Promise.resolve();
    }

    setUserContext(userName) {
        try {
            if (window.gtag) {
                logger.log("📊 Setting user context:", userName);
                window.gtag("set", {
                    player: userName,
                });
            }
        } catch (ex) {
            logger.warn("📊 Failed to set user context:", ex);
        }
    }

    trackStateEnter(stateId) {
        const nonInteractionStates = [
            "LoginState",
            "MainMenuState",
            "PreloadState",
            "RegisterState",
            "WatchAdState",
        ];

        try {
            if (window.gtag) {
                logger.log("📊 Tracking state enter:", stateId);
                window.gtag("event", "enter_state", {
                    event_category: "ui",
                    event_label: stateId,
                    non_interaction: nonInteractionStates.indexOf(stateId) >= 0,
                });
            }
        } catch (ex) {
            logger.warn("📊 Failed to track state analytcis:", ex);
        }
    }

    trackDecision(decisionName) {
        try {
            if (window.gtag) {
                logger.log("📊 Tracking decision:", decisionName);
                window.gtag("event", "decision", {
                    event_category: "ui",
                    event_label: decisionName,
                    non_interaction: true,
                });
            }
        } catch (ex) {
            logger.warn("📊 Failed to track state analytcis:", ex);
        }
    }

    trackUiClick(elementName) {
        const stateKey = this.app.stateMgr.getCurrentState().key;
        const fullSelector = stateKey + ">" + elementName;

        try {
            if (window.gtag) {
                logger.log("📊 Tracking click on:", fullSelector);
                window.gtag("event", "click", {
                    event_category: "ui",
                    event_label: fullSelector,
                });
            }
        } catch (ex) {
            logger.warn("📊 Failed to track ui click:", ex);
        }
    }

    /**
     * Tracks an event so GA keeps track of the user
     */
    internalTrackAfkEvent() {
        if (window.gtag) {
            window.gtag("event", "afk", {
                event_category: "ping",
                event_label: "timed",
            });
        }
    }
}


/***/ }),

/***/ "./src/js/platform/browser/sound.js":
/*!******************************************!*\
  !*** ./src/js/platform/browser/sound.js ***!
  \******************************************/
/*! exports provided: SoundImplBrowser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SoundImplBrowser", function() { return SoundImplBrowser; });
/* harmony import */ var _sound__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sound */ "./src/js/platform/sound.js");
/* harmony import */ var _core_cachebust__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/cachebust */ "./src/js/core/cachebust.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");





const { Howl, Howler } = __webpack_require__(/*! howler */ "./node_modules/howler/dist/howler.js");

const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_2__["createLogger"])("sound/browser");

// @ts-ignore
const sprites = __webpack_require__(/*! ../../built-temp/sfx.json */ "./src/js/built-temp/sfx.json");

class SoundSpritesContainer {
    constructor() {
        this.howl = null;

        this.loadingPromise = null;
    }

    load() {
        if (this.loadingPromise) {
            return this.loadingPromise;
        }
        return (this.loadingPromise = Promise.race([
            new Promise((resolve, reject) => {
                setTimeout(reject,  true ? 500 : undefined);
            }),
            new Promise(resolve => {
                this.howl = new Howl({
                    src: Object(_core_cachebust__WEBPACK_IMPORTED_MODULE_1__["cachebust"])("res/sounds/sfx.mp3"),
                    sprite: sprites.sprite,
                    autoplay: false,
                    loop: false,
                    volume: 0,
                    preload: true,
                    pool: 20,
                    onload: () => {
                        resolve();
                    },
                    onloaderror: (id, err) => {
                        logger.warn("SFX failed to load:", id, err);
                        this.howl = null;
                        resolve();
                    },
                    onplayerror: (id, err) => {
                        logger.warn("SFX failed to play:", id, err);
                    },
                });
            }),
        ]));
    }

    play(volume, key) {
        if (this.howl) {
            const instance = this.howl.play(key);
            this.howl.volume(volume, instance);
        }
    }

    deinitialize() {
        if (this.howl) {
            this.howl.unload();
            this.howl = null;
        }
    }
}

class WrappedSoundInstance extends _sound__WEBPACK_IMPORTED_MODULE_0__["SoundInstanceInterface"] {
    /**
     *
     * @param {SoundSpritesContainer} spriteContainer
     * @param {string} key
     */
    constructor(spriteContainer, key) {
        super(key, "sfx.mp3");
        this.spriteContainer = spriteContainer;
    }

    /** @returns {Promise<void>} */
    load() {
        return this.spriteContainer.load();
    }

    play(volume) {
        this.spriteContainer.play(volume, this.key);
    }

    deinitialize() {
        return this.spriteContainer.deinitialize();
    }
}

class MusicInstance extends _sound__WEBPACK_IMPORTED_MODULE_0__["MusicInstanceInterface"] {
    constructor(key, url) {
        super(key, url);
        this.howl = null;
        this.instance = null;
        this.playing = false;
    }
    load() {
        return Promise.race([
            new Promise((resolve, reject) => {
                setTimeout(reject,  true ? 500 : undefined);
            }),
            new Promise((resolve, reject) => {
                this.howl = new Howl({
                    src: Object(_core_cachebust__WEBPACK_IMPORTED_MODULE_1__["cachebust"])("res/sounds/music/" + this.url + ".mp3"),
                    autoplay: false,
                    loop: true,
                    html5: true,
                    volume: 1,
                    preload: true,
                    pool: 2,

                    onunlock: () => {
                        if (this.playing) {
                            logger.log("Playing music after manual unlock");
                            this.play();
                        }
                    },

                    onload: () => {
                        resolve();
                    },
                    onloaderror: (id, err) => {
                        logger.warn(this, "Music", this.url, "failed to load:", id, err);
                        this.howl = null;
                        resolve();
                    },
                    onplayerror: (id, err) => {
                        logger.warn(this, "Music", this.url, "failed to play:", id, err);
                    },
                });
            }),
        ]);
    }

    stop() {
        if (this.howl && this.instance) {
            this.playing = false;
            this.howl.pause(this.instance);
        }
    }

    isPlaying() {
        return this.playing;
    }

    play() {
        if (this.howl) {
            this.playing = true;
            if (this.instance) {
                this.howl.play(this.instance);
            } else {
                this.instance = this.howl.play();
            }
        }
    }

    deinitialize() {
        if (this.howl) {
            this.howl.unload();
            this.howl = null;
            this.instance = null;
        }
    }
}

class SoundImplBrowser extends _sound__WEBPACK_IMPORTED_MODULE_0__["SoundInterface"] {
    constructor(app) {
        Howler.mobileAutoEnable = true;
        Howler.autoUnlock = true;
        Howler.autoSuspend = false;
        Howler.html5PoolSize = 20;
        Howler.pos(0, 0, 0);

        super(app, WrappedSoundInstance, MusicInstance);
    }

    initialize() {
        this.sfxHandle = new SoundSpritesContainer();

        // @ts-ignore
        const keys = Object.values(_sound__WEBPACK_IMPORTED_MODULE_0__["SOUNDS"]);
        keys.forEach(key => {
            this.sounds[key] = new WrappedSoundInstance(this.sfxHandle, key);
        });
        for (const musicKey in _sound__WEBPACK_IMPORTED_MODULE_0__["MUSIC"]) {
            const musicPath = _sound__WEBPACK_IMPORTED_MODULE_0__["MUSIC"][musicKey];
            const music = new this.musicClass(musicKey, musicPath);
            this.music[musicPath] = music;
        }

        this.musicMuted = this.app.settings.getAllSettings().musicMuted;
        this.soundsMuted = this.app.settings.getAllSettings().soundsMuted;

        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_3__["globalConfig"].debug.disableMusic) {
            this.musicMuted = true;
        }

        return Promise.resolve();
    }

    deinitialize() {
        return super.deinitialize().then(() => Howler.unload());
    }
}


/***/ }),

/***/ "./src/js/platform/browser/storage.js":
/*!********************************************!*\
  !*** ./src/js/platform/browser/storage.js ***!
  \********************************************/
/*! exports provided: StorageImplBrowser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StorageImplBrowser", function() { return StorageImplBrowser; });
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../storage */ "./src/js/platform/storage.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/logging */ "./src/js/core/logging.js");



const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_1__["createLogger"])("storage/browser");

const LOCAL_STORAGE_UNAVAILABLE = "local-storage-unavailable";
const LOCAL_STORAGE_NO_WRITE_PERMISSION = "local-storage-no-write-permission";

let randomDelay = () => 0;

if (true) {
    // Random delay for testing
    // randomDelay = () => 500;
}

class StorageImplBrowser extends _storage__WEBPACK_IMPORTED_MODULE_0__["StorageInterface"] {
    constructor(app) {
        super(app);
        this.currentBusyFilename = false;
    }

    initialize() {
        logger.error("Using localStorage, please update to a newer browser");
        return new Promise((resolve, reject) => {
            // Check for local storage availability in general
            if (!window.localStorage) {
                alert("Local storage is not available! Please upgrade to a newer browser!");
                reject(LOCAL_STORAGE_UNAVAILABLE);
            }

            // Check if we can set and remove items
            try {
                window.localStorage.setItem("storage_availability_test", "1");
                window.localStorage.removeItem("storage_availability_test");
            } catch (e) {
                alert(
                    "It seems we don't have permission to write to local storage! Please update your browsers settings or use a different browser!"
                );
                reject(LOCAL_STORAGE_NO_WRITE_PERMISSION);
                return;
            }
            setTimeout(resolve, 0);
        });
    }

    writeFileAsync(filename, contents) {
        if (this.currentBusyFilename === filename) {
            logger.warn("Attempt to write", filename, "while write process is not finished!");
        }

        this.currentBusyFilename = filename;
        window.localStorage.setItem(filename, contents);
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                this.currentBusyFilename = false;
                resolve();
            }, 0);
        });
    }

    writeFileSyncIfSupported(filename, contents) {
        window.localStorage.setItem(filename, contents);
        return true;
    }

    readFileAsync(filename) {
        if (this.currentBusyFilename === filename) {
            logger.warn("Attempt to read", filename, "while write progress on it is ongoing!");
        }

        return new Promise((resolve, reject) => {
            const contents = window.localStorage.getItem(filename);
            if (!contents) {
                // File not found
                setTimeout(() => reject(_storage__WEBPACK_IMPORTED_MODULE_0__["FILE_NOT_FOUND"]), randomDelay());
                return;
            }

            // File read, simulate delay
            setTimeout(() => resolve(contents), 0);
        });
    }

    deleteFileAsync(filename) {
        if (this.currentBusyFilename === filename) {
            logger.warn("Attempt to delete", filename, "while write progres on it is ongoing!");
        }

        this.currentBusyFilename = filename;
        return new Promise((resolve, reject) => {
            window.localStorage.removeItem(filename);
            setTimeout(() => {
                this.currentBusyFilename = false;
                resolve();
            }, 0);
        });
    }
}


/***/ }),

/***/ "./src/js/platform/browser/storage_indexed_db.js":
/*!*******************************************************!*\
  !*** ./src/js/platform/browser/storage_indexed_db.js ***!
  \*******************************************************/
/*! exports provided: StorageImplBrowserIndexedDB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StorageImplBrowserIndexedDB", function() { return StorageImplBrowserIndexedDB; });
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../storage */ "./src/js/platform/storage.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/logging */ "./src/js/core/logging.js");



const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_1__["createLogger"])("storage/browserIDB");

const LOCAL_STORAGE_UNAVAILABLE = "local-storage-unavailable";
const LOCAL_STORAGE_NO_WRITE_PERMISSION = "local-storage-no-write-permission";

let randomDelay = () => 0;

if (true) {
    // Random delay for testing
    // randomDelay = () => 500;
}

class StorageImplBrowserIndexedDB extends _storage__WEBPACK_IMPORTED_MODULE_0__["StorageInterface"] {
    constructor(app) {
        super(app);
        this.currentBusyFilename = false;

        /** @type {IDBDatabase} */
        this.database = null;
    }

    initialize() {
        logger.log("Using indexed DB storage");
        return new Promise((resolve, reject) => {
            const request = window.indexedDB.open("app_storage", 10);
            request.onerror = event => {
                logger.error("IDB error:", event);
                alert(
                    "Sorry, it seems your browser has blocked the access to the storage system. This might be the case if you are browsing in private mode for example. I recommend to use google chrome or disable private browsing."
                );
                reject("Indexed DB access error");
            };

            // @ts-ignore
            request.onsuccess = event => resolve(event.target.result);

            request.onupgradeneeded = /** @type {IDBVersionChangeEvent} */ event => {
                /** @type {IDBDatabase} */
                // @ts-ignore
                const database = event.target.result;

                const objectStore = database.createObjectStore("files", {
                    keyPath: "filename",
                });

                objectStore.createIndex("filename", "filename", { unique: true });

                objectStore.transaction.onerror = event => {
                    logger.error("IDB transaction error:", event);
                    reject("Indexed DB transaction error during migration, check console output.");
                };

                objectStore.transaction.oncomplete = event => {
                    logger.log("Object store completely initialized");
                    resolve(database);
                };
            };
        }).then(database => {
            this.database = database;
        });
    }

    writeFileAsync(filename, contents) {
        if (this.currentBusyFilename === filename) {
            logger.warn("Attempt to write", filename, "while write process is not finished!");
        }
        if (!this.database) {
            return Promise.reject("Storage not ready");
        }

        this.currentBusyFilename = filename;
        const transaction = this.database.transaction(["files"], "readwrite");

        return new Promise((resolve, reject) => {
            transaction.oncomplete = () => {
                this.currentBusyFilename = null;
                resolve();
            };

            transaction.onerror = error => {
                this.currentBusyFilename = null;
                logger.error("Error while writing", filename, ":", error);
                reject(error);
            };

            const store = transaction.objectStore("files");
            store.put({
                filename,
                contents,
            });
        });
    }

    writeFileSyncIfSupported(filename, contents) {
        // Not supported
        this.writeFileAsync(filename, contents);
        return true;
    }

    readFileAsync(filename) {
        if (!this.database) {
            return Promise.reject("Storage not ready");
        }

        this.currentBusyFilename = filename;
        const transaction = this.database.transaction(["files"], "readonly");

        return new Promise((resolve, reject) => {
            const store = transaction.objectStore("files");
            const request = store.get(filename);

            request.onsuccess = event => {
                this.currentBusyFilename = null;
                if (!request.result) {
                    reject(_storage__WEBPACK_IMPORTED_MODULE_0__["FILE_NOT_FOUND"]);
                    return;
                }
                resolve(request.result.contents);
            };

            request.onerror = error => {
                this.currentBusyFilename = null;
                logger.error("Error while reading", filename, ":", error);
                reject(error);
            };
        });
    }

    deleteFileAsync(filename) {
        if (this.currentBusyFilename === filename) {
            logger.warn("Attempt to delete", filename, "while write progres on it is ongoing!");
        }

        if (!this.database) {
            return Promise.reject("Storage not ready");
        }

        this.currentBusyFilename = filename;
        const transaction = this.database.transaction(["files"], "readwrite");

        return new Promise((resolve, reject) => {
            transaction.oncomplete = () => {
                this.currentBusyFilename = null;
                resolve();
            };

            transaction.onerror = error => {
                this.currentBusyFilename = null;
                logger.error("Error while deleting", filename, ":", error);
                reject(error);
            };

            const store = transaction.objectStore("files");
            store.delete(filename);
        });
    }
}


/***/ }),

/***/ "./src/js/platform/browser/wrapper.js":
/*!********************************************!*\
  !*** ./src/js/platform/browser/wrapper.js ***!
  \********************************************/
/*! exports provided: PlatformWrapperImplBrowser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlatformWrapperImplBrowser", function() { return PlatformWrapperImplBrowser; });
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_query_parameters__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/query_parameters */ "./src/js/core/query_parameters.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _ad_providers_no_ad_provider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ad_providers/no_ad_provider */ "./src/js/platform/ad_providers/no_ad_provider.js");
/* harmony import */ var _wrapper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../wrapper */ "./src/js/platform/wrapper.js");
/* harmony import */ var _ad_providers_gamedistribution__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../ad_providers/gamedistribution */ "./src/js/platform/ad_providers/gamedistribution.js");









const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_2__["createLogger"])("platform/browser");

class PlatformWrapperImplBrowser extends _wrapper__WEBPACK_IMPORTED_MODULE_6__["PlatformWrapperInterface"] {
    initialize() {
        this.recaptchaTokenCallback = null;

        this.embedProvider = {
            id: "shapezio-website",
            adProvider: _ad_providers_no_ad_provider__WEBPACK_IMPORTED_MODULE_5__["NoAdProvider"],
            iframed: false,
            externalLinks: true,
            iogLink: true,
            unlimitedSavegames: _core_config__WEBPACK_IMPORTED_MODULE_1__["IS_DEMO"] ? false : true,
            showDemoBadge: _core_config__WEBPACK_IMPORTED_MODULE_1__["IS_DEMO"],
        };

        if ( true && _core_query_parameters__WEBPACK_IMPORTED_MODULE_3__["queryParamOptions"].embedProvider) {
            const providerId = _core_query_parameters__WEBPACK_IMPORTED_MODULE_3__["queryParamOptions"].embedProvider;
            this.embedProvider.iframed = true;
            this.embedProvider.iogLink = false;

            switch (providerId) {
                case "armorgames": {
                    this.embedProvider.id = "armorgames";
                    break;
                }

                case "iogames.space": {
                    this.embedProvider.id = "iogames.space";
                    this.embedProvider.iogLink = true;
                    this.embedProvider.unlimitedSavegames = true;
                    this.embedProvider.showDemoBadge = false;
                    break;
                }

                case "miniclip": {
                    this.embedProvider.id = "miniclip";
                    break;
                }

                case "gamedistribution": {
                    this.embedProvider.id = "gamedistribution";
                    this.embedProvider.externalLinks = false;
                    this.embedProvider.adProvider = _ad_providers_gamedistribution__WEBPACK_IMPORTED_MODULE_7__["GamedistributionAdProvider"];
                    break;
                }

                case "kongregate": {
                    this.embedProvider.id = "kongregate";
                    break;
                }

                case "crazygames": {
                    this.embedProvider.id = "crazygames";
                    break;
                }

                default: {
                    logger.error("Got unsupported embed provider:", providerId);
                }
            }
        }

        logger.log("Embed provider:", this.embedProvider.id);

        return super.initialize().then(() => this.initializeAdProvider());
    }

    getHasUnlimitedSavegames() {
        return this.embedProvider.unlimitedSavegames;
    }

    getShowDemoBadges() {
        return this.embedProvider.showDemoBadge;
    }

    onSentryLoaded() {
        logger.log("Initializing sentry");
        window.Sentry.init({
            dsn: "TODO SENTRY DSN",
            release: "dev" + "-" + "1.1.3" + "@" + "4eaaf87",
            // Will cause a deprecation warning, but the demise of `ignoreErrors` is still under discussion.
            // See: https://github.com/getsentry/raven-js/issues/73
            ignoreErrors: [
                // Random plugins/extensions
                "top.GLOBALS",
                // See: http://blog.errorception.com/2012/03/tale-of-unfindable-js-error.html
                "originalCreateNotification",
                "canvas.contentDocument",
                "MyApp_RemoveAllHighlights",
                "http://tt.epicplay.com",
                "Can't find variable: ZiteReader",
                "jigsaw is not defined",
                "ComboSearch is not defined",
                "http://loading.retry.widdit.com/",
                "atomicFindClose",
                // Facebook borked
                "fb_xd_fragment",
                // ISP "optimizing" proxy - `Cache-Control: no-transform` seems to reduce this. (thanks @acdha)
                // See http://stackoverflow.com/questions/4113268/how-to-stop-javascript-injection-from-vodafone-proxy
                "bmi_SafeAddOnload",
                "EBCallBackMessageReceived",
                // See http://toolbar.conduit.com/Developer/HtmlAndGadget/Methods/JSInjection.aspx
                "conduitPage",
                // Generic error code from errors outside the security sandbox
                // You can delete this if using raven.js > 1.0, which ignores these automatically.
                "Script error.",

                // Errors from ads
                "Cannot read property 'postMessage' of null",

                // Firefox only
                "AbortError: The operation was aborted.",

                "<unknown>",
            ],
            ignoreUrls: [
                // Facebook flakiness
                /graph\.facebook\.com/i,
                // Facebook blocked
                /connect\.facebook\.net\/en_US\/all\.js/i,
                // Woopra flakiness
                /eatdifferent\.com\.woopra-ns\.com/i,
                /static\.woopra\.com\/js\/woopra\.js/i,
                // Chrome extensions
                /extensions\//i,
                /^chrome:\/\//i,
                // Other plugins
                /127\.0\.0\.1:4001\/isrunning/i, // Cacaoweb
                /webappstoolbarba\.texthelp\.com\//i,
                /metrics\.itunes\.apple\.com\.edgesuite\.net\//i,
            ],
            beforeSend(event, hint) {
                if (window.anyModLoaded) {
                    return null;
                }
                return event;
            },
        });
    }

    getId() {
        return "browser@" + this.embedProvider.id;
    }

    getUiScale() {
        if (_core_config__WEBPACK_IMPORTED_MODULE_1__["IS_MOBILE"]) {
            return 1;
        }

        const avgDims = Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["Math_min"])(this.app.screenWidth, this.app.screenHeight);
        return Object(_core_utils__WEBPACK_IMPORTED_MODULE_4__["clamp"])((avgDims / 1000.0) * 1.9, 0.1, 10);
    }

    getSupportsRestart() {
        return true;
    }

    getTouchPanStrength() {
        return _core_config__WEBPACK_IMPORTED_MODULE_1__["IS_MOBILE"] ? 1 : 0.5;
    }

    openExternalLink(url, force = false) {
        logger.log("Opening external:", url);
        if (force || this.embedProvider.externalLinks) {
            window.open(url);
        } else {
            // Do nothing
            alert(
                "This platform does not allow opening external links. You can play on https://shapez.io directly to open them.\n\nClicked Link: " +
                    url
            );
        }
    }

    performRestart() {
        logger.log("Performing restart");
        window.location.reload(true);
    }

    /**
     * Detects if there is an adblocker installed
     * @returns {Promise<boolean>}
     */
    detectAdblock() {
        return Promise.race([
            new Promise(resolve => {
                // If the request wasn't blocked within a very short period of time, this means
                // the adblocker is not active and the request was actually made -> ignore it then
                setTimeout(() => resolve(false), 30);
            }),
            new Promise(resolve => {
                fetch("https://googleads.g.doubleclick.net/pagead/id", {
                    method: "HEAD",
                    mode: "no-cors",
                })
                    .then(res => {
                        resolve(false);
                    })
                    .catch(err => {
                        resolve(true);
                    });
            }),
        ]);
    }

    initializeAdProvider() {
        if ( true && !_core_config__WEBPACK_IMPORTED_MODULE_1__["globalConfig"].debug.testAds) {
            logger.log("Ads disabled in local environment");
            return Promise.resolve();
        }

        // First, detect adblocker
        return this.detectAdblock().then(hasAdblocker => {
            if (hasAdblocker) {
                logger.log("Adblock detected");
                return;
            }

            const adProvider = this.embedProvider.adProvider;
            this.app.adProvider = new adProvider(this.app);
            return this.app.adProvider.initialize().catch(err => {
                logger.error("Failed to initialize ad provider, disabling ads:", err);
                this.app.adProvider = new _ad_providers_no_ad_provider__WEBPACK_IMPORTED_MODULE_5__["NoAdProvider"](this.app);
            });
        });
    }

    exitApp() {
        // Can not exit app
    }
}


/***/ }),

/***/ "./src/js/platform/electron/storage.js":
/*!*********************************************!*\
  !*** ./src/js/platform/electron/storage.js ***!
  \*********************************************/
/*! exports provided: StorageImplElectron */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StorageImplElectron", function() { return StorageImplElectron; });
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../storage */ "./src/js/platform/storage.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/logging */ "./src/js/core/logging.js");




const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_2__["createLogger"])("electron-storage");

class StorageImplElectron extends _storage__WEBPACK_IMPORTED_MODULE_0__["StorageInterface"] {
    constructor(app) {
        super(app);

        /** @type {Object.<number, {resolve:Function, reject: Function}>} */
        this.jobs = {};
        this.jobId = 0;

        Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["getIPCRenderer"])().on("fs-response", (event, arg) => {
            const id = arg.id;
            if (!this.jobs[id]) {
                logger.warn("Got unhandled FS response, job not known:", id);
                return;
            }
            const { resolve, reject } = this.jobs[id];
            if (arg.result.success) {
                resolve(arg.result.data);
            } else {
                reject(arg.result.error);
            }
        });
    }

    initialize() {
        return Promise.resolve();
    }

    writeFileAsync(filename, contents) {
        return new Promise((resolve, reject) => {
            // ipcMain
            const jobId = ++this.jobId;
            this.jobs[jobId] = { resolve, reject };

            Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["getIPCRenderer"])().send("fs-job", {
                type: "write",
                filename,
                contents,
                id: jobId,
            });
        });
    }

    writeFileSyncIfSupported(filename, contents) {
        return Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["getIPCRenderer"])().sendSync("fs-sync-job", {
            type: "write",
            filename,
            contents,
        });
    }

    readFileAsync(filename) {
        return new Promise((resolve, reject) => {
            // ipcMain
            const jobId = ++this.jobId;
            this.jobs[jobId] = { resolve, reject };

            Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["getIPCRenderer"])().send("fs-job", {
                type: "read",
                filename,
                id: jobId,
            });
        });
    }

    deleteFileAsync(filename) {
        return new Promise((resolve, reject) => {
            // ipcMain
            const jobId = ++this.jobId;
            this.jobs[jobId] = { resolve, reject };
            Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["getIPCRenderer"])().send("fs-job", {
                type: "delete",
                filename,
                id: jobId,
            });
        });
    }
}


/***/ }),

/***/ "./src/js/platform/electron/wrapper.js":
/*!*********************************************!*\
  !*** ./src/js/platform/electron/wrapper.js ***!
  \*********************************************/
/*! exports provided: PlatformWrapperImplElectron */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlatformWrapperImplElectron", function() { return PlatformWrapperImplElectron; });
/* harmony import */ var _browser_wrapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../browser/wrapper */ "./src/js/platform/browser/wrapper.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/logging */ "./src/js/core/logging.js");




const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_2__["createLogger"])("electron-wrapper");

class PlatformWrapperImplElectron extends _browser_wrapper__WEBPACK_IMPORTED_MODULE_0__["PlatformWrapperImplBrowser"] {
    getId() {
        return "electron";
    }

    getSupportsRestart() {
        return true;
    }

    openExternalLink(url) {
        logger.log(this, "Opening external:", url);
        window.open(url, "about:blank");
    }

    getSupportsAds() {
        return false;
    }

    performRestart() {
        logger.log(this, "Performing restart");
        window.location.reload(true);
    }

    initializeAdProvider() {
        return Promise.resolve();
    }

    getSupportsFullscreen() {
        return true;
    }

    setFullscreen(flag) {
        Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["getIPCRenderer"])().send("set-fullscreen", flag);
    }

    getSupportsAppExit() {
        return true;
    }

    exitApp() {
        logger.log(this, "Sending app exit signal");
        Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["getIPCRenderer"])().send("exit-app");
    }
}


/***/ }),

/***/ "./src/js/platform/game_analytics.js":
/*!*******************************************!*\
  !*** ./src/js/platform/game_analytics.js ***!
  \*******************************************/
/*! exports provided: GameAnalyticsInterface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameAnalyticsInterface", function() { return GameAnalyticsInterface; });


class GameAnalyticsInterface {
    constructor(app) {
        /** @type {Application} */
        this.app = app;
    }

    /**
     * Initializes the analytics
     * @returns {Promise<void>}
     */
    initialize() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return Promise.reject();
    }

    /**
     * Handles a new game which was started
     */
    handleGameStarted() {}

    /**
     * @param {ShapeDefinition} definition
     */
    handleShapeDelivered(definition) {}

    /**
     * Handles the given level completed
     * @param {number} level
     */
    handleLevelCompleted(level) {}

    /**
     * Handles the given upgrade completed
     * @param {string} id
     * @param {number} level
     */
    handleUpgradeUnlocked(id, level) {}
}


/***/ }),

/***/ "./src/js/platform/sound.js":
/*!**********************************!*\
  !*** ./src/js/platform/sound.js ***!
  \**********************************/
/*! exports provided: SOUNDS, MUSIC, SoundInstanceInterface, MusicInstanceInterface, SoundInterface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SOUNDS", function() { return SOUNDS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MUSIC", function() { return MUSIC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SoundInstanceInterface", function() { return SoundInstanceInterface; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MusicInstanceInterface", function() { return MusicInstanceInterface; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SoundInterface", function() { return SoundInterface; });
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");






const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_1__["createLogger"])("sound");

const SOUNDS = {
    // Menu and such
    uiClick: "ui_click",
    uiError: "ui_error",
    dialogError: "dialog_error",
    dialogOk: "dialog_ok",
    swishHide: "ui_swish_hide",
    swishShow: "ui_swish_show",
    badgeNotification: "badge_notification",

    levelComplete: "level_complete",

    placeBuilding: "place_building",
    placeBelt: "place_belt",
};

const MUSIC = {
    theme: "theme",
    menu: "menu",
};

class SoundInstanceInterface {
    constructor(key, url) {
        this.key = key;
        this.url = url;
    }

    /** @returns {Promise<void>} */
    load() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return Promise.resolve();
    }

    play(volume) {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }

    deinitialize() {}
}

class MusicInstanceInterface {
    constructor(key, url) {
        this.key = key;
        this.url = url;
    }

    stop() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }

    play() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }

    /** @returns {Promise<void>} */
    load() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return Promise.resolve();
    }

    /** @returns {boolean} */
    isPlaying() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return false;
    }

    deinitialize() {}
}

class SoundInterface {
    constructor(app, soundClass, musicClass) {
        /** @type {Application} */
        this.app = app;

        this.soundClass = soundClass;
        this.musicClass = musicClass;

        /** @type {Object<string, SoundInstanceInterface>} */
        this.sounds = Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__["newEmptyMap"])();

        /** @type {Object<string, MusicInstanceInterface>} */
        this.music = Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__["newEmptyMap"])();

        /** @type {MusicInstanceInterface} */
        this.currentMusic = null;

        this.pageIsVisible = true;

        this.musicMuted = false;
        this.soundsMuted = false;
    }

    /**
     * Initializes the sound
     * @returns {Promise<any>}
     */
    initialize() {
        for (const soundKey in SOUNDS) {
            const soundPath = SOUNDS[soundKey];
            const sound = new this.soundClass(soundKey, soundPath);
            this.sounds[soundPath] = sound;
        }

        for (const musicKey in MUSIC) {
            const musicPath = MUSIC[musicKey];
            const music = new this.musicClass(musicKey, musicPath);
            this.music[musicPath] = music;
        }

        this.musicMuted = this.app.settings.getAllSettings().musicMuted;
        this.soundsMuted = this.app.settings.getAllSettings().soundsMuted;

        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].debug.disableMusic) {
            this.musicMuted = true;
        }

        return Promise.resolve();
    }

    /**
     * Pre-Loads the given sounds
     * @param {string} key
     * @returns {Promise<void>}
     */
    loadSound(key) {
        if (this.sounds[key]) {
            return this.sounds[key].load();
        } else if (this.music[key]) {
            return this.music[key].load();
        } else {
            logger.error("Sound/Music by key not found:", key);
            return Promise.resolve();
        }
    }

    /** Deinits the sound
     * @returns {Promise<void>}
     */
    deinitialize() {
        const promises = [];
        for (const key in this.sounds) {
            promises.push(this.sounds[key].deinitialize());
        }
        for (const key in this.music) {
            promises.push(this.music[key].deinitialize());
        }
        // @ts-ignore
        return Promise.all(...promises);
    }

    /**
     * Returns if the music is muted
     * @returns {boolean}
     */
    getMusicMuted() {
        return this.musicMuted;
    }

    /**
     * Returns if sounds are muted
     * @returns {boolean}
     */
    getSoundsMuted() {
        return this.soundsMuted;
    }

    /**
     * Sets if the music is muted
     * @param {boolean} muted
     */
    setMusicMuted(muted) {
        this.musicMuted = muted;
        if (this.musicMuted) {
            if (this.currentMusic) {
                this.currentMusic.stop();
            }
        } else {
            if (this.currentMusic) {
                this.currentMusic.play();
            }
        }
    }

    /**
     * Sets if the sounds are muted
     * @param {boolean} muted
     */
    setSoundsMuted(muted) {
        this.soundsMuted = muted;
    }

    /**
     * Focus change handler, called by the pap
     * @param {boolean} pageIsVisible
     */
    onPageRenderableStateChanged(pageIsVisible) {
        this.pageIsVisible = pageIsVisible;
        if (this.currentMusic) {
            if (pageIsVisible) {
                if (!this.currentMusic.isPlaying() && !this.musicMuted) {
                    this.currentMusic.play();
                }
            } else {
                this.currentMusic.stop();
            }
        }
    }

    /**
     * @param {string} key
     */
    playUiSound(key) {
        if (this.soundsMuted) {
            return;
        }
        if (!this.sounds[key]) {
            logger.warn("Sound", key, "not found, probably not loaded yet");
            return;
        }
        this.sounds[key].play(1.0);
    }

    /**
     *
     * @param {string} key
     * @param {Vector} worldPosition
     * @param {GameRoot} root
     */
    play3DSound(key, worldPosition, root) {
        if (!this.sounds[key]) {
            logger.warn("Music", key, "not found, probably not loaded yet");
            return;
        }
        if (!this.pageIsVisible || this.soundsMuted) {
            return;
        }

        // hack, but works
        if (root.time.getIsPaused()) {
            return;
        }

        let volume = 1.0;
        if (!root.camera.isWorldPointOnScreen(worldPosition)) {
            volume = 0.2;
        }
        volume *= Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__["clamp"])(root.camera.zoomLevel / 3);
        this.sounds[key].play(Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__["clamp"])(volume));
    }

    /**
     * @param {string} key
     */
    playThemeMusic(key) {
        const music = this.music[key];
        if (key !== null && !music) {
            logger.warn("Music", key, "not found");
        }
        if (this.currentMusic !== music) {
            if (this.currentMusic) {
                logger.log("Stopping", this.currentMusic.key);
                this.currentMusic.stop();
            }
            this.currentMusic = music;
            if (music && this.pageIsVisible && !this.musicMuted) {
                logger.log("Starting", this.currentMusic.key);
                music.play();
            }
        }
    }
}


/***/ }),

/***/ "./src/js/platform/storage.js":
/*!************************************!*\
  !*** ./src/js/platform/storage.js ***!
  \************************************/
/*! exports provided: FILE_NOT_FOUND, StorageInterface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILE_NOT_FOUND", function() { return FILE_NOT_FOUND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StorageInterface", function() { return StorageInterface; });


const FILE_NOT_FOUND = "file_not_found";

class StorageInterface {
    constructor(app) {
        /** @type {Application} */
        this.app = app;
    }

    /**
     * Initializes the storage
     * @returns {Promise<void>}
     */
    initialize() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return Promise.reject();
    }

    /**
     * Writes a string to a file asynchronously
     * @param {string} filename
     * @param {string} contents
     * @returns {Promise<void>}
     */
    writeFileAsync(filename, contents) {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return Promise.reject();
    }

    /**
     * Tries to write a file synchronously, used in unload handler
     * @param {string} filename
     * @param {string} contents
     */
    writeFileSyncIfSupported(filename, contents) {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return false;
    }

    /**
     * Reads a string asynchronously. Returns Promise<FILE_NOT_FOUND> if file was not found.
     * @param {string} filename
     * @returns {Promise<string>}
     */
    readFileAsync(filename) {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return Promise.reject();
    }

    /**
     * Tries to delete a file
     * @param {string} filename
     * @returns {Promise<void>}
     */
    deleteFileAsync(filename) {
        // Default implementation does not allow deleting files
        return Promise.reject();
    }
}


/***/ }),

/***/ "./src/js/platform/wrapper.js":
/*!************************************!*\
  !*** ./src/js/platform/wrapper.js ***!
  \************************************/
/*! exports provided: PlatformWrapperInterface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlatformWrapperInterface", function() { return PlatformWrapperInterface; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");




class PlatformWrapperInterface {
    constructor(app) {
        /** @type {Application} */
        this.app = app;
    }

    /** @returns {string} */
    getId() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return "unknown-platform";
    }

    /**
     * Returns the UI scale, called on every resize
     * @returns {number} */
    getUiScale() {
        return 1;
    }

    /** @returns {boolean} */
    getSupportsRestart() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return false;
    }

    /**
     * Whether the user has unlimited savegames
     */
    getHasUnlimitedSavegames() {
        return true;
    }

    getShowDemoBadges() {
        return false;
    }

    /**
     * Returns the strength of touch pans with the mouse
     */
    getTouchPanStrength() {
        return 1;
    }

    /** @returns {Promise<void>} */
    initialize() {
        document.documentElement.classList.add("p-" + this.getId());
        return Promise.resolve();
    }

    /**
     * Should initialize the apps ad provider in case supported
     *  @returns {Promise<void>}
     */
    initializeAdProvider() {
        return Promise.resolve();
    }

    /**
     * Should return the minimum supported zoom level
     * @returns {number}
     */
    getMinimumZoom() {
        return 0.2 * this.getScreenScale();
    }

    /**
     * Should return the maximum supported zoom level
     * @returns {number}
     */
    getMaximumZoom() {
        return 4 * this.getScreenScale();
    }

    getScreenScale() {
        return Math.min(window.innerWidth, window.innerHeight) / 1024.0;
    }

    /**
     * Should return if this platform supports ads at all
     */
    getSupportsAds() {
        return false;
    }

    /**
     * Attempt to open an external url
     * @param {string} url
     * @param {boolean=} force Whether to always open the url even if not allowed
     */
    openExternalLink(url, force = false) {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }

    /**
     * Attempt to restart the app
     */
    performRestart() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }

    /**
     * Returns whether this platform supports a toggleable fullscreen
     */
    getSupportsFullscreen() {
        return false;
    }

    /**
     * Should set the apps fullscreen state to the desired state
     * @param {boolean} flag
     */
    setFullscreen(flag) {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }

    /**
     * Returns whether this platform supports quitting the app
     */
    getSupportsAppExit() {
        return false;
    }

    /**
     * Attempts to quit the app
     */
    exitApp() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }

    /**
     * Whether this platform supports a keyboard
     */
    getSupportsKeyboard() {
        return !_core_config__WEBPACK_IMPORTED_MODULE_0__["IS_MOBILE"];
    }
}


/***/ }),

/***/ "./src/js/profile/application_settings.js":
/*!************************************************!*\
  !*** ./src/js/profile/application_settings.js ***!
  \************************************************/
/*! exports provided: categoryDebug, uiScales, scrollWheelSensitivities, allApplicationSettings, allDebugSettings, getApplicationSettingById, ApplicationSettings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "categoryDebug", function() { return categoryDebug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uiScales", function() { return uiScales; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scrollWheelSensitivities", function() { return scrollWheelSensitivities; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allApplicationSettings", function() { return allApplicationSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allDebugSettings", function() { return allDebugSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getApplicationSettingById", function() { return getApplicationSettingById; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ApplicationSettings", function() { return ApplicationSettings; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_read_write_proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/read_write_proxy */ "./src/js/core/read_write_proxy.js");
/* harmony import */ var _setting_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./setting_types */ "./src/js/profile/setting_types.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_explained_result__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/explained_result */ "./src/js/core/explained_result.js");
/* harmony import */ var _game_theme__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../game/theme */ "./src/js/game/theme.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../translations */ "./src/js/translations.js");











const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_3__["createLogger"])("application_settings");

const categoryGame = "game";
const categoryApp = "app";
const categoryDebug = "debug";

const uiScales = [
    {
        id: "super_small",
        size: 0.6,
    },
    {
        id: "small",
        size: 0.8,
    },
    {
        id: "regular",
        size: 1,
    },
    {
        id: "large",
        size: 1.2,
    },
    {
        id: "huge",
        size: 1.4,
    },
];

const scrollWheelSensitivities = [
    {
        id: "super_slow",
        scale: 0.25,
    },
    {
        id: "slow",
        scale: 0.5,
    },
    {
        id: "regular",
        scale: 1,
    },
    {
        id: "fast",
        scale: 2,
    },
    {
        id: "super_fast",
        scale: 4,
    },
];

/** @type {Array<BaseSetting>} */
const allApplicationSettings = [
    new _setting_types__WEBPACK_IMPORTED_MODULE_2__["EnumSetting"]("uiScale", {
        options: uiScales.sort((a, b) => a.size - b.size),
        valueGetter: scale => scale.id,
        textGetter: scale => _translations__WEBPACK_IMPORTED_MODULE_6__["T"].settings.labels.uiScale.scales[scale.id],
        category: categoryApp,
        restartRequired: false,
        changeCb:
            /**
             * @param {Application} app
             */
            (app, id) => app.updateAfterUiScaleChanged(),
    }),

    new _setting_types__WEBPACK_IMPORTED_MODULE_2__["BoolSetting"](
        "fullscreen",
        categoryApp,
        /**
         * @param {Application} app
         */
        (app, value) => {
            if (app.platformWrapper.getSupportsFullscreen()) {
                app.platformWrapper.setFullscreen(value);
            }
        },
        !_core_config__WEBPACK_IMPORTED_MODULE_0__["IS_DEMO"]
    ),

    new _setting_types__WEBPACK_IMPORTED_MODULE_2__["BoolSetting"](
        "soundsMuted",
        categoryApp,
        /**
         * @param {Application} app
         */
        (app, value) => app.sound.setSoundsMuted(value)
    ),
    new _setting_types__WEBPACK_IMPORTED_MODULE_2__["BoolSetting"](
        "musicMuted",
        categoryApp,
        /**
         * @param {Application} app
         */
        (app, value) => app.sound.setMusicMuted(value)
    ),
    new _setting_types__WEBPACK_IMPORTED_MODULE_2__["EnumSetting"]("scrollWheelSensitivity", {
        options: scrollWheelSensitivities.sort((a, b) => a.scale - b.scale),
        valueGetter: scale => scale.id,
        textGetter: scale => _translations__WEBPACK_IMPORTED_MODULE_6__["T"].settings.labels.scrollWheelSensitivity.sensitivity[scale.id],
        category: categoryApp,
        restartRequired: false,
        changeCb:
            /**
             * @param {Application} app
             */
            (app, id) => app.updateAfterUiScaleChanged(),
    }),

    // GAME
    new _setting_types__WEBPACK_IMPORTED_MODULE_2__["EnumSetting"]("theme", {
        options: Object.keys(_game_theme__WEBPACK_IMPORTED_MODULE_5__["THEMES"]),
        valueGetter: theme => theme,
        textGetter: theme => theme.substr(0, 1).toUpperCase() + theme.substr(1),
        category: categoryGame,
        restartRequired: false,
        changeCb:
            /**
             * @param {Application} app
             */
            (app, id) => {
                Object(_game_theme__WEBPACK_IMPORTED_MODULE_5__["applyGameTheme"])(id);
                document.body.setAttribute("data-theme", id);
            },
        enabled: !_core_config__WEBPACK_IMPORTED_MODULE_0__["IS_DEMO"],
    }),

    new _setting_types__WEBPACK_IMPORTED_MODULE_2__["EnumSetting"]("refreshRate", {
        options: ["29", "30", "31", "59", "60", "61", "100", "144", "165"],
        valueGetter: rate => rate,
        textGetter: rate => rate + " Hz",
        category: categoryGame,
        restartRequired: false,
        changeCb: (app, id) => {},
        enabled: !_core_config__WEBPACK_IMPORTED_MODULE_0__["IS_DEMO"],
    }),

    new _setting_types__WEBPACK_IMPORTED_MODULE_2__["BoolSetting"]("alwaysMultiplace", categoryGame, (app, value) => {}),
    new _setting_types__WEBPACK_IMPORTED_MODULE_2__["BoolSetting"]("offerHints", categoryGame, (app, value) => {}),
];

/** @type {Array<BaseSetting>} */
const allDebugSettings = [];
for (const k in _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug) {
    allDebugSettings.push(
        new _setting_types__WEBPACK_IMPORTED_MODULE_2__["BoolSetting"](
            "debug_" + k,
            categoryDebug,
            (app, value) => {
                if (_core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug.enableDebugSettings) _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug[k] = value;
            },
            _core_config__WEBPACK_IMPORTED_MODULE_0__["IS_DEBUG"]
        )
    );
}
allApplicationSettings.push(...allDebugSettings);

function getApplicationSettingById(id) {
    return allApplicationSettings.find(setting => setting.id === id);
}

class SettingsStorage {
    constructor() {
        this.uiScale = "regular";
        this.fullscreen = false;

        this.soundsMuted = false;
        this.musicMuted = false;
        this.theme = "light";
        this.refreshRate = "60";
        this.scrollWheelSensitivity = "regular";

        this.alwaysMultiplace = false;
        this.offerHints = true;

        /**
         * @type {Object.<string, number>}
         */
        this.keybindingOverrides = {};
    }
}

class ApplicationSettings extends _core_read_write_proxy__WEBPACK_IMPORTED_MODULE_1__["ReadWriteProxy"] {
    constructor(app) {
        super(app, "app_settings.bin");
    }

    initialize() {
        // Read and directly write latest data back
        return this.readAsync()
            .then(() => {
                // Apply default setting callbacks
                const settings = this.getAllSettings();
                for (let i = 0; i < allApplicationSettings.length; ++i) {
                    const handle = allApplicationSettings[i];
                    handle.apply(this.app, settings[handle.id]);
                }
            })

            .then(() => this.writeAsync());
    }

    save() {
        return this.writeAsync();
    }

    // Getters

    /**
     * @returns {SettingsStorage}
     */
    getAllSettings() {
        return this.getCurrentData().settings;
    }

    /**
     * @param {string} key
     */
    getSetting(key) {
        window.assert(
            key.startsWith("debug_") || this.getAllSettings().hasOwnProperty(key),
            "Setting not known: " + key
        );
        return this.getAllSettings()[key];
    }

    getInterfaceScaleId() {
        if (!this.currentData) {
            // Not initialized yet
            return "regular";
        }
        return this.getAllSettings().uiScale;
    }

    getDesiredFps() {
        return parseInt(this.getAllSettings().refreshRate);
    }

    getInterfaceScaleValue() {
        const id = this.getInterfaceScaleId();
        for (let i = 0; i < uiScales.length; ++i) {
            if (uiScales[i].id === id) {
                return uiScales[i].size;
            }
        }
        logger.error("Unknown ui scale id:", id);
        return 1;
    }

    getScrollWheelSensitivity() {
        const id = this.getAllSettings().scrollWheelSensitivity;
        for (let i = 0; i < scrollWheelSensitivities.length; ++i) {
            if (scrollWheelSensitivities[i].id === id) {
                return scrollWheelSensitivities[i].scale;
            }
        }
        logger.error("Unknown scroll wheel sensitivity id:", id);
        return 1;
    }

    getIsFullScreen() {
        return this.getAllSettings().fullscreen;
    }

    getKeybindingOverrides() {
        return this.getAllSettings().keybindingOverrides;
    }

    // Setters

    /**
     * @param {string} key
     * @param {string|boolean} value
     */
    updateSetting(key, value) {
        for (let i = 0; i < allApplicationSettings.length; ++i) {
            const setting = allApplicationSettings[i];
            if (setting.id === key) {
                if (!setting.validate(value)) {
                    window.assert(false, "Bad setting value: " + key);
                }
                this.getAllSettings()[key] = value;
                if (setting.changeCb) {
                    setting.changeCb(this.app, value);
                }
                return this.writeAsync();
            }
        }
        window.assert(false, "Unknown setting: " + key);
    }

    /**
     * Sets a new keybinding override
     * @param {string} keybindingId
     * @param {number} keyCode
     */
    updateKeybindingOverride(keybindingId, keyCode) {
        window.assert(Number.isInteger(keyCode), "Not a valid key code: " + keyCode);
        this.getAllSettings().keybindingOverrides[keybindingId] = keyCode;
        return this.writeAsync();
    }

    /**
     * Resets a given keybinding override
     * @param {string} id
     */
    resetKeybindingOverride(id) {
        delete this.getAllSettings().keybindingOverrides[id];
        return this.writeAsync();
    }
    /**
     * Resets all keybinding overrides
     */
    resetKeybindingOverrides() {
        this.getAllSettings().keybindingOverrides = {};
        return this.writeAsync();
    }

    // RW Proxy impl
    verify(data) {
        if (!data.settings) {
            return _core_explained_result__WEBPACK_IMPORTED_MODULE_4__["ExplainedResult"].bad("missing key 'settings'");
        }
        if (typeof data.settings !== "object") {
            return _core_explained_result__WEBPACK_IMPORTED_MODULE_4__["ExplainedResult"].bad("Bad settings object");
        }

        const settings = data.settings;
        for (let i = 0; i < allApplicationSettings.length; ++i) {
            const setting = allApplicationSettings[i];
            if (setting.id.startsWith("debug_")) continue;
            const storedValue = settings[setting.id];
            if (!setting.validate(storedValue)) {
                return _core_explained_result__WEBPACK_IMPORTED_MODULE_4__["ExplainedResult"].bad("Bad setting value for " + setting.id + ": " + storedValue);
            }
        }
        return _core_explained_result__WEBPACK_IMPORTED_MODULE_4__["ExplainedResult"].good();
    }

    getDefaultData() {
        return {
            version: this.getCurrentVersion(),
            settings: new SettingsStorage(),
        };
    }

    getCurrentVersion() {
        return 8;
    }

    /** @param {{settings: SettingsStorage, version: number}} data */
    migrate(data) {
        // Simply reset before
        if (data.version < 5) {
            data.settings = new SettingsStorage();
            data.version = this.getCurrentVersion();
            return _core_explained_result__WEBPACK_IMPORTED_MODULE_4__["ExplainedResult"].good();
        }

        if (data.version < 6) {
            data.settings.alwaysMultiplace = false;
            data.version = 6;
        }

        if (data.version < 7) {
            data.settings.offerHints = true;
            data.version = 7;
        }

        if (data.version < 8) {
            data.settings.scrollWheelSensitivity = "regular";
            data.version = 8;
        }

        return _core_explained_result__WEBPACK_IMPORTED_MODULE_4__["ExplainedResult"].good();
    }
}


/***/ }),

/***/ "./src/js/profile/setting_types.js":
/*!*****************************************!*\
  !*** ./src/js/profile/setting_types.js ***!
  \*****************************************/
/*! exports provided: BaseSetting, EnumSetting, BoolSetting */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseSetting", function() { return BaseSetting; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnumSetting", function() { return EnumSetting; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoolSetting", function() { return BoolSetting; });
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../translations */ "./src/js/translations.js");





const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_0__["createLogger"])("setting_types");

const standaloneOnlySettingHtml = `<span class="standaloneOnlyHint">${_translations__WEBPACK_IMPORTED_MODULE_1__["T"].demo.settingNotAvailable}</span>`;

class BaseSetting {
    /**
     *
     * @param {string} id
     * @param {string} categoryId
     * @param {function(Application, any):void} changeCb
     * @param {boolean} enabled
     */
    constructor(id, categoryId, changeCb, enabled) {
        this.id = id;
        this.categoryId = categoryId;
        this.changeCb = changeCb;
        this.enabled = enabled;

        /** @type {Application} */
        this.app = null;

        this.element = null;
        this.dialogs = null;
    }

    /**
     * @param {Application} app
     * @param {any} value
     */
    apply(app, value) {
        if (this.changeCb) {
            this.changeCb(app, value);
        }
    }

    /**
     * @param {Application} app
     * @param {Element} element
     * @param {any} dialogs
     */
    bind(app, element, dialogs) {
        this.app = app;
        this.element = element;
        this.dialogs = dialogs;
    }

    getHtml() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return "";
    }

    syncValueToElement() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }

    modify() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }

    showRestartRequiredDialog() {
        const { restart } = this.dialogs.showInfo(
            _translations__WEBPACK_IMPORTED_MODULE_1__["T"].dialogs.restartRequired.title,
            _translations__WEBPACK_IMPORTED_MODULE_1__["T"].dialogs.restartRequired.text,
            this.app.platformWrapper.getSupportsRestart() ? ["later:grey", "restart:misc"] : ["ok:good"]
        );
        if (restart) {
            restart.add(() => this.app.platformWrapper.performRestart());
        }
    }

    /**
     * @param {any} value
     * @returns {boolean}
     */
    validate(value) {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return false;
    }
}

class EnumSetting extends BaseSetting {
    constructor(
        id,
        {
            options,
            valueGetter,
            textGetter,
            descGetter = null,
            category,
            restartRequired = true,
            iconPrefix = null,
            changeCb = null,
            magicValue = null,
            enabled = true,
        }
    ) {
        super(id, category, changeCb, enabled);

        this.options = options;
        this.valueGetter = valueGetter;
        this.textGetter = textGetter;
        this.descGetter = descGetter || (() => null);
        this.restartRequired = restartRequired;
        this.iconPrefix = iconPrefix;
        this.magicValue = magicValue;
    }

    getHtml() {
        return `
            <div class="setting cardbox ${this.enabled ? "enabled" : "disabled"}">
                ${this.enabled ? "" : standaloneOnlySettingHtml}
                <div class="row">
                    <label>${_translations__WEBPACK_IMPORTED_MODULE_1__["T"].settings.labels[this.id].title}</label>
                    <div class="value enum" data-setting="${this.id}"></div>
                </div>
                <div class="desc">
                    ${_translations__WEBPACK_IMPORTED_MODULE_1__["T"].settings.labels[this.id].description}
                </div>
            </div>`;
    }

    validate(value) {
        if (value === this.magicValue) {
            return true;
        }

        const availableValues = this.options.map(option => this.valueGetter(option));
        if (availableValues.indexOf(value) < 0) {
            logger.error(
                "Value '" + value + "' is not contained in available values:",
                availableValues,
                "of",
                this.id
            );
            return false;
        }
        return true;
    }

    syncValueToElement() {
        const value = this.app.settings.getSetting(this.id);
        let displayText = "???";
        const matchedInstance = this.options.find(data => this.valueGetter(data) === value);
        if (matchedInstance) {
            displayText = this.textGetter(matchedInstance);
        } else {
            logger.warn("Setting value", value, "not found for", this.id, "!");
        }
        this.element.innerText = displayText;
    }

    modify() {
        const { optionSelected } = this.dialogs.showOptionChooser(_translations__WEBPACK_IMPORTED_MODULE_1__["T"].settings.labels[this.id].title, {
            active: this.app.settings.getSetting(this.id),
            options: this.options.map(option => ({
                value: this.valueGetter(option),
                text: this.textGetter(option),
                desc: this.descGetter(option),
                iconPrefix: this.iconPrefix,
            })),
        });
        optionSelected.add(value => {
            if (!this.enabled) {
                return;
            }
            this.app.settings.updateSetting(this.id, value);
            this.syncValueToElement();

            if (this.restartRequired) {
                this.showRestartRequiredDialog();
            }

            if (this.changeCb) {
                this.changeCb(this.app, value);
            }
        }, this);
    }
}

class BoolSetting extends BaseSetting {
    constructor(id, category, changeCb = null, enabled = true) {
        super(id, category, changeCb, enabled);
    }

    getHtml() {
        const label = _translations__WEBPACK_IMPORTED_MODULE_1__["T"].settings.labels[this.id] || {
            title: this.id.replace(/([a-z])([A-Z])/g, (s, a, b) => `${a}_${b}`),
            description: "the consequences are unknown",
        };
        return `
        <div class="setting cardbox ${this.enabled ? "enabled" : "disabled"}">
            ${this.enabled ? "" : standaloneOnlySettingHtml}
                
            <div class="row">
                <label>${label.title}</label>
                <div class="value checkbox checked" data-setting="${this.id}">
                <span class="knob"></span>
                </div>
            </div>
            <div class="desc">
                ${label.description}
            </div>
        </div>`;
    }

    syncValueToElement() {
        const value = this.app.settings.getSetting(this.id);
        this.element.classList.toggle("checked", value);
    }

    modify() {
        if (!this.enabled) {
            return;
        }
        const newValue = !this.app.settings.getSetting(this.id);
        this.app.settings.updateSetting(this.id, newValue);
        this.syncValueToElement();

        if (this.changeCb) {
            this.changeCb(this.app, newValue);
        }
    }

    validate(value) {
        return typeof value === "boolean";
    }
}


/***/ }),

/***/ "./src/js/savegame/savegame.js":
/*!*************************************!*\
  !*** ./src/js/savegame/savegame.js ***!
  \*************************************/
/*! exports provided: Savegame */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Savegame", function() { return Savegame; });
/* harmony import */ var _core_read_write_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/read_write_proxy */ "./src/js/core/read_write_proxy.js");
/* harmony import */ var _core_explained_result__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/explained_result */ "./src/js/core/explained_result.js");
/* harmony import */ var _savegame_serializer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./savegame_serializer */ "./src/js/savegame/savegame_serializer.js");
/* harmony import */ var _savegame_interface__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./savegame_interface */ "./src/js/savegame/savegame_interface.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _schemas_1000__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./schemas/1000 */ "./src/js/savegame/schemas/1000.js");
/* harmony import */ var _savegame_interface_registry__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./savegame_interface_registry */ "./src/js/savegame/savegame_interface_registry.js");
/* harmony import */ var _schemas_1001__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./schemas/1001 */ "./src/js/savegame/schemas/1001.js");
/* harmony import */ var _schemas_1002__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./schemas/1002 */ "./src/js/savegame/schemas/1002.js");













const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_4__["createLogger"])("savegame");

class Savegame extends _core_read_write_proxy__WEBPACK_IMPORTED_MODULE_0__["ReadWriteProxy"] {
    /**
     *
     * @param {Application} app
     * @param {object} param0
     * @param {string} param0.internalId
     * @param {import("./savegame_manager").SavegameMetadata} param0.metaDataRef Handle to the meta data
     */
    constructor(app, { internalId, metaDataRef }) {
        super(app, "savegame-" + internalId + ".bin");
        this.internalId = internalId;
        this.metaDataRef = metaDataRef;

        /** @type {import("./savegame_typedefs").SavegameData} */
        this.currentData = this.getDefaultData();

        window.assert(
            _savegame_interface_registry__WEBPACK_IMPORTED_MODULE_7__["savegameInterfaces"][Savegame.getCurrentVersion()],
            "Savegame interface not defined: " + Savegame.getCurrentVersion()
        );
    }

    //////// RW Proxy Impl //////////

    /**
     * @returns {number}
     */
    static getCurrentVersion() {
        return 1002;
    }

    /**
     * @returns {typeof BaseSavegameInterface}
     */
    static getReaderClass() {
        return _savegame_interface_registry__WEBPACK_IMPORTED_MODULE_7__["savegameInterfaces"][Savegame.getCurrentVersion()];
    }

    /**
     * @returns {number}
     */
    getCurrentVersion() {
        return /** @type {typeof Savegame} */ (this.constructor).getCurrentVersion();
    }

    /**
     * Returns the savegames default data
     * @returns {import("./savegame_typedefs").SavegameData}
     */
    getDefaultData() {
        return {
            version: this.getCurrentVersion(),
            dump: null,
            stats: {},
            lastUpdate: Date.now(),
        };
    }

    /**
     * Migrates the savegames data
     * @param {import("./savegame_typedefs").SavegameData} data
     */
    migrate(data) {
        if (data.version < 1000) {
            return _core_explained_result__WEBPACK_IMPORTED_MODULE_1__["ExplainedResult"].bad("Can not migrate savegame, too old");
        }

        if (data.version === 1000) {
            _schemas_1001__WEBPACK_IMPORTED_MODULE_8__["SavegameInterface_V1001"].migrate1000to1001(data);
            data.version = 1001;
        }

        if (data.version === 1001) {
            _schemas_1002__WEBPACK_IMPORTED_MODULE_9__["SavegameInterface_V1002"].migrate1001to1002(data);
            data.version = 1002;
        }

        return _core_explained_result__WEBPACK_IMPORTED_MODULE_1__["ExplainedResult"].good();
    }

    /**
     * Verifies the savegames data
     * @param {import("./savegame_typedefs").SavegameData} data
     */
    verify(data) {
        if (!data.dump) {
            // Well, guess that works
            return _core_explained_result__WEBPACK_IMPORTED_MODULE_1__["ExplainedResult"].good();
        }

        if (!this.getDumpReaderForExternalData(data).validate()) {
            return _core_explained_result__WEBPACK_IMPORTED_MODULE_1__["ExplainedResult"].bad("dump-reader-failed-validation");
        }
        return _core_explained_result__WEBPACK_IMPORTED_MODULE_1__["ExplainedResult"].good();
    }

    //////// Subclasses interface  ////////

    /**
     * Returns if this game can be saved on disc
     * @returns {boolean}
     */
    isSaveable() {
        return true;
    }
    /**
     * Returns the statistics of the savegame
     * @returns {import("./savegame_typedefs").SavegameStats}
     */
    getStatistics() {
        return this.currentData.stats;
    }

    /**
     * Returns the *real* last update of the savegame, not the one of the metadata
     * which could also be the servers one
     */
    getRealLastUpdate() {
        return this.currentData.lastUpdate;
    }

    /**
     * Returns if this game has a serialized game dump
     */
    hasGameDump() {
        return !!this.currentData.dump && this.currentData.dump.entities.length > 0;
    }

    /**
     * Returns the current game dump
     * @returns {import("./savegame_typedefs").SerializedGame}
     */
    getCurrentDump() {
        return this.currentData.dump;
    }

    /**
     * Returns a reader to access the data
     * @returns {BaseSavegameInterface}
     */
    getDumpReader() {
        if (!this.currentData.dump) {
            logger.warn("Getting reader on null-savegame dump");
        }

        const cls = /** @type {typeof Savegame} */ (this.constructor).getReaderClass();
        return new cls(this.currentData);
    }

    /**
     * Returns a reader to access external data
     * @returns {BaseSavegameInterface}
     */
    getDumpReaderForExternalData(data) {
        window.assert(data.version, "External data contains no version");
        return Object(_savegame_interface_registry__WEBPACK_IMPORTED_MODULE_7__["getSavegameInterface"])(data);
    }

    ///////// Public Interface ///////////

    /**
     * Updates the last update field so we can send the savegame to the server,
     * WITHOUT Saving!
     */
    setLastUpdate(time) {
        this.currentData.lastUpdate = time;
    }

    /**
     *
     * @param {GameRoot} root
     */
    updateData(root) {
        // Construct a new serializer
        const serializer = new _savegame_serializer__WEBPACK_IMPORTED_MODULE_2__["SavegameSerializer"]();

        // let timer = performanceNow();
        const dump = serializer.generateDumpFromGameRoot(root);
        if (!dump) {
            return false;
        }

        const shadowData = Object.assign({}, this.currentData);
        shadowData.dump = dump;
        shadowData.lastUpdate = new Date().getTime();
        shadowData.version = this.getCurrentVersion();

        const reader = this.getDumpReaderForExternalData(shadowData);

        // Validate (not in prod though)
        if (true) {
            const validationResult = reader.validate();
            if (!validationResult) {
                return false;
            }
        }

        // Save data
        this.currentData = shadowData;
    }

    /**
     * Writes the savegame as well as its metadata
     */
    writeSavegameAndMetadata() {
        return this.writeAsync().then(() => this.saveMetadata());
    }

    /**
     * Updates the savegames metadata
     */
    saveMetadata() {
        this.metaDataRef.lastUpdate = new Date().getTime();
        this.metaDataRef.version = this.getCurrentVersion();
        if (!this.hasGameDump()) {
            this.metaDataRef.level = 0;
        } else {
            this.metaDataRef.level = this.currentData.dump.hubGoals.level;
        }

        return this.app.savegameMgr.writeAsync();
    }

    /**
     * @see ReadWriteProxy.writeAsync
     * @returns {Promise<any>}
     */
    writeAsync() {
        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_5__["globalConfig"].debug.disableSavegameWrite) {
            return Promise.resolve();
        }
        return super.writeAsync();
    }
}


/***/ }),

/***/ "./src/js/savegame/savegame_compressor.js":
/*!************************************************!*\
  !*** ./src/js/savegame/savegame_compressor.js ***!
  \************************************************/
/*! exports provided: compressObject, decompressObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compressObject", function() { return compressObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decompressObject", function() { return decompressObject; });
const charmap =
    "!#%&'()*+,-./:;<=>?@[]^_`{|}~¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿABCDEFGHIJKLMNOPQRSTUVWXYZ";

let compressionCache = {};
let decompressionCache = {};

/**
 * Compresses an integer into a tight string representation
 * @param {number} i
 * @returns {string}
 */
function compressInt(i) {
    // Zero value breaks
    i += 1;

    if (compressionCache[i]) {
        return compressionCache[i];
    }
    let result = "";
    do {
        result += charmap[i % charmap.length];
        i = Math.floor(i / charmap.length);
    } while (i > 0);
    return (compressionCache[i] = result);
}

/**
 * Decompresses an integer from its tight string representation
 * @param {string} s
 * @returns {number}
 */
function decompressInt(s) {
    if (decompressionCache[s]) {
        return decompressionCache[s];
    }
    s = "" + s;
    let result = 0;
    for (let i = s.length - 1; i >= 0; --i) {
        result = result * charmap.length + charmap.indexOf(s.charAt(i));
    }
    // Fixes zero value break fix from above
    result -= 1;
    return (decompressionCache[s] = result);
}

// Sanity
for (let i = 0; i < 10000; ++i) {
    if (decompressInt(compressInt(i)) !== i) {
        throw new Error(
            "Bad compression for: " +
                i +
                " compressed: " +
                compressInt(i) +
                " decompressed: " +
                decompressInt(compressInt(i))
        );
    }
}

function compressObjectInternal(obj, keys = [], values = []) {
    if (Array.isArray(obj)) {
        let result = [];
        for (let i = 0; i < obj.length; ++i) {
            result.push(compressObjectInternal(obj[i], keys, values));
        }
        return result;
    } else if (typeof obj === "object" && obj !== null) {
        let result = {};
        for (const key in obj) {
            let index = keys.indexOf(key);
            if (index < 0) {
                keys.push(key);
                index = keys.length - 1;
            }
            const value = obj[key];
            result[compressInt(index)] = compressObjectInternal(value, keys, values);
        }
        return result;
    } else if (typeof obj === "string") {
        let index = values.indexOf(obj);
        if (index < 0) {
            values.push(obj);
            index = values.length - 1;
        }
        return compressInt(index);
    }
    return obj;
}

function compressObject(obj) {
    if (true) {
        return obj;
    }
    const keys = [];
    const values = [];
    const data = compressObjectInternal(obj, keys, values);
    return {
        keys,
        values,
        data,
    };
}

function decompressObjectInternal(obj, keys = [], values = []) {
    if (Array.isArray(obj)) {
        let result = [];
        for (let i = 0; i < obj.length; ++i) {
            result.push(decompressObjectInternal(obj[i], keys, values));
        }
        return result;
    } else if (typeof obj === "object" && obj !== null) {
        let result = {};
        for (const key in obj) {
            const realIndex = decompressInt(key);
            const value = obj[key];
            result[keys[realIndex]] = decompressObjectInternal(value, keys, values);
        }
        return result;
    } else if (typeof obj === "string") {
        const realIndex = decompressInt(obj);
        return values[realIndex];
    }
    return obj;
}

function decompressObject(obj) {
    if (obj.keys && obj.values && obj.data) {
        const keys = obj.keys;
        const values = obj.values;
        const result = decompressObjectInternal(obj.data, keys, values);
        return result;
    }
    return obj;
}


/***/ }),

/***/ "./src/js/savegame/savegame_interface.js":
/*!***********************************************!*\
  !*** ./src/js/savegame/savegame_interface.js ***!
  \***********************************************/
/*! exports provided: BaseSavegameInterface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseSavegameInterface", function() { return BaseSavegameInterface; });
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");


const Ajv = __webpack_require__(/*! ajv */ "./node_modules/ajv/lib/ajv.js");
const ajv = new Ajv({
    allErrors: false,
    uniqueItems: false,
    unicode: false,
    nullable: false,
});

const validators = {};

const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_0__["createLogger"])("savegame_interface");

class BaseSavegameInterface {
    /**
     * Returns the interfaces version
     */
    getVersion() {
        throw new Error("Implement get version");
    }

    /**
     * Returns the uncached json schema
     * @returns {object}
     */
    getSchemaUncached() {
        throw new Error("Implement get schema");
    }

    getValidator() {
        const version = this.getVersion();
        if (validators[version]) {
            return validators[version];
        }
        logger.log("Compiling schema for savegame version", version);
        const schema = this.getSchemaUncached();
        try {
            validators[version] = ajv.compile(schema);
        } catch (ex) {
            logger.error("SCHEMA FOR", this.getVersion(), "IS INVALID!");
            logger.error(ex);
            throw new Error("Invalid schema for version " + version);
        }
        return validators[version];
    }

    /**
     * Constructs an new interface for the given savegame
     * @param {any} data
     */
    constructor(data) {
        this.data = data;
    }

    /**
     * Validates the data
     * @returns {boolean}
     */
    validate() {
        const validator = this.getValidator();

        if (!validator(this.data)) {
            logger.error(
                "Savegame failed validation! ErrorText:",
                ajv.errorsText(validator.errors),
                "RawErrors:",
                validator.errors
            );
            return false;
        }

        return true;
    }

    ///// INTERFACE (Override when the schema changes) /////

    /**
     * Returns the time of last update
     * @returns {number}
     */
    readLastUpdate() {
        return this.data.lastUpdate;
    }

    /**
     * Returns the ingame time in seconds
     * @returns {number}
     */
    readIngameTimeSeconds() {
        return this.data.dump.time.timeSeconds;
    }

    /**


    //////// ANTICHEAT ///////

    /**
     * Detects cheats in the savegame - returns false if the game looks cheated
     */
    performAnticheatCheck() {
        // TODO

        return true;
    }
}


/***/ }),

/***/ "./src/js/savegame/savegame_interface_registry.js":
/*!********************************************************!*\
  !*** ./src/js/savegame/savegame_interface_registry.js ***!
  \********************************************************/
/*! exports provided: savegameInterfaces, getSavegameInterface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "savegameInterfaces", function() { return savegameInterfaces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSavegameInterface", function() { return getSavegameInterface; });
/* harmony import */ var _savegame_interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./savegame_interface */ "./src/js/savegame/savegame_interface.js");
/* harmony import */ var _schemas_1000__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schemas/1000 */ "./src/js/savegame/schemas/1000.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _schemas_1001__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./schemas/1001 */ "./src/js/savegame/schemas/1001.js");
/* harmony import */ var _schemas_1002__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./schemas/1002 */ "./src/js/savegame/schemas/1002.js");






/** @type {Object.<number, typeof BaseSavegameInterface>} */
const savegameInterfaces = {
    1000: _schemas_1000__WEBPACK_IMPORTED_MODULE_1__["SavegameInterface_V1000"],
    1001: _schemas_1001__WEBPACK_IMPORTED_MODULE_3__["SavegameInterface_V1001"],
    1002: _schemas_1002__WEBPACK_IMPORTED_MODULE_4__["SavegameInterface_V1002"],
};

const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_2__["createLogger"])("savegame_interface_registry");

/**
 * Returns if the given savegame has any supported interface
 * @param {any} savegame
 * @returns {BaseSavegameInterface|null}
 */
function getSavegameInterface(savegame) {
    if (!savegame || !savegame.version) {
        logger.warn("Savegame does not contain a valid version (undefined)");
        return null;
    }
    const version = savegame.version;
    if (!Number.isInteger(version)) {
        logger.warn("Savegame does not contain a valid version (non-integer):", version);
        return null;
    }

    const interfaceClass = savegameInterfaces[version];
    if (!interfaceClass) {
        logger.warn("Version", version, "has no implemented interface!");
        return null;
    }

    return new interfaceClass(savegame);
}


/***/ }),

/***/ "./src/js/savegame/savegame_manager.js":
/*!*********************************************!*\
  !*** ./src/js/savegame/savegame_manager.js ***!
  \*********************************************/
/*! exports provided: enumLocalSavegameStatus, SavegameManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumLocalSavegameStatus", function() { return enumLocalSavegameStatus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SavegameManager", function() { return SavegameManager; });
/* harmony import */ var _core_explained_result__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/explained_result */ "./src/js/core/explained_result.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_read_write_proxy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/read_write_proxy */ "./src/js/core/read_write_proxy.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _savegame__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./savegame */ "./src/js/savegame/savegame.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");







const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_1__["createLogger"])("savegame_manager");

const Rusha = __webpack_require__(/*! rusha */ "./node_modules/rusha/dist/rusha.js");

/** @enum {string} */
const enumLocalSavegameStatus = {
    offline: "offline",
    synced: "synced",
};

/**
 * @typedef {{
 *   lastUpdate: number,
 *   version: number,
 *   internalId: string,
 *   level: number
 * }} SavegameMetadata
 *
 * @typedef {{
 *   version: number,
 *   savegames: Array<SavegameMetadata>
 * }} SavegamesData
 */

class SavegameManager extends _core_read_write_proxy__WEBPACK_IMPORTED_MODULE_2__["ReadWriteProxy"] {
    constructor(app) {
        super(app, "savegames.bin");

        /** @type {SavegamesData} */
        this.currentData = this.getDefaultData();
    }

    // RW Proxy Impl
    /**
     * @returns {SavegamesData}
     */
    getDefaultData() {
        return {
            version: this.getCurrentVersion(),
            savegames: [],
        };
    }

    getCurrentVersion() {
        return 1001;
    }

    /**
     * @returns {SavegamesData}
     */
    getCurrentData() {
        return super.getCurrentData();
    }

    verify(data) {
        // TODO / FIXME!!!!
        return _core_explained_result__WEBPACK_IMPORTED_MODULE_0__["ExplainedResult"].good();
    }

    /**
     *
     * @param {SavegamesData} data
     */
    migrate(data) {
        if (data.version < 1001) {
            data.savegames.forEach(savegame => {
                savegame.level = 0;
            });
            data.version = 1001;
        }

        return _core_explained_result__WEBPACK_IMPORTED_MODULE_0__["ExplainedResult"].good();
    }

    // End rw proxy

    /**
     * @returns {Array<SavegameMetadata>}
     */
    getSavegamesMetaData() {
        return this.currentData.savegames;
    }

    /**
     *
     * @param {string} internalId
     * @returns {Savegame}
     */
    getSavegameById(internalId) {
        const metadata = this.getGameMetaDataByInternalId(internalId);
        if (!metadata) {
            return null;
        }
        return new _savegame__WEBPACK_IMPORTED_MODULE_4__["Savegame"](this.app, { internalId, metaDataRef: metadata });
    }

    /**
     * Deletes a savegame
     * @param {SavegameMetadata} game
     */
    deleteSavegame(game) {
        const handle = new _savegame__WEBPACK_IMPORTED_MODULE_4__["Savegame"](this.app, {
            internalId: game.internalId,
            metaDataRef: game,
        });

        return handle.deleteAsync().then(() => {
            for (let i = 0; i < this.currentData.savegames.length; ++i) {
                const potentialGame = this.currentData.savegames[i];
                if (potentialGame.internalId === handle.internalId) {
                    this.currentData.savegames.splice(i, 1);
                    break;
                }
            }

            return this.writeAsync();
        });
    }

    /**
     * Returns a given games metadata by id
     * @param {string} id
     * @returns {SavegameMetadata}
     */
    getGameMetaDataByInternalId(id) {
        for (let i = 0; i < this.currentData.savegames.length; ++i) {
            const data = this.currentData.savegames[i];
            if (data.internalId === id) {
                return data;
            }
        }
        logger.error("Savegame internal id not found:", id);
        return null;
    }

    /**
     * Creates a new savegame
     * @returns {Savegame}
     */
    createNewSavegame() {
        const id = this.generateInternalId();

        const metaData = /** @type {SavegameMetadata} */ ({
            lastUpdate: Date.now(),
            version: _savegame__WEBPACK_IMPORTED_MODULE_4__["Savegame"].getCurrentVersion(),
            internalId: id,
        });

        this.currentData.savegames.push(metaData);
        this.sortSavegames();

        return new _savegame__WEBPACK_IMPORTED_MODULE_4__["Savegame"](this.app, {
            internalId: id,
            metaDataRef: metaData,
        });
    }

    importSavegame(data) {
        const savegame = this.createNewSavegame();
        const migrationResult = savegame.migrate(data);
        if (migrationResult.isBad()) {
            return Promise.reject("Failed to migrate: " + migrationResult.reason);
        }

        savegame.currentData = data;
        const verification = savegame.verify(data);
        if (verification.isBad()) {
            return Promise.reject("Verification failed: " + verification.result);
        }

        return savegame.writeSavegameAndMetadata().then(() => this.sortSavegames());
    }

    /**
     * Sorts all savegames by their creation time descending
     * @returns {Promise<any>}
     */
    sortSavegames() {
        this.currentData.savegames.sort((a, b) => b.lastUpdate - a.lastUpdate);
        let promiseChain = Promise.resolve();
        while (this.currentData.savegames.length > 30) {
            const toRemove = this.currentData.savegames.pop();

            // Try to remove the savegame since its no longer available
            const game = new _savegame__WEBPACK_IMPORTED_MODULE_4__["Savegame"](this.app, {
                internalId: toRemove.internalId,
                metaDataRef: toRemove,
            });
            promiseChain = promiseChain
                .then(() => game.deleteAsync())
                .then(
                    () => {},
                    err => {
                        logger.error(this, "Failed to remove old savegame:", toRemove, ":", err);
                    }
                );
        }

        return promiseChain;
    }

    /**
     * Helper method to generate a new internal savegame id
     */
    generateInternalId() {
        return Rusha.createHash()
            .update(Date.now() + "/" + Math.random())
            .digest("hex");
    }

    // End

    initialize() {
        // First read, then directly write to ensure we have the latest data
        // @ts-ignore
        return this.readAsync().then(() => {
            if ( true && _core_config__WEBPACK_IMPORTED_MODULE_3__["globalConfig"].debug.disableSavegameWrite) {
                return Promise.resolve();
            }
            return this.sortSavegames().then(() => this.writeAsync());
        });
    }
}


/***/ }),

/***/ "./src/js/savegame/savegame_serializer.js":
/*!************************************************!*\
  !*** ./src/js/savegame/savegame_serializer.js ***!
  \************************************************/
/*! exports provided: SavegameSerializer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SavegameSerializer", function() { return SavegameSerializer; });
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _core_explained_result__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/explained_result */ "./src/js/core/explained_result.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/global_registries */ "./src/js/core/global_registries.js");
/* harmony import */ var _serializer_internal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./serializer_internal */ "./src/js/savegame/serializer_internal.js");





// import { BuildingComponent } from "../components/impl/building";



const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_2__["createLogger"])("savegame_serializer");

/**
 * Allows to serialize a savegame
 */
class SavegameSerializer {
    constructor() {
        this.internal = new _serializer_internal__WEBPACK_IMPORTED_MODULE_4__["SerializerInternal"]();
    }

    /**
     * Serializes the game root into a dump
     * @param {GameRoot} root
     * @param {boolean=} sanityChecks Whether to check for validity
     * @returns {object}
     */
    generateDumpFromGameRoot(root, sanityChecks = true) {
        // Finalize particles before saving (Like granting destroy indicator rewards)
        // root.particleMgr.finalizeBeforeSave();
        // root.uiParticleMgr.finalizeBeforeSave();

        // Now store generic savegame payload
        const data = {
            camera: root.camera.serialize(),
            time: root.time.serialize(),
            map: root.map.serialize(),
            entityMgr: root.entityMgr.serialize(),
            hubGoals: root.hubGoals.serialize(),
            pinnedShapes: root.hud.parts.pinnedShapes.serialize(),
            waypoints: root.hud.parts.waypoints.serialize(),
        };

        data.entities = this.internal.serializeEntityArray(root.entityMgr.entities);

        if (true) {
            if (sanityChecks) {
                // Sanity check
                const sanity = this.verifyLogicalErrors(data);
                if (!sanity.result) {
                    logger.error("Created invalid savegame:", sanity.reason, "savegame:", data);
                    return null;
                }
            }
        }
        return data;
    }

    /**
     * Verifies if there are logical errors in the savegame
     * @param {object} savegame
     * @returns {ExplainedResult}
     */
    verifyLogicalErrors(savegame) {
        if (!savegame.entities) {
            return _core_explained_result__WEBPACK_IMPORTED_MODULE_1__["ExplainedResult"].bad("Savegame has no entities");
        }

        const seenUids = [];

        // Check for duplicate UIDS
        for (const entityListId in savegame.entities) {
            for (let i = 0; i < savegame.entities[entityListId].length; ++i) {
                const list = savegame.entities[entityListId][i];
                for (let k = 0; k < list.length; ++k) {
                    const entity = list[k];
                    const uid = entity.uid;
                    if (!Number.isInteger(uid)) {
                        return _core_explained_result__WEBPACK_IMPORTED_MODULE_1__["ExplainedResult"].bad("Entity has invalid uid: " + uid);
                    }
                    if (seenUids.indexOf(uid) >= 0) {
                        return _core_explained_result__WEBPACK_IMPORTED_MODULE_1__["ExplainedResult"].bad("Duplicate uid " + uid);
                    }
                    seenUids.push(uid);

                    // Verify components
                    if (!entity.components) {
                        return _core_explained_result__WEBPACK_IMPORTED_MODULE_1__["ExplainedResult"].bad(
                            "Entity is missing key 'components': " + Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["JSON_stringify"])(entity)
                        );
                    }
                    const components = entity.components;
                    for (const componentId in components) {
                        // Verify component data
                        const componentData = components[componentId];
                        const componentClass = _core_global_registries__WEBPACK_IMPORTED_MODULE_3__["gComponentRegistry"].findById(componentId);

                        // Check component id is known
                        if (!componentClass) {
                            return _core_explained_result__WEBPACK_IMPORTED_MODULE_1__["ExplainedResult"].bad("Unknown component id: " + componentId);
                        }

                        // Check component data is ok
                        const componentVerifyError = /** @type {typeof Component} */ (componentClass).verify(
                            componentData
                        );
                        if (componentVerifyError) {
                            return _core_explained_result__WEBPACK_IMPORTED_MODULE_1__["ExplainedResult"].bad(
                                "Component " + componentId + " has invalid data: " + componentVerifyError
                            );
                        }
                    }
                }
            }
        }

        return _core_explained_result__WEBPACK_IMPORTED_MODULE_1__["ExplainedResult"].good();
    }

    /**
     * Tries to load the savegame from a given dump
     * @param {import("./savegame_typedefs").SerializedGame} savegame
     * @param {GameRoot} root
     * @returns {ExplainedResult}
     */
    deserialize(savegame, root) {
        // Sanity
        const verifyResult = this.verifyLogicalErrors(savegame);
        if (!verifyResult.result) {
            return _core_explained_result__WEBPACK_IMPORTED_MODULE_1__["ExplainedResult"].bad(verifyResult.reason);
        }
        let errorReason = null;

        errorReason = errorReason || root.entityMgr.deserialize(savegame.entityMgr);
        errorReason = errorReason || root.time.deserialize(savegame.time);
        errorReason = errorReason || root.camera.deserialize(savegame.camera);
        errorReason = errorReason || root.map.deserialize(savegame.map);
        errorReason = errorReason || root.hubGoals.deserialize(savegame.hubGoals);
        errorReason = errorReason || root.hud.parts.pinnedShapes.deserialize(savegame.pinnedShapes);
        errorReason = errorReason || root.hud.parts.waypoints.deserialize(savegame.waypoints);
        errorReason = errorReason || this.internal.deserializeEntityArray(root, savegame.entities);

        // Check for errors
        if (errorReason) {
            return _core_explained_result__WEBPACK_IMPORTED_MODULE_1__["ExplainedResult"].bad(errorReason);
        }

        return _core_explained_result__WEBPACK_IMPORTED_MODULE_1__["ExplainedResult"].good();
    }
}


/***/ }),

/***/ "./src/js/savegame/schemas/1000.js":
/*!*****************************************!*\
  !*** ./src/js/savegame/schemas/1000.js ***!
  \*****************************************/
/*! exports provided: SavegameInterface_V1000 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SavegameInterface_V1000", function() { return SavegameInterface_V1000; });
/* harmony import */ var _savegame_interface_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../savegame_interface.js */ "./src/js/savegame/savegame_interface.js");


const schema = __webpack_require__(/*! ./1000.json */ "./src/js/savegame/schemas/1000.json");

class SavegameInterface_V1000 extends _savegame_interface_js__WEBPACK_IMPORTED_MODULE_0__["BaseSavegameInterface"] {
    getVersion() {
        return 1000;
    }

    getSchemaUncached() {
        return schema;
    }
}


/***/ }),

/***/ "./src/js/savegame/schemas/1000.json":
/*!*******************************************!*\
  !*** ./src/js/savegame/schemas/1000.json ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (function() {
        return JSON.parse(__webpack_require__(/*! global-compression */ "./src/js/core/lzstring.js").decompressX64("N4WAUABFEEQC4E8AOBTGAuWB7ARgKxQGM4YAacaWAJxQEcBXASxoBMMIBtAXXMmhgCGLFoziMsAOwEAbAApUsqKmJQBndnCr0U4AL7ggA"));
    })()

/***/ }),

/***/ "./src/js/savegame/schemas/1001.js":
/*!*****************************************!*\
  !*** ./src/js/savegame/schemas/1001.js ***!
  \*****************************************/
/*! exports provided: SavegameInterface_V1001 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SavegameInterface_V1001", function() { return SavegameInterface_V1001; });
/* harmony import */ var _1000_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./1000.js */ "./src/js/savegame/schemas/1000.js");
/* harmony import */ var _core_logging_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/logging.js */ "./src/js/core/logging.js");
/* harmony import */ var _translations_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../translations.js */ "./src/js/translations.js");




const schema = __webpack_require__(/*! ./1001.json */ "./src/js/savegame/schemas/1001.json");

const logger = Object(_core_logging_js__WEBPACK_IMPORTED_MODULE_1__["createLogger"])("savegame_interface/1001");

class SavegameInterface_V1001 extends _1000_js__WEBPACK_IMPORTED_MODULE_0__["SavegameInterface_V1000"] {
    getVersion() {
        return 1001;
    }

    getSchemaUncached() {
        return schema;
    }

    /**
     * @param {import("../savegame_typedefs.js").SavegameData} data
     */
    static migrate1000to1001(data) {
        logger.log("Migrating 1000 to 1001");
        const dump = data.dump;
        if (!dump) {
            return true;
        }

        dump.pinnedShapes = {
            shapes: [],
        };
        dump.waypoints = {
            waypoints: [
                {
                    label: _translations_js__WEBPACK_IMPORTED_MODULE_2__["T"].ingame.waypoints.hub,
                    center: { x: 0, y: 0 },
                    zoomLevel: 3,
                    deletable: false,
                },
            ],
        };

        const entities = dump.entities;
        for (let i = 0; i < entities.length; ++i) {
            const entity = entities[i];

            const staticComp = entity.components.StaticMapEntity;
            const beltComp = entity.components.Belt;
            if (staticComp) {
                if (staticComp.spriteKey) {
                    staticComp.blueprintSpriteKey = staticComp.spriteKey.replace(
                        "sprites/buildings",
                        "sprites/blueprints"
                    );
                } else {
                    if (entity.components.Hub) {
                        staticComp.blueprintSpriteKey = "";
                    } else if (beltComp) {
                        const direction = beltComp.direction;
                        staticComp.blueprintSpriteKey = "sprites/blueprints/belt_" + direction + ".png";
                    } else {
                        window.assert(false, "Could not deduct entity type for migrating 1000 -> 1001");
                    }
                }
            }
        }
    }
}


/***/ }),

/***/ "./src/js/savegame/schemas/1001.json":
/*!*******************************************!*\
  !*** ./src/js/savegame/schemas/1001.json ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (function() {
        return JSON.parse(__webpack_require__(/*! global-compression */ "./src/js/core/lzstring.js").decompressX64("N4WAUABFEEQC4E8AOBTGAuWB7ARgKxQGM4YAacaWAJxQEcBXASxoBMMIBtAXXMmhgCGLFoziMsAOwEAbAApUsqKmJQBndnCr0U4AL7ggA"));
    })()

/***/ }),

/***/ "./src/js/savegame/schemas/1002.js":
/*!*****************************************!*\
  !*** ./src/js/savegame/schemas/1002.js ***!
  \*****************************************/
/*! exports provided: SavegameInterface_V1002 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SavegameInterface_V1002", function() { return SavegameInterface_V1002; });
/* harmony import */ var _core_logging_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/logging.js */ "./src/js/core/logging.js");
/* harmony import */ var _translations_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../translations.js */ "./src/js/translations.js");
/* harmony import */ var _1001_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./1001.js */ "./src/js/savegame/schemas/1001.js");




const schema = __webpack_require__(/*! ./1002.json */ "./src/js/savegame/schemas/1002.json");
const logger = Object(_core_logging_js__WEBPACK_IMPORTED_MODULE_0__["createLogger"])("savegame_interface/1002");

class SavegameInterface_V1002 extends _1001_js__WEBPACK_IMPORTED_MODULE_2__["SavegameInterface_V1001"] {
    getVersion() {
        return 1002;
    }

    getSchemaUncached() {
        return schema;
    }

    /**
     * @param {import("../savegame_typedefs.js").SavegameData} data
     */
    static migrate1001to1002(data) {
        logger.log("Migrating 1001 to 1002");
        const dump = data.dump;
        if (!dump) {
            return true;
        }

        const entities = dump.entities;
        for (let i = 0; i < entities.length; ++i) {
            const entity = entities[i];
            const beltComp = entity.components.Belt;
            const ejectorComp = entity.components.ItemEjector;
            if (beltComp && ejectorComp) {
                ejectorComp.instantEject = true;
            }
        }
    }
}


/***/ }),

/***/ "./src/js/savegame/schemas/1002.json":
/*!*******************************************!*\
  !*** ./src/js/savegame/schemas/1002.json ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (function() {
        return JSON.parse(__webpack_require__(/*! global-compression */ "./src/js/core/lzstring.js").decompressX64("N4WAUABFEEQC4E8AOBTGAuWB7ARgKxQGM4YAacaWAJxQEcBXASxoBMMIBtAXXMmhgCGLFoziMsAOwEAbAApUsqKmJQBndnCr0U4AL7ggA"));
    })()

/***/ }),

/***/ "./src/js/savegame/serialization.js":
/*!******************************************!*\
  !*** ./src/js/savegame/serialization.js ***!
  \******************************************/
/*! exports provided: types, BasicSerializableObject, serializeSchema, deserializeSchema, verifySchema, extendSchema */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "types", function() { return types; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicSerializableObject", function() { return BasicSerializableObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serializeSchema", function() { return serializeSchema; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deserializeSchema", function() { return deserializeSchema; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifySchema", function() { return verifySchema; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendSchema", function() { return extendSchema; });
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");
/* harmony import */ var _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serialization_data_types */ "./src/js/savegame/serialization_data_types.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");




const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_2__["createLogger"])("serialization");

// Schema declarations
const types = {
    int: new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeInteger"](),
    uint: new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypePositiveInteger"](),
    float: new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeNumber"](),
    ufloat: new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypePositiveNumber"](),
    string: new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeString"](),
    entity: new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeEntity"](),
    weakEntityRef: new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeEntityWeakref"](),
    vector: new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeVector"](),
    tileVector: new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeVector"](),
    bool: new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeBoolean"](),

    /**
     * @param {BaseDataType} wrapped
     */
    nullable(wrapped) {
        return new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeNullable"](wrapped);
    },

    /**
     * @param {FactoryTemplate<*>|SingletonFactoryTemplate<*>} registry
     */
    classId(registry) {
        return new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeClassId"](registry);
    },
    /**
     * @param {BaseDataType} valueType
     * @param {boolean=} includeEmptyValues
     */
    keyValueMap(valueType, includeEmptyValues = true) {
        return new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeKeyValueMap"](valueType, includeEmptyValues);
    },

    /**
     * @param {Object<string, any>} values
     */
    enum(values) {
        return new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeEnum"](values);
    },

    /**
     * @param {FactoryTemplate<*>} registry
     */
    obj(registry) {
        return new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeClass"](registry);
    },

    /**
     * @param {FactoryTemplate<*>} registry
     */
    objData(registry) {
        return new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeClassData"](registry);
    },

    /**
     * @param {typeof BasicSerializableObject} cls
     */
    knownType(cls) {
        return new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeFixedClass"](cls);
    },

    /**
     * @param {BaseDataType} innerType
     */
    array(innerType) {
        return new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeArray"](innerType);
    },

    /**
     * @param {SingletonFactoryTemplate<*>} innerType
     */
    classRef(registry) {
        return new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeMetaClass"](registry);
    },

    /**
     * @param {Object.<string, BaseDataType>} descriptor
     */
    structured(descriptor) {
        return new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeStructuredObject"](descriptor);
    },

    /**
     * @param {BaseDataType} a
     * @param {BaseDataType} b
     */
    pair(a, b) {
        return new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypePair"](a, b);
    },

    /**
     * @param {typeof BasicSerializableObject} classHandle
     * @param {SingletonFactoryTemplate<*>} registry
     */
    classWithMetaclass(classHandle, registry) {
        return new _serialization_data_types__WEBPACK_IMPORTED_MODULE_1__["TypeClassFromMetaclass"](classHandle, registry);
    },
};

/**
 * A full schema declaration
 * @typedef {Object.<string, BaseDataType>} Schema
 */

const globalSchemaCache = {};

/* dev:start */
const classnamesCache = {};
/* dev:end*/

class BasicSerializableObject {
    /* dev:start */
    /**
     * Fixes typeof DerivedComponent is not assignable to typeof Component, compiled out
     * in non-dev builds
     */
    constructor(...args) {}

    /* dev:end */

    static getId() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }

    /**
     * Should return the serialization schema
     * @returns {Schema}
     */
    static getSchema() {
        return {};
    }

    // Implementation
    /** @returns {Schema} */
    static getCachedSchema() {
        const id = this.getId();

        /* dev:start */
        window.assert(
            classnamesCache[id] === this || classnamesCache[id] === undefined,
            "Class name taken twice: " + id + " (from " + this.name + ")"
        );
        classnamesCache[id] = this;
        /* dev:end */

        const entry = globalSchemaCache[id];
        if (entry) {
            return entry;
        }

        const schema = this.getSchema();
        globalSchemaCache[id] = schema;
        return schema;
    }

    /** @returns {object} */
    serialize() {
        return serializeSchema(
            this,
            /** @type {typeof BasicSerializableObject} */ (this.constructor).getCachedSchema()
        );
    }

    /** @returns {string|void} */
    deserialize(data) {
        return deserializeSchema(
            this,
            /** @type {typeof BasicSerializableObject} */ (this.constructor).getCachedSchema(),
            data
        );
    }

    /** @returns {string|void} */
    static verify(data) {
        return verifySchema(this.getCachedSchema(), data);
    }
}

/**
 * Serializes an object using the given schema, mergin with the given properties
 * @param {object} obj The object to serialize
 * @param {Schema} schema The schema to use
 * @param {object=} mergeWith Any additional properties to merge with the schema, useful for super calls
 * @returns {object} Serialized data object
 */
function serializeSchema(obj, schema, mergeWith = {}) {
    for (const key in schema) {
        if (!obj.hasOwnProperty(key)) {
            logger.error("Invalid schema, property", key, "does not exist on", obj, "(schema=", schema, ")");
            window.assert(
                obj.hasOwnProperty(key),
                "serialization: invalid schema, property does not exist on object: " + key
            );
        }
        if (!schema[key]) {
            window.assert(false, "Invalid schema (bad key '" + key + "'): " + Object(_core_builtins__WEBPACK_IMPORTED_MODULE_0__["JSON_stringify"])(schema));
        }

        if (true) {
            try {
                mergeWith[key] = schema[key].serialize(obj[key]);
            } catch (ex) {
                logger.error(
                    "Serialization of",
                    obj,
                    "failed on key '" + key + "' ->",
                    ex,
                    "(schema was",
                    schema,
                    ")"
                );
                throw ex;
            }
        } else {}
    }
    return mergeWith;
}

/**
 * Deserializes data into an object
 * @param {object} obj The object to store the deserialized data into
 * @param {Schema} schema The schema to use
 * @param {object} data The serialized data
 * @param {string|void|null=} baseclassErrorResult Convenience, if this is a string error code, do nothing and return it
 * @returns {string|void} String error code or nothing on success
 */
function deserializeSchema(obj, schema, data, baseclassErrorResult = null) {
    if (baseclassErrorResult) {
        return baseclassErrorResult;
    }

    if (!data) {
        logger.error("Got 'NULL' data for", obj, "and schema", schema, "!");
        return "Got null data";
    }

    for (const key in schema) {
        if (!data.hasOwnProperty(key)) {
            logger.error("Data", data, "does not contain", key, "(schema:", schema, ")");
            return "Missing key in schema: " + key + " of class " + obj.constructor.name;
        }
        if (!schema[key].allowNull() && (data[key] === null || data[key] === undefined)) {
            logger.error("Data", data, "has null value for", key, "(schema:", schema, ")");
            return "Non-nullable entry is null: " + key + " of class " + obj.constructor.name;
        }

        const errorStatus = schema[key].deserializeWithVerify(data[key], obj, key, obj.root);
        if (errorStatus) {
            logger.error(
                "Deserialization failed with error '" + errorStatus + "' on object",
                obj,
                "and key",
                key,
                "(root? =",
                obj.root ? "y" : "n",
                ")"
            );
            return errorStatus;
        }
    }
}

/**
 * Verifies stored data using the given schema
 * @param {Schema} schema The schema to use
 * @param {object} data The data to verify
 * @returns {string|void} String error code or nothing on success
 */
function verifySchema(schema, data) {
    for (const key in schema) {
        if (!data.hasOwnProperty(key)) {
            logger.error("Data", data, "does not contain", key, "(schema:", schema, ")");
            return "verify: missing key required by schema in stored data: " + key;
        }
        if (!schema[key].allowNull() && (data[key] === null || data[key] === undefined)) {
            logger.error("Data", data, "has null value for", key, "(schema:", schema, ")");
            return "verify: non-nullable entry is null: " + key;
        }

        const errorStatus = schema[key].verifySerializedValue(data[key]);
        if (errorStatus) {
            logger.error(errorStatus);
            return "verify: " + errorStatus;
        }
    }
}

/**
 * Extends a schema by adding the properties from the new schema to the existing base schema
 * @param {Schema} base
 * @param {Schema} newOne
 * @returns {Schema}
 */
function extendSchema(base, newOne) {
    /** @type {Schema} */
    const result = Object.assign({}, base);
    for (const key in newOne) {
        if (result.hasOwnProperty(key)) {
            logger.error("Extend schema got duplicate key:", key);
            continue;
        }
        result[key] = newOne[key];
    }
    return result;
}


/***/ }),

/***/ "./src/js/savegame/serialization_data_types.js":
/*!*****************************************************!*\
  !*** ./src/js/savegame/serialization_data_types.js ***!
  \*****************************************************/
/*! exports provided: globalJsonSchemaDefs, schemaToJsonSchema, BaseDataType, TypeInteger, TypePositiveInteger, TypeBoolean, TypeString, TypeVector, TypeTileVector, TypeNumber, TypePositiveNumber, TypeEnum, TypeEntity, TypeEntityWeakref, TypeClass, TypeClassData, TypeClassFromMetaclass, TypeMetaClass, TypeArray, TypeFixedClass, TypeKeyValueMap, TypeClassId, TypePair, TypeNullable, TypeStructuredObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalJsonSchemaDefs", function() { return globalJsonSchemaDefs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "schemaToJsonSchema", function() { return schemaToJsonSchema; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseDataType", function() { return BaseDataType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeInteger", function() { return TypeInteger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypePositiveInteger", function() { return TypePositiveInteger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeBoolean", function() { return TypeBoolean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeString", function() { return TypeString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeVector", function() { return TypeVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeTileVector", function() { return TypeTileVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeNumber", function() { return TypeNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypePositiveNumber", function() { return TypePositiveNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeEnum", function() { return TypeEnum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeEntity", function() { return TypeEntity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeEntityWeakref", function() { return TypeEntityWeakref; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeClass", function() { return TypeClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeClassData", function() { return TypeClassData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeClassFromMetaclass", function() { return TypeClassFromMetaclass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeMetaClass", function() { return TypeMetaClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeArray", function() { return TypeArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeFixedClass", function() { return TypeFixedClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeKeyValueMap", function() { return TypeKeyValueMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeClassId", function() { return TypeClassId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypePair", function() { return TypePair; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeNullable", function() { return TypeNullable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeStructuredObject", function() { return TypeStructuredObject; });
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/vector */ "./src/js/core/vector.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_builtins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/builtins */ "./src/js/core/builtins.js");






const globalJsonSchemaDefs = {};

/**
 *
 * @param {import("./serialization").Schema} schema
 */
function schemaToJsonSchema(schema) {
    const jsonSchema = {
        type: "object",
        additionalProperties: false,
        required: [],
        properties: {},
    };

    for (const key in schema) {
        const subSchema = schema[key].getAsJsonSchema();
        jsonSchema.required.push(key);
        jsonSchema.properties[key] = subSchema;
    }

    return jsonSchema;
}

/**
 * Base serialization data type
 */
class BaseDataType {
    /**
     * Serializes a given raw value
     * @param {any} value
     */
    serialize(value) {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return {};
    }

    /**
     * Verifies a given serialized value
     * @param {any} value
     * @returns {string|void} String error code or null on success
     */
    verifySerializedValue(value) {}

    /**
     * Deserializes a serialized value into the target object under the given key
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }

    /**
     * Returns the json schema
     */
    getAsJsonSchema() {
        const key = this.getCacheKey();
        const schema = this.getAsJsonSchemaUncached();

        if (!globalJsonSchemaDefs[key]) {
            // schema.$id = key;
            globalJsonSchemaDefs[key] = schema;
        }

        return {
            $ref: "#/definitions/" + key,
        };

        // return this.getAsJsonSchemaUncached();
        // if (!globalJsonSchemaDefs[key]) {
        //     // schema.$id = key;
        //     globalJsonSchemaDefs[key] = {
        //         $id: key,
        //         definitions: {
        //             ["d-" + key]: schema
        //         }
        //     };
        // }

        // return {
        //     $ref: key + "#/definitions/d-" + key
        // }

        // // return this.getAsJsonSchemaUncached();
    }

    /**
     * INTERNAL Should return the json schema representation
     */
    getAsJsonSchemaUncached() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
    }

    /**
     * Returns whether null values are okay
     * @returns {boolean}
     */
    allowNull() {
        return false;
    }

    // Helper methods

    /**
     * Deserializes a serialized value, but performs integrity checks before
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserializeWithVerify(value, targetObject, targetKey, root) {
        const errorCode = this.verifySerializedValue(value);
        if (errorCode) {
            return (
                "serialization verify failed: " +
                errorCode +
                " [value " +
                Object(_core_builtins__WEBPACK_IMPORTED_MODULE_2__["JSON_stringify"])(value).substr(0, 100) +
                "]"
            );
        }
        return this.deserialize(value, targetObject, targetKey, root);
    }

    /**
     * Should return a cacheable key
     */
    getCacheKey() {
        window.assert(false, 'abstract method called of: ' + (this.name || (this.constructor && this.constructor.name)));;
        return "";
    }
}

class TypeInteger extends BaseDataType {
    serialize(value) {
        window.assert(Number.isInteger(value), "Type integer got non integer for serialize: " + value);
        return value;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = value;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "integer",
        };
    }

    verifySerializedValue(value) {
        if (!Number.isInteger(value)) {
            return "Not a valid number";
        }
    }

    getCacheKey() {
        return "int";
    }
}

class TypePositiveInteger extends BaseDataType {
    serialize(value) {
        window.assert(Number.isInteger(value), "Type integer got non integer for serialize: " + value);
        window.assert(value >= 0, "value < 0: " + value);
        return value;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = value;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "integer",
            minimum: 0,
        };
    }

    verifySerializedValue(value) {
        if (!Number.isInteger(value)) {
            return "Not a valid number";
        }
        if (value < 0) {
            return "Negative value for positive integer";
        }
    }

    getCacheKey() {
        return "uint";
    }
}

class TypeBoolean extends BaseDataType {
    serialize(value) {
        window.assert(value === true || value === false, "Type bool got non bool for serialize: " + value);
        return value;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = value;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "boolean",
        };
    }

    verifySerializedValue(value) {
        if (value !== true && value !== false) {
            return "Not a boolean";
        }
    }

    getCacheKey() {
        return "bool";
    }
}

class TypeString extends BaseDataType {
    serialize(value) {
        window.assert(typeof value === "string", "Type string got non string for serialize: " + value);
        return value;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = value;
    }
    getAsJsonSchemaUncached() {
        return {
            type: "string",
        };
    }

    verifySerializedValue(value) {
        if (typeof value !== "string") {
            return "Not a valid string";
        }
    }

    getCacheKey() {
        return "string";
    }
}

class TypeVector extends BaseDataType {
    serialize(value) {
        window.assert(value instanceof _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"], "Type vector got non vector for serialize: " + value);
        return {
            x: Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["round4Digits"])(value.x),
            y: Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["round4Digits"])(value.y),
        };
    }

    getAsJsonSchemaUncached() {
        return Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["schemaObject"])({
            x: {
                type: "number",
            },
            y: {
                type: "number",
            },
        });
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](value.x, value.y);
    }

    verifySerializedValue(value) {
        if (!Number.isFinite(value.x) || !Number.isFinite(value.y)) {
            return "Not a valid vector, missing x/y or bad data type";
        }
    }

    getCacheKey() {
        return "vector";
    }
}

class TypeTileVector extends BaseDataType {
    serialize(value) {
        window.assert(value instanceof _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"], "Type vector got non vector for serialize: " + value);
        window.assert(Number.isInteger(value.x) && value.x > 0, "Invalid tile x:" + value.x);
        window.assert(Number.isInteger(value.y) && value.y > 0, "Invalid tile x:" + value.y);
        return { x: value.x, y: value.y };
    }

    getAsJsonSchemaUncached() {
        return Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["schemaObject"])({
            x: {
                type: "integer",
                minimum: 0,
                maximum: 256,
            },
            y: {
                type: "integer",
                minimum: 0,
                maximum: 256,
            },
        });
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = new _core_vector__WEBPACK_IMPORTED_MODULE_0__["Vector"](value.x, value.y);
    }

    verifySerializedValue(value) {
        if (!Number.isInteger(value.x) || !Number.isInteger(value.y)) {
            return "Not a valid tile vector, missing x/y or bad data type";
        }
        if (value.x < 0 || value.y < 0) {
            return "Invalid tile vector, x or y < 0";
        }
    }

    getCacheKey() {
        return "tilevector";
    }
}

class TypeNumber extends BaseDataType {
    serialize(value) {
        window.assert(Number.isFinite(value), "Type number got non number for serialize: " + value);
        window.assert(!Number.isNaN(value), "Value is nan: " + value);
        return Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["round4Digits"])(value);
    }

    getAsJsonSchemaUncached() {
        return {
            type: "number",
        };
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = value;
    }

    verifySerializedValue(value) {
        if (!Number.isFinite(value)) {
            return "Not a valid number: " + value;
        }
    }

    getCacheKey() {
        return "float";
    }
}

class TypePositiveNumber extends BaseDataType {
    serialize(value) {
        window.assert(Number.isFinite(value), "Type number got non number for serialize: " + value);
        window.assert(value >= 0, "Postitive number got negative value: " + value);
        return Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["round4Digits"])(value);
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = value;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "number",
            minimum: 0,
        };
    }

    verifySerializedValue(value) {
        if (!Number.isFinite(value)) {
            return "Not a valid number: " + value;
        }
        if (value < 0) {
            return "Positive number got negative value: " + value;
        }
    }

    getCacheKey() {
        return "ufloat";
    }
}

class TypeEnum extends BaseDataType {
    /**
     * @param {Object.<string, any>} enumeration
     */
    constructor(enumeration = {}) {
        super();
        this.availableValues = Object.keys(enumeration);
    }

    serialize(value) {
        window.assert(this.availableValues.indexOf(value) >= 0, "Unknown value: " + value);
        return value;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = value;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "string",
            enum: this.availableValues,
        };
    }

    verifySerializedValue(value) {
        if (this.availableValues.indexOf(value) < 0) {
            return "Unknown enum value: " + value;
        }
    }

    getCacheKey() {
        return "enum." + this.availableValues.join(",");
    }
}

class TypeEntity extends BaseDataType {
    serialize(value) {
        // assert(value instanceof Entity, "Not a valid entity ref: " + value);
        window.assert(value.uid, "Entity has no uid yet");
        window.assert(!value.destroyed, "Entity already destroyed");
        window.assert(!value.queuedForDestroy, "Entity queued for destroy");

        return value.uid;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "integer",
            minimum: 0,
        };
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        const entity = root.entityMgr.findByUid(value);
        if (!entity) {
            return "Entity not found by uid: " + value;
        }
        targetObject[targetKey] = entity;
    }

    verifySerializedValue(value) {
        if (!Number.isFinite(value)) {
            return "Not a valid uuid: " + value;
        }
    }

    getCacheKey() {
        return "entity";
    }
}

class TypeEntityWeakref extends BaseDataType {
    serialize(value) {
        if (value === null) {
            return null;
        }

        // assert(value instanceof Entity, "Not a valid entity ref (weak): " + value);
        window.assert(value.uid, "Entity has no uid yet");
        if (value.destroyed || value.queuedForDestroy) {
            return null;
        }
        return value.uid;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        if (value === null) {
            targetObject[targetKey] = null;
            return;
        }
        const entity = root.entityMgr.findByUid(value, false);
        targetObject[targetKey] = entity;
    }

    getAsJsonSchemaUncached() {
        return {
            type: ["null", "integer"],
            minimum: 0,
        };
    }

    allowNull() {
        return true;
    }

    verifySerializedValue(value) {
        if (value !== null && !Number.isFinite(value)) {
            return "Not a valid uuid: " + value;
        }
    }

    getCacheKey() {
        return "entity-weakref";
    }
}

class TypeClass extends BaseDataType {
    /**
     *
     * @param {FactoryTemplate<*>} registry
     */
    constructor(registry) {
        super();
        this.registry = registry;
    }

    serialize(value) {
        window.assert(typeof value === "object", "Not a class instance: " + value);
        return {
            $: value.constructor.getId(),
            data: value.serialize(),
        };
    }

    getAsJsonSchemaUncached() {
        const options = [];
        const entries = this.registry.getEntries();
        for (let i = 0; i < entries.length; ++i) {
            const entry = entries[i];

            options.push(
                Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__["schemaObject"])({
                    $: {
                        type: "string",
                        // @ts-ignore
                        enum: [entry.getId()],
                    },
                    // @ts-ignore
                    data: schemaToJsonSchema(entry.getCachedSchema()),
                })
            );
        }

        return { oneOf: options };
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        const instanceClass = this.registry.findById(value.$);
        if (!instanceClass || !instanceClass.prototype) {
            return "Invalid class id (runtime-err): " + value.$ + "->" + instanceClass;
        }
        const instance = Object.create(instanceClass.prototype);
        const errorState = instance.deserialize(value.data);
        if (errorState) {
            return errorState;
        }
        targetObject[targetKey] = instance;
    }

    verifySerializedValue(value) {
        if (!value) {
            return "Got null data";
        }

        if (!this.registry.hasId(value.$)) {
            return "Invalid class id: " + value.$ + " (factory is " + this.registry.getId() + ")";
        }
    }

    getCacheKey() {
        return "class." + this.registry.getId();
    }
}

class TypeClassData extends BaseDataType {
    /**
     *
     * @param {FactoryTemplate<*>} registry
     */
    constructor(registry) {
        super();
        this.registry = registry;
    }

    serialize(value) {
        window.assert(typeof value === "object", "Not a class instance: " + value);
        return value.serialize();
    }

    getAsJsonSchemaUncached() {
        const options = [];
        const entries = this.registry.getEntries();
        for (let i = 0; i < entries.length; ++i) {
            const entry = entries[i];
            options.push(
                schemaToJsonSchema(/** @type {typeof BasicSerializableObject} */ (entry).getCachedSchema())
            );
        }
        return { oneOf: options };
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        window.assert(false, "can not deserialize class data of type " + this.registry.getId());
    }

    verifySerializedValue(value) {
        if (!value) {
            return "Got null data";
        }
    }

    getCacheKey() {
        return "class." + this.registry.getId();
    }
}

class TypeClassFromMetaclass extends BaseDataType {
    /**
     *
     * @param {typeof BasicSerializableObject} classHandle
     * @param {SingletonFactoryTemplate<*>} registry
     */
    constructor(classHandle, registry) {
        super();
        this.registry = registry;
        this.classHandle = classHandle;
    }

    serialize(value) {
        window.assert(typeof value === "object", "Not a class instance: " + value);
        return {
            $: value.getMetaclass().getId(),
            data: value.serialize(),
        };
    }

    getAsJsonSchemaUncached() {
        // const options = [];
        const ids = this.registry.getAllIds();

        return {
            $: {
                type: "string",
                enum: ids,
            },
            data: schemaToJsonSchema(this.classHandle.getCachedSchema()),
        };
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        const metaClassInstance = this.registry.findById(value.$);
        if (!metaClassInstance || !metaClassInstance.prototype) {
            return "Invalid meta class id (runtime-err): " + value.$ + "->" + metaClassInstance;
        }

        const instanceClass = metaClassInstance.getInstanceClass();
        const instance = Object.create(instanceClass.prototype);
        const errorState = instance.deserialize(value.data);
        if (errorState) {
            return errorState;
        }
        targetObject[targetKey] = instance;
    }

    verifySerializedValue(value) {
        if (!value) {
            return "Got null data";
        }

        if (!this.registry.hasId(value.$)) {
            return "Invalid class id: " + value.$ + " (factory is " + this.registry.getId() + ")";
        }
    }

    getCacheKey() {
        return "classofmetaclass." + this.registry.getId();
    }
}

class TypeMetaClass extends BaseDataType {
    /**
     *
     * @param {SingletonFactoryTemplate<*>} registry
     */
    constructor(registry) {
        super();
        this.registry = registry;
    }

    serialize(value) {
        return value.getId();
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        const instanceClass = this.registry.findById(value);
        if (!instanceClass) {
            return "Invalid class id (runtime-err): " + value;
        }
        targetObject[targetKey] = instanceClass;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "string",
            enum: this.registry.getAllIds(),
        };
    }

    verifySerializedValue(value) {
        if (!value) {
            return "Got null data";
        }

        if (typeof value !== "string") {
            return "Got non string data";
        }

        if (!this.registry.hasId(value)) {
            return "Invalid class id: " + value + " (factory is " + this.registry.getId() + ")";
        }
    }

    getCacheKey() {
        return "metaclass." + this.registry.getId();
    }
}

class TypeArray extends BaseDataType {
    /**
     * @param {BaseDataType} innerType
     */
    constructor(innerType) {
        super();
        this.innerType = innerType;
    }

    serialize(value) {
        window.assert(Array.isArray(value), "Not an array");
        const result = new Array(value.length);
        for (let i = 0; i < value.length; ++i) {
            result[i] = this.innerType.serialize(value[i]);
        }
        return result;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        const result = new Array(value.length);
        for (let i = 0; i < value.length; ++i) {
            const errorStatus = this.innerType.deserializeWithVerify(value[i], result, i, root);
            if (errorStatus) {
                return errorStatus;
            }
        }
        targetObject[targetKey] = result;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "array",
            items: this.innerType.getAsJsonSchema(),
        };
    }

    verifySerializedValue(value) {
        if (!Array.isArray(value)) {
            return "Not an array: " + value;
        }
    }

    getCacheKey() {
        return "array." + this.innerType.getCacheKey();
    }
}

class TypeFixedClass extends BaseDataType {
    /**
     *
     * @param {typeof BasicSerializableObject} baseclass
     */
    constructor(baseclass) {
        super();
        this.baseclass = baseclass;
    }

    serialize(value) {
        window.assert(value instanceof this.baseclass, "Not a valid class instance");
        return value.serialize();
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        const instance = Object.create(this.baseclass.prototype);
        const errorState = instance.deserialize(value);
        if (errorState) {
            return "Failed to deserialize class: " + errorState;
        }
        targetObject[targetKey] = instance;
    }

    getAsJsonSchemaUncached() {
        this.baseclass.getSchema();
        this.baseclass.getCachedSchema();
        return schemaToJsonSchema(this.baseclass.getCachedSchema());
    }

    verifySerializedValue(value) {
        if (!value) {
            return "Got null data";
        }
    }

    getCacheKey() {
        return "fixedclass." + this.baseclass.getId();
    }
}

class TypeKeyValueMap extends BaseDataType {
    /**
     * @param {BaseDataType} valueType
     * @param {boolean=} includeEmptyValues
     */
    constructor(valueType, includeEmptyValues = true) {
        super();
        this.valueType = valueType;
        this.includeEmptyValues = includeEmptyValues;
    }

    serialize(value) {
        window.assert(typeof value === "object", "not an object");
        let result = {};
        for (const key in value) {
            const serialized = this.valueType.serialize(value[key]);
            if (!this.includeEmptyValues && typeof serialized === "object") {
                if (
                    serialized.$ &&
                    typeof serialized.data === "object" &&
                    Object.keys(serialized.data).length === 0
                ) {
                    continue;
                } else if (Object.keys(serialized).length === 0) {
                    continue;
                }
            }

            result[key] = serialized;
        }
        return result;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        let result = {};
        for (const key in value) {
            const errorCode = this.valueType.deserializeWithVerify(value[key], result, key, root);
            if (errorCode) {
                return errorCode;
            }
        }
        targetObject[targetKey] = result;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "object",
            additionalProperties: this.valueType.getAsJsonSchema(),
        };
    }

    verifySerializedValue(value) {
        if (typeof value !== "object") {
            return "KV map is not an object";
        }
    }

    getCacheKey() {
        return "kvmap." + this.valueType.getCacheKey();
    }
}

class TypeClassId extends BaseDataType {
    /**
     * @param {FactoryTemplate<*>|SingletonFactoryTemplate<*>} registry
     */
    constructor(registry) {
        super();
        this.registry = registry;
    }

    serialize(value) {
        window.assert(typeof value === "string", "Not a valid string");
        window.assert(this.registry.hasId(value), "Id " + value + " not found in registry");
        return value;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        targetObject[targetKey] = value;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "string",
            enum: this.registry.getAllIds(),
        };
    }

    verifySerializedValue(value) {
        if (typeof value !== "string") {
            return "Not a valid registry id key: " + value;
        }
        if (!this.registry.hasId(value)) {
            return "Id " + value + " not known to registry";
        }
    }

    getCacheKey() {
        return "classid." + this.registry.getId();
    }
}

class TypePair extends BaseDataType {
    /**
     * @param {BaseDataType} type1
     * @param {BaseDataType} type2
     */
    constructor(type1, type2) {
        super();
        window.assert(type1 && type1 instanceof BaseDataType, "bad first type given for pair");
        window.assert(type2 && type2 instanceof BaseDataType, "bad second type given for pair");
        this.type1 = type1;
        this.type2 = type2;
    }

    serialize(value) {
        window.assert(Array.isArray(value), "pair: not an array");
        window.assert(value.length === 2, "pair: length != 2");
        return [this.type1.serialize(value[0]), this.type2.serialize(value[1])];
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        const result = [undefined, undefined];

        let errorCode = this.type1.deserialize(value[0], result, 0, root);
        if (errorCode) {
            return errorCode;
        }
        errorCode = this.type2.deserialize(value[1], result, 1, root);
        if (errorCode) {
            return errorCode;
        }

        targetObject[targetKey] = result;
    }

    getAsJsonSchemaUncached() {
        return {
            type: "array",
            minLength: 2,
            maxLength: 2,
            items: [this.type1.getAsJsonSchema(), this.type2.getAsJsonSchema()],
        };
    }

    verifySerializedValue(value) {
        if (!Array.isArray(value)) {
            return "Pair is not an array";
        }
        if (value.length !== 2) {
            return "Pair length != 2";
        }
        let errorCode = this.type1.verifySerializedValue(value[0]);
        if (errorCode) {
            return errorCode;
        }
        errorCode = this.type2.verifySerializedValue(value[1]);
        if (errorCode) {
            return errorCode;
        }
    }

    getCacheKey() {
        return "pair.(" + this.type1.getCacheKey() + "," + this.type2.getCacheKey + ")";
    }
}

class TypeNullable extends BaseDataType {
    /**
     * @param {BaseDataType} wrapped
     */
    constructor(wrapped) {
        super();
        this.wrapped = wrapped;
    }

    serialize(value) {
        if (value === null || value === undefined) {
            return null;
        }
        return this.wrapped.serialize(value);
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        if (value === null || value === undefined) {
            targetObject[targetKey] = null;
            return;
        }
        return this.wrapped.deserialize(value, targetObject, targetKey, root);
    }

    verifySerializedValue(value) {
        if (value === null) {
            return;
        }
        return this.wrapped.verifySerializedValue(value);
    }

    getAsJsonSchemaUncached() {
        return {
            oneOf: [
                {
                    type: "null",
                },
                this.wrapped.getAsJsonSchema(),
            ],
        };
    }

    allowNull() {
        return true;
    }

    getCacheKey() {
        return "nullable." + this.wrapped.getCacheKey();
    }
}

class TypeStructuredObject extends BaseDataType {
    /**
     * @param {Object.<string, BaseDataType>} descriptor
     */
    constructor(descriptor) {
        super();
        this.descriptor = descriptor;
    }

    serialize(value) {
        window.assert(typeof value === "object", "not an object");
        let result = {};
        for (const key in this.descriptor) {
            // assert(value.hasOwnProperty(key), "Serialization: Object does not have", key, "property!");
            result[key] = this.descriptor[key].serialize(value[key]);
        }
        return result;
    }

    /**
     * @see BaseDataType.deserialize
     * @param {any} value
     * @param {GameRoot} root
     * @param {object} targetObject
     * @param {string|number} targetKey
     * @returns {string|void} String error code or null on success
     */
    deserialize(value, targetObject, targetKey, root) {
        let result = {};
        for (const key in value) {
            const valueType = this.descriptor[key];
            const errorCode = valueType.deserializeWithVerify(value[key], result, key, root);
            if (errorCode) {
                return errorCode;
            }
        }
        targetObject[targetKey] = result;
    }

    getAsJsonSchemaUncached() {
        let properties = {};
        for (const key in this.descriptor) {
            properties[key] = this.descriptor[key].getAsJsonSchema();
        }

        return {
            type: "object",
            required: Object.keys(this.descriptor),
            properties,
        };
    }

    verifySerializedValue(value) {
        if (typeof value !== "object") {
            return "structured object is not an object";
        }
        for (const key in this.descriptor) {
            if (!value.hasOwnProperty(key)) {
                return "structured object is missing key " + key;
            }
            const subError = this.descriptor[key].verifySerializedValue(value[key]);
            if (subError) {
                return "structured object::" + subError;
            }
        }
    }

    getCacheKey() {
        let props = [];
        for (const key in this.descriptor) {
            props.push(key + "=" + this.descriptor[key].getCacheKey());
        }
        return "structured[" + props.join(",") + "]";
    }
}


/***/ }),

/***/ "./src/js/savegame/serializer_internal.js":
/*!************************************************!*\
  !*** ./src/js/savegame/serializer_internal.js ***!
  \************************************************/
/*! exports provided: SerializerInternal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SerializerInternal", function() { return SerializerInternal; });
/* harmony import */ var _core_global_registries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/global_registries */ "./src/js/core/global_registries.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _game_entity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../game/entity */ "./src/js/game/entity.js");






// Internal serializer methods
class SerializerInternal {
    constructor() {}

    /**
     * Serializes an array of entities
     * @param {Array<Entity>} array
     */
    serializeEntityArray(array) {
        const serialized = [];
        for (let i = 0; i < array.length; ++i) {
            const entity = array[i];
            if (!entity.queuedForDestroy && !entity.destroyed) {
                serialized.push(entity.serialize());
            }
        }
        return serialized;
    }

    /**
     *
     * @param {GameRoot} root
     * @param {Array<any>} array
     * @returns {string|void}
     */
    deserializeEntityArray(root, array) {
        for (let i = 0; i < array.length; ++i) {
            this.deserializeEntity(root, array[i]);
        }
    }

    /**
     *
     * @param {GameRoot} root
     * @param {Entity} payload
     */
    deserializeEntity(root, payload) {
        const entity = new _game_entity__WEBPACK_IMPORTED_MODULE_2__["Entity"](root);
        this.deserializeComponents(entity, payload.components);

        root.entityMgr.registerEntity(entity, payload.uid);

        if (entity.components.StaticMapEntity) {
            root.map.placeStaticEntity(entity);
        }
    }

    /////// COMPONENTS ////

    /**
     * Deserializes components of an entity
     * @param {Entity} entity
     * @param {Object.<string, any>} data
     * @returns {string|void}
     */
    deserializeComponents(entity, data) {
        for (const componentId in data) {
            const componentClass = _core_global_registries__WEBPACK_IMPORTED_MODULE_0__["gComponentRegistry"].findById(componentId);
            const componentHandle = new componentClass({});
            entity.addComponent(componentHandle);
            const errorStatus = componentHandle.deserialize(data[componentId]);
            if (errorStatus) {
                return errorStatus;
            }
        }
    }
}


/***/ }),

/***/ "./src/js/states/about.js":
/*!********************************!*\
  !*** ./src/js/states/about.js ***!
  \********************************/
/*! exports provided: AboutState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AboutState", function() { return AboutState; });
/* harmony import */ var _core_textual_game_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/textual_game_state */ "./src/js/core/textual_game_state.js");
/* harmony import */ var _platform_sound__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/sound */ "./src/js/platform/sound.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../translations */ "./src/js/translations.js");
/* harmony import */ var _game_key_action_mapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../game/key_action_mapper */ "./src/js/game/key_action_mapper.js");
/* harmony import */ var _core_modal_dialog_elements__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/modal_dialog_elements */ "./src/js/core/modal_dialog_elements.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");







class AboutState extends _core_textual_game_state__WEBPACK_IMPORTED_MODULE_0__["TextualGameState"] {
    constructor() {
        super("AboutState");
    }

    getStateHeaderTitle() {
        return _translations__WEBPACK_IMPORTED_MODULE_2__["T"].about.title;
    }

    getMainContentHTML() {
        return `
            This game is open source and developed by <a href="https://github.com/tobspr" target="_blank">Tobias Springer</a> (this is me).
            <br><br>
            If you want to contribute, check out <a href="${_core_config__WEBPACK_IMPORTED_MODULE_5__["THIRDPARTY_URLS"].github}" target="_blank">shapez.io on github</a>.
            <br><br>
            This game wouldn't have been possible without the great discord community arround my games - You should really join the <a href="${_core_config__WEBPACK_IMPORTED_MODULE_5__["THIRDPARTY_URLS"].discord}" target="_blank">discord server</a>!
            <br><br>
            The soundtrack was made by <a href="https://soundcloud.com/pettersumelius" target="_blank">Peppsen</a> - He's awesome. 
            <br><br>
            Finally, huge thanks to my best friend <a href="https://github.com/niklas-dahl" target="_blank">Niklas</a> - Without our factorio sessions this game would never have existed. 
        `;
    }

    onEnter() {
        const links = this.htmlElement.querySelectorAll("a[href]");
        links.forEach(link => {
            this.trackClicks(
                link,
                () => this.app.platformWrapper.openExternalLink(link.getAttribute("href")),
                { preventClick: true }
            );
        });
    }

    getDefaultPreviousState() {
        return "SettingsState";
    }
}


/***/ }),

/***/ "./src/js/states/changelog.js":
/*!************************************!*\
  !*** ./src/js/states/changelog.js ***!
  \************************************/
/*! exports provided: ChangelogState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChangelogState", function() { return ChangelogState; });
/* harmony import */ var _core_textual_game_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/textual_game_state */ "./src/js/core/textual_game_state.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../translations */ "./src/js/translations.js");
/* harmony import */ var _changelog__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../changelog */ "./src/js/changelog.js");




class ChangelogState extends _core_textual_game_state__WEBPACK_IMPORTED_MODULE_0__["TextualGameState"] {
    constructor() {
        super("ChangelogState");
    }

    getStateHeaderTitle() {
        return _translations__WEBPACK_IMPORTED_MODULE_1__["T"].changelog.title;
    }

    getMainContentHTML() {
        const entries = _changelog__WEBPACK_IMPORTED_MODULE_2__["CHANGELOG"];

        let html = "";

        for (let i = 0; i < entries.length; ++i) {
            const entry = entries[i];
            html += `
                <div class="entry">
                    <span class="version">${entry.version}</span>
                    <span class="date">${entry.date}</span>
                    <ul class="changes">
                        ${entry.entries.map(text => `<li>${text}</li>`).join("")}
                    </ul>
                </div>
            `;
        }

        return html;
    }

    onEnter() {
        const links = this.htmlElement.querySelectorAll("a[href]");
        links.forEach(link => {
            this.trackClicks(
                link,
                () => this.app.platformWrapper.openExternalLink(link.getAttribute("href")),
                { preventClick: true }
            );
        });
    }
}


/***/ }),

/***/ "./src/js/states/ingame.js":
/*!*********************************!*\
  !*** ./src/js/states/ingame.js ***!
  \*********************************/
/*! exports provided: gameCreationAction, GameCreationPayload, InGameState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gameCreationAction", function() { return gameCreationAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameCreationPayload", function() { return GameCreationPayload; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InGameState", function() { return InGameState; });
/* harmony import */ var _core_error_handler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/error_handler */ "./src/js/core/error_handler.js");
/* harmony import */ var _core_game_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/game_state */ "./src/js/core/game_state.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _game_game_loading_overlay__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../game/game_loading_overlay */ "./src/js/game/game_loading_overlay.js");
/* harmony import */ var _game_key_action_mapper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../game/key_action_mapper */ "./src/js/game/key_action_mapper.js");
/* harmony import */ var _savegame_savegame__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../savegame/savegame */ "./src/js/savegame/savegame.js");
/* harmony import */ var _game_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../game/core */ "./src/js/game/core.js");
/* harmony import */ var _platform_sound__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../platform/sound */ "./src/js/platform/sound.js");











const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_2__["createLogger"])("state/ingame");

// Different sub-states
const stages = {
    s3_createCore: "🌈 3: Create core",
    s4_A_initEmptyGame: "🌈 4/A: Init empty game",
    s4_B_resumeGame: "🌈 4/B: Resume game",

    s5_firstUpdate: "🌈 5: First game update",
    s6_postLoadHook: "🌈 6: Post load hook",
    s7_warmup: "🌈 7: Warmup",

    s10_gameRunning: "🌈 10: Game finally running",

    leaving: "🌈 Saving, then leaving the game",
    destroyed: "🌈 DESTROYED: Core is empty and waits for state leave",
    initFailed: "🌈 ERROR: Initialization failed!",
};

const gameCreationAction = {
    new: "new-game",
    resume: "resume-game",
};

// Typehints
class GameCreationPayload {
    constructor() {
        /** @type {boolean|undefined} */
        this.fastEnter;

        /** @type {Savegame} */
        this.savegame;
    }
}

class InGameState extends _core_game_state__WEBPACK_IMPORTED_MODULE_1__["GameState"] {
    constructor() {
        super("InGameState");

        /** @type {GameCreationPayload} */
        this.creationPayload = null;

        // Stores current stage
        this.stage = "";

        /** @type {GameCore} */
        this.core = null;

        /** @type {KeyActionMapper} */
        this.keyActionMapper = null;

        /** @type {GameLoadingOverlay} */
        this.loadingOverlay = null;

        /** @type {Savegame} */
        this.savegame;

        this.boundInputFilter = this.filterInput.bind(this);
    }

    /**
     * Switches the game into another sub-state
     * @param {string} stage
     */
    switchStage(stage) {
        window.assert(stage, "Got empty stage");
        if (stage !== this.stage) {
            this.stage = stage;
            logger.log(this.stage);
            return true;
        } else {
            // log(this, "Re entering", stage);
            return false;
        }
    }

    // GameState implementation
    getInnerHTML() {
        return "";
    }

    getThemeMusic() {
        return _platform_sound__WEBPACK_IMPORTED_MODULE_9__["MUSIC"].theme;
    }

    onBeforeExit() {
        // logger.log("Saving before quitting");
        // return this.doSave().then(() => {
        //     logger.log(this, "Successfully saved");
        //     // this.stageDestroyed();
        // });
    }

    onAppPause() {
        // if (this.stage === stages.s10_gameRunning) {
        //     logger.log("Saving because app got paused");
        //     this.doSave();
        // }
    }

    getHasFadeIn() {
        return false;
    }

    getPauseOnFocusLost() {
        return false;
    }

    getHasUnloadConfirmation() {
        return true;
    }

    onLeave() {
        if (this.core) {
            this.stageDestroyed();
        }
        this.app.inputMgr.dismountFilter(this.boundInputFilter);
    }

    onResized(w, h) {
        super.onResized(w, h);
        if (this.stage === stages.s10_gameRunning) {
            this.core.resize(w, h);
        }
    }

    // ---- End of GameState implementation

    /**
     * Goes back to the menu state
     */
    goBackToMenu() {
        this.saveThenGoToState("MainMenuState");
    }

    /**
     * Goes back to the settings state
     */
    goToSettings() {
        this.saveThenGoToState("SettingsState", {
            backToStateId: this.key,
            backToStatePayload: this.creationPayload,
        });
    }

    /**
     * Goes back to the settings state
     */
    goToKeybindings() {
        this.saveThenGoToState("KeybindingsState", {
            backToStateId: this.key,
            backToStatePayload: this.creationPayload,
        });
    }

    /**
     * Moves to a state outside of the game
     * @param {string} stateId
     * @param {any=} payload
     */
    saveThenGoToState(stateId, payload) {
        if (this.stage === stages.leaving || this.stage === stages.destroyed) {
            logger.warn(
                "Tried to leave game twice or during destroy:",
                this.stage,
                "(attempted to move to",
                stateId,
                ")"
            );
            return;
        }
        this.stageLeavingGame();
        this.doSave().then(() => {
            this.stageDestroyed();
            this.moveToState(stateId, payload);
        });
    }

    onBackButton() {
        // do nothing
    }

    /**
     * Called when the game somehow failed to initialize. Resets everything to basic state and
     * then goes to the main menu, showing the error
     * @param {string} err
     */
    onInitializationFailure(err) {
        if (this.switchStage(stages.initFailed)) {
            logger.error("Init failure:", err);
            this.stageDestroyed();
            this.moveToState("MainMenuState", { loadError: err });
        }
    }

    // STAGES

    /**
     * Creates the game core instance, and thus the root
     */
    stage3CreateCore() {
        if (this.switchStage(stages.s3_createCore)) {
            logger.log("Creating new game core");
            this.core = new _game_core__WEBPACK_IMPORTED_MODULE_8__["GameCore"](this.app);

            this.core.initializeRoot(this, this.savegame);

            if (this.savegame.hasGameDump()) {
                this.app.gameAnalytics.handleGameStarted();
                this.stage4bResumeGame();
            } else {
                this.app.gameAnalytics.handleGameStarted();
                this.stage4aInitEmptyGame();
            }
        }
    }

    /**
     * Initializes a new empty game
     */
    stage4aInitEmptyGame() {
        if (this.switchStage(stages.s4_A_initEmptyGame)) {
            this.core.initNewGame();
            this.stage5FirstUpdate();
        }
    }

    /**
     * Resumes an existing game
     */
    stage4bResumeGame() {
        if (this.switchStage(stages.s4_B_resumeGame)) {
            if (!this.core.initExistingGame()) {
                this.onInitializationFailure("Savegame is corrupt and can not be restored.");
                return;
            }
            this.stage5FirstUpdate();
        }
    }

    /**
     * Performs the first game update on the game which initializes most caches
     */
    stage5FirstUpdate() {
        if (this.switchStage(stages.s5_firstUpdate)) {
            this.core.root.logicInitialized = true;
            this.core.updateLogic();
            this.stage6PostLoadHook();
        }
    }

    /**
     * Call the post load hook, this means that we have loaded the game, and all systems
     * can operate and start to work now.
     */
    stage6PostLoadHook() {
        if (this.switchStage(stages.s6_postLoadHook)) {
            logger.log("Post load hook");
            this.core.postLoadHook();
            this.stage7Warmup();
        }
    }

    /**
     * This makes the game idle and draw for a while, because we run most code this way
     * the V8 engine can already start to optimize it. Also this makes sure the resources
     * are in the VRAM and we have a smooth experience once we start.
     */
    stage7Warmup() {
        if (this.switchStage(stages.s7_warmup)) {
            if ( true && _core_config__WEBPACK_IMPORTED_MODULE_4__["globalConfig"].debug.noArtificialDelays) {
                this.warmupTimeSeconds = 0.05;
            } else {
                if (this.creationPayload.fastEnter) {
                    this.warmupTimeSeconds = _core_config__WEBPACK_IMPORTED_MODULE_4__["globalConfig"].warmupTimeSecondsFast;
                } else {
                    this.warmupTimeSeconds = _core_config__WEBPACK_IMPORTED_MODULE_4__["globalConfig"].warmupTimeSecondsRegular;
                }
            }
        }
    }

    /**
     * The final stage where this game is running and updating regulary.
     */
    stage10GameRunning() {
        if (this.switchStage(stages.s10_gameRunning)) {
            this.core.root.signals.readyToRender.dispatch();

            Object(_core_logging__WEBPACK_IMPORTED_MODULE_2__["logSection"])("GAME STARTED", "#26a69a");

            // Initial resize, might have changed during loading (this is possible)
            this.core.resize(this.app.screenWidth, this.app.screenHeight);
        }
    }

    /**
     * This stage destroys the whole game, used to cleanup
     */
    stageDestroyed() {
        if (this.switchStage(stages.destroyed)) {
            // Cleanup all api calls
            this.cancelAllAsyncOperations();

            if (this.syncer) {
                this.syncer.cancelSync();
                this.syncer = null;
            }

            // Cleanup core
            if (this.core) {
                this.core.destruct();
                this.core = null;
            }
        }
    }

    /**
     * When leaving the game
     */
    stageLeavingGame() {
        if (this.switchStage(stages.leaving)) {
            // ...
        }
    }

    // END STAGES

    /**
     * Filters the input (keybindings)
     */
    filterInput() {
        return this.stage === stages.s10_gameRunning;
    }

    /**
     * @param {GameCreationPayload} payload
     */
    onEnter(payload) {
        this.app.inputMgr.installFilter(this.boundInputFilter);

        this.creationPayload = payload;
        this.savegame = payload.savegame;

        this.loadingOverlay = new _game_game_loading_overlay__WEBPACK_IMPORTED_MODULE_5__["GameLoadingOverlay"](this.app, this.getDivElement());
        this.loadingOverlay.showBasic();

        // Remove unneded default element
        document.body.querySelector(".modalDialogParent").remove();

        this.asyncChannel.watch(Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["waitNextFrame"])()).then(() => this.stage3CreateCore());
    }

    /**
     * Render callback
     * @param {number} dt
     */
    onRender(dt) {
        if (_core_error_handler__WEBPACK_IMPORTED_MODULE_0__["APPLICATION_ERROR_OCCURED"]) {
            // Application somehow crashed, do not do anything
            return;
        }

        if (this.stage === stages.s7_warmup) {
            this.core.draw();
            this.warmupTimeSeconds -= dt / 1000.0;
            if (this.warmupTimeSeconds < 0) {
                logger.log("Warmup completed");
                this.stage10GameRunning();
            }
        }

        // // Check if we can show an ad
        // // DISABLED
        // if (this.stage === stages.s10_gameRunning && !this.core.root.hud.parts.processingOverlay.hasTasks()) {
        //     if (this.app.isRenderable() && this.app.adProvider.getCanShowVideoAd()) {
        //         this.saveThenGoToState("WatchAdState", {
        //             nextStateId: "RunningGameState",
        //             nextStatePayload: this.creationPayload,
        //         });
        //     }
        // }

        if (this.stage === stages.s10_gameRunning) {
            this.core.tick(dt);
        }

        // If the stage is still active (This might not be the case if tick() moved us to game over)
        if (this.stage === stages.s10_gameRunning) {
            // Only draw if page visible
            if (this.app.pageVisible) {
                this.core.draw();
            }

            this.loadingOverlay.removeIfAttached();
        } else {
            if (!this.loadingOverlay.isAttached()) {
                this.loadingOverlay.showBasic();
            }
        }
    }

    onBackgroundTick(dt) {
        this.onRender(dt);
    }

    /**
     * Saves the game
     */

    doSave() {
        if (!this.savegame || !this.savegame.isSaveable()) {
            return Promise.resolve();
        }

        if (_core_error_handler__WEBPACK_IMPORTED_MODULE_0__["APPLICATION_ERROR_OCCURED"]) {
            logger.warn("skipping save because application crashed");
            return Promise.resolve();
        }

        if (
            this.stage !== stages.s10_gameRunning &&
            this.stage !== stages.s7_warmup &&
            this.stage !== stages.leaving
        ) {
            logger.warn("Skipping save because game is not ready");
            return Promise.resolve();
        }

        // First update the game data
        logger.log("Starting to save game ...");
        this.core.root.signals.gameSaved.dispatch();
        this.savegame.updateData(this.core.root);
        return this.savegame.writeSavegameAndMetadata().catch(err => {
            logger.warn("Failed to save:", err);
        });
    }
}


/***/ }),

/***/ "./src/js/states/keybindings.js":
/*!**************************************!*\
  !*** ./src/js/states/keybindings.js ***!
  \**************************************/
/*! exports provided: KeybindingsState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeybindingsState", function() { return KeybindingsState; });
/* harmony import */ var _core_textual_game_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/textual_game_state */ "./src/js/core/textual_game_state.js");
/* harmony import */ var _platform_sound__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/sound */ "./src/js/platform/sound.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../translations */ "./src/js/translations.js");
/* harmony import */ var _game_key_action_mapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../game/key_action_mapper */ "./src/js/game/key_action_mapper.js");
/* harmony import */ var _core_modal_dialog_elements__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/modal_dialog_elements */ "./src/js/core/modal_dialog_elements.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");







class KeybindingsState extends _core_textual_game_state__WEBPACK_IMPORTED_MODULE_0__["TextualGameState"] {
    constructor() {
        super("KeybindingsState");
    }

    getStateHeaderTitle() {
        return _translations__WEBPACK_IMPORTED_MODULE_2__["T"].keybindings.title;
    }

    getMainContentHTML() {
        return `

            <div class="topEntries">
                <span class="hint">${_translations__WEBPACK_IMPORTED_MODULE_2__["T"].keybindings.hint}</span>
                <button class="styledButton resetBindings">${_translations__WEBPACK_IMPORTED_MODULE_2__["T"].keybindings.resetKeybindings}</button>
            
            </div>

            <div class="keybindings">

            </div>
        `;
    }

    onEnter() {
        const keybindingsElem = this.htmlElement.querySelector(".keybindings");

        this.trackClicks(this.htmlElement.querySelector(".resetBindings"), this.resetBindings);

        for (const category in _game_key_action_mapper__WEBPACK_IMPORTED_MODULE_3__["KEYMAPPINGS"]) {
            const categoryDiv = document.createElement("div");
            categoryDiv.classList.add("category");
            keybindingsElem.appendChild(categoryDiv);

            const labelDiv = document.createElement("strong");
            labelDiv.innerText = _translations__WEBPACK_IMPORTED_MODULE_2__["T"].keybindings.categoryLabels[category] || `unset(${category})`;
            labelDiv.classList.add("categoryLabel");
            categoryDiv.appendChild(labelDiv);

            for (const keybindingId in _game_key_action_mapper__WEBPACK_IMPORTED_MODULE_3__["KEYMAPPINGS"][category]) {
                const mapped = _game_key_action_mapper__WEBPACK_IMPORTED_MODULE_3__["KEYMAPPINGS"][category][keybindingId];

                const elem = document.createElement("div");
                elem.classList.add("entry");
                elem.setAttribute("data-keybinding", keybindingId);
                categoryDiv.appendChild(elem);

                const title = document.createElement("span");
                title.classList.add("title");
                title.innerText = _translations__WEBPACK_IMPORTED_MODULE_2__["T"].keybindings.mappings[keybindingId] || `unset(${keybindingId})`;
                elem.appendChild(title);

                const mappingDiv = document.createElement("span");
                mappingDiv.classList.add("mapping");
                elem.appendChild(mappingDiv);

                const editBtn = document.createElement("button");
                editBtn.classList.add("styledButton", "editKeybinding");

                const mappingDiv2 = document.createElement("span");
                mappingDiv2.classList.add("mapping");
                mappingDiv2.classList.add("mapping_2");

                const editBtn2 = document.createElement("button");
                editBtn2.classList.add("styledButton", "editKeybinding");
                editBtn2.classList.add("styledButton", "editKeybinding_2");

                const resetBtn = document.createElement("button");
                resetBtn.classList.add("styledButton", "resetKeybinding");
                const resetBtn2 = document.createElement("button");
                resetBtn2.classList.add("styledButton", "resetKeybinding");
                resetBtn2.classList.add("styledButton", "resetKeybinding_2");

                if (mapped.builtin) {
                    editBtn.classList.add("disabled");
                    resetBtn.classList.add("disabled");
                    editBtn2.classList.add("disabled");
                    resetBtn2.classList.add("disabled");
                } else {
                    this.trackClicks(editBtn, () => this.editKeybinding(keybindingId));
                    this.trackClicks(resetBtn, () => this.resetKeybinding(keybindingId));
                    this.trackClicks(editBtn2, () => this.editKeybinding(keybindingId + "_2"));
                    this.trackClicks(resetBtn2, () => this.resetKeybinding(keybindingId + "_2"));
                }
                elem.appendChild(editBtn);
                elem.appendChild(resetBtn);
                elem.appendChild(mappingDiv2);
                elem.appendChild(editBtn2);
                elem.appendChild(resetBtn2);
            }
        }
        this.updateKeybindings();
    }

    editKeybinding(id) {
        // if (IS_DEMO) {
        //     this.dialogs.showFeatureRestrictionInfo(T.demo.features.customizeKeybindings);
        //     return;
        // }

        const dialog = new _core_modal_dialog_elements__WEBPACK_IMPORTED_MODULE_4__["Dialog"]({
            app: this.app,
            title: _translations__WEBPACK_IMPORTED_MODULE_2__["T"].dialogs.editKeybinding.title,
            contentHTML: _translations__WEBPACK_IMPORTED_MODULE_2__["T"].dialogs.editKeybinding.desc,
            buttons: ["cancel:good"],
            type: "info",
        });

        dialog.inputReciever.keydown.add(({ keyCode, shift, alt, event }) => {
            if (keyCode === 27) {
                this.dialogs.closeDialog(dialog);
                return;
            }

            if (event) {
                event.preventDefault();
            }

            if (event.target && event.target.tagName === "BUTTON" && keyCode === 1) {
                return;
            }

            if (
                // Enter
                keyCode === 13 ||
                // TAB
                keyCode === 9
            ) {
                // Ignore builtins
                return;
            }

            this.app.settings.updateKeybindingOverride(id, keyCode);

            this.dialogs.closeDialog(dialog);
            this.updateKeybindings();
        });

        dialog.inputReciever.backButton.add(() => {});
        this.dialogs.internalShowDialog(dialog);

        this.app.sound.playUiSound(_platform_sound__WEBPACK_IMPORTED_MODULE_1__["SOUNDS"].dialogOk);
    }

    updateKeybindings() {
        const overrides = this.app.settings.getKeybindingOverrides();
        for (const category in _game_key_action_mapper__WEBPACK_IMPORTED_MODULE_3__["KEYMAPPINGS"]) {
            for (const keybindingId in _game_key_action_mapper__WEBPACK_IMPORTED_MODULE_3__["KEYMAPPINGS"][category]) {
                const mapped = _game_key_action_mapper__WEBPACK_IMPORTED_MODULE_3__["KEYMAPPINGS"][category][keybindingId];

                const container = this.htmlElement.querySelector("[data-keybinding='" + keybindingId + "']");
                window.assert(container, "Container for keybinding not found: " + keybindingId);

                let keyCode = mapped.keyCode;
                if (overrides[keybindingId]) {
                    keyCode = overrides[keybindingId];
                }
                let keyCode2 = mapped.keyCode2;
                if (overrides[keybindingId + "_2"]) {
                    keyCode2 = overrides[keybindingId + "_2"];
                }

                const mappingDiv = container.querySelector(".mapping");
                mappingDiv.innerHTML = Object(_game_key_action_mapper__WEBPACK_IMPORTED_MODULE_3__["getStringForKeyCode"])(keyCode);
                mappingDiv.classList.toggle("changed", !!overrides[keybindingId]);

                const mappingDiv2 = container.querySelector(".mapping_2");
                mappingDiv2.innerHTML = Object(_game_key_action_mapper__WEBPACK_IMPORTED_MODULE_3__["getStringForKeyCode"])(keyCode2);
                mappingDiv2.classList.toggle("changed", !!overrides[keybindingId + "_2"]);

                const resetBtn = container.querySelector("button.resetKeybinding");
                resetBtn.classList.toggle("disabled", mapped.builtin || !overrides[keybindingId]);

                const resetBtn2 = container.querySelector("button.resetKeybinding_2");
                resetBtn2.classList.toggle("disabled", mapped.builtin || !overrides[keybindingId + "_2"]);
            }
        }
    }

    resetKeybinding(id) {
        this.app.settings.resetKeybindingOverride(id);
        this.updateKeybindings();
    }

    resetBindings() {
        const { reset } = this.dialogs.showWarning(
            _translations__WEBPACK_IMPORTED_MODULE_2__["T"].dialogs.resetKeybindingsConfirmation.title,
            _translations__WEBPACK_IMPORTED_MODULE_2__["T"].dialogs.resetKeybindingsConfirmation.desc,
            ["cancel:good", "reset:bad"]
        );

        reset.add(() => {
            this.app.settings.resetKeybindingOverrides();
            this.updateKeybindings();

            this.dialogs.showInfo(_translations__WEBPACK_IMPORTED_MODULE_2__["T"].dialogs.keybindingsResetOk.title, _translations__WEBPACK_IMPORTED_MODULE_2__["T"].dialogs.keybindingsResetOk.desc);
        });
    }

    getDefaultPreviousState() {
        return "SettingsState";
    }
}


/***/ }),

/***/ "./src/js/states/main_menu.js":
/*!************************************!*\
  !*** ./src/js/states/main_menu.js ***!
  \************************************/
/*! exports provided: MainMenuState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MainMenuState", function() { return MainMenuState; });
/* harmony import */ var _core_game_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/game_state */ "./src/js/core/game_state.js");
/* harmony import */ var _core_cachebust__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/cachebust */ "./src/js/core/cachebust.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_read_write_proxy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/read_write_proxy */ "./src/js/core/read_write_proxy.js");
/* harmony import */ var _game_hud_parts_modal_dialogs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../game/hud/parts/modal_dialogs */ "./src/js/game/hud/parts/modal_dialogs.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../translations */ "./src/js/translations.js");
/* harmony import */ var _platform_browser_wrapper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../platform/browser/wrapper */ "./src/js/platform/browser/wrapper.js");









class MainMenuState extends _core_game_state__WEBPACK_IMPORTED_MODULE_0__["GameState"] {
    constructor() {
        super("MainMenuState");
    }

    getInnerHTML() {
        const bannerHtml = `
            <h3>${_translations__WEBPACK_IMPORTED_MODULE_6__["T"].demoBanners.title}</h3>
            
            <p>${_translations__WEBPACK_IMPORTED_MODULE_6__["T"].demoBanners.intro}</p>

            <ul>
                ${_translations__WEBPACK_IMPORTED_MODULE_6__["T"].demoBanners.advantages.map(advantage => `<li>${advantage}</li>`).join("")}
            </ul>

            <a href="#" class="steamLink" target="_blank">Get the shapez.io standalone!</a>
        `;

        return `

            <button class="settingsButton"></button>
            
        ${
             false
                ? undefined
                : ""
        }

            ${
                 false
                    ? undefined
                    : `<video autoplay muted loop class="fullscreenBackgroundVideo">
                <source src="${Object(_core_cachebust__WEBPACK_IMPORTED_MODULE_1__["cachebust"])("res/bg_render.webm")}" type="video/webm">
            </video>`
            }


            <div class="logo">
                <img src="${Object(_core_cachebust__WEBPACK_IMPORTED_MODULE_1__["cachebust"])("res/logo.png")}" alt="shapez.io Logo">
                ${
                    _core_config__WEBPACK_IMPORTED_MODULE_2__["IS_DEMO"] && this.app.platformWrapper.getShowDemoBadges()
                        ? `<div class="demoBadge"></div>`
                        : ""
                }
            </div>


            <div class="mainWrapper ${_core_config__WEBPACK_IMPORTED_MODULE_2__["IS_DEMO"] ? "demo" : "noDemo"}">
            
                ${_core_config__WEBPACK_IMPORTED_MODULE_2__["IS_DEMO"] ? `<div class="standaloneBanner">${bannerHtml}</div>` : ""}    
                
                <div class="mainContainer">
                    ${
                        Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["isSupportedBrowser"])()
                            ? ""
                            : `<div class="browserWarning">${_translations__WEBPACK_IMPORTED_MODULE_6__["T"].mainMenu.browserWarning}</div>`
                    }
                    <button class="playButton styledButton">${_translations__WEBPACK_IMPORTED_MODULE_6__["T"].mainMenu.play}</button>
                    <button class="importButton styledButton">${_translations__WEBPACK_IMPORTED_MODULE_6__["T"].mainMenu.importSavegame}</button>
                </div>
                
    
            </div>

            <div class="footer">

                <a class="githubLink boxLink" target="_blank">
                    ${_translations__WEBPACK_IMPORTED_MODULE_6__["T"].mainMenu.openSourceHint}
                    <span class="thirdpartyLogo githubLogo"></span>
                </a>    
                    
                <a class="discordLink boxLink" target="_blank">
                    ${_translations__WEBPACK_IMPORTED_MODULE_6__["T"].mainMenu.discordLink}
                    <span class="thirdpartyLogo  discordLogo"></span>
                </a>

                <a class="changelog">${_translations__WEBPACK_IMPORTED_MODULE_6__["T"].changelog.title}</a>

                ${
                     true &&
                    this.app.platformWrapper instanceof _platform_browser_wrapper__WEBPACK_IMPORTED_MODULE_7__["PlatformWrapperImplBrowser"] &&
                    this.app.platformWrapper.embedProvider.iogLink
                        ? `<a class="iogLink" target="_blank" href="https://iogames.space">.io games</a>`
                        : ""
                }

                <div class="author">Made by <a class="producerLink" target="_blank">Tobias Springer</a></div>

            </div>
        `;
    }

    requestImportSavegame() {
        if (
            _core_config__WEBPACK_IMPORTED_MODULE_2__["IS_DEMO"] &&
            this.app.savegameMgr.getSavegamesMetaData().length > 0 &&
            !this.app.platformWrapper.getHasUnlimitedSavegames()
        ) {
            this.app.analytics.trackUiClick("importgame_slot_limit_show");
            this.dialogs.showWarning(_translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.oneSavegameLimit.title, _translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.oneSavegameLimit.desc);
            return;
        }

        var input = document.createElement("input");
        input.type = "file";
        input.accept = ".bin";

        input.onchange = e => {
            const file = input.files[0];
            if (file) {
                Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["waitNextFrame"])().then(() => {
                    this.app.analytics.trackUiClick("import_savegame");
                    const closeLoader = this.dialogs.showLoadingDialog();
                    const reader = new FileReader();
                    reader.addEventListener("load", event => {
                        // @ts-ignore
                        const contents = event.target.result;
                        let realContent;

                        try {
                            realContent = _core_read_write_proxy__WEBPACK_IMPORTED_MODULE_4__["ReadWriteProxy"].deserializeObject(contents);
                        } catch (err) {
                            closeLoader();
                            this.dialogs.showWarning(
                                _translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.importSavegameError.title,
                                _translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.importSavegameError.text + "<br><br>" + err
                            );
                            return;
                        }

                        this.app.savegameMgr.importSavegame(realContent).then(
                            () => {
                                closeLoader();
                                this.dialogs.showWarning(
                                    _translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.importSavegameSuccess.title,
                                    _translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.importSavegameSuccess.text
                                );

                                this.renderSavegames();
                            },
                            err => {
                                closeLoader();
                                this.dialogs.showWarning(
                                    _translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.importSavegameError.title,
                                    _translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.importSavegameError.text + ":<br><br>" + err
                                );
                            }
                        );
                    });
                    reader.addEventListener("error", error => {
                        this.dialogs.showWarning(
                            _translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.importSavegameError.title,
                            _translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.importSavegameError.text + ":<br><br>" + error
                        );
                    });
                    reader.readAsText(file, "utf-8");
                });
            }
        };
        input.click();
    }

    onBackButton() {
        this.app.platformWrapper.exitApp();
    }

    onEnter(payload) {
        this.dialogs = new _game_hud_parts_modal_dialogs__WEBPACK_IMPORTED_MODULE_5__["HUDModalDialogs"](null, this.app);
        const dialogsElement = document.body.querySelector(".modalDialogParent");
        this.dialogs.initializeToElement(dialogsElement);

        if (payload.loadError) {
            this.dialogs.showWarning(
                _translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.gameLoadFailure.title,
                _translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.gameLoadFailure.text + "<br><br>" + payload.loadError
            );
        }

        const qs = this.htmlElement.querySelector.bind(this.htmlElement);
        this.trackClicks(qs(".mainContainer .playButton"), this.onPlayButtonClicked);
        this.trackClicks(qs(".mainContainer .importButton"), this.requestImportSavegame);

        if ( true && _core_config__WEBPACK_IMPORTED_MODULE_2__["globalConfig"].debug.fastGameEnter) {
            const games = this.app.savegameMgr.getSavegamesMetaData();
            if (games.length > 0) {
                this.resumeGame(games[0]);
            } else {
                this.onPlayButtonClicked();
            }
        }

        // Initialize video
        this.videoElement = this.htmlElement.querySelector("video");
        if (this.videoElement) {
            this.videoElement.playbackRate = 0.9;
            this.videoElement.addEventListener("canplay", () => {
                if (this.videoElement) {
                    this.videoElement.classList.add("loaded");
                }
            });
        }

        this.trackClicks(qs(".settingsButton"), this.onSettingsButtonClicked);
        this.trackClicks(qs(".changelog"), this.onChangelogClicked);

        if (false) {}

        this.renderSavegames();

        const steamLink = this.htmlElement.querySelector(".steamLink");
        if (steamLink) {
            this.trackClicks(steamLink, () => this.onSteamLinkClicked(), { preventClick: true });
        }

        const discordLink = this.htmlElement.querySelector(".discordLink");
        this.trackClicks(
            discordLink,
            () => this.app.platformWrapper.openExternalLink(_core_config__WEBPACK_IMPORTED_MODULE_2__["THIRDPARTY_URLS"].discord),
            { preventClick: true }
        );

        const githubLink = this.htmlElement.querySelector(".githubLink");
        this.trackClicks(
            githubLink,
            () => this.app.platformWrapper.openExternalLink(_core_config__WEBPACK_IMPORTED_MODULE_2__["THIRDPARTY_URLS"].github),
            { preventClick: true }
        );

        const producerLink = this.htmlElement.querySelector(".producerLink");
        this.trackClicks(
            producerLink,
            () => this.app.platformWrapper.openExternalLink("https://tobspr.com"),
            { preventClick: true }
        );
    }

    onSteamLinkClicked() {
        this.app.analytics.trackUiClick("main_menu_steam_link");
        this.app.platformWrapper.openExternalLink(_core_config__WEBPACK_IMPORTED_MODULE_2__["THIRDPARTY_URLS"].standaloneStorePage);
        return false;
    }

    onExitAppButtonClicked() {
        this.app.platformWrapper.exitApp();
    }

    onChangelogClicked() {
        this.moveToState("ChangelogState");
    }

    renderSavegames() {
        const oldContainer = this.htmlElement.querySelector(".mainContainer .savegames");
        if (oldContainer) {
            oldContainer.remove();
        }
        const games = this.app.savegameMgr.getSavegamesMetaData();
        if (games.length > 0) {
            const parent = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(this.htmlElement.querySelector(".mainContainer"), null, ["savegames"]);

            for (let i = 0; i < games.length; ++i) {
                const elem = Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(parent, null, ["savegame"]);

                Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(
                    elem,
                    null,
                    ["playtime"],
                    Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["formatSecondsToTimeAgo"])((new Date().getTime() - games[i].lastUpdate) / 1000.0)
                );

                Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["makeDiv"])(
                    elem,
                    null,
                    ["level"],
                    games[i].level
                        ? _translations__WEBPACK_IMPORTED_MODULE_6__["T"].mainMenu.savegameLevel.replace("<x>", "" + games[i].level)
                        : _translations__WEBPACK_IMPORTED_MODULE_6__["T"].mainMenu.savegameLevelUnknown
                );

                const deleteButton = document.createElement("button");
                deleteButton.classList.add("styledButton", "deleteGame");
                elem.appendChild(deleteButton);

                const downloadButton = document.createElement("button");
                downloadButton.classList.add("styledButton", "downloadGame");
                elem.appendChild(downloadButton);

                const resumeBtn = document.createElement("button");
                resumeBtn.classList.add("styledButton", "resumeGame");
                elem.appendChild(resumeBtn);

                this.trackClicks(deleteButton, () => this.deleteGame(games[i]));
                this.trackClicks(downloadButton, () => this.downloadGame(games[i]));
                this.trackClicks(resumeBtn, () => this.resumeGame(games[i]));
            }
        }
    }

    /**
     * @param {object} game
     */
    resumeGame(game) {
        this.app.analytics.trackUiClick("resume_game");

        this.app.adProvider.showVideoAd().then(() => {
            this.app.analytics.trackUiClick("resume_game_adcomplete");
            const savegame = this.app.savegameMgr.getSavegameById(game.internalId);
            savegame.readAsync().then(() => {
                this.moveToState("InGameState", {
                    savegame,
                });
            });
        });
    }

    /**
     * @param {object} game
     */
    deleteGame(game) {
        this.app.analytics.trackUiClick("delete_game");

        const signals = this.dialogs.showWarning(
            _translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.confirmSavegameDelete.title,
            _translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.confirmSavegameDelete.text,
            ["delete:bad", "cancel:good"]
        );

        signals.delete.add(() => {
            this.app.savegameMgr.deleteSavegame(game).then(
                () => {
                    this.renderSavegames();
                },
                err => {
                    this.dialogs.showWarning(
                        _translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.savegameDeletionError.title,
                        _translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.savegameDeletionError.text + "<br><br>" + err
                    );
                }
            );
        });
    }

    /**
     * @param {object} game
     */
    downloadGame(game) {
        this.app.analytics.trackUiClick("download_game");

        const savegame = this.app.savegameMgr.getSavegameById(game.internalId);
        savegame.readAsync().then(() => {
            const data = _core_read_write_proxy__WEBPACK_IMPORTED_MODULE_4__["ReadWriteProxy"].serializeObject(savegame.currentData);
            Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__["generateFileDownload"])(
                savegame.filename.replace("savegame_", `shapez_lv${game.level}_${new Date()}_`),
                data
            );
        });
    }

    onSettingsButtonClicked() {
        this.moveToState("SettingsState");
    }

    doStartNewGame() {
        this.app.analytics.trackUiClick("startgame");

        this.app.adProvider.showVideoAd().then(() => {
            const savegame = this.app.savegameMgr.createNewSavegame();

            this.moveToState("InGameState", {
                savegame,
            });
            this.app.analytics.trackUiClick("startgame_adcomplete");
        });
    }

    onPlayButtonClicked() {
        if (
            _core_config__WEBPACK_IMPORTED_MODULE_2__["IS_DEMO"] &&
            this.app.savegameMgr.getSavegamesMetaData().length > 0 &&
            !this.app.platformWrapper.getHasUnlimitedSavegames()
        ) {
            this.app.analytics.trackUiClick("startgame_slot_limit_show");
            this.dialogs.showWarning(_translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.oneSavegameLimit.title, _translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.oneSavegameLimit.desc);
            return;
        }

        if (_core_config__WEBPACK_IMPORTED_MODULE_2__["IS_DEMO"]) {
            this.app.analytics.trackUiClick("startgame_pre_show");
            const { ok } = this.dialogs.showWarning(
                _translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.demoExplanation.title,
                _translations__WEBPACK_IMPORTED_MODULE_6__["T"].dialogs.demoExplanation.desc
            );
            ok.add(() => this.doStartNewGame());
            return;
        }

        this.doStartNewGame();
    }

    onLeave() {
        this.dialogs.cleanup();
    }
}


/***/ }),

/***/ "./src/js/states/mobile_warning.js":
/*!*****************************************!*\
  !*** ./src/js/states/mobile_warning.js ***!
  \*****************************************/
/*! exports provided: MobileWarningState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MobileWarningState", function() { return MobileWarningState; });
/* harmony import */ var _core_game_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/game_state */ "./src/js/core/game_state.js");
/* harmony import */ var _core_cachebust__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/cachebust */ "./src/js/core/cachebust.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");




class MobileWarningState extends _core_game_state__WEBPACK_IMPORTED_MODULE_0__["GameState"] {
    constructor() {
        super("MobileWarningState");
    }

    getInnerHTML() {
        return `
    
            <img class="logo" src="${Object(_core_cachebust__WEBPACK_IMPORTED_MODULE_1__["cachebust"])("res/logo.png")}" alt="shapez.io Logo">

            <p>
                I'm sorry, but shapez.io is not yet available on mobile devices!
                (There is also no estimate when this will change, but feel to make a contribution! It's
                &nbsp;<a href="https://github.com/tobspr/shapez.io" target="_blank">open source</a>!)</p>
            
            <p>If you want to play on your computer, you can also get the standalone on itch.io:</p>

            
            <a href="${
                _core_config__WEBPACK_IMPORTED_MODULE_2__["THIRDPARTY_URLS"].standaloneStorePage
            }" class="standaloneLink" target="_blank">Get the shapez.io standalone!</a>
        `;
    }

    getThemeMusic() {
        return null;
    }

    getHasFadeIn() {
        return false;
    }

    onEnter() {
        try {
            if (window.gtag) {
                window.gtag("event", "click", {
                    event_category: "ui",
                    event_label: "mobile_warning",
                });
            }
        } catch (ex) {
            console.warn("Failed to track mobile click:", ex);
        }
    }
    onLeave() {
        // this.dialogs.cleanup();
    }
}


/***/ }),

/***/ "./src/js/states/preload.js":
/*!**********************************!*\
  !*** ./src/js/states/preload.js ***!
  \**********************************/
/*! exports provided: PreloadState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PreloadState", function() { return PreloadState; });
/* harmony import */ var _core_game_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/game_state */ "./src/js/core/game_state.js");
/* harmony import */ var _core_logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/logging */ "./src/js/core/logging.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _core_cachebust__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/cachebust */ "./src/js/core/cachebust.js");
/* harmony import */ var _platform_browser_wrapper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../platform/browser/wrapper */ "./src/js/platform/browser/wrapper.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../translations */ "./src/js/translations.js");
/* harmony import */ var _game_hud_parts_modal_dialogs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../game/hud/parts/modal_dialogs */ "./src/js/game/hud/parts/modal_dialogs.js");
/* harmony import */ var _changelog__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../changelog */ "./src/js/changelog.js");
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");










const logger = Object(_core_logging__WEBPACK_IMPORTED_MODULE_1__["createLogger"])("state/preload");

class PreloadState extends _core_game_state__WEBPACK_IMPORTED_MODULE_0__["GameState"] {
    constructor() {
        super("PreloadState");
    }

    getInnerHTML() {
        return `
            <div class="loadingImage"></div>
            <div class="loadingStatus">
                <span class="desc">Booting</span>
                <span class="bar">
                    <span class="inner" style="width: 0%"></span>
                    <span class="status">0%</span>
                </span>
            </div>
            </div>
        `;
    }

    getThemeMusic() {
        return null;
    }

    getHasFadeIn() {
        return false;
    }

    onEnter(payload) {
        this.htmlElement.classList.add("prefab_LoadingState");

        const elementsToRemove = ["#loadingPreload", "#fontPreload"];
        for (let i = 0; i < elementsToRemove.length; ++i) {
            const elem = document.querySelector(elementsToRemove[i]);
            if (elem) {
                elem.remove();
            }
        }

        this.dialogs = new _game_hud_parts_modal_dialogs__WEBPACK_IMPORTED_MODULE_6__["HUDModalDialogs"](null, this.app);
        const dialogsElement = document.body.querySelector(".modalDialogParent");
        this.dialogs.initializeToElement(dialogsElement);

        this.statusText = this.htmlElement.querySelector(".loadingStatus > .desc");
        this.statusBar = this.htmlElement.querySelector(".loadingStatus > .bar > .inner");
        this.statusBarText = this.htmlElement.querySelector(".loadingStatus > .bar > .status");
        this.currentStatus = "booting";
        this.currentIndex = 0;

        this.startLoading();
    }

    onLeave() {
        // this.dialogs.cleanup();
    }

    startLoading() {
        this.setStatus("Booting")

            .then(() => this.setStatus("Checking for updates"))
            .then(() => {
                if (false) {}
            })

            .then(() => this.setStatus("Creating platform wrapper"))
            .then(() => this.app.platformWrapper.initialize())

            .then(() => this.setStatus("Initializing local storage"))
            .then(() => {
                const wrapper = this.app.platformWrapper;
                if (wrapper instanceof _platform_browser_wrapper__WEBPACK_IMPORTED_MODULE_4__["PlatformWrapperImplBrowser"]) {
                    try {
                        window.localStorage.setItem("local_storage_test", "1");
                        window.localStorage.removeItem("local_storage_test");
                    } catch (ex) {
                        logger.error("Failed to read/write local storage:", ex);
                        return new Promise(() => {
                            alert(`Your brower does not support thirdparty cookies or you have disabled it in your security settings.\n\n
                                In Chrome this setting is called "Block third-party cookies and site data".\n\n
                                Please allow third party cookies and then reload the page.`);
                            // Never return
                        });
                    }
                }
            })

            .then(() => this.setStatus("Creating storage"))
            .then(() => {
                return this.app.storage.initialize();
            })

            .then(() => this.setStatus("Initializing libraries"))
            .then(() => this.app.analytics.initialize())
            .then(() => this.app.gameAnalytics.initialize())

            .then(() => this.setStatus("Initializing settings"))
            .then(() => {
                return this.app.settings.initialize();
            })

            .then(() => {
                // Initialize fullscreen
                if (this.app.platformWrapper.getSupportsFullscreen()) {
                    this.app.platformWrapper.setFullscreen(this.app.settings.getIsFullScreen());
                }
            })

            .then(() => this.setStatus("Initializing sounds"))
            .then(() => {
                // Notice: We don't await the sounds loading itself
                return this.app.sound.initialize();
            })

            .then(() => {
                this.app.backgroundResourceLoader.startLoading();
            })

            .then(() => this.setStatus("Initializing savegame"))
            .then(() => {
                return this.app.savegameMgr.initialize().catch(err => {
                    logger.error("Failed to initialize savegames:", err);
                    return new Promise(resolve => {
                        // const { ok } = this.dialogs.showWarning(
                        //     T.preload.savegame_corrupt_dialog.title,
                        //     T.preload.savegame_corrupt_dialog.content,
                        //     ["ok:good"]
                        // );
                        // ok.add(resolve);
                        alert("Your savegames failed to load. They might not show up. Sorry!");
                    });
                });
            })

            .then(() => this.setStatus("Downloading resources"))
            .then(() => {
                return this.app.backgroundResourceLoader.getPromiseForBareGame();
            })

            .then(() => this.setStatus("Checking changelog"))
            .then(() => {
                if ( true && _core_config__WEBPACK_IMPORTED_MODULE_8__["globalConfig"].debug.disableUpgradeNotification) {
                    return;
                }

                return this.app.storage
                    .readFileAsync("lastversion.bin")
                    .catch(err => {
                        logger.warn("Failed to read lastversion:", err);
                        return "1.1.3";
                    })
                    .then(version => {
                        logger.log("Last version:", version, "App version:", "1.1.3");
                        this.app.storage.writeFileAsync("lastversion.bin", "1.1.3");
                        return version;
                    })
                    .then(version => {
                        let changelogEntries = [];
                        logger.log("Last seen version:", version);

                        for (let i = 0; i < _changelog__WEBPACK_IMPORTED_MODULE_7__["CHANGELOG"].length; ++i) {
                            if (_changelog__WEBPACK_IMPORTED_MODULE_7__["CHANGELOG"][i].version === version) {
                                break;
                            }
                            changelogEntries.push(_changelog__WEBPACK_IMPORTED_MODULE_7__["CHANGELOG"][i]);
                        }
                        if (changelogEntries.length === 0) {
                            return;
                        }

                        let dialogHtml = _translations__WEBPACK_IMPORTED_MODULE_5__["T"].dialogs.updateSummary.desc;
                        for (let i = 0; i < changelogEntries.length; ++i) {
                            const entry = changelogEntries[i];
                            dialogHtml += `
                            <div class="changelogDialogEntry">
                                <span class="version">${entry.version}</span>
                                <span class="date">${entry.date}</span>
                                <ul class="changes">
                                    ${entry.entries.map(text => `<li>${text}</li>`).join("")}
                                </ul>
                            </div>
                        `;
                        }

                        return new Promise(resolve => {
                            this.dialogs.showInfo(_translations__WEBPACK_IMPORTED_MODULE_5__["T"].dialogs.updateSummary.title, dialogHtml).ok.add(resolve);
                        });
                    });
            })

            .then(() => this.setStatus("Launching"))
            .then(
                () => {
                    this.moveToState("MainMenuState");
                },
                err => {
                    this.showFailMessage(err);
                }
            );
    }

    setStatus(text) {
        logger.log("✅ " + text);
        this.currentIndex += 1;
        this.currentStatus = text;
        this.statusText.innerText = text;

        const numSteps = 10; // FIXME

        const percentage = (this.currentIndex / numSteps) * 100.0;
        this.statusBar.style.width = percentage + "%";
        this.statusBarText.innerText = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["findNiceValue"])(percentage) + "%";

        if (true) {
            return Promise.resolve();
        }
        return Promise.resolve();
        // return waitNextFrame();
    }

    showFailMessage(text) {
        logger.error("App init failed:", text);

        const email = "bugs@shapez.io";

        const subElement = document.createElement("div");
        subElement.classList.add("failureBox");

        subElement.innerHTML = `
                <div class="logo">
                    <img src="${Object(_core_cachebust__WEBPACK_IMPORTED_MODULE_3__["cachebust"])("res/logo.png")}" alt="Shapez.io Logo">
                </div>
                <div class="failureInner">
                    <div class="errorHeader">
                    Failed to initialize application!
                    </div>
                    <div class="errorMessage">
                        ${this.currentStatus} failed:<br/>
                        ${text}
                    </div>
                    
                    <div class="supportHelp">
                    Please send me an email with steps to reproduce and what you did before this happened:
                        <br /><a class="email" href="mailto:${email}?subject=App%20does%20not%20launch">${email}</a>
                    </div>
                        
                    <div class="lower">
                        <button class="resetApp styledButton">Reset App</button>
                        <i>Build ${"1.1.3"} @ ${"4eaaf87"}</i>
                    </div>
                </div>
        `;

        this.htmlElement.classList.add("failure");
        this.htmlElement.appendChild(subElement);

        const resetBtn = subElement.querySelector("button.resetApp");
        this.trackClicks(resetBtn, this.showResetConfirm);
    }

    showResetConfirm() {
        if (confirm("Are you sure you want to reset the app? This will delete all your savegames")) {
            this.resetApp();
        }
        // const signals = this.dialogs.showWarning(T.preload.reset_app_warning.title, T.preload.reset_app_warning.desc, [
        //     "delete:bad:timeout",
        //     "cancel:good",
        // ]);
        // signals.delete.add(this.resetApp, this);
    }

    resetApp() {
        this.app.settings
            .resetEverythingAsync()
            .then(() => {
                this.app.savegameMgr.resetEverythingAsync();
            })
            .then(() => {
                this.app.settings.resetEverythingAsync();
            })
            .then(() => {
                window.location.reload();
            });
    }
}


/***/ }),

/***/ "./src/js/states/settings.js":
/*!***********************************!*\
  !*** ./src/js/states/settings.js ***!
  \***********************************/
/*! exports provided: SettingsState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SettingsState", function() { return SettingsState; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/config */ "./src/js/core/config.js");
/* harmony import */ var _core_textual_game_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/textual_game_state */ "./src/js/core/textual_game_state.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/js/core/utils.js");
/* harmony import */ var _profile_application_settings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../profile/application_settings */ "./src/js/profile/application_settings.js");
/* harmony import */ var _translations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../translations */ "./src/js/translations.js");






class SettingsState extends _core_textual_game_state__WEBPACK_IMPORTED_MODULE_1__["TextualGameState"] {
    constructor() {
        super("SettingsState");
    }

    getStateHeaderTitle() {
        return _translations__WEBPACK_IMPORTED_MODULE_4__["T"].settings.title;
    }

    getMainContentHTML() {
        return `

            <div class="upperLinks">
            ${
                this.app.platformWrapper.getSupportsKeyboard()
                    ? `
                        <button class="styledButton editKeybindings">Keybindings</button>
            `
                    : ""
            }
            <button class="styledButton about">${_translations__WEBPACK_IMPORTED_MODULE_4__["T"].about.title}</button>

         </div>


            ${this.getSettingsHtml()}
            <div class="versionbar">
                <div class="buildVersion">${_translations__WEBPACK_IMPORTED_MODULE_4__["T"].global.loading} ...</div>
            </div>


        `;
    }

    getSettingsHtml() {
        let lastCategory = null;
        let html = "";
        for (let i = 0; i < _profile_application_settings__WEBPACK_IMPORTED_MODULE_3__["allApplicationSettings"].length; ++i) {
            const setting = _profile_application_settings__WEBPACK_IMPORTED_MODULE_3__["allApplicationSettings"][i];

            if (setting.categoryId !== lastCategory) {
                lastCategory = setting.categoryId;
                const isHidden = setting.categoryId == _profile_application_settings__WEBPACK_IMPORTED_MODULE_3__["categoryDebug"] && !_core_config__WEBPACK_IMPORTED_MODULE_0__["IS_DEBUG"];

                if (i !== 0) {
                    html += "</div>";
                }
                html += `<strong class='categoryLabel'${isHidden ? " style='display:none'" : ""}>${
                    _translations__WEBPACK_IMPORTED_MODULE_4__["T"].settings.categories[lastCategory]
                }</strong>`;
                html += `<div class='settingsContainer'${isHidden ? " style='display:none'" : ""}>`;
            }

            html += setting.getHtml();
        }
        if (lastCategory) {
            html += "</div>";
        }

        return html;
    }

    renderBuildText() {
        const labelVersion = this.htmlElement.querySelector(".buildVersion");
        const lastBuildMs = new Date().getTime() - 1591112380633;
        const lastBuildText = Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__["formatSecondsToTimeAgo"])(lastBuildMs / 1000.0);

        const version = _translations__WEBPACK_IMPORTED_MODULE_4__["T"].settings.versionBadges["dev"];

        labelVersion.innerHTML = `
            <span class='version'>
                ${"1.1.3"} @ ${version} @ ${"4eaaf87"}
            </span>
            <span class='buildTime'>
                ${_translations__WEBPACK_IMPORTED_MODULE_4__["T"].settings.buildDate.replace("<at-date>", lastBuildText)}<br />
            </span>`;
    }

    onEnter(payload) {
        this.renderBuildText();
        this.trackClicks(this.htmlElement.querySelector(".about"), this.onAboutClicked, {
            preventDefault: false,
        });

        const keybindingsButton = this.htmlElement.querySelector(".editKeybindings");

        if (keybindingsButton) {
            this.trackClicks(keybindingsButton, this.onKeybindingsClicked, { preventDefault: false });
        }

        this.initSettings();
    }

    initSettings() {
        _profile_application_settings__WEBPACK_IMPORTED_MODULE_3__["allApplicationSettings"].forEach(setting => {
            const element = this.htmlElement.querySelector("[data-setting='" + setting.id + "']");
            setting.bind(this.app, element, this.dialogs);
            setting.syncValueToElement();
            this.trackClicks(
                element,
                () => {
                    setting.modify();
                },
                { preventDefault: false }
            );
        });
    }

    onAboutClicked() {
        this.moveToStateAddGoBack("AboutState");
    }

    onKeybindingsClicked() {
        this.moveToStateAddGoBack("KeybindingsState");
    }
}


/***/ }),

/***/ "./src/js/translations.js":
/*!********************************!*\
  !*** ./src/js/translations.js ***!
  \********************************/
/*! exports provided: T */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T", function() { return T; });
/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/config */ "./src/js/core/config.js");


// @ts-ignore
const baseTranslations = __webpack_require__(/*! ./built-temp/base-en.json */ "./src/js/built-temp/base-en.json");

const T = baseTranslations;

if ( true && _core_config__WEBPACK_IMPORTED_MODULE_0__["globalConfig"].debug.testTranslations) {
    // Replaces all translations by fake translations to see whats translated and what not
    const mapTranslations = obj => {
        for (const key in obj) {
            const value = obj[key];
            if (typeof value === "string") {
                obj[key] = value.replace(/[a-z]/gi, "x");
            } else {
                mapTranslations(value);
            }
        }
    };
    mapTranslations(T);
}


/***/ }),

/***/ "./src/js/webworkers/background_animation_frame_emittter.worker.js":
/*!*************************************************************************!*\
  !*** ./src/js/webworkers/background_animation_frame_emittter.worker.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ "./node_modules/worker-loader/dist/workers/InlineWorker.js")("/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./node_modules/webpack-strip-block/index.js?!./src/js/webworkers/background_animation_frame_emittter.worker.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/webpack-strip-block/index.js?!./src/js/webworkers/background_animation_frame_emittter.worker.js\":\n/*!**********************************************************************************************************************!*\\\n  !*** ./node_modules/webpack-strip-block??ref--7-0!./src/js/webworkers/background_animation_frame_emittter.worker.js ***!\n  \\**********************************************************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n// We clamp high deltas so 30 fps is fairly ok\r\nvar bgFps = 30;\r\nvar desiredMsDelay = 1000 / bgFps;\r\n\r\nlet lastTick = 0;\r\n\r\nfunction tick() {\r\n    var now = performance.now();\r\n    var delta = now - lastTick;\r\n    lastTick = now;\r\n\r\n    // @ts-ignore\r\n    postMessage({ delta });\r\n}\r\n\r\nsetInterval(tick, desiredMsDelay);\r\n\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=f0467d1900aabc5d7923.worker.js.map", null);
};

/***/ }),

/***/ "./src/js/webworkers/compression.worker.js":
/*!*************************************************!*\
  !*** ./src/js/webworkers/compression.worker.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ "./node_modules/worker-loader/dist/workers/InlineWorker.js")("/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./node_modules/webpack-strip-block/index.js?!./src/js/webworkers/compression.worker.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/rusha/dist/rusha.js\":\n/*!******************************************!*\\\n  !*** ./node_modules/rusha/dist/rusha.js ***!\n  \\******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* eslint-env commonjs, browser */\n\nvar RushaCore = __webpack_require__(5);\n\nvar _require = __webpack_require__(1),\n    toHex = _require.toHex,\n    ceilHeapSize = _require.ceilHeapSize;\n\nvar conv = __webpack_require__(6);\n\n// Calculate the length of buffer that the sha1 routine uses\n// including the padding.\nvar padlen = function (len) {\n  for (len += 9; len % 64 > 0; len += 1) {}\n  return len;\n};\n\nvar padZeroes = function (bin, len) {\n  var h8 = new Uint8Array(bin.buffer);\n  var om = len % 4,\n      align = len - om;\n  switch (om) {\n    case 0:\n      h8[align + 3] = 0;\n    case 1:\n      h8[align + 2] = 0;\n    case 2:\n      h8[align + 1] = 0;\n    case 3:\n      h8[align + 0] = 0;\n  }\n  for (var i = (len >> 2) + 1; i < bin.length; i++) {\n    bin[i] = 0;\n  }\n};\n\nvar padData = function (bin, chunkLen, msgLen) {\n  bin[chunkLen >> 2] |= 0x80 << 24 - (chunkLen % 4 << 3);\n  // To support msgLen >= 2 GiB, use a float division when computing the\n  // high 32-bits of the big-endian message length in bits.\n  bin[((chunkLen >> 2) + 2 & ~0x0f) + 14] = msgLen / (1 << 29) | 0;\n  bin[((chunkLen >> 2) + 2 & ~0x0f) + 15] = msgLen << 3;\n};\n\nvar getRawDigest = function (heap, padMaxChunkLen) {\n  var io = new Int32Array(heap, padMaxChunkLen + 320, 5);\n  var out = new Int32Array(5);\n  var arr = new DataView(out.buffer);\n  arr.setInt32(0, io[0], false);\n  arr.setInt32(4, io[1], false);\n  arr.setInt32(8, io[2], false);\n  arr.setInt32(12, io[3], false);\n  arr.setInt32(16, io[4], false);\n  return out;\n};\n\nvar Rusha = function () {\n  function Rusha(chunkSize) {\n    _classCallCheck(this, Rusha);\n\n    chunkSize = chunkSize || 64 * 1024;\n    if (chunkSize % 64 > 0) {\n      throw new Error('Chunk size must be a multiple of 128 bit');\n    }\n    this._offset = 0;\n    this._maxChunkLen = chunkSize;\n    this._padMaxChunkLen = padlen(chunkSize);\n    // The size of the heap is the sum of:\n    // 1. The padded input message size\n    // 2. The extended space the algorithm needs (320 byte)\n    // 3. The 160 bit state the algoritm uses\n    this._heap = new ArrayBuffer(ceilHeapSize(this._padMaxChunkLen + 320 + 20));\n    this._h32 = new Int32Array(this._heap);\n    this._h8 = new Int8Array(this._heap);\n    this._core = new RushaCore({ Int32Array: Int32Array }, {}, this._heap);\n  }\n\n  Rusha.prototype._initState = function _initState(heap, padMsgLen) {\n    this._offset = 0;\n    var io = new Int32Array(heap, padMsgLen + 320, 5);\n    io[0] = 1732584193;\n    io[1] = -271733879;\n    io[2] = -1732584194;\n    io[3] = 271733878;\n    io[4] = -1009589776;\n  };\n\n  Rusha.prototype._padChunk = function _padChunk(chunkLen, msgLen) {\n    var padChunkLen = padlen(chunkLen);\n    var view = new Int32Array(this._heap, 0, padChunkLen >> 2);\n    padZeroes(view, chunkLen);\n    padData(view, chunkLen, msgLen);\n    return padChunkLen;\n  };\n\n  Rusha.prototype._write = function _write(data, chunkOffset, chunkLen, off) {\n    conv(data, this._h8, this._h32, chunkOffset, chunkLen, off || 0);\n  };\n\n  Rusha.prototype._coreCall = function _coreCall(data, chunkOffset, chunkLen, msgLen, finalize) {\n    var padChunkLen = chunkLen;\n    this._write(data, chunkOffset, chunkLen);\n    if (finalize) {\n      padChunkLen = this._padChunk(chunkLen, msgLen);\n    }\n    this._core.hash(padChunkLen, this._padMaxChunkLen);\n  };\n\n  Rusha.prototype.rawDigest = function rawDigest(str) {\n    var msgLen = str.byteLength || str.length || str.size || 0;\n    this._initState(this._heap, this._padMaxChunkLen);\n    var chunkOffset = 0,\n        chunkLen = this._maxChunkLen;\n    for (chunkOffset = 0; msgLen > chunkOffset + chunkLen; chunkOffset += chunkLen) {\n      this._coreCall(str, chunkOffset, chunkLen, msgLen, false);\n    }\n    this._coreCall(str, chunkOffset, msgLen - chunkOffset, msgLen, true);\n    return getRawDigest(this._heap, this._padMaxChunkLen);\n  };\n\n  Rusha.prototype.digest = function digest(str) {\n    return toHex(this.rawDigest(str).buffer);\n  };\n\n  Rusha.prototype.digestFromString = function digestFromString(str) {\n    return this.digest(str);\n  };\n\n  Rusha.prototype.digestFromBuffer = function digestFromBuffer(str) {\n    return this.digest(str);\n  };\n\n  Rusha.prototype.digestFromArrayBuffer = function digestFromArrayBuffer(str) {\n    return this.digest(str);\n  };\n\n  Rusha.prototype.resetState = function resetState() {\n    this._initState(this._heap, this._padMaxChunkLen);\n    return this;\n  };\n\n  Rusha.prototype.append = function append(chunk) {\n    var chunkOffset = 0;\n    var chunkLen = chunk.byteLength || chunk.length || chunk.size || 0;\n    var turnOffset = this._offset % this._maxChunkLen;\n    var inputLen = void 0;\n\n    this._offset += chunkLen;\n    while (chunkOffset < chunkLen) {\n      inputLen = Math.min(chunkLen - chunkOffset, this._maxChunkLen - turnOffset);\n      this._write(chunk, chunkOffset, inputLen, turnOffset);\n      turnOffset += inputLen;\n      chunkOffset += inputLen;\n      if (turnOffset === this._maxChunkLen) {\n        this._core.hash(this._maxChunkLen, this._padMaxChunkLen);\n        turnOffset = 0;\n      }\n    }\n    return this;\n  };\n\n  Rusha.prototype.getState = function getState() {\n    var turnOffset = this._offset % this._maxChunkLen;\n    var heap = void 0;\n    if (!turnOffset) {\n      var io = new Int32Array(this._heap, this._padMaxChunkLen + 320, 5);\n      heap = io.buffer.slice(io.byteOffset, io.byteOffset + io.byteLength);\n    } else {\n      heap = this._heap.slice(0);\n    }\n    return {\n      offset: this._offset,\n      heap: heap\n    };\n  };\n\n  Rusha.prototype.setState = function setState(state) {\n    this._offset = state.offset;\n    if (state.heap.byteLength === 20) {\n      var io = new Int32Array(this._heap, this._padMaxChunkLen + 320, 5);\n      io.set(new Int32Array(state.heap));\n    } else {\n      this._h32.set(new Int32Array(state.heap));\n    }\n    return this;\n  };\n\n  Rusha.prototype.rawEnd = function rawEnd() {\n    var msgLen = this._offset;\n    var chunkLen = msgLen % this._maxChunkLen;\n    var padChunkLen = this._padChunk(chunkLen, msgLen);\n    this._core.hash(padChunkLen, this._padMaxChunkLen);\n    var result = getRawDigest(this._heap, this._padMaxChunkLen);\n    this._initState(this._heap, this._padMaxChunkLen);\n    return result;\n  };\n\n  Rusha.prototype.end = function end() {\n    return toHex(this.rawEnd().buffer);\n  };\n\n  return Rusha;\n}();\n\nmodule.exports = Rusha;\nmodule.exports._core = RushaCore;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n/* eslint-env commonjs, browser */\n\n//\n// toHex\n//\n\nvar precomputedHex = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  precomputedHex[i] = (i < 0x10 ? '0' : '') + i.toString(16);\n}\n\nmodule.exports.toHex = function (arrayBuffer) {\n  var binarray = new Uint8Array(arrayBuffer);\n  var res = new Array(arrayBuffer.byteLength);\n  for (var _i = 0; _i < res.length; _i++) {\n    res[_i] = precomputedHex[binarray[_i]];\n  }\n  return res.join('');\n};\n\n//\n// ceilHeapSize\n//\n\nmodule.exports.ceilHeapSize = function (v) {\n  // The asm.js spec says:\n  // The heap object's byteLength must be either\n  // 2^n for n in [12, 24) or 2^24 * n for n ≥ 1.\n  // Also, byteLengths smaller than 2^16 are deprecated.\n  var p = 0;\n  // If v is smaller than 2^16, the smallest possible solution\n  // is 2^16.\n  if (v <= 65536) return 65536;\n  // If v < 2^24, we round up to 2^n,\n  // otherwise we round up to 2^24 * n.\n  if (v < 16777216) {\n    for (p = 1; p < v; p = p << 1) {}\n  } else {\n    for (p = 16777216; p < v; p += 16777216) {}\n  }\n  return p;\n};\n\n//\n// isDedicatedWorkerScope\n//\n\nmodule.exports.isDedicatedWorkerScope = function (self) {\n  var isRunningInWorker = 'WorkerGlobalScope' in self && self instanceof self.WorkerGlobalScope;\n  var isRunningInSharedWorker = 'SharedWorkerGlobalScope' in self && self instanceof self.SharedWorkerGlobalScope;\n  var isRunningInServiceWorker = 'ServiceWorkerGlobalScope' in self && self instanceof self.ServiceWorkerGlobalScope;\n\n  // Detects whether we run inside a dedicated worker or not.\n  //\n  // We can't just check for `DedicatedWorkerGlobalScope`, since IE11\n  // has a bug where it only supports `WorkerGlobalScope`.\n  //\n  // Therefore, we consider us as running inside a dedicated worker\n  // when we are running inside a worker, but not in a shared or service worker.\n  //\n  // When new types of workers are introduced, we will need to adjust this code.\n  return isRunningInWorker && !isRunningInSharedWorker && !isRunningInServiceWorker;\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* eslint-env commonjs, worker */\n\nmodule.exports = function () {\n  var Rusha = __webpack_require__(0);\n\n  var hashData = function (hasher, data, cb) {\n    try {\n      return cb(null, hasher.digest(data));\n    } catch (e) {\n      return cb(e);\n    }\n  };\n\n  var hashFile = function (hasher, readTotal, blockSize, file, cb) {\n    var reader = new self.FileReader();\n    reader.onloadend = function onloadend() {\n      if (reader.error) {\n        return cb(reader.error);\n      }\n      var buffer = reader.result;\n      readTotal += reader.result.byteLength;\n      try {\n        hasher.append(buffer);\n      } catch (e) {\n        cb(e);\n        return;\n      }\n      if (readTotal < file.size) {\n        hashFile(hasher, readTotal, blockSize, file, cb);\n      } else {\n        cb(null, hasher.end());\n      }\n    };\n    reader.readAsArrayBuffer(file.slice(readTotal, readTotal + blockSize));\n  };\n\n  var workerBehaviourEnabled = true;\n\n  self.onmessage = function (event) {\n    if (!workerBehaviourEnabled) {\n      return;\n    }\n\n    var data = event.data.data,\n        file = event.data.file,\n        id = event.data.id;\n    if (typeof id === 'undefined') return;\n    if (!file && !data) return;\n    var blockSize = event.data.blockSize || 4 * 1024 * 1024;\n    var hasher = new Rusha(blockSize);\n    hasher.resetState();\n    var done = function (err, hash) {\n      if (!err) {\n        self.postMessage({ id: id, hash: hash });\n      } else {\n        self.postMessage({ id: id, error: err.name });\n      }\n    };\n    if (data) hashData(hasher, data, done);\n    if (file) hashFile(hasher, 0, blockSize, file, done);\n  };\n\n  return function () {\n    workerBehaviourEnabled = false;\n  };\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* eslint-env commonjs, browser */\n\nvar work = __webpack_require__(4);\nvar Rusha = __webpack_require__(0);\nvar createHash = __webpack_require__(7);\nvar runWorker = __webpack_require__(2);\n\nvar _require = __webpack_require__(1),\n    isDedicatedWorkerScope = _require.isDedicatedWorkerScope;\n\nvar isRunningInDedicatedWorker = typeof self !== 'undefined' && isDedicatedWorkerScope(self);\n\nRusha.disableWorkerBehaviour = isRunningInDedicatedWorker ? runWorker() : function () {};\n\nRusha.createWorker = function () {\n  var worker = work(/*require.resolve*/(2));\n  var terminate = worker.terminate;\n  worker.terminate = function () {\n    URL.revokeObjectURL(worker.objectURL);\n    terminate.call(worker);\n  };\n  return worker;\n};\n\nRusha.createHash = createHash;\n\nmodule.exports = Rusha;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction webpackBootstrapFunc (modules) {\n/******/  // The module cache\n/******/  var installedModules = {};\n\n/******/  // The require function\n/******/  function __webpack_require__(moduleId) {\n\n/******/    // Check if module is in cache\n/******/    if(installedModules[moduleId])\n/******/      return installedModules[moduleId].exports;\n\n/******/    // Create a new module (and put it into the cache)\n/******/    var module = installedModules[moduleId] = {\n/******/      i: moduleId,\n/******/      l: false,\n/******/      exports: {}\n/******/    };\n\n/******/    // Execute the module function\n/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/    // Flag the module as loaded\n/******/    module.l = true;\n\n/******/    // Return the exports of the module\n/******/    return module.exports;\n/******/  }\n\n/******/  // expose the modules object (__webpack_modules__)\n/******/  __webpack_require__.m = modules;\n\n/******/  // expose the module cache\n/******/  __webpack_require__.c = installedModules;\n\n/******/  // identity function for calling harmony imports with the correct context\n/******/  __webpack_require__.i = function(value) { return value; };\n\n/******/  // define getter function for harmony exports\n/******/  __webpack_require__.d = function(exports, name, getter) {\n/******/    if(!__webpack_require__.o(exports, name)) {\n/******/      Object.defineProperty(exports, name, {\n/******/        configurable: false,\n/******/        enumerable: true,\n/******/        get: getter\n/******/      });\n/******/    }\n/******/  };\n\n/******/  // define __esModule on exports\n/******/  __webpack_require__.r = function(exports) {\n/******/    Object.defineProperty(exports, '__esModule', { value: true });\n/******/  };\n\n/******/  // getDefaultExport function for compatibility with non-harmony modules\n/******/  __webpack_require__.n = function(module) {\n/******/    var getter = module && module.__esModule ?\n/******/      function getDefault() { return module['default']; } :\n/******/      function getModuleExports() { return module; };\n/******/    __webpack_require__.d(getter, 'a', getter);\n/******/    return getter;\n/******/  };\n\n/******/  // Object.prototype.hasOwnProperty.call\n/******/  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n/******/  // __webpack_public_path__\n/******/  __webpack_require__.p = \"/\";\n\n/******/  // on error function for async loading\n/******/  __webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE)\n  return f.default || f // try to call default if defined to also support babel esmodule exports\n}\n\nvar moduleNameReqExp = '[\\\\.|\\\\-|\\\\+|\\\\w|\\/|@]+'\nvar dependencyRegExp = '\\\\((\\/\\\\*.*?\\\\*\\/)?\\s?.*?(' + moduleNameReqExp + ').*?\\\\)' // additional chars when output.pathinfo is true\n\n// http://stackoverflow.com/a/2593661/130442\nfunction quoteRegExp (str) {\n  return (str + '').replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&')\n}\n\nfunction getModuleDependencies (sources, module, queueName) {\n  var retval = {}\n  retval[queueName] = []\n\n  var fnString = module.toString()\n  var wrapperSignature = fnString.match(/^function\\s?\\(\\w+,\\s*\\w+,\\s*(\\w+)\\)/)\n  if (!wrapperSignature) return retval\n  var webpackRequireName = wrapperSignature[1]\n\n  // main bundle deps\n  var re = new RegExp('(\\\\\\\\n|\\\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g')\n  var match\n  while ((match = re.exec(fnString))) {\n    if (match[3] === 'dll-reference') continue\n    retval[queueName].push(match[3])\n  }\n\n  // dll deps\n  re = new RegExp('\\\\(' + quoteRegExp(webpackRequireName) + '\\\\(\"(dll-reference\\\\s(' + moduleNameReqExp + '))\"\\\\)\\\\)' + dependencyRegExp, 'g')\n  while ((match = re.exec(fnString))) {\n    if (!sources[match[2]]) {\n      retval[queueName].push(match[1])\n      sources[match[2]] = __webpack_require__(match[1]).m\n    }\n    retval[match[2]] = retval[match[2]] || []\n    retval[match[2]].push(match[4])\n  }\n\n  return retval\n}\n\nfunction hasValuesInQueues (queues) {\n  var keys = Object.keys(queues)\n  return keys.reduce(function (hasValues, key) {\n    return hasValues || queues[key].length > 0\n  }, false)\n}\n\nfunction getRequiredModules (sources, moduleId) {\n  var modulesQueue = {\n    main: [moduleId]\n  }\n  var requiredModules = {\n    main: []\n  }\n  var seenModules = {\n    main: {}\n  }\n\n  while (hasValuesInQueues(modulesQueue)) {\n    var queues = Object.keys(modulesQueue)\n    for (var i = 0; i < queues.length; i++) {\n      var queueName = queues[i]\n      var queue = modulesQueue[queueName]\n      var moduleToCheck = queue.pop()\n      seenModules[queueName] = seenModules[queueName] || {}\n      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue\n      seenModules[queueName][moduleToCheck] = true\n      requiredModules[queueName] = requiredModules[queueName] || []\n      requiredModules[queueName].push(moduleToCheck)\n      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName)\n      var newModulesKeys = Object.keys(newModules)\n      for (var j = 0; j < newModulesKeys.length; j++) {\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || []\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]])\n      }\n    }\n  }\n\n  return requiredModules\n}\n\nmodule.exports = function (moduleId, options) {\n  options = options || {}\n  var sources = {\n    main: __webpack_require__.m\n  }\n\n  var requiredModules = options.all ? { main: Object.keys(sources) } : getRequiredModules(sources, moduleId)\n\n  var src = ''\n\n  Object.keys(requiredModules).filter(function (m) { return m !== 'main' }).forEach(function (module) {\n    var entryModule = 0\n    while (requiredModules[module][entryModule]) {\n      entryModule++\n    }\n    requiredModules[module].push(entryModule)\n    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'\n    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[module][id].toString() }).join(',') + '});\\n'\n  })\n\n  src = src + '(' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources.main[id].toString() }).join(',') + '})(self);'\n\n  var blob = new window.Blob([src], { type: 'text/javascript' })\n  if (options.bare) { return blob }\n\n  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL\n\n  var workerUrl = URL.createObjectURL(blob)\n  var worker = new window.Worker(workerUrl)\n  worker.objectURL = workerUrl\n\n  return worker\n}\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n// The low-level RushCore module provides the heart of Rusha,\n// a high-speed sha1 implementation working on an Int32Array heap.\n// At first glance, the implementation seems complicated, however\n// with the SHA1 spec at hand, it is obvious this almost a textbook\n// implementation that has a few functions hand-inlined and a few loops\n// hand-unrolled.\nmodule.exports = function RushaCore(stdlib$846, foreign$847, heap$848) {\n    'use asm';\n    var H$849 = new stdlib$846.Int32Array(heap$848);\n    function hash$850(k$851, x$852) {\n        // k in bytes\n        k$851 = k$851 | 0;\n        x$852 = x$852 | 0;\n        var i$853 = 0, j$854 = 0, y0$855 = 0, z0$856 = 0, y1$857 = 0, z1$858 = 0, y2$859 = 0, z2$860 = 0, y3$861 = 0, z3$862 = 0, y4$863 = 0, z4$864 = 0, t0$865 = 0, t1$866 = 0;\n        y0$855 = H$849[x$852 + 320 >> 2] | 0;\n        y1$857 = H$849[x$852 + 324 >> 2] | 0;\n        y2$859 = H$849[x$852 + 328 >> 2] | 0;\n        y3$861 = H$849[x$852 + 332 >> 2] | 0;\n        y4$863 = H$849[x$852 + 336 >> 2] | 0;\n        for (i$853 = 0; (i$853 | 0) < (k$851 | 0); i$853 = i$853 + 64 | 0) {\n            z0$856 = y0$855;\n            z1$858 = y1$857;\n            z2$860 = y2$859;\n            z3$862 = y3$861;\n            z4$864 = y4$863;\n            for (j$854 = 0; (j$854 | 0) < 64; j$854 = j$854 + 4 | 0) {\n                t1$866 = H$849[i$853 + j$854 >> 2] | 0;\n                t0$865 = ((y0$855 << 5 | y0$855 >>> 27) + (y1$857 & y2$859 | ~y1$857 & y3$861) | 0) + ((t1$866 + y4$863 | 0) + 1518500249 | 0) | 0;\n                y4$863 = y3$861;\n                y3$861 = y2$859;\n                y2$859 = y1$857 << 30 | y1$857 >>> 2;\n                y1$857 = y0$855;\n                y0$855 = t0$865;\n                H$849[k$851 + j$854 >> 2] = t1$866;\n            }\n            for (j$854 = k$851 + 64 | 0; (j$854 | 0) < (k$851 + 80 | 0); j$854 = j$854 + 4 | 0) {\n                t1$866 = (H$849[j$854 - 12 >> 2] ^ H$849[j$854 - 32 >> 2] ^ H$849[j$854 - 56 >> 2] ^ H$849[j$854 - 64 >> 2]) << 1 | (H$849[j$854 - 12 >> 2] ^ H$849[j$854 - 32 >> 2] ^ H$849[j$854 - 56 >> 2] ^ H$849[j$854 - 64 >> 2]) >>> 31;\n                t0$865 = ((y0$855 << 5 | y0$855 >>> 27) + (y1$857 & y2$859 | ~y1$857 & y3$861) | 0) + ((t1$866 + y4$863 | 0) + 1518500249 | 0) | 0;\n                y4$863 = y3$861;\n                y3$861 = y2$859;\n                y2$859 = y1$857 << 30 | y1$857 >>> 2;\n                y1$857 = y0$855;\n                y0$855 = t0$865;\n                H$849[j$854 >> 2] = t1$866;\n            }\n            for (j$854 = k$851 + 80 | 0; (j$854 | 0) < (k$851 + 160 | 0); j$854 = j$854 + 4 | 0) {\n                t1$866 = (H$849[j$854 - 12 >> 2] ^ H$849[j$854 - 32 >> 2] ^ H$849[j$854 - 56 >> 2] ^ H$849[j$854 - 64 >> 2]) << 1 | (H$849[j$854 - 12 >> 2] ^ H$849[j$854 - 32 >> 2] ^ H$849[j$854 - 56 >> 2] ^ H$849[j$854 - 64 >> 2]) >>> 31;\n                t0$865 = ((y0$855 << 5 | y0$855 >>> 27) + (y1$857 ^ y2$859 ^ y3$861) | 0) + ((t1$866 + y4$863 | 0) + 1859775393 | 0) | 0;\n                y4$863 = y3$861;\n                y3$861 = y2$859;\n                y2$859 = y1$857 << 30 | y1$857 >>> 2;\n                y1$857 = y0$855;\n                y0$855 = t0$865;\n                H$849[j$854 >> 2] = t1$866;\n            }\n            for (j$854 = k$851 + 160 | 0; (j$854 | 0) < (k$851 + 240 | 0); j$854 = j$854 + 4 | 0) {\n                t1$866 = (H$849[j$854 - 12 >> 2] ^ H$849[j$854 - 32 >> 2] ^ H$849[j$854 - 56 >> 2] ^ H$849[j$854 - 64 >> 2]) << 1 | (H$849[j$854 - 12 >> 2] ^ H$849[j$854 - 32 >> 2] ^ H$849[j$854 - 56 >> 2] ^ H$849[j$854 - 64 >> 2]) >>> 31;\n                t0$865 = ((y0$855 << 5 | y0$855 >>> 27) + (y1$857 & y2$859 | y1$857 & y3$861 | y2$859 & y3$861) | 0) + ((t1$866 + y4$863 | 0) - 1894007588 | 0) | 0;\n                y4$863 = y3$861;\n                y3$861 = y2$859;\n                y2$859 = y1$857 << 30 | y1$857 >>> 2;\n                y1$857 = y0$855;\n                y0$855 = t0$865;\n                H$849[j$854 >> 2] = t1$866;\n            }\n            for (j$854 = k$851 + 240 | 0; (j$854 | 0) < (k$851 + 320 | 0); j$854 = j$854 + 4 | 0) {\n                t1$866 = (H$849[j$854 - 12 >> 2] ^ H$849[j$854 - 32 >> 2] ^ H$849[j$854 - 56 >> 2] ^ H$849[j$854 - 64 >> 2]) << 1 | (H$849[j$854 - 12 >> 2] ^ H$849[j$854 - 32 >> 2] ^ H$849[j$854 - 56 >> 2] ^ H$849[j$854 - 64 >> 2]) >>> 31;\n                t0$865 = ((y0$855 << 5 | y0$855 >>> 27) + (y1$857 ^ y2$859 ^ y3$861) | 0) + ((t1$866 + y4$863 | 0) - 899497514 | 0) | 0;\n                y4$863 = y3$861;\n                y3$861 = y2$859;\n                y2$859 = y1$857 << 30 | y1$857 >>> 2;\n                y1$857 = y0$855;\n                y0$855 = t0$865;\n                H$849[j$854 >> 2] = t1$866;\n            }\n            y0$855 = y0$855 + z0$856 | 0;\n            y1$857 = y1$857 + z1$858 | 0;\n            y2$859 = y2$859 + z2$860 | 0;\n            y3$861 = y3$861 + z3$862 | 0;\n            y4$863 = y4$863 + z4$864 | 0;\n        }\n        H$849[x$852 + 320 >> 2] = y0$855;\n        H$849[x$852 + 324 >> 2] = y1$857;\n        H$849[x$852 + 328 >> 2] = y2$859;\n        H$849[x$852 + 332 >> 2] = y3$861;\n        H$849[x$852 + 336 >> 2] = y4$863;\n    }\n    return { hash: hash$850 };\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nvar _this = this;\n\n/* eslint-env commonjs, browser */\n\nvar reader = void 0;\nif (typeof self !== 'undefined' && typeof self.FileReaderSync !== 'undefined') {\n  reader = new self.FileReaderSync();\n}\n\n// Convert a binary string and write it to the heap.\n// A binary string is expected to only contain char codes < 256.\nvar convStr = function (str, H8, H32, start, len, off) {\n  var i = void 0,\n      om = off % 4,\n      lm = (len + om) % 4,\n      j = len - lm;\n  switch (om) {\n    case 0:\n      H8[off] = str.charCodeAt(start + 3);\n    case 1:\n      H8[off + 1 - (om << 1) | 0] = str.charCodeAt(start + 2);\n    case 2:\n      H8[off + 2 - (om << 1) | 0] = str.charCodeAt(start + 1);\n    case 3:\n      H8[off + 3 - (om << 1) | 0] = str.charCodeAt(start);\n  }\n  if (len < lm + (4 - om)) {\n    return;\n  }\n  for (i = 4 - om; i < j; i = i + 4 | 0) {\n    H32[off + i >> 2] = str.charCodeAt(start + i) << 24 | str.charCodeAt(start + i + 1) << 16 | str.charCodeAt(start + i + 2) << 8 | str.charCodeAt(start + i + 3);\n  }\n  switch (lm) {\n    case 3:\n      H8[off + j + 1 | 0] = str.charCodeAt(start + j + 2);\n    case 2:\n      H8[off + j + 2 | 0] = str.charCodeAt(start + j + 1);\n    case 1:\n      H8[off + j + 3 | 0] = str.charCodeAt(start + j);\n  }\n};\n\n// Convert a buffer or array and write it to the heap.\n// The buffer or array is expected to only contain elements < 256.\nvar convBuf = function (buf, H8, H32, start, len, off) {\n  var i = void 0,\n      om = off % 4,\n      lm = (len + om) % 4,\n      j = len - lm;\n  switch (om) {\n    case 0:\n      H8[off] = buf[start + 3];\n    case 1:\n      H8[off + 1 - (om << 1) | 0] = buf[start + 2];\n    case 2:\n      H8[off + 2 - (om << 1) | 0] = buf[start + 1];\n    case 3:\n      H8[off + 3 - (om << 1) | 0] = buf[start];\n  }\n  if (len < lm + (4 - om)) {\n    return;\n  }\n  for (i = 4 - om; i < j; i = i + 4 | 0) {\n    H32[off + i >> 2 | 0] = buf[start + i] << 24 | buf[start + i + 1] << 16 | buf[start + i + 2] << 8 | buf[start + i + 3];\n  }\n  switch (lm) {\n    case 3:\n      H8[off + j + 1 | 0] = buf[start + j + 2];\n    case 2:\n      H8[off + j + 2 | 0] = buf[start + j + 1];\n    case 1:\n      H8[off + j + 3 | 0] = buf[start + j];\n  }\n};\n\nvar convBlob = function (blob, H8, H32, start, len, off) {\n  var i = void 0,\n      om = off % 4,\n      lm = (len + om) % 4,\n      j = len - lm;\n  var buf = new Uint8Array(reader.readAsArrayBuffer(blob.slice(start, start + len)));\n  switch (om) {\n    case 0:\n      H8[off] = buf[3];\n    case 1:\n      H8[off + 1 - (om << 1) | 0] = buf[2];\n    case 2:\n      H8[off + 2 - (om << 1) | 0] = buf[1];\n    case 3:\n      H8[off + 3 - (om << 1) | 0] = buf[0];\n  }\n  if (len < lm + (4 - om)) {\n    return;\n  }\n  for (i = 4 - om; i < j; i = i + 4 | 0) {\n    H32[off + i >> 2 | 0] = buf[i] << 24 | buf[i + 1] << 16 | buf[i + 2] << 8 | buf[i + 3];\n  }\n  switch (lm) {\n    case 3:\n      H8[off + j + 1 | 0] = buf[j + 2];\n    case 2:\n      H8[off + j + 2 | 0] = buf[j + 1];\n    case 1:\n      H8[off + j + 3 | 0] = buf[j];\n  }\n};\n\nmodule.exports = function (data, H8, H32, start, len, off) {\n  if (typeof data === 'string') {\n    return convStr(data, H8, H32, start, len, off);\n  }\n  if (data instanceof Array) {\n    return convBuf(data, H8, H32, start, len, off);\n  }\n  // Safely doing a Buffer check using \"this\" to avoid Buffer polyfill to be included in the dist\n  if (_this && _this.Buffer && _this.Buffer.isBuffer(data)) {\n    return convBuf(data, H8, H32, start, len, off);\n  }\n  if (data instanceof ArrayBuffer) {\n    return convBuf(new Uint8Array(data), H8, H32, start, len, off);\n  }\n  if (data.buffer instanceof ArrayBuffer) {\n    return convBuf(new Uint8Array(data.buffer, data.byteOffset, data.byteLength), H8, H32, start, len, off);\n  }\n  if (data instanceof Blob) {\n    return convBlob(data, H8, H32, start, len, off);\n  }\n  throw new Error('Unsupported data type.');\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* eslint-env commonjs, browser */\n\nvar Rusha = __webpack_require__(0);\n\nvar _require = __webpack_require__(1),\n    toHex = _require.toHex;\n\nvar Hash = function () {\n  function Hash() {\n    _classCallCheck(this, Hash);\n\n    this._rusha = new Rusha();\n    this._rusha.resetState();\n  }\n\n  Hash.prototype.update = function update(data) {\n    this._rusha.append(data);\n    return this;\n  };\n\n  Hash.prototype.digest = function digest(encoding) {\n    var digest = this._rusha.rawEnd().buffer;\n    if (!encoding) {\n      return digest;\n    }\n    if (encoding === 'hex') {\n      return toHex(digest);\n    }\n    throw new Error('unsupported digest encoding');\n  };\n\n  return Hash;\n}();\n\nmodule.exports = function () {\n  return new Hash();\n};\n\n/***/ })\n/******/ ]);\n});\n\n/***/ }),\n\n/***/ \"./node_modules/webpack-strip-block/index.js?!./src/js/webworkers/compression.worker.js\":\n/*!**********************************************************************************************!*\\\n  !*** ./node_modules/webpack-strip-block??ref--7-0!./src/js/webworkers/compression.worker.js ***!\n  \\**********************************************************************************************/\n/*! no exports provided */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_lzstring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/lzstring */ \"./src/js/core/lzstring.js\");\n/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/config */ \"./src/js/core/config.js\");\n/* harmony import */ var _core_sensitive_utils_encrypt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/sensitive_utils.encrypt */ \"./src/js/core/sensitive_utils.encrypt.js\");\n\r\n\r\n\r\n\r\nfunction accessNestedPropertyReverse(obj, keys) {\r\n    let result = obj;\r\n    for (let i = keys.length - 1; i >= 0; --i) {\r\n        result = result[keys[i]];\r\n    }\r\n    return result;\r\n}\r\n\r\nconst salt = accessNestedPropertyReverse(_core_config__WEBPACK_IMPORTED_MODULE_1__[\"globalConfig\"], [\"file\", \"info\"]);\r\n\r\nonmessage = function (event) {\r\n    const { jobId, job, data } = event.data;\r\n    const result = performJob(job, data);\r\n\r\n    // @ts-ignore\r\n    postMessage({\r\n        jobId,\r\n        result,\r\n    });\r\n};\r\n\r\nfunction performJob(job, data) {\r\n    switch (job) {\r\n        case \"compressX64\": {\r\n            return Object(_core_lzstring__WEBPACK_IMPORTED_MODULE_0__[\"compressX64\"])(data);\r\n        }\r\n        case \"compressFile\": {\r\n            const checksum = Object(_core_sensitive_utils_encrypt__WEBPACK_IMPORTED_MODULE_2__[\"sha1\"])(data.text + salt);\r\n            return data.compressionPrefix + Object(_core_lzstring__WEBPACK_IMPORTED_MODULE_0__[\"compressX64\"])(checksum + data.text);\r\n        }\r\n        default:\r\n            throw new Error(\"Webworker: Unknown job: \" + job);\r\n    }\r\n}\r\n\n\n/***/ }),\n\n/***/ \"./src/js/core/config.js\":\n/*!*******************************!*\\\n  !*** ./src/js/core/config.js ***!\n  \\*******************************/\n/*! exports provided: IS_DEBUG, IS_DEMO, THIRDPARTY_URLS, globalConfig, IS_MOBILE */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IS_DEBUG\", function() { return IS_DEBUG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IS_DEMO\", function() { return IS_DEMO; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"THIRDPARTY_URLS\", function() { return THIRDPARTY_URLS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"globalConfig\", function() { return globalConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IS_MOBILE\", function() { return IS_MOBILE; });\nconst IS_DEBUG =\r\n    (typeof window !== \"undefined\" && window.location.search.indexOf(\"isdebug\") >= 0) ||\r\n    ( true &&\r\n        typeof window !== \"undefined\" &&\r\n        window.location.port === \"3005\" &&\r\n        (window.location.host.indexOf(\"localhost:\") >= 0 ||\r\n            window.location.host.indexOf(\"192.168.0.\") >= 0) &&\r\n        window.location.search.indexOf(\"nodebug\") < 0);\r\n\r\nconst IS_DEMO =\r\n    ( false) ||\r\n    (typeof window !== \"undefined\" && window.location.search.indexOf(\"isdemo\") >= 0);\r\n\r\nconst smoothCanvas = true;\r\n\r\nconst THIRDPARTY_URLS = {\r\n    discord: \"https://discord.gg/HN7EVzV\",\r\n    github: \"https://github.com/tobspr/shapez.io\",\r\n\r\n    // standaloneStorePage: \"https://steam.shapez.io\",\r\n    standaloneStorePage: \"https://tobspr.itch.io/shapez.io\",\r\n};\r\n\r\nconst globalConfig = {\r\n    // Size of a single tile in Pixels.\r\n    // NOTICE: Update webpack.production.config too!\r\n    tileSize: 32,\r\n    halfTileSize: 16,\r\n\r\n    // Which dpi the assets have\r\n    assetsDpi: 192 / 32,\r\n    assetsSharpness: 1.2,\r\n    shapesSharpness: 1.4,\r\n\r\n    // Production analytics\r\n    statisticsGraphDpi: 2.5,\r\n    statisticsGraphSlices: 100,\r\n    analyticsSliceDurationSeconds: 10,\r\n\r\n    minimumTickRate: 25,\r\n    maximumTickRate: 500,\r\n\r\n    // Map\r\n    mapChunkSize: 16,\r\n    mapChunkPrerenderMinZoom: 1.15,\r\n    mapChunkOverviewMinZoom: 0.7,\r\n\r\n    // Belt speeds\r\n    // NOTICE: Update webpack.production.config too!\r\n    beltSpeedItemsPerSecond: 2,\r\n    itemSpacingOnBelts: 0.63,\r\n    minerSpeedItemsPerSecond: 0, // COMPUTED\r\n\r\n    undergroundBeltMaxTilesByTier: [5, 8],\r\n\r\n    buildingSpeeds: {\r\n        cutter: 1 / 4,\r\n        cutterQuad: 1 / 4,\r\n        rotater: 1 / 1,\r\n        rotaterCCW: 1 / 1,\r\n        painter: 1 / 6,\r\n        painterDouble: 1 / 8,\r\n        sorter: 1 / 1,\r\n        painterQuad: 1 / 8,\r\n        mixer: 1 / 5,\r\n        stacker: 1 / 6,\r\n    },\r\n\r\n    // Zooming\r\n    initialZoom: 2,\r\n    minZoomLevel: 0.125,\r\n    maxZoomLevel: 4,\r\n\r\n    // Global game speed\r\n    gameSpeed: 1,\r\n\r\n    warmupTimeSecondsFast: 0.1,\r\n    warmupTimeSecondsRegular: 1,\r\n\r\n    smoothing: {\r\n        smoothMainCanvas: smoothCanvas && true,\r\n        quality: \"low\", // Low is CRUCIAL for mobile performance!\r\n    },\r\n\r\n    rendering: {},\r\n\r\n    debug: {\r\n        /* dev:start */\r\n\r\n        // Settings menu is generated *automatically*,\r\n        // but does not changes globalConfig.debug if enableDebugSettings is off\r\n        // DEFAULT VALUES:\r\n        enableDebugSettings: true,\r\n        \r\n        // UI\r\n        waitForImages: true,\r\n        showChunkBorders: false,\r\n        disableZoomLimits: false,\r\n        disableShortNumbers: false,\r\n\r\n        // FEATURE\r\n        fastGameEnter: false,\r\n        disableSavegameWrite: false,\r\n        disableUnlockDialog: false,\r\n        disableTutorialHints: false,\r\n        disableUpgradeNotification: false,\r\n        disableDynamicTickrate: false,\r\n\r\n        // ASSERT\r\n        disableInternalCheckTile: false,\r\n        disableGetTileAsserts: false,\r\n        disableBeltAsserts: false,\r\n\r\n        // CHEATS\r\n        rewardsInstant: false,\r\n        allBuildingsUnlocked: false,\r\n        blueprintsNoCost: true,\r\n        upgradesNoCost: false,\r\n        instantBelts: false,\r\n        instantProcessors: false,\r\n        instantMiners: false,\r\n\r\n        // TEST\r\n        noArtificialDelays: false,\r\n        showEntityBounds: false,\r\n        showAcceptorEjectors: false,\r\n        disableMusic: false,\r\n        doNotRenderStatics: false,\r\n        disableLogicTicks: false,\r\n        testClipping: false,\r\n        testTranslations: false,\r\n        enableEntityInspector: false,\r\n        testAds: false,\r\n        disableMapOverview: false,\r\n        disableBulkOperations: false,\r\n\r\n        // framePausesBetweenTicks: 40,\r\n\r\n        renderForTrailer: false,\r\n        /* dev:end */\r\n    },\r\n\r\n    // Secret vars\r\n    info: {\r\n        // Binary file salt\r\n        file: \"Ec'])@^+*9zMevK3uMV4432x9%iK'=\",\r\n\r\n        // Savegame salt\r\n        sgSalt: \"}95Q3%8/.837Lqym_BJx%q7)pAHJbF\",\r\n\r\n        // Analytics key\r\n        analyticsApiKey: \"baf6a50f0cc7dfdec5a0e21c88a1c69a4b34bc4a\",\r\n    },\r\n};\r\n\r\nconst IS_MOBILE = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);\r\n\r\n// Automatic calculations\r\n\r\nglobalConfig.minerSpeedItemsPerSecond = globalConfig.beltSpeedItemsPerSecond / 5;\r\n\r\nif (globalConfig.debug.disableMapOverview) {\r\n    globalConfig.mapChunkOverviewMinZoom = 0;\r\n    globalConfig.mapChunkPrerenderMinZoom = 0;\r\n}\r\n\r\nif ( true && globalConfig.debug.renderForTrailer) {\r\n    globalConfig.debug.framePausesBetweenTicks = 32;\r\n    // globalConfig.mapChunkOverviewMinZoom = 0.0;\r\n    // globalConfig.mapChunkPrerenderMinZoom = globalConfig.mapChunkOverviewMinZoom;\r\n    // globalConfig.debug.instantBelts = true;\r\n    // globalConfig.debug.instantProcessors = true;\r\n    // globalConfig.debug.instantMiners = true;\r\n    globalConfig.debug.disableSavegameWrite = true;\r\n    // globalConfig.beltSpeedItemsPerSecond *= 2;\r\n}\r\n\n\n/***/ }),\n\n/***/ \"./src/js/core/lzstring.js\":\n/*!*********************************!*\\\n  !*** ./src/js/core/lzstring.js ***!\n  \\*********************************/\n/*! exports provided: compressU8, compressU8WHeader, decompressU8WHeader, compressX64, decompressX64 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compressU8\", function() { return compressU8; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compressU8WHeader\", function() { return compressU8WHeader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decompressU8WHeader\", function() { return decompressU8WHeader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compressX64\", function() { return compressX64; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decompressX64\", function() { return decompressX64; });\n// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>\r\n// This work is free. You can redistribute it and/or modify it\r\n// under the terms of the WTFPL, Version 2\r\n// For more information see LICENSE.txt or http://www.wtfpl.net/\r\n//\r\n// For more information, the home page:\r\n// http://pieroxy.net/blog/pages/lz-string/testing.html\r\n//\r\n// LZ-based compression algorithm, version 1.4.4\r\n\r\nconst fromCharCode = String.fromCharCode;\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\nconst keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\r\nconst baseReverseDic = {};\r\n\r\nfunction getBaseValue(alphabet, character) {\r\n    if (!baseReverseDic[alphabet]) {\r\n        baseReverseDic[alphabet] = {};\r\n        for (let i = 0; i < alphabet.length; i++) {\r\n            baseReverseDic[alphabet][alphabet.charAt(i)] = i;\r\n        }\r\n    }\r\n    return baseReverseDic[alphabet][character];\r\n}\r\n\r\n//compress into uint8array (UCS-2 big endian format)\r\nfunction compressU8(uncompressed) {\r\n    let compressed = compress(uncompressed);\r\n    let buf = new Uint8Array(compressed.length * 2); // 2 bytes per character\r\n\r\n    for (let i = 0, TotalLen = compressed.length; i < TotalLen; i++) {\r\n        let current_value = compressed.charCodeAt(i);\r\n        buf[i * 2] = current_value >>> 8;\r\n        buf[i * 2 + 1] = current_value % 256;\r\n    }\r\n    return buf;\r\n}\r\n\r\n// Compreses with header\r\n/**\r\n * @param {string} uncompressed\r\n * @param {number} header\r\n */\r\nfunction compressU8WHeader(uncompressed, header) {\r\n    let compressed = compress(uncompressed);\r\n    let buf = new Uint8Array(2 + compressed.length * 2); // 2 bytes per character\r\n\r\n    buf[0] = header >>> 8;\r\n    buf[1] = header % 256;\r\n    for (let i = 0, TotalLen = compressed.length; i < TotalLen; i++) {\r\n        let current_value = compressed.charCodeAt(i);\r\n        buf[2 + i * 2] = current_value >>> 8;\r\n        buf[2 + i * 2 + 1] = current_value % 256;\r\n    }\r\n    return buf;\r\n}\r\n\r\n//decompress from uint8array (UCS-2 big endian format)\r\n/**\r\n *\r\n * @param {Uint8Array} compressed\r\n */\r\nfunction decompressU8WHeader(compressed) {\r\n    // let buf = new Array(compressed.length / 2); // 2 bytes per character\r\n    // for (let i = 0, TotalLen = buf.length; i < TotalLen; i++) {\r\n    //     buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];\r\n    // }\r\n\r\n    // let result = [];\r\n    // buf.forEach(function (c) {\r\n    //     result.push(fromCharCode(c));\r\n    // });\r\n    let result = [];\r\n    for (let i = 2, n = compressed.length; i < n; i += 2) {\r\n        const code = compressed[i] * 256 + compressed[i + 1];\r\n        result.push(fromCharCode(code));\r\n    }\r\n    return decompress(result.join(\"\"));\r\n}\r\n\r\n//compress into a string that is already URI encoded\r\nfunction compressX64(input) {\r\n    if (input == null) return \"\";\r\n    return _compress(input, 6, function (a) {\r\n        return keyStrUriSafe.charAt(a);\r\n    });\r\n}\r\n\r\n//decompress from an output of compressToEncodedURIComponent\r\nfunction decompressX64(input) {\r\n    if (input == null) return \"\";\r\n    if (input == \"\") return null;\r\n    input = input.replace(/ /g, \"+\");\r\n    return _decompress(input.length, 32, function (index) {\r\n        return getBaseValue(keyStrUriSafe, input.charAt(index));\r\n    });\r\n}\r\n\r\nfunction compress(uncompressed) {\r\n    return _compress(uncompressed, 16, function (a) {\r\n        return fromCharCode(a);\r\n    });\r\n}\r\n\r\nfunction _compress(uncompressed, bitsPerChar, getCharFromInt) {\r\n    if (uncompressed == null) return \"\";\r\n    let i,\r\n        value,\r\n        context_dictionary = {},\r\n        context_dictionaryToCreate = {},\r\n        context_c = \"\",\r\n        context_wc = \"\",\r\n        context_w = \"\",\r\n        context_enlargeIn = 2, // Compensate for the first entry which should not count\r\n        context_dictSize = 3,\r\n        context_numBits = 2,\r\n        context_data = [],\r\n        context_data_val = 0,\r\n        context_data_position = 0,\r\n        ii;\r\n\r\n    for (ii = 0; ii < uncompressed.length; ii += 1) {\r\n        context_c = uncompressed.charAt(ii);\r\n        if (!hasOwnProperty.call(context_dictionary, context_c)) {\r\n            context_dictionary[context_c] = context_dictSize++;\r\n            context_dictionaryToCreate[context_c] = true;\r\n        }\r\n\r\n        context_wc = context_w + context_c;\r\n        if (hasOwnProperty.call(context_dictionary, context_wc)) {\r\n            context_w = context_wc;\r\n        } else {\r\n            if (hasOwnProperty.call(context_dictionaryToCreate, context_w)) {\r\n                if (context_w.charCodeAt(0) < 256) {\r\n                    for (i = 0; i < context_numBits; i++) {\r\n                        context_data_val = context_data_val << 1;\r\n                        if (context_data_position == bitsPerChar - 1) {\r\n                            context_data_position = 0;\r\n                            context_data.push(getCharFromInt(context_data_val));\r\n                            context_data_val = 0;\r\n                        } else {\r\n                            context_data_position++;\r\n                        }\r\n                    }\r\n                    value = context_w.charCodeAt(0);\r\n                    for (i = 0; i < 8; i++) {\r\n                        context_data_val = (context_data_val << 1) | (value & 1);\r\n                        if (context_data_position == bitsPerChar - 1) {\r\n                            context_data_position = 0;\r\n                            context_data.push(getCharFromInt(context_data_val));\r\n                            context_data_val = 0;\r\n                        } else {\r\n                            context_data_position++;\r\n                        }\r\n                        value = value >> 1;\r\n                    }\r\n                } else {\r\n                    value = 1;\r\n                    for (i = 0; i < context_numBits; i++) {\r\n                        context_data_val = (context_data_val << 1) | value;\r\n                        if (context_data_position == bitsPerChar - 1) {\r\n                            context_data_position = 0;\r\n                            context_data.push(getCharFromInt(context_data_val));\r\n                            context_data_val = 0;\r\n                        } else {\r\n                            context_data_position++;\r\n                        }\r\n                        value = 0;\r\n                    }\r\n                    value = context_w.charCodeAt(0);\r\n                    for (i = 0; i < 16; i++) {\r\n                        context_data_val = (context_data_val << 1) | (value & 1);\r\n                        if (context_data_position == bitsPerChar - 1) {\r\n                            context_data_position = 0;\r\n                            context_data.push(getCharFromInt(context_data_val));\r\n                            context_data_val = 0;\r\n                        } else {\r\n                            context_data_position++;\r\n                        }\r\n                        value = value >> 1;\r\n                    }\r\n                }\r\n                context_enlargeIn--;\r\n                if (context_enlargeIn == 0) {\r\n                    context_enlargeIn = Math.pow(2, context_numBits);\r\n                    context_numBits++;\r\n                }\r\n                delete context_dictionaryToCreate[context_w];\r\n            } else {\r\n                value = context_dictionary[context_w];\r\n                for (i = 0; i < context_numBits; i++) {\r\n                    context_data_val = (context_data_val << 1) | (value & 1);\r\n                    if (context_data_position == bitsPerChar - 1) {\r\n                        context_data_position = 0;\r\n                        context_data.push(getCharFromInt(context_data_val));\r\n                        context_data_val = 0;\r\n                    } else {\r\n                        context_data_position++;\r\n                    }\r\n                    value = value >> 1;\r\n                }\r\n            }\r\n            context_enlargeIn--;\r\n            if (context_enlargeIn == 0) {\r\n                context_enlargeIn = Math.pow(2, context_numBits);\r\n                context_numBits++;\r\n            }\r\n            // Add wc to the dictionary.\r\n            context_dictionary[context_wc] = context_dictSize++;\r\n            context_w = String(context_c);\r\n        }\r\n    }\r\n\r\n    // Output the code for w.\r\n    if (context_w !== \"\") {\r\n        if (hasOwnProperty.call(context_dictionaryToCreate, context_w)) {\r\n            if (context_w.charCodeAt(0) < 256) {\r\n                for (i = 0; i < context_numBits; i++) {\r\n                    context_data_val = context_data_val << 1;\r\n                    if (context_data_position == bitsPerChar - 1) {\r\n                        context_data_position = 0;\r\n                        context_data.push(getCharFromInt(context_data_val));\r\n                        context_data_val = 0;\r\n                    } else {\r\n                        context_data_position++;\r\n                    }\r\n                }\r\n                value = context_w.charCodeAt(0);\r\n                for (i = 0; i < 8; i++) {\r\n                    context_data_val = (context_data_val << 1) | (value & 1);\r\n                    if (context_data_position == bitsPerChar - 1) {\r\n                        context_data_position = 0;\r\n                        context_data.push(getCharFromInt(context_data_val));\r\n                        context_data_val = 0;\r\n                    } else {\r\n                        context_data_position++;\r\n                    }\r\n                    value = value >> 1;\r\n                }\r\n            } else {\r\n                value = 1;\r\n                for (i = 0; i < context_numBits; i++) {\r\n                    context_data_val = (context_data_val << 1) | value;\r\n                    if (context_data_position == bitsPerChar - 1) {\r\n                        context_data_position = 0;\r\n                        context_data.push(getCharFromInt(context_data_val));\r\n                        context_data_val = 0;\r\n                    } else {\r\n                        context_data_position++;\r\n                    }\r\n                    value = 0;\r\n                }\r\n                value = context_w.charCodeAt(0);\r\n                for (i = 0; i < 16; i++) {\r\n                    context_data_val = (context_data_val << 1) | (value & 1);\r\n                    if (context_data_position == bitsPerChar - 1) {\r\n                        context_data_position = 0;\r\n                        context_data.push(getCharFromInt(context_data_val));\r\n                        context_data_val = 0;\r\n                    } else {\r\n                        context_data_position++;\r\n                    }\r\n                    value = value >> 1;\r\n                }\r\n            }\r\n            context_enlargeIn--;\r\n            if (context_enlargeIn == 0) {\r\n                context_enlargeIn = Math.pow(2, context_numBits);\r\n                context_numBits++;\r\n            }\r\n            delete context_dictionaryToCreate[context_w];\r\n        } else {\r\n            value = context_dictionary[context_w];\r\n            for (i = 0; i < context_numBits; i++) {\r\n                context_data_val = (context_data_val << 1) | (value & 1);\r\n                if (context_data_position == bitsPerChar - 1) {\r\n                    context_data_position = 0;\r\n                    context_data.push(getCharFromInt(context_data_val));\r\n                    context_data_val = 0;\r\n                } else {\r\n                    context_data_position++;\r\n                }\r\n                value = value >> 1;\r\n            }\r\n        }\r\n        context_enlargeIn--;\r\n        if (context_enlargeIn == 0) {\r\n            context_enlargeIn = Math.pow(2, context_numBits);\r\n            context_numBits++;\r\n        }\r\n    }\r\n\r\n    // Mark the end of the stream\r\n    value = 2;\r\n    for (i = 0; i < context_numBits; i++) {\r\n        context_data_val = (context_data_val << 1) | (value & 1);\r\n        if (context_data_position == bitsPerChar - 1) {\r\n            context_data_position = 0;\r\n            context_data.push(getCharFromInt(context_data_val));\r\n            context_data_val = 0;\r\n        } else {\r\n            context_data_position++;\r\n        }\r\n        value = value >> 1;\r\n    }\r\n\r\n    // Flush the last char\r\n    // eslint-disable-next-line no-constant-condition\r\n    while (true) {\r\n        context_data_val = context_data_val << 1;\r\n        if (context_data_position == bitsPerChar - 1) {\r\n            context_data.push(getCharFromInt(context_data_val));\r\n            break;\r\n        } else context_data_position++;\r\n    }\r\n    return context_data.join(\"\");\r\n}\r\n\r\nfunction decompress(compressed) {\r\n    if (compressed == null) return \"\";\r\n    if (compressed == \"\") return null;\r\n    return _decompress(compressed.length, 32768, function (index) {\r\n        return compressed.charCodeAt(index);\r\n    });\r\n}\r\n\r\nfunction _decompress(length, resetValue, getNextValue) {\r\n    let dictionary = [],\r\n        next,\r\n        enlargeIn = 4,\r\n        dictSize = 4,\r\n        numBits = 3,\r\n        entry = \"\",\r\n        result = [],\r\n        i,\r\n        w,\r\n        bits,\r\n        resb,\r\n        maxpower,\r\n        power,\r\n        c,\r\n        data = { val: getNextValue(0), position: resetValue, index: 1 };\r\n\r\n    for (i = 0; i < 3; i += 1) {\r\n        dictionary[i] = i;\r\n    }\r\n\r\n    bits = 0;\r\n    maxpower = Math.pow(2, 2);\r\n    power = 1;\r\n    while (power != maxpower) {\r\n        resb = data.val & data.position;\r\n        data.position >>= 1;\r\n        if (data.position == 0) {\r\n            data.position = resetValue;\r\n            data.val = getNextValue(data.index++);\r\n        }\r\n        bits |= (resb > 0 ? 1 : 0) * power;\r\n        power <<= 1;\r\n    }\r\n\r\n    switch ((next = bits)) {\r\n        case 0:\r\n            bits = 0;\r\n            maxpower = Math.pow(2, 8);\r\n            power = 1;\r\n            while (power != maxpower) {\r\n                resb = data.val & data.position;\r\n                data.position >>= 1;\r\n                if (data.position == 0) {\r\n                    data.position = resetValue;\r\n                    data.val = getNextValue(data.index++);\r\n                }\r\n                bits |= (resb > 0 ? 1 : 0) * power;\r\n                power <<= 1;\r\n            }\r\n            c = fromCharCode(bits);\r\n            break;\r\n        case 1:\r\n            bits = 0;\r\n            maxpower = Math.pow(2, 16);\r\n            power = 1;\r\n            while (power != maxpower) {\r\n                resb = data.val & data.position;\r\n                data.position >>= 1;\r\n                if (data.position == 0) {\r\n                    data.position = resetValue;\r\n                    data.val = getNextValue(data.index++);\r\n                }\r\n                bits |= (resb > 0 ? 1 : 0) * power;\r\n                power <<= 1;\r\n            }\r\n            c = fromCharCode(bits);\r\n            break;\r\n        case 2:\r\n            return \"\";\r\n    }\r\n    dictionary[3] = c;\r\n    w = c;\r\n    result.push(c);\r\n\r\n    // eslint-disable-next-line no-constant-condition\r\n    while (true) {\r\n        if (data.index > length) {\r\n            return \"\";\r\n        }\r\n\r\n        bits = 0;\r\n        maxpower = Math.pow(2, numBits);\r\n        power = 1;\r\n        while (power != maxpower) {\r\n            resb = data.val & data.position;\r\n            data.position >>= 1;\r\n            if (data.position == 0) {\r\n                data.position = resetValue;\r\n                data.val = getNextValue(data.index++);\r\n            }\r\n            bits |= (resb > 0 ? 1 : 0) * power;\r\n            power <<= 1;\r\n        }\r\n\r\n        switch ((c = bits)) {\r\n            case 0:\r\n                bits = 0;\r\n                maxpower = Math.pow(2, 8);\r\n                power = 1;\r\n                while (power != maxpower) {\r\n                    resb = data.val & data.position;\r\n                    data.position >>= 1;\r\n                    if (data.position == 0) {\r\n                        data.position = resetValue;\r\n                        data.val = getNextValue(data.index++);\r\n                    }\r\n                    bits |= (resb > 0 ? 1 : 0) * power;\r\n                    power <<= 1;\r\n                }\r\n\r\n                dictionary[dictSize++] = fromCharCode(bits);\r\n                c = dictSize - 1;\r\n                enlargeIn--;\r\n                break;\r\n            case 1:\r\n                bits = 0;\r\n                maxpower = Math.pow(2, 16);\r\n                power = 1;\r\n                while (power != maxpower) {\r\n                    resb = data.val & data.position;\r\n                    data.position >>= 1;\r\n                    if (data.position == 0) {\r\n                        data.position = resetValue;\r\n                        data.val = getNextValue(data.index++);\r\n                    }\r\n                    bits |= (resb > 0 ? 1 : 0) * power;\r\n                    power <<= 1;\r\n                }\r\n                dictionary[dictSize++] = fromCharCode(bits);\r\n                c = dictSize - 1;\r\n                enlargeIn--;\r\n                break;\r\n            case 2:\r\n                return result.join(\"\");\r\n        }\r\n\r\n        if (enlargeIn == 0) {\r\n            enlargeIn = Math.pow(2, numBits);\r\n            numBits++;\r\n        }\r\n\r\n        if (dictionary[c]) {\r\n            // @ts-ignore\r\n            entry = dictionary[c];\r\n        } else {\r\n            if (c === dictSize) {\r\n                entry = w + w.charAt(0);\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        result.push(entry);\r\n\r\n        // Add w+entry[0] to the dictionary.\r\n        dictionary[dictSize++] = w + entry.charAt(0);\r\n        enlargeIn--;\r\n\r\n        w = entry;\r\n\r\n        if (enlargeIn == 0) {\r\n            enlargeIn = Math.pow(2, numBits);\r\n            numBits++;\r\n        }\r\n    }\r\n}\r\n\n\n/***/ }),\n\n/***/ \"./src/js/core/sensitive_utils.encrypt.js\":\n/*!************************************************!*\\\n  !*** ./src/js/core/sensitive_utils.encrypt.js ***!\n  \\************************************************/\n/*! exports provided: decodeHashedString, sha1, getNameOfProvider */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decodeHashedString\", function() { return decodeHashedString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sha1\", function() { return sha1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getNameOfProvider\", function() { return getNameOfProvider; });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/js/core/config.js\");\n/* harmony import */ var _lzstring__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lzstring */ \"./src/js/core/lzstring.js\");\n\r\n\r\n\r\nconst Rusha = __webpack_require__(/*! rusha */ \"./node_modules/rusha/dist/rusha.js\");\r\n\r\nconst encryptKey = _config__WEBPACK_IMPORTED_MODULE_0__[\"globalConfig\"].info.sgSalt;\r\n\r\nfunction decodeHashedString(s) {\r\n    return Object(_lzstring__WEBPACK_IMPORTED_MODULE_1__[\"decompressX64\"])(s);\r\n}\r\n\r\nfunction sha1(str) {\r\n    return Rusha.createHash().update(str).digest(\"hex\");\r\n}\r\n\r\n// Window.location.host\r\nfunction getNameOfProvider() {\r\n    return window[decodeHashedString(\"DYewxghgLgliB2Q\")][decodeHashedString(\"BYewzgLgdghgtgUyA\")];\r\n}\r\n\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=12d48f000b34774f8e39.worker.js.map", null);
};

/***/ }),

/***/ 0:
/*!******************************!*\
  !*** multi ./src/js/main.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! D:\Users\dimava\Desktop\projects\shapez.io\src\js\main.js */"./src/js/main.js");


/***/ })

/******/ });
//# sourceMappingURL=bundle.js.map